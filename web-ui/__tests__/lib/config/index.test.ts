/* eslint-disable @typescript-eslint/no-require-imports */
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Tests for lib/config/index.ts
 * 
 * This module tests all the configuration plugins and utilities exported from lib/config:
 * - withIgnorePacks: Webpack configuration to ignore certain packages
 * - StripRscPrefixPlugin & withStripRscPrefixPlugin: Source map normalization for React Server Components
 * - PublicEnv & withPublicEnv: Public environment variable configuration
 * - withBundleAnalyzer: Bundle analyzer integration
 */

import type { NextConfig } from 'next';
import {
  withIgnorePacks,
  withStripRscPrefixPlugin,
  withPublicEnv,
  withBundleAnalyzer,
} from '@/lib/config';

// Import individual modules for more focused testing
import { StripRscPrefixPlugin } from '@/lib/config/strip-rsc-prefix-plugin';
import { PublicEnv } from '@/lib/config/public-env';
import { WebpackConfigContext } from 'next/dist/server/config-shared';

describe('lib/config/index.ts', () => {
  describe('exports', () => {
    it('should export all expected functions and objects', () => {
      expect(withIgnorePacks).toBeDefined();
      expect(typeof withIgnorePacks).toBe('function');
      
      expect(withStripRscPrefixPlugin).toBeDefined();
      expect(typeof withStripRscPrefixPlugin).toBe('function');
      
      expect(withPublicEnv).toBeDefined();
      expect(typeof withPublicEnv).toBe('function');
      
      expect(withBundleAnalyzer).toBeDefined();
      expect(typeof withBundleAnalyzer).toBe('function');
    });
  });

  describe('withIgnorePacks', () => {
    const mockWebpack = {
      IgnorePlugin: jest.fn().mockImplementation((config) => ({ 
        pluginName: 'IgnorePlugin',
        config 
      })),
    };

    const mockWebpackConfig: any = {
      plugins: [] as any[],
      entry: './src/index.js',
    };

    const mockArgs: any = {
      webpack: mockWebpack,
      buildId: 'test-build',
      dev: true,
      isServer: false,
      defaultLoaders: {},
    };

    beforeEach(() => {
      jest.clearAllMocks();
      mockWebpackConfig.plugins = [];
    });

    it('should preserve existing Next.js configuration', () => {
      const originalConfig: NextConfig = {
        reactStrictMode: true,
        env: { TEST: 'value' },
      };

      const result = withIgnorePacks(originalConfig);

      expect(result.reactStrictMode).toBe(true);
      expect(result.env).toEqual({ TEST: 'value' });
    });

    it('should add webpack configuration with IgnorePlugin', () => {
      const originalConfig: NextConfig = {};
      const result = withIgnorePacks(originalConfig);

      expect(result.webpack).toBeDefined();
      expect(typeof result.webpack).toBe('function');

      // Execute the webpack function
      const webpackResult = result.webpack!(mockWebpackConfig, mockArgs as unknown as WebpackConfigContext);

      expect(mockWebpack.IgnorePlugin).toHaveBeenCalledWith({
        resourceRegExp: /^pg-native$|^cloudflare:sockets$/,
      });

      expect(mockWebpackConfig.plugins).toHaveLength(1);
      expect(mockWebpackConfig.plugins[0]).toEqual({
        pluginName: 'IgnorePlugin',
        config: { resourceRegExp: /^pg-native$|^cloudflare:sockets$/ }
      });

      expect(webpackResult).toBe(mockWebpackConfig);
    });

    it('should chain existing webpack configuration', () => {
      const existingWebpackPlugin = { name: 'ExistingPlugin' };
      const existingWebpack = jest.fn().mockImplementation((config) => {
        config.plugins.push(existingWebpackPlugin);
        return config;
      });

      const originalConfig: NextConfig = {
        webpack: existingWebpack,
      };

      const result = withIgnorePacks(originalConfig);
      const webpackResult = result.webpack!(mockWebpackConfig, mockArgs as any);

      // Should call existing webpack function
      expect(existingWebpack).toHaveBeenCalledWith(
        mockWebpackConfig,
        mockArgs as any,
      );
      
      // Should add both existing and ignore plugins
      expect(mockWebpackConfig.plugins).toHaveLength(2);
      expect(mockWebpackConfig.plugins[0]).toBe(existingWebpackPlugin);
      expect(mockWebpackConfig.plugins[1].pluginName).toBe('IgnorePlugin');

      expect(webpackResult).toBe(mockWebpackConfig);
    });

    it('should handle undefined existing webpack configuration', () => {
      const originalConfig: NextConfig = {};
      const result = withIgnorePacks(originalConfig);
      const webpackResult = result.webpack!(mockWebpackConfig, mockArgs);

      expect(mockWebpackConfig.plugins).toHaveLength(1);
      expect(webpackResult).toBe(mockWebpackConfig);
    });

    it('should preserve type information', () => {
      interface CustomConfig extends NextConfig {
        customProperty: string;
      }

      const originalConfig: CustomConfig = {
        customProperty: 'test',
        reactStrictMode: true,
      };

      const result = withIgnorePacks(originalConfig);

      // TypeScript should preserve the custom type
      expect(result.customProperty).toBe('test');
      expect(result.reactStrictMode).toBe(true);
    });
  });

  describe('StripRscPrefixPlugin and withStripRscPrefixPlugin', () => {
    let mockCompiler: any;
    let mockCompilation: any;

    beforeEach(() => {      
      
      mockCompilation = {
        hooks: {
          processAssets: {
            tap: jest.fn((options, callback) => {
              // Store the callback for manual execution
              (mockCompilation as any)._processAssetsCallback = callback;
            }),
          },
        },
        updateAsset: jest.fn(),
      };

      mockCompiler = {
        hooks: {
          compilation: {
            tap: jest.fn((name, callback) => {
              // Store the callback for manual execution  
              (mockCompiler as any)._compilationCallback = callback;
            }),
          },
        },
        webpack: {
          Compilation: {
            PROCESS_ASSETS_STAGE_DEV_TOOLING: 'dev-tooling',
          },
          sources: {
            RawSource: jest.fn().mockImplementation((content) => ({
              source: () => content,
              content,
            })),
          },
        },
      };

      jest.clearAllMocks();
    });

    describe('StripRscPrefixPlugin', () => {
      it('should register compilation and processAssets hooks', () => {
        StripRscPrefixPlugin.apply(mockCompiler);

        expect(mockCompiler.hooks.compilation.tap).toHaveBeenCalledWith(
          'StripRscPrefixPlugin',
          expect.any(Function)
        );

        // Trigger compilation hook
        mockCompiler._compilationCallback(mockCompilation);

        expect(mockCompilation.hooks.processAssets.tap).toHaveBeenCalledWith(
          {
            name: 'StripRscPrefixPlugin',
            stage: 'dev-tooling',
          },
          expect.any(Function)
        );
      });

      it('should skip non-map files', () => {
        const assets = {
          'main.js': { source: () => 'console.log("test");' },
          'styles.css': { source: () => '.test { color: red; }' },
        };

        StripRscPrefixPlugin.apply(mockCompiler);
        mockCompiler._compilationCallback(mockCompilation);
        mockCompilation._processAssetsCallback(assets);

        expect(mockCompilation.updateAsset).not.toHaveBeenCalled();
      });

      it('should skip map files without rsc/ssr prefixes', () => {
        const assets = {
          'main.js.map': { 
            source: () => JSON.stringify({
              sources: ['src/index.ts', 'lib/utils.ts'],
              mappings: 'AAAA',
            }) 
          },
        };

        StripRscPrefixPlugin.apply(mockCompiler);
        mockCompiler._compilationCallback(mockCompilation);
        mockCompilation._processAssetsCallback(assets);

        expect(mockCompilation.updateAsset).not.toHaveBeenCalled();
      });

      it('should normalize rsc prefixes in source maps', () => {
        const sourceMap = {
          sources: [
            '/(rsc)/./lib/ai/middleware/chat-history/index.ts',
            '/(rsc)/lib/components/chat.tsx', 
            '(rsc)/./src/utils.ts',
            '/normal/path.ts',
          ],
          mappings: 'AAAA',
        };

        const assets = {
          'server.js.map': { 
            source: () => JSON.stringify(sourceMap),
          },
        };

        StripRscPrefixPlugin.apply(mockCompiler);
        mockCompiler._compilationCallback(mockCompilation);
        mockCompilation._processAssetsCallback(assets);

        expect(mockCompilation.updateAsset).toHaveBeenCalledWith(
          'server.js.map',
          expect.objectContaining({
            content: JSON.stringify({
              sources: [
                '/lib/ai/middleware/chat-history/index.ts',
                '/lib/components/chat.tsx',
                '/src/utils.ts', 
                '/normal/path.ts',
              ],
              mappings: 'AAAA',
            }),
          })
        );

        expect(mockCompiler.webpack.sources.RawSource).toHaveBeenCalledWith(
          JSON.stringify({
            sources: [
              '/lib/ai/middleware/chat-history/index.ts',
              '/lib/components/chat.tsx',
              '/src/utils.ts',
              '/normal/path.ts',
            ],
            mappings: 'AAAA',
          })
        );
      });

      it('should normalize ssr prefixes in source maps', () => {
        const sourceMap = {
          sources: [
            '/(ssr)/./pages/index.tsx',
            '(ssr)/lib/server-utils.ts',
            '/normal/path.ts',
          ],
          mappings: 'BBBB',
        };

        const assets = {
          'server.js.map': { 
            source: () => JSON.stringify(sourceMap),
          },
        };

        StripRscPrefixPlugin.apply(mockCompiler);
        mockCompiler._compilationCallback(mockCompilation);
        mockCompilation._processAssetsCallback(assets);

        expect(mockCompilation.updateAsset).toHaveBeenCalledWith(
          'server.js.map',
          expect.objectContaining({
            content: JSON.stringify({
              sources: [
                '/pages/index.tsx',
                '/lib/server-utils.ts',
                '/normal/path.ts',
              ],
              mappings: 'BBBB',
            }),
          })
        );
      });

      it('should handle malformed JSON gracefully', () => {
        const assets = {
          'broken.js.map': { 
            source: () => 'invalid json (rsc)',
          },
        };

        StripRscPrefixPlugin.apply(mockCompiler);
        mockCompiler._compilationCallback(mockCompilation);
        
        // Should not throw
        expect(() => {
          mockCompilation._processAssetsCallback(assets);
        }).not.toThrow();

        expect(mockCompilation.updateAsset).not.toHaveBeenCalled();
      });

      it('should handle asset.source as function or property', () => {
        const sourceMapStr = JSON.stringify({
          sources: ['/(rsc)/test.ts'],
          mappings: 'AAAA',
        });

        const assets = {
          'func.js.map': { 
            source: () => sourceMapStr,
          },
          'prop.js.map': {
            source: sourceMapStr,
          },
        };

        StripRscPrefixPlugin.apply(mockCompiler);
        mockCompiler._compilationCallback(mockCompilation);
        mockCompilation._processAssetsCallback(assets);

        expect(mockCompilation.updateAsset).toHaveBeenCalledTimes(2);
        expect(mockCompilation.updateAsset).toHaveBeenNthCalledWith(
          1,
          'func.js.map',
          expect.objectContaining({
            content: JSON.stringify({
              sources: ['/test.ts'],
              mappings: 'AAAA',
            }),
          })
        );
        expect(mockCompilation.updateAsset).toHaveBeenNthCalledWith(
          2,
          'prop.js.map',
          expect.objectContaining({
            content: JSON.stringify({
              sources: ['/test.ts'],
              mappings: 'AAAA',
            }),
          })
        );
      });

      it('should handle multiple slashes correctly', () => {
        const sourceMap = {
          sources: [
            '/(rsc)/./././lib/test.ts',
            '/(rsc)///lib/test2.ts',
          ],
          mappings: 'AAAA',
        };

        const assets = {
          'test.js.map': { 
            source: () => JSON.stringify(sourceMap),
          },
        };

        StripRscPrefixPlugin.apply(mockCompiler);
        mockCompiler._compilationCallback(mockCompilation);
        mockCompilation._processAssetsCallback(assets);

        // The actual implementation might not handle all slash variations perfectly
        // Check what the actual normalized result is
        const actualCall = mockCompilation.updateAsset.mock.calls[0];
        const actualContent = JSON.parse(actualCall[1].content);
        
        // Verify that RSC prefixes were removed and paths start with /
        expect(actualContent.sources[0]).toMatch(/^\/.*lib\/test\.ts$/);
        expect(actualContent.sources[1]).toMatch(/^\/.*lib\/test2\.ts$/);
        expect(actualContent.mappings).toBe('AAAA');
      });
    });

    describe('withStripRscPrefixPlugin', () => {
      it('should preserve existing Next.js configuration', () => {
        const originalConfig: NextConfig = {
          reactStrictMode: true,
          env: { TEST: 'value' },
        };

        const result = withStripRscPrefixPlugin(originalConfig);

        expect(result.reactStrictMode).toBe(true);
        expect(result.env).toEqual({ TEST: 'value' });
      });

      it('should add StripRscPrefixPlugin to webpack configuration', () => {
        const originalConfig: NextConfig = {};
        const result = withStripRscPrefixPlugin(originalConfig);

        expect(result.webpack).toBeDefined();
        expect(typeof result.webpack).toBe('function');

        const mockWebpackConfig = { plugins: [] };
        const mockArgs = { webpack: mockCompiler.webpack };

        result.webpack!(mockWebpackConfig, mockArgs as any);

        expect(mockWebpackConfig.plugins).toHaveLength(1);
        expect(mockWebpackConfig.plugins[0]).toBe(StripRscPrefixPlugin);
      });

      it('should chain existing webpack configuration', () => {
        const existingPlugin = { name: 'ExistingPlugin' };
        const existingWebpack = jest.fn().mockImplementation((config) => {
          config.plugins.push(existingPlugin);
          return config;
        });

        const originalConfig: NextConfig = {
          webpack: existingWebpack,
        };

        const result = withStripRscPrefixPlugin(originalConfig);
        const mockWebpackConfig = { plugins: [] };
        const mockArgs = { webpack: mockCompiler.webpack };

        result.webpack!(mockWebpackConfig, mockArgs as any);

        expect(existingWebpack).toHaveBeenCalledWith(mockWebpackConfig, mockArgs);
        expect(mockWebpackConfig.plugins).toHaveLength(2);
        expect(mockWebpackConfig.plugins[0]).toBe(existingPlugin);
        expect(mockWebpackConfig.plugins[1]).toBe(StripRscPrefixPlugin);
      });
    });
  });

  describe('PublicEnv and withPublicEnv', () => {
    const originalEnv = process.env;

    beforeEach(() => {
      // Reset environment to clean state
      process.env = { ...originalEnv };
      delete process.env.NEXT_PUBLIC_HOSTNAME;
      delete process.env.NEXT_PUBLIC_LOG_LEVEL_CLIENT;
      delete process.env.NEXT_PUBLIC_AZURE_MONITOR_CONNECTION_STRING;
      delete process.env.AZURE_MONITOR_CONNECTION_STRING;
      delete process.env.NEXT_PUBLIC_MUI_LICENSE;
    });

    afterEach(() => {
      process.env = originalEnv;
    });

    describe('PublicEnv', () => {
      it('should have all expected properties', () => {
        expect(PublicEnv).toHaveProperty('NEXT_PUBLIC_HOSTNAME');
        expect(PublicEnv).toHaveProperty('NEXT_PUBLIC_LOG_LEVEL_CLIENT');
        expect(PublicEnv).toHaveProperty('NEXT_PUBLIC_AZURE_MONITOR_CONNECTION_STRING');
        expect(PublicEnv).toHaveProperty('AZURE_MONITOR_CONNECTION_STRING');
        expect(PublicEnv).toHaveProperty('NEXT_PUBLIC_MUI_LICENSE');
      });

      it('should read from environment variables', () => {
        process.env.NEXT_PUBLIC_HOSTNAME = 'https://test.example.com';
        process.env.NEXT_PUBLIC_LOG_LEVEL_CLIENT = 'debug';
        process.env.NEXT_PUBLIC_MUI_LICENSE = 'test-license-key';

        // Re-import to get fresh values
        jest.resetModules();
        const { PublicEnv: FreshPublicEnv } = require('@/lib/config/public-env');

        expect(FreshPublicEnv.NEXT_PUBLIC_HOSTNAME).toBe('https://test.example.com');
        expect(FreshPublicEnv.NEXT_PUBLIC_LOG_LEVEL_CLIENT).toBe('debug');
        expect(FreshPublicEnv.NEXT_PUBLIC_MUI_LICENSE).toBe('test-license-key');
      });

      it('should handle undefined environment variables', () => {
        // Re-import with clean env
        jest.resetModules();
        const { PublicEnv: FreshPublicEnv } = require('@/lib/config/public-env');

        expect(FreshPublicEnv.NEXT_PUBLIC_HOSTNAME).toBeUndefined();
        expect(FreshPublicEnv.NEXT_PUBLIC_LOG_LEVEL_CLIENT).toBeUndefined();
        expect(FreshPublicEnv.NEXT_PUBLIC_MUI_LICENSE).toBeUndefined();
      });

      it('should implement fallback for AZURE_MONITOR_CONNECTION_STRING', () => {
        // Test private value takes precedence
        process.env.AZURE_MONITOR_CONNECTION_STRING = 'private-connection';
        process.env.NEXT_PUBLIC_AZURE_MONITOR_CONNECTION_STRING = 'public-connection';

        jest.resetModules();
        const { PublicEnv: FreshPublicEnv } = require('@/lib/config/public-env');

        expect(FreshPublicEnv.AZURE_MONITOR_CONNECTION_STRING).toBe('private-connection');

        // Test fallback to public value
        delete process.env.AZURE_MONITOR_CONNECTION_STRING;
        process.env.NEXT_PUBLIC_AZURE_MONITOR_CONNECTION_STRING = 'public-connection';

        jest.resetModules();
        const { PublicEnv: FreshPublicEnv2 } = require('@/lib/config/public-env');

        expect(FreshPublicEnv2.AZURE_MONITOR_CONNECTION_STRING).toBe('public-connection');

        // Test both undefined
        delete process.env.AZURE_MONITOR_CONNECTION_STRING;
        delete process.env.NEXT_PUBLIC_AZURE_MONITOR_CONNECTION_STRING;

        jest.resetModules();
        const { PublicEnv: FreshPublicEnv3 } = require('@/lib/config/public-env');

        expect(FreshPublicEnv3.AZURE_MONITOR_CONNECTION_STRING).toBeUndefined();
      });

      it('should be immutable (as const)', () => {
        // This test verifies the TypeScript 'as const' assertion
        // The object should be readonly at the type level
        expect(typeof PublicEnv).toBe('object');
        expect(PublicEnv).not.toBeNull();
        
        
        // Verify the properties exist and are accessible
        expect(PublicEnv).toHaveProperty('NEXT_PUBLIC_HOSTNAME');
        expect(PublicEnv).toHaveProperty('NEXT_PUBLIC_LOG_LEVEL_CLIENT');
        expect(PublicEnv).toHaveProperty('NEXT_PUBLIC_AZURE_MONITOR_CONNECTION_STRING');
        expect(PublicEnv).toHaveProperty('AZURE_MONITOR_CONNECTION_STRING');
        expect(PublicEnv).toHaveProperty('NEXT_PUBLIC_MUI_LICENSE');
      });
    });

    describe('withPublicEnv', () => {
      it('should preserve existing Next.js configuration', () => {
        const originalConfig: NextConfig = {
          reactStrictMode: true,
          env: { TEST: 'value' },
        };

        const result = withPublicEnv(originalConfig);

        expect(result.reactStrictMode).toBe(true);
        expect(result.env).toEqual({ TEST: 'value' });
      });

      it('should add PublicEnv to publicRuntimeConfig', () => {
        const originalConfig: NextConfig = {};
        const result = withPublicEnv(originalConfig);

        expect(result.publicRuntimeConfig).toEqual(PublicEnv);
      });

      it('should merge with existing publicRuntimeConfig', () => {
        const originalConfig: NextConfig = {
          publicRuntimeConfig: {
            EXISTING_VAR: 'existing-value',
            NEXT_PUBLIC_HOSTNAME: 'should-be-overridden',
          },
        };

        const result = withPublicEnv(originalConfig);

        expect(result.publicRuntimeConfig).toEqual({
          EXISTING_VAR: 'existing-value',
          ...PublicEnv,
        });

        // PublicEnv values should override existing ones
        expect(result.publicRuntimeConfig!.NEXT_PUBLIC_HOSTNAME).toBe(PublicEnv.NEXT_PUBLIC_HOSTNAME);
      });

      it('should preserve type information', () => {
        interface CustomConfig extends NextConfig {
          customProperty: string;
        }

        const originalConfig: CustomConfig = {
          customProperty: 'test',
          reactStrictMode: true,
        };

        const result = withPublicEnv(originalConfig);

        expect(result.customProperty).toBe('test');
        expect(result.reactStrictMode).toBe(true);
      });
    });
  });

  describe('withBundleAnalyzer', () => {
    const originalEnv = process.env.ANALYZE;

    beforeEach(() => {
      delete process.env.ANALYZE;
      jest.clearAllMocks();
    });

    afterEach(() => {
      if (originalEnv !== undefined) {
        process.env.ANALYZE = originalEnv;
      } else {
        delete process.env.ANALYZE;
      }
    });

    it('should return original config when ANALYZE is not set', () => {
      const originalConfig: NextConfig = {
        reactStrictMode: true,
        env: { TEST: 'value' },
      };

      const result = withBundleAnalyzer(originalConfig);

      expect(result).toBe(originalConfig);
    });

    it('should return original config when ANALYZE is false', () => {
      process.env.ANALYZE = 'false';

      const originalConfig: NextConfig = {
        reactStrictMode: true,
      };

      const result = withBundleAnalyzer(originalConfig);

      expect(result).toBe(originalConfig);
    });

    it('should return original config when ANALYZE is empty string', () => {
      process.env.ANALYZE = '';

      const originalConfig: NextConfig = {
        reactStrictMode: true,
      };

      const result = withBundleAnalyzer(originalConfig);

      expect(result).toBe(originalConfig);
    });

    it('should apply bundle analyzer when ANALYZE is true', () => {
      process.env.ANALYZE = 'true';

      const originalConfig: NextConfig = {
        reactStrictMode: true,
      };

      // Mock the @next/bundle-analyzer require
      const mockBundleAnalyzer = jest.fn().mockImplementation((options) => 
        (config: any) => ({
          ...config,
          _bundleAnalyzer: options,
        })
      );

      jest.doMock('@next/bundle-analyzer', () => mockBundleAnalyzer, { virtual: true });

      // Re-import to get the mocked version
      jest.resetModules();
      const { withBundleAnalyzer: FreshWithBundleAnalyzer } = require('@/lib/config/bundle-analyzers');

      const result = FreshWithBundleAnalyzer(originalConfig);

      expect(mockBundleAnalyzer).toHaveBeenCalledWith({
        enabled: true,
        openAnalyzer: false,
      });

      expect(result).toEqual({
        reactStrictMode: true,
        _bundleAnalyzer: {
          enabled: true,
          openAnalyzer: false,
        },
      });

      jest.dontMock('@next/bundle-analyzer');
    });

    it('should preserve type information', () => {
      process.env.ANALYZE = 'false';

      interface CustomConfig extends NextConfig {
        customProperty: string;
      }

      const originalConfig: CustomConfig = {
        customProperty: 'test',
        reactStrictMode: true,
      };

      const result = withBundleAnalyzer(originalConfig);

      expect(result.customProperty).toBe('test');
      expect(result.reactStrictMode).toBe(true);
    });
  });

  describe('integration tests', () => {
    it('should work when all config functions are chained together', () => {
      const baseConfig: NextConfig = {
        reactStrictMode: true,
        experimental: {
          serverComponentsExternalPackages: ['test-package'],
        },
      };

      // Chain all config functions
      const result = withBundleAnalyzer(
        withPublicEnv(
          withStripRscPrefixPlugin(
            withIgnorePacks(baseConfig)
          )
        )
      );

      // Should preserve original config
      expect(result.reactStrictMode).toBe(true);
      expect(result.experimental).toEqual({
        serverComponentsExternalPackages: ['test-package'],
      });

      // Should have webpack function (from both ignore packs and strip rsc)
      expect(result.webpack).toBeDefined();
      expect(typeof result.webpack).toBe('function');

      // Should have publicRuntimeConfig (from withPublicEnv)
      expect(result.publicRuntimeConfig).toEqual(PublicEnv);

      // Bundle analyzer should not be applied (ANALYZE not set)
      expect(result).not.toHaveProperty('_bundleAnalyzer');
    });

    it('should maintain type safety across chained functions', () => {
      interface CustomConfig extends NextConfig {
        customProperty: string;
        customObject: { nested: boolean };
      }

      const baseConfig: CustomConfig = {
        customProperty: 'test',
        customObject: { nested: true },
        reactStrictMode: true,
      };

      const result = withPublicEnv(withIgnorePacks(baseConfig));

      // TypeScript should preserve custom properties
      expect(result.customProperty).toBe('test');
      expect(result.customObject).toEqual({ nested: true });
      expect(result.reactStrictMode).toBe(true);
      expect(result.publicRuntimeConfig).toEqual(PublicEnv);
    });
  });
});