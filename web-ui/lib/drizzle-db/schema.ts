/**
 * @fileoverview Database Schema Module
 *
 * This module provides a unified database schema interface for the NoEducation application.
 * It combines table definitions from the main schema with custom relations to create a
 * comprehensive database schema object that includes all tables, views, enums, and their relationships.
 *
 * The schema is designed for use with Drizzle ORM and PostgreSQL, providing type-safe
 * database operations throughout the application.
 *
 * @module lib/drizzle-db/schema
 * @version 1.0.0
 * @since 2025-07-16
 *
 * @example
 * ```typescript
 * import { schema, SchemaType, FullSchemaType } from '/lib/drizzle-db/schema';
 *
 * // Use the complete schema for database operations
 * const db = drizzle(connection, { schema });
 *
 * // Type-safe table access
 * const users = await db.select().from(schema.users);
 * ```
 */

import * as tables from '/drizzle/schema';
import * as dbRelations from '/drizzle/custom-relations';
import {
  PgQueryResultHKT,
  PgTable,
  PgTransaction,
  PgUpdateBuilder,
} from 'drizzle-orm/pg-core';
import { drizzle } from 'drizzle-orm/postgres-js';
import { RelationalQueryBuilder } from 'drizzle-orm/gel-core/query-builders/query';
import { DrizzleTypeError } from 'drizzle-orm/utils';
import { TablesRelationalConfig } from 'drizzle-orm';

/**
 * Unified database schema object combining all table definitions and custom relations.
 *
 * This schema object includes:
 * - All table definitions (users, emails, chats, documents, etc.)
 * - All enum definitions (importStageType, recipientType, etc.)
 * - All view definitions (materialized and regular views)
 * - All custom relations between tables
 * - Foreign key constraints and indexes
 *
 * The schema supports the following main functional areas:
 * - **Email Management**: emails, emailAttachments, emailRecipients, stagingMessage
 * - **Document Processing**: documentUnits, documentProperty, documentUnitEmbeddings
 * - **AI Chat System**: chats, chatTurns, chatMessages, chatHistory
 * - **User Management**: users, accounts, sessions, contacts
 * - **Analysis & Compliance**: analysisStage, complianceScoresDetails, violationDetails
 * - **Call-to-Action Tracking**: callToActionDetails, callToActionExpectedResponse
 * - **MCP Integration**: mcpSessions, mcpEvents
 *
 * @constant
 * @type {object}
 */
const schema = { ...tables, ...dbRelations };

export const relations = dbRelations;
/**
 * Complete type definition for the entire database schema.
 *
 * This type represents the full schema object including all tables, relations,
 * views, and enums. It provides comprehensive type safety for all database
 * operations and can be used for advanced type manipulations.
 *
 * @typedef {typeof schema} DbFullSchemaType
 *
 * @example
 * ```typescript
 * import type { DbFullSchemaType } from '/lib/drizzle-db/schema';
 *
 * function processSchema(schema: DbFullSchemaType) {
 *   // Access any table or relation with full type safety
 *   const userTable = schema.users;
 *   const emailRelation = schema.emailsRelations;
 * }
 * ```
 */
export type DbFullSchemaType = typeof schema;

/**
 * Helper function used to infer the type of our database schema.
 *
 * This function creates a mock database instance to extract type information
 * from Drizzle's type system. It's used internally for type inference and
 * should not be called at runtime.
 *
 * **⚠️ CRITICAL FOR TYPE SYSTEM - DO NOT REMOVE**
 *
 * This function is essential for:
 * - Extracting the correct `DbQueryResultHKT` type from Drizzle's internals
 * - Providing type-safe transaction interfaces
 * - Ensuring proper TypeScript inference for database operations
 *
 * The function uses Drizzle's `.mock()` method to create a virtual database
 * instance that matches our schema configuration. This allows TypeScript
 * to infer the exact types needed for transactions and queries without
 * requiring an actual database connection.
 *
 * @internal
 * @returns A mock database instance with the complete schema configured
 * @example
 * ```typescript
 * // This is used internally for type inference only
 * type DbInstance = ReturnType<typeof makeMockDb>;
 *
 * // The function enables these type extractions:
 * type TransactionType = Parameters<DbInstance['transaction']>[0];
 * type QueryResultType = Parameters<TransactionType>[0];
 * ```
 *
 * @see {@link DbQueryResultHKT} - Type extracted from this function's return type
 * @see {@link DbTransactionType} - Transaction type that depends on this function
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const makeMockDb = () =>
  drizzle.mock({
    schema,
    casing: 'snake_case',
  });

/**
 * Type definition for the project database instance.
 * This type is generated by Drizzle ORM and corresponds to the database instance,
 * which includes all tables, relations, and configurations.
 * This type is used throughout the application to ensure type-safe database operations
 *
 *
 * @typedef {typeof makeMockDb} DatabaseType
 * @example
 * ```typescript
 * import type { DatabaseType } from '/lib/drizzle-db/schema';
 * // This type represents the database instance with all tables and relations
 * const db: DatabaseType = makeMockDb();
 * // Use the db instance for type-safe queries
 * const users = await db.select().from(schema.users);
 * ```
 */
export type DbDatabaseType = Omit<ReturnType<typeof makeMockDb>, '$client'>;

export type DbTransactionParam = Parameters<
  ReturnType<typeof makeMockDb>['transaction']
>[0];

/**
 * Higher-Kinded Type (HKT) representing the query result interface for database operations.
 *
 * This advanced TypeScript type extracts the query result type from Drizzle's transaction
 * interface using conditional type inference. It represents the shape of the query builder
 * that's available within database transactions and regular database operations.
 *
 * The HKT pattern allows for:
 * - Type-safe query building
 * - Proper inference of return types for database operations
 * - Consistent typing across transaction and non-transaction contexts
 *
 * This type is extracted by:
 * 1. Creating a mock database instance with our schema via `makeMockDb()`
 * 2. Inferring the transaction callback parameter type from the mock instance
 * 3. Extracting the `TQueryResult` generic from the `PgTransaction` type
 * 4. Using conditional type inference to capture the query builder interface
 *
 * **Type Extraction Process:**
 * ```typescript
 * ReturnType<typeof makeMockDb> // → Mock database instance
 *   extends { transaction: (...) => ... } // → Check for transaction method
 *     ? TQueryResult // → Extract the query result type parameter
 *     : never // → Fallback if extraction fails
 * ```
 *
 * @typedef {object} DbQueryResultHKT
 *
 * @example
 * ```typescript
 * import type { DbQueryResultHKT } from '/lib/drizzle-db/schema';
 *
 * // This type provides the query builder interface
 * type QueryBuilder = DbQueryResultHKT;
 *
 * // Used internally by Drizzle for type-safe operations
 * function executeQuery(qb: QueryBuilder) {
 *   return qb.select().from(schema.users);
 * }
 * ```
 *
 * @see {@link DbTransactionType} - The transaction type that uses this HKT
 * @see {@link makeMockDb} - The helper function used for type inference
 */
export type DbQueryResultHKT = DbTransactionParam extends (
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  tx: PgTransaction<infer TQueryResult, any, any>,
) => unknown
  ? TQueryResult
  : never;

/**
 * Filtered schema type containing only entities with relation configurations.
 *
 * This utility type extracts only the schema entities that have relation
 * configurations defined. It's useful when you need to work specifically
 * with related data and want to ensure type safety for relational operations.
 *
 * The type uses conditional type mapping to include only entities where:
 * - The entity has a `config` property
 * - The `config` property contains a `relations` field
 *
 * This is particularly useful for:
 * - Relational queries with joins
 * - Type-safe relation access
 * - Filtering out standalone tables without relationships
 *
 * @typedef {object} DbSchemaType
 *
 * @example
 * ```typescript
 * import type { DbSchemaType } from '/lib/drizzle-db/schema';
 *
 * function queryWithRelations(relationalSchema: DbSchemaType) {
 *   // Only tables with relations are available
 *   // This ensures you're working with entities that support joins
 *   const usersWithRelations = relationalSchema.users;
 * }
 * ```
 */
export type DbSchemaType = DbTransactionParam extends (
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  tx: PgTransaction<any, any, infer TQueryResult>,
) => unknown
  ? TQueryResult
  : never;

/**
 * Type definition for database transactions with full schema support.
 *
 * This type represents a PostgreSQL transaction context that includes:
 * - Complete type safety for all schema entities
 * - Support for both relational and non-relational tables
 * - Proper query result type inference
 * - Transaction-specific operations and rollback capabilities
 *
 * The transaction type is parameterized with:
 * - `DbQueryResultHKT`: The query result interface for type-safe operations
 * - `DbFullSchemaType`: The complete schema including all tables and relations
 * - `DbSchemaType`: The filtered schema containing only relational entities
 *
 * Common use cases:
 * - **Atomic Operations**: Ensuring multiple database operations succeed or fail together
 * - **Complex Queries**: Performing multi-table operations with proper type safety
 * - **Data Consistency**: Maintaining referential integrity across related tables
 * - **Error Handling**: Automatic rollback on exceptions
 *
 * @typedef {PgTransaction<DbQueryResultHKT, DbFullSchemaType, DbSchemaType>} DbTransactionType
 *
 * @example
 * ```typescript
 * import type { DbTransactionType } from '/lib/drizzle-db/schema';
 * import { db } from '/lib/drizzle-db';
 *
 * // Type-safe transaction function
 * async function createUserWithProfile(
 *   userData: { name: string; email: string },
 *   profileData: { bio: string; avatar: string }
 * ) {
 *   return await db.transaction(async (tx: DbTransactionType) => {
 *     // Insert user with full type safety
 *     const [user] = await tx
 *       .insert(schema.users)
 *       .values(userData)
 *       .returning();
 *
 *     // Insert related profile
 *     const [profile] = await tx
 *       .insert(schema.userProfiles)
 *       .values({ ...profileData, userId: user.id })
 *       .returning();
 *
 *     return { user, profile };
 *   });
 * }
 *
 * // Error handling with automatic rollback
 * async function transferData(fromId: string, toId: string, amount: number) {
 *   try {
 *     return await db.transaction(async (tx: DbTransactionType) => {
 *       // All operations are atomic
 *       await tx.update(schema.accounts)
 *         .set({ balance: sql`balance - ${amount}` })
 *         .where(eq(schema.accounts.id, fromId));
 *
 *       await tx.update(schema.accounts)
 *         .set({ balance: sql`balance + ${amount}` })
 *         .where(eq(schema.accounts.id, toId));
 *
 *       // If any operation fails, entire transaction rolls back
 *     });
 *   } catch (error) {
 *     console.error('Transaction failed, rolled back:', error);
 *     throw error;
 *   }
 * }
 * ```
 *
 * @see {@link DbQueryResultHKT} - The query result type used in transactions
 * @see {@link DbFullSchemaType} - The complete schema type
 * @see {@link DbSchemaType} - The relational schema type
 */
export type DbTransactionType = PgTransaction<
  DbQueryResultHKT,
  DbFullSchemaType,
  DbSchemaType
>;

/**
 * Named export of the complete database schema.
 *
 * @see {@link schema}
 */
export { schema };

/**
 * Default export of the complete database schema.
 *
 * @default schema
 * @see {@link schema}
 */
export default schema;

export type DbQueryProvider<
  TSchema extends TablesRelationalConfig,
  TFullSchema,
> = {
  query: TFullSchema extends Record<string, never>
    ? DrizzleTypeError<'Seems like the schema generic is missing - did you forget to add it to your DB type?'>
    : {
        [K in keyof TSchema]: RelationalQueryBuilder<TSchema, TSchema[K]>;
      };
  update: <
    TTable extends PgTable,
    TQueryResult extends PgQueryResultHKT = PgQueryResultHKT,
  >(
    table: TTable,
  ) => PgUpdateBuilder<TTable, TQueryResult>;
};
export type ThisDbQueryProvider = DbQueryProvider<
  DbSchemaType,
  DbQueryResultHKT
>;
