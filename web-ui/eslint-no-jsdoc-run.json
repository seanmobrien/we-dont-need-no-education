[{"filePath":"D:\\repos\\no-ed\\web-ui\\.eslintrc-no-jsdoc-rule.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\.eslintrc-no-jsdoc-rule.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__mocks__\\data-models\\api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__mocks__\\fetch-mock.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[93,96],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[93,96],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[364,367],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[364,367],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__mocks__\\google-auth-library.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__mocks__\\googleapis.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":6,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":9,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[281,284],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[281,284],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__mocks__\\got.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__mocks__\\lib\\logger.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":11,"column":1,"nodeType":"Program","endLine":27,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file This module provides a mock implementation of a logger for testing purposes.\r\n *\r\n * The `logger` function returns an object with various logging methods (`warn`, `error`, `info`, `debug`, `silly`, `verbose`, `log`),\r\n * each of which is a Jest mock function. These mock functions log their calls to the console with a specific format,\r\n * indicating the method name and the arguments passed to it.\r\n *\r\n * This mock logger can be used in unit tests to verify that logging methods are called with the expected arguments\r\n * without actually performing any logging operations.\r\n */\r\nconst makeMockImplementation = (name: string) => {\r\n  return (...args: unknown[]) =>\r\n    console.log(`logger::${name} called with `, args);\r\n};\r\nexport const logger = () => ({\r\n  warn: jest.fn(makeMockImplementation('warn')),\r\n  error: jest.fn(makeMockImplementation('error')),\r\n  info: jest.fn(makeMockImplementation('info')),\r\n  debug: jest.fn(makeMockImplementation('debug')),\r\n  silly: jest.fn(makeMockImplementation('silly')),\r\n  verbose: jest.fn(makeMockImplementation('verbose')),\r\n  log: jest.fn(makeMockImplementation('log')),\r\n});\r\nexport const log = jest.fn((cb: (l: ReturnType<typeof logger>) => void) =>\r\n  cb(logger())\r\n);\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__mocks__\\lib\\send-api-request.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'x' is defined but never used.","line":12,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":34,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\app\\api\\ai\\chat\\history.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\app\\api\\ai\\chat\\history\\[chatId].test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\app\\api\\ai\\chat\\stats\\models.redis.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\app\\api\\auth\\keys\\route.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\app\\api\\auth\\session\\route.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\app\\api\\contact\\[contactId]\\route.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\app\\api\\contact\\route.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\app\\api\\email\\[emailId]\\properties\\call-to-action\\route.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\app\\api\\email\\import\\[provider]\\_utilities.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\app\\api\\email\\route.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\app\\api\\health\\route.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\app\\chat\\[chatId]\\page.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\app\\home-page-theme.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\app\\messages\\email\\emailId\\call-to-action-panel.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\app\\messages\\email\\emailId\\email-header-panel.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\app\\messages\\email\\emailId\\key-points-panel.test.tsx","messages":[],"suppressedMessages":[{"ruleId":"react/display-name","severity":2,"message":"Component definition is missing display name","line":12,"column":5,"nodeType":"ArrowFunctionExpression","messageId":"noDisplayName","endLine":19,"endColumn":6,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react/display-name","severity":2,"message":"Component definition is missing display name","line":25,"column":5,"nodeType":"ArrowFunctionExpression","messageId":"noDisplayName","endLine":27,"endColumn":6,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\app\\messages\\email\\emailId\\notes-panel.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\app\\messages\\email\\emailId\\responsive-action-panel.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\auth-bypass.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\ai\\chat-panel\\chat-menu-provider-selection.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\ai\\chat-panel\\chat-panel-comprehensive-docking.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\ai\\chat-panel\\chat-panel-context.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\ai\\chat-panel\\chat-panel-dock.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\ai\\chat-panel\\chat-panel-float.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\ai\\chat-panel\\chat-panel-layout.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\ai\\chat-panel\\chat-panel-model-formatting.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\auth\\key-refresh-notify\\wrapper.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\chat-status\\chat-status-indicator.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\chat.mock-data.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\chat\\chat-message-display.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\chat\\chat-message-filters.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\chat\\chat-turn-display.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\chat\\history.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\chat\\list.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\chat\\message-filtering.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\chat\\virtualized-chat-display.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\database-status\\database-status-indicator.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\email-message\\dashboard-layout\\branding.test.tsx","messages":[],"suppressedMessages":[{"ruleId":"@next/next/no-img-element","severity":1,"message":"Using `<img>` could result in slower LCP and higher bandwidth. Consider using `<Image />` from `next/image` or a custom image loader to automatically optimize images. This may incur additional usage or cost from your provider. See: https://nextjs.org/docs/messages/no-img-element","line":36,"column":7,"nodeType":"JSXOpeningElement","endLine":43,"endColumn":9,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\email-message\\dashboard-layout\\custom-email-page-item.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\email-message\\dashboard-layout\\email-dashboard-layout.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\email-message\\dashboard-layout\\email-dashboard-toolbar-action.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\email-message\\dashboard-layout\\index.test.tsx","messages":[],"suppressedMessages":[{"ruleId":"react/no-children-prop","severity":2,"message":"Do not pass children as props. Instead, pass them as additional arguments to React.createElement.","line":156,"column":9,"nodeType":"CallExpression","messageId":"passChildrenAsArgs","endLine":159,"endColumn":11,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\email-message\\email-detail-panel.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\email-message\\email-form-react-query.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\email-message\\email-list.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\email-message\\email-viewer.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\email-message\\list\\email-list.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\email.mock-data.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\error-boundaries\\ClientErrorManager.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\error-boundaries\\error-flow-integration.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\error-boundaries\\renderFallback.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\general\\enhanced-table-head.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\general\\flags\\flag-provider.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\general\\loading-component-updates.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\general\\modal.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\memory-status\\memory-status-indicator.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\mui\\data-grid\\valueGetters.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\mui\\resizeable-draggable-dialog\\background-interaction.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\mui\\resizeable-draggable-dialog\\dialog.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\mui\\resizeable-draggable-dialog\\index.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\mui\\resizeable-draggable-dialog\\integration.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\components\\mui\\resizeable-draggable-dialog\\types.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\concurrency-validation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\data-models\\_utilities.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\instrument\\ChunkingLogExporter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\instrument\\ChunkingTraceExporter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\jest.mock-auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\jest.mock-drizzle.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\jest.mock-error-boundary.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":45,"column":3,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":45,"endColumn":5,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[1504,1506],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[1504,1506],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\jest.mock-got.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\jest.mock-health.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\jest.mock-impersonation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\jest.mock-instrumentation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\jest.mock-metrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\jest.mock-node-modules.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\jest.mock-prexit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\jest.mock-provider-model-maps.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\jest.mock-tracing.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\jest.setup.env.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\jest.setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\jest.test-extensions.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\jest.test-extensions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\agents\\timeline-agent.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\aiModelFactory.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\chat\\message-optimizer-tools.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\core\\count-tokens.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\mcp\\client-tool-provider.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\mcp\\tool-cache.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\mcp\\toolProviderFactory.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\mcp\\user-tool-provider-cache.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\mem0\\types\\health-check.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\cache-basic.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\cache-success-only.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\chat-history\\enhancement-demonstration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\chat-history\\flush-handlers-simple.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\chat-history\\import-incoming-message.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\chat-history\\index.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\chat-history\\instrumentation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\chat-history\\message-deduplication-integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\chat-history\\message-deduplication.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\chat-history\\middleware-integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\chat-history\\processing-queue.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\chat-history\\stream-handlers.generic-start.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\chat-history\\stream-handlers.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\chat-history\\tool-message-deduplication.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\chat-history\\types.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\chat-history\\utility.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\enterprise.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\key-rate-limiter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\set-normalized-defaults.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\state-management\\integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\state-management\\state-management.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\tokenStatsTracking\\tokenStatsMiddleware.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\tokenStatsTracking\\tokenStatsService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\tool-optimizing-middleware\\index.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\tool-optimizing-middleware\\integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\middleware\\tool-optimizing-middleware\\performance.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\services\\chat\\errors\\error-classes.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\services\\chat\\errors\\model-resource-not-found-error.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\services\\chat\\language-model-queue.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\services\\embedding\\EmbeddingService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\services\\model-stats\\model-map-full.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\services\\model-stats\\provider-and-model-map-throwing.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\services\\model-stats\\tool-map.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\services\\search\\hybridSearchClient.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\tools\\getCaseFileDocument\\compact-casefile-document.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\tools\\searchCaseFile.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\tools\\searchPolicyStore.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\tools\\todo.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\tools\\toolCallbackResultFactory.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\tools\\utility.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\ai\\types\\message-structure-preservation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\api\\_baseDrizzleRepository.test.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Do not use \"@ts-nocheck\" because it alters compilation errors.","line":5,"column":1,"nodeType":"Line","messageId":"tsDirectiveComment","endLine":5,"endColumn":15,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\api\\attachment\\drizzle-repository.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\api\\drizzle-crud-controller.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\api\\email.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\api\\email\\email-drizzle-repository.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\api\\email\\email-service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\api\\email\\import\\google\\index.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\api\\email\\properties\\CallToActionDetailsRepository.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\api\\email\\properties\\call-to-action-response\\CallToActionResponseDetailsRepository.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\api\\email\\properties\\call-to-action\\CallToActionDetailsRepository.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\api\\email\\properties\\compliance-scores\\ComplianceScoresDetailsRepository.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\api\\email\\properties\\email-header\\EmailHeaderDetailsRepository.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\api\\email\\properties\\key-points\\KeyPointsDetailsRepository.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\api\\email\\properties\\sentiment-analysis\\SentimentAnalysisDetailsRepository.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\api\\email\\properties\\violation-details\\ViolationDetailsRepository.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\api\\target-repositories.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\auth\\impersonation.thirdparty.cache.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\auth\\impersonation.thirdparty.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\auth\\impersonation\\impersonation-service-cache.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\auth\\impersonation\\utility.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\auth\\redirect.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\components\\ai\\chat-query-integration.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\components\\mui\\data-grid\\buildDrizzleFilter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\components\\mui\\data-grid\\buildDrizzleOrderBy.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\components\\mui\\data-grid\\buildDrizzlePagination.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\components\\mui\\data-grid\\buildQueryFilter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\components\\mui\\data-grid\\selectForGrid.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\components\\mui\\data-grid\\useDataSourceQuery.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\components\\mui\\data-grid\\utility.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\config\\index.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\drizzle-db\\drizzle-error.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\drizzle-db\\drizzle-types.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\email\\email-id-resolver.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\email\\import\\google\\parsedHeaderMap.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\email\\import\\google\\utilities.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\email\\import\\importmanager.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\error-monitoring\\error-reporter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\error-monitoring\\recovery-strategies.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\error-monitoring\\use-error-reporter.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\hooks\\use-email.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\hooks\\use-statistics.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\logger\\simple-scoped-logger.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\logger\\utilities.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\neondb\\main.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\nextjs-util\\error-response.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\nextjs-util\\guards.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\nextjs-util\\server\\error-response.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\nextjs-util\\server\\utils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\nextjs-util\\server\\utils.tracing.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\nextjs-util\\utils.wrapRouteRequest.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\react-util\\_utility-methods.debounce.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\react-util\\_utility-methods.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\react-util\\errors\\aggregate-error.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\react-util\\errors\\error-like.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\react-util\\simple-circuit-breaker.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\react-util\\simple-rate-limiter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\react-util\\url.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\react-util\\utility-methods.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\site-util\\auth\\crypto-service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\site-util\\auth\\key-validation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\site-util\\auth\\keycloak-token-exchange.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\site-util\\auth\\security.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\site-util\\auth\\user-keys.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\site-util\\format.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\site-util\\url-builder\\url-builder.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\themes\\definitions.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\typescript\\_generics.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\typescript\\_guards.extra.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\typescript\\_guards.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\typescript\\_record-decorators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\typescript\\dual-key-map.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\typescript\\singleton-provider.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\lib\\typescript\\zod.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\mocks\\zodex.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\test-utils.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\test-utils\\auth-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\__tests__\\themes\\theme-integration.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\ai\\agents\\timeline\\route.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":196,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export const dynamic = 'force-dynamic';\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { wrapRouteRequest } from '@/lib/nextjs-util/server/utils';\r\nimport {\r\n  TimelineAgentFactory,\r\n  ServerTimelineAgent as TimelineAgent,\r\n} from '@/lib/ai/agents/timeline/agent-server';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\n\r\nconst buildFallback = {\r\n  success: true,\r\n  data: {\r\n    summary: {\r\n      title: 'Mock Timeline Summary',\r\n      description: 'This is a mock summary for the timeline.',\r\n    },\r\n    counts: {\r\n      totalDocuments: 1,\r\n      processedDocuments: 1,\r\n    },\r\n    hasMoreDocuments: false,\r\n    snapshot: {\r\n      documentId: 'mock-doc-1',\r\n      date: new Date().toISOString(),\r\n      summary: 'Mock document processed successfully',\r\n      verbatimStatements: [\r\n        'This is a mock verbatim statement from the document',\r\n      ],\r\n      complianceNotes: ['Build-optimized mock document'],\r\n      actionTaken: 'Document reviewed and analyzed',\r\n      actionRequired: 'Continue to next document in sequence',\r\n    },\r\n  },\r\n} as const;\r\n\r\n/**\r\n * API endpoint for Timeline Agent operations\r\n * Handles initialization, document processing, summary generation, and state serialization\r\n */\r\nexport const POST = wrapRouteRequest(\r\n  async (request: NextRequest) => {\r\n    try {\r\n      const { action, initialDocumentId, snapshot, propertyId } =\r\n        await request.json();\r\n\r\n      switch (action) {\r\n        case 'initialize': {\r\n          if (!initialDocumentId) {\r\n            return NextResponse.json(\r\n              { error: 'initialDocumentId is required' },\r\n              { status: 400 },\r\n            );\r\n          }\r\n\r\n          const agent = TimelineAgentFactory({ initialDocumentId, propertyId });\r\n\r\n          await agent.initialize({ req: request });\r\n\r\n          const summary = agent.generateSummary();\r\n          const counts = agent.getDocumentCounts();\r\n\r\n          return NextResponse.json({\r\n            success: true,\r\n            data: {\r\n              summary,\r\n              counts,\r\n              hasMoreDocuments: agent.hasMoreDocuments(),\r\n              snapshot: agent.createSnapshot(), // Include serialized state\r\n            },\r\n          });\r\n        }\r\n\r\n        case 'restore': {\r\n          if (!snapshot) {\r\n            return NextResponse.json(\r\n              { error: 'snapshot is required for restore action' },\r\n              { status: 400 },\r\n            );\r\n          }\r\n\r\n          try {\r\n            const agent = TimelineAgent.fromSnapshot(snapshot);\r\n            const summary = agent.generateSummary();\r\n            const counts = agent.getDocumentCounts();\r\n\r\n            return NextResponse.json({\r\n              success: true,\r\n              data: {\r\n                summary,\r\n                counts,\r\n                hasMoreDocuments: agent.hasMoreDocuments(),\r\n                snapshot: agent.createSnapshot(),\r\n              },\r\n            });\r\n          } catch (error) {\r\n            return NextResponse.json(\r\n              { error: `Failed to restore agent: ${error}` },\r\n              { status: 400 },\r\n            );\r\n          }\r\n        }\r\n\r\n        case 'process': {\r\n          // In a real implementation, you would need to persist the agent state\r\n          // For now, this is a mock response\r\n          return NextResponse.json({\r\n            success: true,\r\n            data: {\r\n              documentId: 'mock-doc-' + Date.now(),\r\n              timelineEntry: {\r\n                documentId: 'mock-doc-' + Date.now(),\r\n                date: new Date().toISOString(),\r\n                summary: 'Mock document processed successfully',\r\n                verbatimStatements: [\r\n                  'This is a mock verbatim statement from the document',\r\n                  'Another key statement for compliance review',\r\n                ],\r\n                complianceNotes: [\r\n                  'Document follows standard format',\r\n                  'No immediate compliance concerns identified',\r\n                ],\r\n                actionTaken: 'Document reviewed and analyzed',\r\n                actionRequired: 'Continue to next document in sequence',\r\n              },\r\n              notes: [\r\n                'Mock processing completed successfully',\r\n                'Document appears to be in proper format',\r\n              ],\r\n              additionalDocuments:\r\n                Math.random() > 0.7 ? ['additional-doc-' + Date.now()] : [],\r\n            },\r\n          });\r\n        }\r\n\r\n        default:\r\n          return NextResponse.json(\r\n            { error: 'Invalid action' },\r\n            { status: 400 },\r\n          );\r\n      }\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'Timeline Agent API',\r\n        message: 'Error processing Timeline Agent request',\r\n        extra: { action: request.method, url: request.url },\r\n      });\r\n      return NextResponse.json(\r\n        { error: 'Internal server error' },\r\n        { status: 500 },\r\n      );\r\n    }\r\n  },\r\n  { buildFallback },\r\n);\r\n\r\nexport const GET = wrapRouteRequest(\r\n  async (request: NextRequest) => {\r\n    const { searchParams } = new URL(request.url);\r\n    const documentId = searchParams.get('documentId');\r\n\r\n    if (!documentId) {\r\n      return NextResponse.json(\r\n        { error: 'documentId parameter is required' },\r\n        { status: 400 },\r\n      );\r\n    }\r\n\r\n    // Mock document data for demonstration\r\n    const mockDocument = {\r\n      id: documentId,\r\n      content: `This is mock content for document ${documentId}. In a real implementation, this would be fetched from a document store or database.`,\r\n      metadata: {\r\n        documentType: 'Email Communication',\r\n        dateSent: new Date(\r\n          Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000,\r\n        ).toISOString(),\r\n        sender: 'mock.sender@example.com',\r\n        recipient: 'mock.recipient@example.com',\r\n        subject: `Mock Document ${documentId}`,\r\n        attachmentCount: Math.floor(Math.random() * 3),\r\n        priority: ['Low', 'Medium', 'High', 'Critical'][\r\n          Math.floor(Math.random() * 4)\r\n        ] as 'Low' | 'Medium' | 'High' | 'Critical',\r\n      },\r\n    };\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      data: mockDocument,\r\n    });\r\n  },\r\n  { buildFallback },\r\n);\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\ai\\chat\\history\\[chatId]\\route.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":156,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { auth } from '@/auth';\r\nimport { drizDbWithInit } from '@/lib/drizzle-db';\r\nimport { schema } from '@/lib/drizzle-db/schema';\r\nimport { eq, and } from 'drizzle-orm';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport type { ChatDetails, ChatTurn } from '@/lib/ai/chat';\r\nimport { wrapRouteRequest } from '@/lib/nextjs-util/server/utils';\r\n\r\nexport const dynamic = 'force-dynamic';\r\n\r\n/**\r\n * Handles GET request to fetch chat details by ID\r\n *\r\n * @param req - The Next.js request object\r\n * @param params - Route parameters containing chatId\r\n * @returns JSON response with chat details or error\r\n */\r\nexport const GET = wrapRouteRequest(\r\n  async (\r\n    req: NextRequest,\r\n    { params }: { params: Promise<{ chatId: string }> },\r\n  ): Promise<NextResponse> => {\r\n    const { chatId } = await params;\r\n    try {\r\n      // Validate session authentication\r\n      const session = await auth();\r\n      if (!session) {\r\n        return NextResponse.json(\r\n          { error: 'Unauthorized - session required' },\r\n          { status: 401 },\r\n        );\r\n      }\r\n\r\n      const db = await drizDbWithInit();\r\n\r\n      // Get chat basic info using drizzle\r\n      const chatResult = await db\r\n        .select({\r\n          id: schema.chats.id,\r\n          title: schema.chats.title,\r\n          createdAt: schema.chats.createdAt,\r\n        })\r\n        .from(schema.chats)\r\n        .where(eq(schema.chats.id, chatId))\r\n        .limit(1);\r\n\r\n      if (chatResult.length === 0) {\r\n        return NextResponse.json({ error: 'Chat not found' }, { status: 404 });\r\n      }\r\n\r\n      const chat = chatResult[0];\r\n\r\n      // Get chat turns and messages using drizzle with joins\r\n      const turnsAndMessagesResult = await db\r\n        .select({\r\n          // Turn fields\r\n          turnId: schema.chatTurns.turnId,\r\n          createdAt: schema.chatTurns.createdAt,\r\n          completedAt: schema.chatTurns.completedAt,\r\n          modelName: schema.chatTurns.modelName,\r\n          turnStatusId: schema.chatTurns.statusId,\r\n          temperature: schema.chatTurns.temperature,\r\n          topP: schema.chatTurns.topP,\r\n          latencyMs: schema.chatTurns.latencyMs,\r\n          warnings: schema.chatTurns.warnings,\r\n          errors: schema.chatTurns.errors,\r\n          turnMetadata: schema.chatTurns.metadata,\r\n          // Message fields\r\n          messageId: schema.chatMessages.messageId,\r\n          role: schema.chatMessages.role,\r\n          content: schema.chatMessages.content,\r\n          messageOrder: schema.chatMessages.messageOrder,\r\n          toolName: schema.chatMessages.toolName,\r\n          functionCall: schema.chatMessages.functionCall,\r\n          toolResult: schema.chatMessages.toolResult,\r\n          messageStatusId: schema.chatMessages.statusId,\r\n          providerId: schema.chatMessages.providerId,\r\n          messageMetadata: schema.chatMessages.metadata,\r\n          toolInstanceId: schema.chatMessages.toolInstanceId,\r\n          optimizedContent: schema.chatMessages.optimizedContent,\r\n        })\r\n        .from(schema.chatTurns)\r\n        .leftJoin(\r\n          schema.chatMessages,\r\n          and(\r\n            eq(schema.chatTurns.chatId, schema.chatMessages.chatId),\r\n            eq(schema.chatTurns.turnId, schema.chatMessages.turnId),\r\n          ),\r\n        )\r\n        .where(eq(schema.chatTurns.chatId, chatId))\r\n        .orderBy(schema.chatTurns.turnId, schema.chatMessages.messageOrder);\r\n\r\n      // Group messages by turn\r\n      const turnsMap = new Map<number, ChatTurn>();\r\n      turnsAndMessagesResult.forEach((row: Record<string, unknown>) => {\r\n        if (!turnsMap.has(Number(row.turnId))) {\r\n          turnsMap.set(Number(row.turnId), {\r\n            turnId: Number(row.turnId),\r\n            createdAt: String(row.createdAt),\r\n            completedAt: String(row.completedAt),\r\n            modelName: String(row.modelName),\r\n            statusId: Number(row.turnStatusId),\r\n            temperature: Number(row.temperature),\r\n            topP: Number(row.topP),\r\n            latencyMs: Number(row.latencyMs),\r\n            warnings: Array.isArray(row.warnings) ? row.warnings : [],\r\n            errors: Array.isArray(row.errors) ? row.errors : [],\r\n            metadata: row.turnMetadata as Record<string, unknown>,\r\n            messages: [],\r\n          });\r\n        }\r\n\r\n        if (row.messageId) {\r\n          const turn = turnsMap.get(Number(row.turnId))!;\r\n          turn.messages.push({\r\n            turnId: Number(row.turnId),\r\n            messageId: Number(row.messageId),\r\n            role: String(row.role),\r\n            content: String(row.content),\r\n            messageOrder: Number(row.messageOrder),\r\n            toolName: String(row.toolName),\r\n            functionCall: row.functionCall as Record<string, unknown> | null,\r\n            toolResult: row.toolResult as Record<string, unknown> | null,\r\n            statusId: Number(row.messageStatusId),\r\n            providerId: String(row.providerId),\r\n            metadata: row.messageMetadata as Record<string, unknown>,\r\n            toolInstanceId: String(row.toolInstanceId),\r\n            optimizedContent: row.optimizedContent as string | null,\r\n          });\r\n        }\r\n      });\r\n\r\n      const chatDetails: ChatDetails = {\r\n        id: chat.id,\r\n        title: chat.title,\r\n        createdAt: chat.createdAt ?? new Date().toISOString(),\r\n        turns: Array.from(turnsMap.values()),\r\n      };\r\n\r\n      return NextResponse.json(chatDetails);\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        message: 'Error fetching chat details',\r\n        context: { chatId },\r\n      });\r\n      return NextResponse.json(\r\n        { error: 'Internal Server Error' },\r\n        { status: 500 },\r\n      );\r\n    }\r\n  },\r\n  { buildFallback: { id: 'not-enabled', title: 'Wait for build to complete' } },\r\n);\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\ai\\chat\\history\\route.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":201,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type NextRequest, NextResponse } from 'next/server';\r\nimport { log } from '@/lib/logger';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { drizDbWithInit } from '@/lib/drizzle-db';\r\nimport { schema } from '@/lib/drizzle-db/schema';\r\nimport {\r\n  DrizzleSelectQuery,\r\n  selectForGrid,\r\n} from '@/lib/components/mui/data-grid/queryHelpers';\r\nimport type { PgColumn } from 'drizzle-orm/pg-core';\r\nimport { wrapRouteRequest } from '@/lib/nextjs-util/server/utils';\r\nimport { SQL, eq, count, sum, lte, gt } from 'drizzle-orm/sql';\r\n\r\n/**\r\n * Chat summary interface for the data grid\r\n */\r\ninterface ChatSummary {\r\n  id: string;\r\n  title: string | null;\r\n  userId: number;\r\n  createdAt: string;\r\n  chatMetadata: object | null;\r\n  totalTokens: number;\r\n  totalMessages: number;\r\n  totalTurns: number;\r\n}\r\n\r\ntype ColumnType = PgColumn | SQL.Aliased;\r\n\r\nconst getColumnFromName = (\r\n  columnName: string,\r\n  {\r\n    columnTurns,\r\n    columnMessages,\r\n    columnTokens,\r\n  }: {\r\n    columnTurns: ColumnType;\r\n    columnMessages: ColumnType;\r\n    columnTokens: ColumnType;\r\n  },\r\n): ColumnType | undefined => {\r\n  switch (columnName) {\r\n    case 'id':\r\n      return schema.chats.id;\r\n    case 'title':\r\n      return schema.chats.title;\r\n    case 'user_id':\r\n      return schema.chats.userId;\r\n    case 'created_at':\r\n      return schema.chats.createdAt;\r\n    case 'chat_metadata':\r\n      return schema.chats.metadata;\r\n    case 'total_tokens':\r\n      return columnTokens;\r\n    case 'total_messages':\r\n      return columnMessages;\r\n    case 'total_turns':\r\n      return columnTurns;\r\n    default:\r\n      return undefined;\r\n  }\r\n};\r\n\r\n// Record mapper to transform database records to ChatSummary objects\r\nconst recordMapper = (record: Record<string, unknown>): ChatSummary => ({\r\n  id: String(record.id),\r\n  title: record.title != null ? String(record.title) : null,\r\n  userId: Number(record.userId),\r\n  createdAt: String(record.createdAt),\r\n  chatMetadata:\r\n    typeof record.chatMetadata === 'string'\r\n      ? JSON.parse(record.chatMetadata)\r\n      : record.chatMetadata,\r\n  totalTokens: Number(record.totalTokens) || 0,\r\n  totalMessages: Number(record.totalMessages) || 0,\r\n  totalTurns: Number(record.totalTurns) || 0,\r\n});\r\n\r\n// Column map for the data grid\r\nconst columnMap = {\r\n  chatMetadata: 'chat_metadata',\r\n  createdAt: 'created_at',\r\n  id: 'id',\r\n  title: 'title',\r\n  totalTokens: 'total_tokens',\r\n  totalMessages: 'total_messages',\r\n  totalTurns: 'total_turns',\r\n  userId: 'user_id',\r\n} as const;\r\n\r\n/**\r\n * Handles the GET request to fetch a list of chats with pagination.\r\n *\r\n * This function queries the database to retrieve chats using drizzle ORM.\r\n * Supports filtering by user type via query parameter:\r\n * - viewType=user: Shows chats for users with userId > 0 (default)\r\n * - viewType=system: Shows system chats with userId <= 0\r\n *\r\n * @returns {Promise<NextResponse>} A promise that resolves to a JSON response containing the\r\n * list of chats with pagination information, or an error message if the request fails.\r\n */\r\nexport const GET = wrapRouteRequest(\r\n  async (req: NextRequest): Promise<NextResponse> => {\r\n    try {\r\n      // Get view type from query parameters\r\n      const url = new URL(req.url);\r\n      const viewType = url.searchParams.get('viewType') || 'user';\r\n      const isSystemView = viewType === 'system';\r\n\r\n      // Define the base query for chats\r\n      const result = await drizDbWithInit((db) => {\r\n        const qSumTokens = db\r\n          .select({\r\n            chatId: schema.tokenUsage.chatId,\r\n            totalTokens: sum(schema.tokenUsage.totalTokens).as(\r\n              'all_the_tokens',\r\n            ),\r\n          })\r\n          .from(schema.tokenUsage)\r\n          .groupBy(schema.tokenUsage.chatId)\r\n          .as('tblTokens');\r\n        // Sum messages\r\n        const qSumMessages = db\r\n          .select({\r\n            chatId: schema.chatMessages.chatId,\r\n            totalMessages: count().as('all_the_messages'),\r\n          })\r\n          .from(schema.chatMessages)\r\n          .groupBy(schema.chatMessages.chatId)\r\n          .as('tblMessages');\r\n        // Sum turns\r\n        const qSumTurns = db\r\n          .select({\r\n            chatId: schema.chatTurns.chatId,\r\n            totalTurns: count().as('all_the_turns'),\r\n          })\r\n          .from(schema.chatTurns)\r\n          .groupBy(schema.chatTurns.chatId)\r\n          .as('tblTurns');\r\n\r\n        // Sum tokens by chat\r\n        const columnTurns: SQL.Aliased = qSumTurns.totalTurns;\r\n        // count(schema.chatTurns.turnId).as('all_the_turns');\r\n        const columnTokens: SQL.Aliased = qSumTokens.totalTokens;\r\n        const columnMessages: SQL.Aliased = qSumMessages.totalMessages;\r\n\r\n        const query = db\r\n          .select({\r\n            id: schema.chats.id,\r\n            title: schema.chats.title,\r\n            userId: schema.chats.userId,\r\n            createdAt: schema.chats.createdAt,\r\n            chatMetadata: schema.chats.metadata,\r\n            totalTokens: columnTokens,\r\n            totalMessages: columnMessages,\r\n            totalTurns: columnTurns,\r\n          })\r\n          .from(schema.chats)\r\n          .leftJoin(qSumTokens, eq(qSumTokens.chatId, schema.chats.id))\r\n          .leftJoin(qSumMessages, eq(qSumMessages.chatId, schema.chats.id))\r\n          .leftJoin(qSumTurns, eq(qSumTurns.chatId, schema.chats.id));\r\n\r\n        // Apply the user/system filter\r\n        const filteredQuery = isSystemView\r\n          ? query.where(lte(schema.chats.userId, 0))\r\n          : query.where(gt(schema.chats.userId, 0));\r\n\r\n        return selectForGrid<ChatSummary>({\r\n          req,\r\n          query: filteredQuery as unknown as DrizzleSelectQuery,\r\n          getColumn: (c) =>\r\n            getColumnFromName(c, { columnTokens, columnMessages, columnTurns }),\r\n          columnMap,\r\n          recordMapper,\r\n          defaultSort: [{ field: 'created_at', sort: 'desc' }],\r\n        });\r\n      });\r\n      log((l) =>\r\n        l.verbose({\r\n          msg: `[[AUDIT]] - Chat history list (${viewType} view) ${result.results.length} matches:`,\r\n          resultset: result.results.map((x) => x.id),\r\n          viewType,\r\n        }),\r\n      );\r\n      return NextResponse.json(result);\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'GET chat history',\r\n      });\r\n      return NextResponse.json(\r\n        { error: 'Internal Server Error' },\r\n        { status: 500 },\r\n      );\r\n    }\r\n  },\r\n  { buildFallback: { rows: [], rowCount: 0 } },\r\n);\r\n\r\nexport const dynamic = 'force-dynamic';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\ai\\chat\\rate-retry\\response\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\ai\\chat\\rate-retry\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\ai\\chat\\route.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":387,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export const dynamic = 'force-dynamic';\r\nimport {\r\n  streamText,\r\n  convertToModelMessages,\r\n  UIMessage,\r\n  stepCountIs,\r\n  hasToolCall,\r\n} from 'ai';\r\nimport { aiModelFactory } from '@/lib/ai/aiModelFactory';\r\nimport { isAiLanguageModelType } from '@/lib/ai/core/guards';\r\nimport { splitIds, generateChatId } from '@/lib/ai/core/chat-ids';\r\nimport { getRetryErrorInfo } from '@/lib/ai/chat/error-helpers';\r\nimport { getUserToolProviderCache } from '@/lib/ai/mcp/cache';\r\nimport { wrapChatHistoryMiddleware } from '@/lib/ai/middleware/chat-history';\r\nimport { env } from '@/lib/site-util/env';\r\nimport { auth } from '@/auth';\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { log } from '@/lib/logger';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { isAbortError, isTruthy } from '@/lib/react-util/utility-methods';\r\nimport { wrapRouteRequest } from '@/lib/nextjs-util/server';\r\nimport { createUserChatHistoryContext } from '@/lib/ai/middleware/chat-history/create-chat-history-context';\r\nimport type { ToolProviderSet } from '@/lib/ai/mcp/types';\r\nimport { setupDefaultTools } from '@/lib/ai/mcp/providers';\r\nimport { getFeatureFlag } from '@/lib/site-util/feature-flags/server';\r\nimport { User } from 'next-auth';\r\n// Allow streaming responses up to 360 seconds\r\n//const maxDuration = 60 * 1000 * 360;\r\n\r\n/**\r\n * Safely disposes of tool providers, suppressing expected AbortErrors during cleanup.\r\n * @param toolProviders - The tool provider set to dispose\r\n */\r\nconst safeDisposeToolProviders = async (\r\n  user: User | null,\r\n  toolProviders: ToolProviderSet | undefined,\r\n): Promise<void> => {\r\n  if (!toolProviders) return;\r\n  try {\r\n    // I think we only want to dispose if we created them\r\n    const flag = await getFeatureFlag('mcp_cache_tools', user?.id);\r\n    if (!isTruthy(flag)) {\r\n      await toolProviders.dispose();\r\n    }\r\n  } catch (disposalError) {\r\n    // Suppress AbortErrors during disposal as they're expected during cleanup\r\n    if (!isAbortError(disposalError)) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(disposalError, {\r\n        log: true,\r\n        severity: 'warn',\r\n        source: 'route:ai:chat safeDisposeToolProviders',\r\n        message: 'Error during tool provider disposal',\r\n      });\r\n    }\r\n  }\r\n};\r\n\r\nconst toolProviderFactory = async ({\r\n  req,\r\n  chatHistoryId,\r\n  memoryDisabled = false,\r\n  writeEnabled = false,\r\n  user,\r\n  sessionId,\r\n}: {\r\n  req: NextRequest;\r\n  chatHistoryId: string;\r\n  writeEnabled?: boolean;\r\n  memoryDisabled?: boolean;\r\n  // impersonation?: ImpersonationService;\r\n  user: User;\r\n  sessionId: string;\r\n}) => {\r\n  const flag = await getFeatureFlag('mcp_cache_tools', user?.id);\r\n  if (isTruthy(flag)) {\r\n    const toolProviderCache = await getUserToolProviderCache({\r\n      maxEntriesPerUser: 5, // Allow up to 5 different tool configurations per user\r\n      maxTotalEntries: 200, // Increase total limit for multiple users\r\n      ttl: 45 * 60 * 1000, // 45 minutes (longer than typical chat sessions)\r\n      cleanupInterval: 10 * 60 * 1000, // Cleanup every 10 minutes\r\n    });\r\n    // Use the cache to get or create tool providers\r\n    return toolProviderCache.getOrCreate(\r\n      user.id!,\r\n      sessionId,\r\n      {\r\n        writeEnabled,\r\n        memoryDisabled,\r\n      },\r\n      () =>\r\n        setupDefaultTools({\r\n          writeEnabled,\r\n          user,\r\n          req,\r\n          chatHistoryId,\r\n          memoryEnabled: !memoryDisabled,\r\n        }),\r\n    );\r\n  }\r\n  return setupDefaultTools({\r\n    user,\r\n    writeEnabled,\r\n    req,\r\n    chatHistoryId,\r\n    memoryEnabled: !memoryDisabled,\r\n  });\r\n};\r\n\r\nconst extractRequestParams = async (req: NextRequest) => {\r\n  // Pull messages and ID from body\r\n  const { messages, id } = (await req.json()) ?? {};\r\n  const modelFromRequest =\r\n    req.headers.get('x-active-model') ?? env('NEXT_PUBLIC_DEFAULT_AI_MODEL');\r\n  const writeEnabled = req.headers.get('x-write-enabled') === 'true';\r\n  const memoryDisabled = req.headers.get('x-memory-disabled') === 'true';\r\n  const activePage = req.headers.get('x-active-page') === 'true';\r\n  // Extract thread portion of id from message id\r\n  const [threadId] = splitIds(id ?? undefined);\r\n  // and return it all in a handly extractable payload\r\n  return {\r\n    activePage,\r\n    messages,\r\n    id,\r\n    threadId,\r\n    modelFromRequest,\r\n    writeEnabled,\r\n    memoryDisabled,\r\n    model: isAiLanguageModelType(modelFromRequest)\r\n      ? modelFromRequest\r\n      : env('NEXT_PUBLIC_DEFAULT_AI_MODEL'),\r\n  };\r\n};\r\n\r\nexport const POST = (req: NextRequest) => {\r\n  let toolProviders: ToolProviderSet | undefined = undefined;\r\n\r\n  return wrapRouteRequest(\r\n    async (req: NextRequest) => {\r\n      const session = await auth();\r\n      if (\r\n        !session ||\r\n        !session.user ||\r\n        process.env.NEXT_PHASE === 'phase-production-build'\r\n      ) {\r\n        return new Response('Unauthorized', { status: 401 });\r\n      }\r\n      if (!session || !session.user) {\r\n        throw new Error('Unauthorized');\r\n      }\r\n      const {\r\n        // activePage,\r\n        messages,\r\n        id,\r\n        threadId,\r\n        writeEnabled,\r\n        memoryDisabled,\r\n        model,\r\n      } = await extractRequestParams(req);\r\n      // Validate args\r\n      if (!Array.isArray(messages) || messages.length === 0) {\r\n        return new Response('Invalid messages format', { status: 400 });\r\n      }\r\n      const chatHistoryId = id ?? `${threadId}:${generateChatId().id}`;\r\n\r\n      // Get tools\r\n      try {\r\n        toolProviders ??= await toolProviderFactory({\r\n          req,\r\n          chatHistoryId,\r\n          memoryDisabled,\r\n          writeEnabled,\r\n          user: session?.user,\r\n          sessionId: chatHistoryId,\r\n        });\r\n        // Create chat history context\r\n        const chatHistoryContext = createUserChatHistoryContext({\r\n          userId: session?.user?.id || 'anonymous',\r\n          requestId: chatHistoryId,\r\n          chatId: threadId,\r\n          model,\r\n        });\r\n\r\n        // Wrap the base model with chat history middleware\r\n        const baseModel = aiModelFactory(model);\r\n        const modelWithHistory = wrapChatHistoryMiddleware({\r\n          model: baseModel,\r\n          chatHistoryContext,\r\n        });\r\n        // attach tools\r\n        let isRateLimitError = false;\r\n        let retryAfter = 0;\r\n        toolProviders ??= await toolProviderFactory({\r\n          req,\r\n          chatHistoryId,\r\n          memoryDisabled,\r\n          writeEnabled,\r\n          user: session?.user,\r\n          sessionId: chatHistoryId,\r\n        });\r\n        // In v5: create a UI message stream response and merge the generated stream.\r\n        // We'll create a merged ReadableStream that forwards the SDK stream and allows\r\n        // injecting an annotated retry data chunk when a rate limit is detected.\r\n        const result = streamText({\r\n          model: modelWithHistory,\r\n          messages: convertToModelMessages(messages),\r\n          _internal: {\r\n            generateId: () => `${threadId ?? 'not-set'}:${generateChatId().id}`,\r\n          },\r\n          experimental_telemetry: {\r\n            isEnabled: true, // Currently a bug in the ai package processing string dates\r\n            functionId: 'chat-request',\r\n            metadata: {\r\n              userId: session?.user?.id || 'anonymous',\r\n              requestId: chatHistoryId,\r\n              chatId: threadId || 'no-thread',\r\n            },\r\n          },\r\n          providerOptions: {\r\n            openai: {\r\n              store: true,\r\n              user: session.user ? `user-${session.user.id}` : `user-anon`,\r\n            },\r\n          },\r\n          stopWhen: [stepCountIs(20), hasToolCall('askConfirmation')],\r\n          onError: async (error) => {\r\n            // await safeDisposeToolProviders(toolProviders);\r\n            LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n              log: true,\r\n              source: 'route:ai:chat onError',\r\n              message: 'Error during chat processing',\r\n              critical: true,\r\n              data: {\r\n                userId: session?.user?.id,\r\n                model,\r\n                chatHistoryId,\r\n              },\r\n            });\r\n            chatHistoryContext.error = error;\r\n            try {\r\n              const rateLimitErrorInfo = getRetryErrorInfo(error);\r\n              if (\r\n                rateLimitErrorInfo &&\r\n                rateLimitErrorInfo.isError === true &&\r\n                rateLimitErrorInfo.isRetry === true\r\n              ) {\r\n                isRateLimitError = true;\r\n                retryAfter = rateLimitErrorInfo.retryAfter ?? 60;\r\n              }\r\n\r\n              if (isRateLimitError) {\r\n                const retryAt = new Date(Date.now() + retryAfter * 1000);\r\n                log((l) =>\r\n                  l.warn('Rate limit exceeded - retry request later', {\r\n                    model,\r\n                    retryAt,\r\n                    chatHistoryId,\r\n                    userId: session?.user?.id ?? -1,\r\n                  }),\r\n                );\r\n                return;\r\n              }\r\n            } finally {\r\n              chatHistoryContext.dispose();\r\n            }\r\n          },\r\n          onFinish: async (/*evt*/) => {\r\n            try {\r\n              // await safeDisposeToolProviders(toolProviders);\r\n              log((l) =>\r\n                l.verbose({\r\n                  source: 'route:ai:chat onFinish',\r\n                  message: 'Chat response generated',\r\n                  data: {\r\n                    userId: session?.user?.id,\r\n                    chatHistoryId,\r\n                    model,\r\n                    isRateLimitError,\r\n                    retryAfter,\r\n                    // event: evt,\r\n                  },\r\n                }),\r\n              );\r\n            } catch (error) {\r\n              LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n                log: true,\r\n                source: 'route:ai:chat onFinish',\r\n                severity: 'error',\r\n                data: {\r\n                  userId: session?.user?.id,\r\n                  model,\r\n                  chatHistoryId,\r\n                  isRateLimitError,\r\n                  retryAfter,\r\n                },\r\n              });\r\n              chatHistoryContext.error = error;\r\n            } finally {\r\n              chatHistoryContext.dispose();\r\n            }\r\n          },\r\n          tools: (toolProviders ??= await toolProviderFactory({\r\n            req,\r\n            chatHistoryId,\r\n            memoryDisabled,\r\n            writeEnabled,\r\n            user: session?.user,\r\n            sessionId: chatHistoryId,\r\n          })).tools,\r\n        });\r\n\r\n        // Create a merged UI message chunk stream so we can inject a structured\r\n        // `data-error-notify-retry` chunk when a rate limit is detected. We use the\r\n        // SDK's `toUIMessageStream()` AsyncIterable then forward each chunk as an\r\n        // SSE data event, and append our retry data chunk if needed.\r\n        const uiChunkIterable = result.toUIMessageStream<UIMessage>({\r\n          // preserve defaults; originalMessages aren't required here because we\r\n          // will forward all chunks and emit an explicit data part when needed.\r\n        });\r\n\r\n        async function* mergedChunks() {\r\n          try {\r\n            for await (const chunk of uiChunkIterable) {\r\n              yield chunk as unknown as Record<string, unknown>;\r\n            }\r\n          } finally {\r\n            // After the SDK stream completes, if we detected a rate limit during\r\n            // streaming, emit a structured data chunk that the client UI can\r\n            // recognize and handle.\r\n            if (isRateLimitError) {\r\n              const retryAt = new Date(Date.now() + retryAfter * 1000);\r\n              yield {\r\n                type: 'data-error-notify-retry',\r\n                id: `${threadId ?? 'not-set'}:retry`,\r\n                data: {\r\n                  model: model,\r\n                  retryAt: retryAt.toISOString(),\r\n                },\r\n                transient: false,\r\n              } as Record<string, unknown>;\r\n            }\r\n          }\r\n        }\r\n\r\n        const encoder = new TextEncoder();\r\n        const stream = new ReadableStream<Uint8Array>({\r\n          async start(controller) {\r\n            try {\r\n              for await (const chunk of mergedChunks()) {\r\n                const payload = JSON.stringify(chunk);\r\n                controller.enqueue(encoder.encode(`data: ${payload}\\n\\n`));\r\n              }\r\n              controller.close();\r\n            } catch (err) {\r\n              controller.error(err as Error);\r\n            }\r\n          },\r\n          cancel() {\r\n            // noop\r\n          },\r\n        });\r\n\r\n        return new Response(stream, {\r\n          headers: {\r\n            'Content-Type': 'text/event-stream;charset=utf-8',\r\n            'Cache-Control': 'no-cache, no-transform',\r\n          },\r\n        });\r\n      } catch (error) {\r\n        LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n          log: true,\r\n          source: 'route:ai:chat',\r\n          severity: 'error',\r\n        });\r\n        await safeDisposeToolProviders(session?.user, toolProviders);\r\n        return NextResponse.error();\r\n      }\r\n    },\r\n    {\r\n      buildFallback: {\r\n        role: 'assistant',\r\n        content: \"I'm currently disabled for solution rebuild.\",\r\n      },\r\n      errorCallback: () => safeDisposeToolProviders(null, toolProviders),\r\n    },\r\n  )(req);\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\ai\\chat\\stats\\models\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\ai\\chat\\stats\\queues\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\ai\\tools\\[transport]\\route.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":159,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5325,5328],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5325,5328],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":236,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":236,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8480,8483],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8480,8483],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":382,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":382,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13451,13454],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13451,13454],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\attachment\\[attachmentId]\\extract\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\attachment\\[attachmentId]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\attachment\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\auth\\[...nextauth]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\auth\\keys\\route.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":10,"column":1,"nodeType":"Program","endLine":258,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview API endpoint for managing user cryptographic keys\r\n *\r\n * This endpoint allows authenticated users to upload new public keys\r\n * to be associated with their account for cryptographic operations.\r\n *\r\n * @module app/api/auth/keys/route\r\n */\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { wrapRouteRequest } from '@/lib/nextjs-util/server/utils';\r\nimport { auth } from '@/auth';\r\nimport { drizDb, schema } from '@/lib/drizzle-db';\r\nimport { log } from '@/lib/logger';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { z } from 'zod';\r\n\r\nexport const dynamic = 'force-dynamic';\r\n\r\n/**\r\n * Schema for validating public key upload requests\r\n */\r\nconst UploadKeyRequestSchema = z.object({\r\n  publicKey: z.string().min(1, 'Public key is required'),\r\n  expirationDate: z.string().datetime().optional(),\r\n});\r\n\r\ntype UploadKeyRequest = z.infer<typeof UploadKeyRequestSchema>;\r\n\r\n/**\r\n * Validates that a base64 string represents a valid public key\r\n */\r\nfunction validatePublicKeyFormat(publicKeyBase64: string): boolean {\r\n  try {\r\n    // Basic validation - check if it's valid base64\r\n    const decoded = atob(publicKeyBase64);\r\n\r\n    // Check minimum length (ECDSA P-256 public keys are typically 65-91 bytes)\r\n    if (decoded.length < 50) {\r\n      return false;\r\n    }\r\n\r\n    // Check for SPKI header (basic format validation)\r\n    const uint8Array = new Uint8Array(decoded.length);\r\n    for (let i = 0; i < decoded.length; i++) {\r\n      uint8Array[i] = decoded.charCodeAt(i);\r\n    }\r\n\r\n    // SPKI format typically starts with 0x30 (SEQUENCE)\r\n    if (uint8Array[0] !== 0x30) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * POST /api/auth/keys\r\n *\r\n * Uploads a new public key for the authenticated user\r\n */\r\nexport const POST = wrapRouteRequest(\r\n  async (req: NextRequest): Promise<NextResponse> => {\r\n    try {\r\n      // Verify user authentication\r\n      const session = await auth();\r\n      if (!session?.user?.id) {\r\n        return NextResponse.json(\r\n          { success: false, error: 'Authentication required' },\r\n          { status: 401 },\r\n        );\r\n      }\r\n\r\n      const userId =\r\n        typeof session.user.id === 'number'\r\n          ? session.user.id\r\n          : parseInt(session.user.id, 10);\r\n\r\n      if (isNaN(userId)) {\r\n        return NextResponse.json(\r\n          { success: false, error: 'Invalid user ID' },\r\n          { status: 400 },\r\n        );\r\n      }\r\n\r\n      // Parse and validate request body\r\n      let requestBody: UploadKeyRequest;\r\n      try {\r\n        const rawBody = await req.json();\r\n        requestBody = UploadKeyRequestSchema.parse(rawBody);\r\n      } catch (error) {\r\n        log((l) => l.warn('Invalid key upload request', { error, userId }));\r\n        return NextResponse.json(\r\n          { success: false, error: 'Invalid request format' },\r\n          { status: 400 },\r\n        );\r\n      }\r\n\r\n      // Validate public key format\r\n      if (!validatePublicKeyFormat(requestBody.publicKey)) {\r\n        return NextResponse.json(\r\n          { success: false, error: 'Invalid public key format' },\r\n          { status: 400 },\r\n        );\r\n      }\r\n\r\n      // Check if this public key already exists for this user\r\n      const existingKey = await drizDb().query.userPublicKeys.findFirst({\r\n        where: (keys, { eq, and, isNull, gte, or }) =>\r\n          and(\r\n            eq(keys.userId, userId),\r\n            eq(keys.publicKey, requestBody.publicKey),\r\n            // Key is still active (not expired)\r\n            or(\r\n              isNull(keys.expirationDate),\r\n              gte(keys.expirationDate, new Date().toISOString()),\r\n            ),\r\n          ),\r\n      });\r\n\r\n      if (existingKey) {\r\n        log((l) =>\r\n          l.info('Public key already exists for user', {\r\n            userId,\r\n            keyId: existingKey.id,\r\n          }),\r\n        );\r\n        return NextResponse.json({\r\n          success: true,\r\n          message: 'Public key already registered',\r\n          keyId: existingKey.id,\r\n        });\r\n      }\r\n\r\n      // Calculate expiration date (default to 1 year from now)\r\n      const expirationDate = requestBody.expirationDate\r\n        ? new Date(requestBody.expirationDate)\r\n        : new Date(Date.now() + 365 * 24 * 60 * 60 * 1000); // 1 year\r\n\r\n      // Insert new public key\r\n      const [insertedKey] = await drizDb()\r\n        .insert(schema.userPublicKeys)\r\n        .values({\r\n          userId,\r\n          publicKey: requestBody.publicKey,\r\n          effectiveDate: new Date().toISOString(),\r\n          expirationDate: expirationDate.toISOString(),\r\n        })\r\n        .returning({\r\n          id: schema.userPublicKeys.id,\r\n          effectiveDate: schema.userPublicKeys.effectiveDate,\r\n          expirationDate: schema.userPublicKeys.expirationDate,\r\n        });\r\n\r\n      log((l) =>\r\n        l.info('New public key registered', {\r\n          userId,\r\n          keyId: insertedKey.id,\r\n          effectiveDate: insertedKey.effectiveDate,\r\n          expirationDate: insertedKey.expirationDate,\r\n        }),\r\n      );\r\n\r\n      return NextResponse.json({\r\n        success: true,\r\n        message: 'Public key registered successfully',\r\n        keyId: insertedKey.id,\r\n        effectiveDate: insertedKey.effectiveDate,\r\n        expirationDate: insertedKey.expirationDate,\r\n      });\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'POST /api/auth/keys',\r\n        message: 'Failed to upload public key',\r\n        critical: false,\r\n      });\r\n\r\n      return NextResponse.json(\r\n        { success: false, error: 'Internal server error' },\r\n        { status: 500 },\r\n      );\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * GET /api/auth/keys\r\n *\r\n * Retrieves all active public keys for the authenticated user\r\n */\r\nexport const GET = wrapRouteRequest(async (): Promise<NextResponse> => {\r\n  try {\r\n    // Verify user authentication\r\n    const session = await auth();\r\n    if (!session?.user?.id) {\r\n      return NextResponse.json(\r\n        { success: false, error: 'Authentication required' },\r\n        { status: 401 },\r\n      );\r\n    }\r\n\r\n    const userId =\r\n      typeof session.user.id === 'number'\r\n        ? session.user.id\r\n        : parseInt(session.user.id, 10);\r\n\r\n    if (isNaN(userId)) {\r\n      return NextResponse.json(\r\n        { success: false, error: 'Invalid user ID' },\r\n        { status: 400 },\r\n      );\r\n    }\r\n\r\n    // Get all active public keys for the user\r\n    const userKeys = await drizDb().query.userPublicKeys.findMany({\r\n      where: (keys, { eq, and, isNull, gte, or }) =>\r\n        and(\r\n          eq(keys.userId, userId),\r\n          // Key is still active (not expired)\r\n          or(\r\n            isNull(keys.expirationDate),\r\n            gte(keys.expirationDate, new Date().toISOString()),\r\n          ),\r\n        ),\r\n      columns: {\r\n        id: true,\r\n        publicKey: true,\r\n        effectiveDate: true,\r\n        expirationDate: true,\r\n        createdAt: true,\r\n      },\r\n      orderBy: (keys, { desc }) => [desc(keys.effectiveDate)],\r\n    });\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      keys: userKeys,\r\n      count: userKeys.length,\r\n    });\r\n  } catch (error) {\r\n    LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: 'GET /api/auth/keys',\r\n      message: 'Failed to retrieve public keys',\r\n      critical: false,\r\n    });\r\n\r\n    return NextResponse.json(\r\n      { success: false, error: 'Internal server error' },\r\n      { status: 500 },\r\n    );\r\n  }\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\auth\\session\\route.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":12,"column":1,"nodeType":"Program","endLine":57,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module AuthSessionRoute\r\n *\r\n * This module provides an API route handler for retrieving the current authentication session.\r\n * It exports a GET handler that checks the user's authentication status using the `auth` utility\r\n * and returns a JSON response with the session data if authenticated.\r\n *\r\n * The route is configured to be dynamic using the `force-dynamic` export, ensuring that the session\r\n * is evaluated on each request.\r\n */\r\n\r\nimport { auth } from '@/auth';\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { getActiveUserPublicKeys } from '@/lib/site-util/auth/user-keys-server';\r\nimport { isSessionActive } from '@/lib/site-util/auth';\r\n\r\nexport const dynamic = 'force-dynamic';\r\n\r\n/**\r\n * Handles GET requests to retrieve the current authentication session.\r\n *\r\n * This function uses the `auth` utility to check if a user session exists.\r\n * It returns a JSON response indicating the authentication status and\r\n * includes the session data if authenticated.\r\n *\r\n * @returns {Promise<NextResponse>} A JSON response with the authentication status and session data.\r\n */\r\nexport const GET = async (req: NextRequest): Promise<NextResponse> => {\r\n  // Get the current request (Next.js 13+ API route)\r\n  // Use globalThis.request if available, otherwise fallback to NextRequest\r\n  // (Next.js 14+ passes the request as a parameter, but for compatibility, use URL)\r\n  const { nextUrl } = req;\r\n\r\n  const session = await auth();\r\n  const isActiveSession = isSessionActive({ session });\r\n  let keys: string[] | undefined = undefined;\r\n  if (isActiveSession && nextUrl) {\r\n    const getKeys = nextUrl.searchParams.get('get-keys');\r\n    if (getKeys && session?.user?.id) {\r\n      // getActiveUserPublicKeys expects userId (number) and date\r\n      // If session.id is not a number, try to parseInt, else skip\r\n      const userId =\r\n        typeof session.user.id === 'number'\r\n          ? session.user.id\r\n          : parseInt(session.user.id, 10);\r\n      if (!isNaN(userId)) {\r\n        keys = await getActiveUserPublicKeys({ userId });\r\n      }\r\n    }\r\n  }\r\n  return NextResponse.json({\r\n    status: isActiveSession ? 'authenticated' : 'unauthenticated',\r\n    data: session ?? null,\r\n    publicKeys: keys,\r\n  });\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\auth\\test\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\call-to-action\\[propertyId]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\call-to-action\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\contact\\[contactId]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\contact\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\document-unit\\[unitId]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\document-unit\\route.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1984,1987],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1984,1987],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\attachments\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\properties\\[propertyId]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\properties\\call-to-action-response\\[propertyId]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\properties\\call-to-action-response\\route.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":140,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6506,6509],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6506,6509],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\properties\\call-to-action\\[propertyId]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\properties\\call-to-action\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\properties\\compliance-scores\\[propertyId]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\properties\\compliance-scores\\route.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":123,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":123,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4856,4859],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4856,4859],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\properties\\email-header\\[propertyId]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\properties\\email-header\\route.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":98,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3713,3716],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3713,3716],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\properties\\key-points\\[propertyId]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\properties\\key-points\\route.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":91,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3563,3566],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3563,3566],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\properties\\notes\\[propertyId]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\properties\\notes\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\properties\\related-docs\\route.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":220,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":220,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9548,9551],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9548,9551],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\properties\\route.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1895,1898],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1895,1898],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":44,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1998,2001],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1998,2001],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":50,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2300,2303],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2300,2303],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\properties\\sentiment-analysis\\[propertyId]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\properties\\sentiment-analysis\\route.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":145,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":145,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5907,5910],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5907,5910],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\properties\\violation-details\\[propertyId]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\properties\\violation-details\\route.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":168,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":168,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6978,6981],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6978,6981],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\[emailId]\\route.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":239,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport {\r\n  buildFallbackGrid,\r\n  wrapRouteRequest,\r\n} from '@/lib/nextjs-util/server/utils';\r\nimport { log } from '@/lib/logger';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { extractParams } from '@/lib/nextjs-util/utils';\r\nimport { eq } from 'drizzle-orm';\r\nimport { drizDbWithInit, schema } from '@/lib/drizzle-db';\r\n\r\n/**\r\n * Extracts the emailId out of the route parameters, with some magic to support document IDs if that's what we were given.\r\n * @param req - The request object containing the emailId parameter.\r\n * @template T - The type of the request parameters, which should include an emailId property\r\n * @returns A promise that resolves to an object containing the emailId and an optional documentId\r\n */\r\nconst extractEmailId = async <T extends { emailId: string }>(req: {\r\n  params: T | Promise<T>;\r\n}): Promise<{ emailId: string | null; documentId?: number }> => {\r\n  const { emailId } = await extractParams<T>(req);\r\n  // If no email id provided, return null\r\n  if (!emailId) {\r\n    return { emailId: null };\r\n  }\r\n  // Otherwise check to see if we got a GUID\r\n  const guidRegex =\r\n    /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;\r\n  if (guidRegex.test(emailId)) {\r\n    // If so, return it as-is\r\n    return { emailId };\r\n  }\r\n  // If not, see if it can be interpreted as a document id (eg a number)\r\n  const documentId = Number(emailId);\r\n  if (!documentId || Number.isNaN(documentId)) {\r\n    // If not, return null\r\n    return { emailId: null };\r\n  }\r\n  // If so try and look it up\r\n  const doc = await (\r\n    await drizDbWithInit()\r\n  ).query.documentUnits.findFirst({\r\n    where: (d, { eq }) => eq(d.unitId, documentId),\r\n    columns: {\r\n      unitId: true,\r\n      emailId: true,\r\n    },\r\n  });\r\n  if (doc) {\r\n    // And if we found it, return the email id with the doc id for context\r\n    return { emailId: doc.emailId, documentId: doc.unitId };\r\n  }\r\n  // Otherwise, we have nada\r\n  return { emailId: null };\r\n};\r\n\r\nexport const dynamic = 'force-dynamic';\r\n\r\nexport const GET = wrapRouteRequest(\r\n  async (\r\n    req: NextRequest,\r\n    withParams: { params: Promise<{ emailId: string }> },\r\n  ) => {\r\n    const { emailId, documentId } = await extractEmailId(withParams);\r\n    if (!emailId) {\r\n      return NextResponse.json(\r\n        { error: 'Email ID is required' },\r\n        { status: 400 },\r\n      );\r\n    }\r\n    try {\r\n      const record = await (\r\n        await drizDbWithInit()\r\n      ).query.emails.findFirst({\r\n        where: (e, { eq }) => eq(e.emailId, emailId),\r\n        with: {\r\n          sender: {\r\n            columns: {\r\n              contactId: true,\r\n              name: true,\r\n              email: true,\r\n            },\r\n          },\r\n          emailRecipients: {\r\n            with: {\r\n              recipient: {\r\n                columns: {\r\n                  contactId: true,\r\n                  name: true,\r\n                  email: true,\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n        columns: {\r\n          emailId: true,\r\n          subject: true,\r\n          emailContents: true,\r\n          sentTimestamp: true,\r\n          threadId: true,\r\n          parentId: true,\r\n        },\r\n      });\r\n      if (!record) {\r\n        return NextResponse.json({ error: 'Email not found' }, { status: 404 });\r\n      }\r\n      const result = {\r\n        emailId: record.emailId,\r\n        subject: record.subject,\r\n        body: record.emailContents,\r\n        sentOn: record.sentTimestamp,\r\n        threadId: record.threadId,\r\n        parentEmailId: record.parentId,\r\n        sender: {\r\n          contactId: record.sender.contactId,\r\n          name: record.sender.name,\r\n          email: record.sender.email,\r\n        },\r\n        recipients: (record.emailRecipients || []).map((er) => ({\r\n          contactId: er.recipient.contactId,\r\n          name: er.recipient.name,\r\n          email: er.recipient.email,\r\n        })),\r\n        // If they passed us a document id, include it in the response\r\n        ...(documentId ? { documentId } : {}),\r\n      };\r\n      return NextResponse.json(result, { status: 200 });\r\n      /*\r\n    // Fetch detailed email data        \r\n    const result = await query(\r\n      (sql) => sql`\r\n        SELECT \r\n          e.email_id,\r\n          e.subject,\r\n          e.email_contents,\r\n          e.sent_timestamp,\r\n          e.thread_id,\r\n          e.parent_id,\r\n          sender.contact_id AS senderId,\r\n          sender.name AS senderName,\r\n          sender.email AS senderEmail,\r\n          COALESCE(json_agg(\r\n            json_build_object(\r\n              'recipient_id', recipient.contact_id,\r\n              'recipient_name', recipient.name,\r\n              'recipient_email', recipient.email\r\n            )\r\n          ) FILTER (WHERE recipient.contact_id IS NOT NULL), '[]') AS recipients\r\n        FROM emails e\r\n        JOIN contacts sender ON e.sender_id = sender.contact_id\r\n        LEFT JOIN email_recipients er ON e.email_id = er.email_id\r\n        LEFT JOIN contacts recipient ON er.recipient_id = recipient.contact_id\r\n        WHERE e.email_id = ${emailId}\r\n        GROUP BY e.email_id, sender.contact_id, sender.name, sender.email;\r\n      `,\r\n      { transform: mapRecordToObject },\r\n    );\r\n      */\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'GET email/emailId',\r\n        msg: 'Error fetching email details',\r\n        include: { emailId: emailId },\r\n      });\r\n      return NextResponse.json(\r\n        { error: 'Internal Server Error' },\r\n        { status: 500 },\r\n      );\r\n    }\r\n  },\r\n  { buildFallback: buildFallbackGrid },\r\n);\r\n\r\n/**\r\n * Handles the DELETE request to remove an email and its associated recipients from the database.\r\n *\r\n * @param {NextRequest} req - The incoming request object.\r\n * @returns {Promise<NextResponse>} - The response object containing the result of the deletion operation.\r\n *\r\n * @throws {Error} - If there is an issue with the deletion process.\r\n *\r\n * The function performs the following steps:\r\n * 1. Parses the request body to extract the `emailId`.\r\n * 2. Validates that the `emailId` is provided.\r\n * 3. Deletes associated recipients from the `email_recipients` table.\r\n * 4. Deletes the email from the `emails` table and returns the deleted email.\r\n * 5. Logs the deletion operation.\r\n * 6. Returns a success response if the email is deleted, or an error response if the email is not found or if an internal server error occurs.\r\n */\r\nexport const DELETE = wrapRouteRequest(\r\n  async (\r\n    req: NextRequest,\r\n    withParams: {\r\n      params: Promise<{ emailId: string }>;\r\n    },\r\n  ): Promise<NextResponse> => {\r\n    const { emailId } = await extractEmailId(withParams);\r\n    if (!emailId) {\r\n      return NextResponse.json(\r\n        { error: 'Email ID is required' },\r\n        { status: 400 },\r\n      );\r\n    }\r\n    try {\r\n      const records = await (await drizDbWithInit())\r\n        .delete(schema.emails)\r\n        .where(eq(schema.emails.emailId, emailId))\r\n        .returning({ emailId: schema.emails.emailId });\r\n      if (records.length === 0) {\r\n        return NextResponse.json({ error: 'Email not found' }, { status: 404 });\r\n      }\r\n      const { emailId: deletedEmailId } = records[0];\r\n      log((l) =>\r\n        l.verbose({\r\n          msg: '[[AUDIT]] -  Email deleted:',\r\n          resultset: deletedEmailId,\r\n        }),\r\n      );\r\n      return NextResponse.json(\r\n        { message: 'Email deleted successfully', email: deletedEmailId },\r\n        { status: 200 },\r\n      );\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'DELETE email/emailId',\r\n        msg: 'Error deleting email',\r\n        include: { emailId },\r\n      });\r\n      return NextResponse.json(\r\n        { error: 'Internal Server Error' },\r\n        { status: 500 },\r\n      );\r\n    }\r\n  },\r\n);\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\import\\[provider]\\_googleProviderFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\import\\[provider]\\_mailQueryBuilder.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":10,"column":1,"nodeType":"Program","endLine":105,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * A class to build mail query strings for a specific provider.\r\n *\r\n * @class\r\n * @example\r\n * const builder = new MailQueryBuilder();\r\n * builder.appendQueryParam('from', 'example@example.com');\r\n * const query = builder.build(); // 'from:example@example.com'\r\n */\r\nexport class MailQueryBuilder {\r\n  #query: string;\r\n  readonly #messageIds: Array<string>;\r\n\r\n  constructor() {\r\n    this.#query = '';\r\n    this.#messageIds = [];\r\n  }\r\n\r\n  /**\r\n   * Checks if the query has any elements.\r\n   *\r\n   * @returns {boolean} `true` if the query has one or more elements, otherwise `false`.\r\n   */\r\n  get hasQuery(): boolean {\r\n    return this.#query.length > 0;\r\n  }\r\n\r\n  /**\r\n   * Appends a query parameter to the existing query string.\r\n   *\r\n   * @param queryKey - The key of the query parameter to append.\r\n   * @param input - The value(s) of the query parameter. Can be a string or an array of strings.\r\n   * @returns The current instance of `MailQueryBuilder` for method chaining.\r\n   */\r\n  appendQueryParam(\r\n    queryKey: string,\r\n    input: string | string[]\r\n  ): MailQueryBuilder {\r\n    const data = (Array.isArray(input) ? input : [input])\r\n      .map((item) => item?.trim() ?? '')\r\n      .filter(Boolean);\r\n    if (data.length > 0) {\r\n      this.#query += `${queryKey}:${data.join(` ${queryKey}:`)} `;\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Appends a message ID to the list of message IDs.\r\n   *\r\n   * @param messageId - The ID of the message to append.\r\n   * @returns The current instance of MailQueryBuilder for method chaining.\r\n   */\r\n  appendMessageId(messageId: string | string[]): MailQueryBuilder {\r\n    const normalize = (x: string) => {\r\n      return x.replace(' ', '+');\r\n    };\r\n\r\n    if (Array.isArray(messageId)) {\r\n      messageId.forEach((x) => this.appendMessageId(normalize(x)));\r\n      return this;\r\n    }\r\n\r\n    if (this.#messageIds.includes(messageId)) {\r\n      return this;\r\n    }\r\n    this.#messageIds.push(normalize(messageId));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Builds and returns the query string if it exists.\r\n   *\r\n   * @returns {string | undefined} The trimmed query string if it exists, otherwise undefined.\r\n   */\r\n  build(): string | undefined {\r\n    let q = this.hasQuery\r\n      ? this.#query.trim()\r\n      : '' + this.buildMessageIdQuery();\r\n    q = q.trim();\r\n    return q.length > 0 ? q : undefined;\r\n  }\r\n\r\n  /**\r\n   * Builds a query string for message IDs.\r\n   *\r\n   * This method constructs a query string based on the `#messageIds` array.\r\n   * If the array is empty, it returns an empty string.\r\n   * If the array contains one message ID, it returns a string in the format `rfc822msgid:<messageId>`.\r\n   * If the array contains multiple message IDs, it returns a string in the format `{rfc822msgid:<messageId1> rfc822msgid:<messageId2> ...}`.\r\n   *\r\n   * @returns {string} The constructed query string for message IDs.\r\n   */\r\n  private buildMessageIdQuery(): string {\r\n    if (this.#messageIds.length === 0) {\r\n      return '';\r\n    }\r\n    const key = 'rfc822msgid';\r\n    if (this.#messageIds.length === 1) {\r\n      return `${key}:${this.#messageIds[0]}`;\r\n    }\r\n    return '{' + this.#messageIds.map((id) => `${key}:${id}`).join(' ') + '}';\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\import\\[provider]\\_utilitites.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":709,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":613,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":613,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20701,20704],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20701,20704],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { normalizeNullableNumeric } from '@/data-models/_utilities';\r\nimport { PaginationStats } from '@/data-models/_types';\r\nimport {\r\n  GmailEmailImportSource,\r\n  ImportSourceMessage,\r\n  ImportStage,\r\n  MessageImportStatusWithChildren,\r\n  ImportStatusType,\r\n  MessageImportStatus,\r\n} from '@/data-models/api/import/email-message';\r\nimport { query } from '@/lib/neondb';\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { googleProviderFactory } from './_googleProviderFactory';\r\nimport { isError } from '@/lib/react-util/utility-methods';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { auth } from '@/auth';\r\nimport {\r\n  GmailEmailMessageHeader,\r\n  GmailEmailMessagePart,\r\n  GmailEmailMessagePayload,\r\n  GmailMessagdApi,\r\n} from '@/data-models/api/import/provider-google';\r\nimport { MailQueryBuilder } from './_mailQueryBuilder';\r\nimport { ParsedHeaderMap } from '@/lib/email/parsedHeaderMap';\r\nimport { NextApiRequest } from 'next/types';\r\n\r\n/**\r\n * Parses pagination statistics from a URL or URLSearchParams object.\r\n *\r\n * @param req - The request object containing pagination parameters. It can be either a URL or URLSearchParams.\r\n * @returns An object containing the parsed pagination statistics:\r\n * - `page`: The current page as a string.\r\n * - `num`: The number of items per page, defaulting to 100 if not specified or invalid.\r\n * - `total`: The total number of items, initialized to 0.\r\n */\r\nexport const parsePaginationStats = (\r\n  req: URL | URLSearchParams,\r\n): PaginationStats<string> => {\r\n  if ('searchParams' in req) {\r\n    req = req.searchParams;\r\n  }\r\n  const page = (req.get('page') ?? '').trim();\r\n  const num = normalizeNullableNumeric(Number(req.get('num')), 100) ?? 100;\r\n\r\n  return {\r\n    page,\r\n    num,\r\n    total: 0,\r\n  };\r\n};\r\n\r\n/**\r\n * An array of known error cause values for Gmail integration.\r\n *\r\n * The possible values are:\r\n * - 'unauthorized': The request is not authorized.\r\n * - 'invalid-args': The arguments provided are invalid.\r\n * - 'gmail-failure': A failure occurred on the Gmail side.\r\n * - 'email-not-found': The specified email was not found.\r\n * - 'email-exists': The email already exists.\r\n * - 'unknown-error': An unknown error occurred.\r\n *\r\n * @constant\r\n * @type {readonly string[]}\r\n */\r\nconst KnownGmailErrorCauseValues = [\r\n  'unauthorized',\r\n  'invalid-args',\r\n  'gmail-failure',\r\n  'email-not-found',\r\n  'source-not-found',\r\n  'email-exists',\r\n  'unknown-error',\r\n] as const;\r\n\r\n/**\r\n * Represents the type of known Gmail error causes.\r\n *\r\n * This type is derived from the values of the `KnownGmailErrorCauseValues` array.\r\n * It allows for type-safe usage of Gmail error causes by restricting the values\r\n * to those defined in the `KnownGmailErrorCauseValues` array.\r\n */\r\nexport type KnownGmailErrorCauseType =\r\n  (typeof KnownGmailErrorCauseValues)[number];\r\n\r\n/**\r\n * Checks if the provided value is a known Gmail error cause.\r\n *\r\n * @param check - The value to check.\r\n * @returns A boolean indicating whether the value is a known Gmail error cause.\r\n */\r\nexport const isKnownGmailErrorCause = (\r\n  check: unknown,\r\n): check is KnownGmailErrorCauseType =>\r\n  KnownGmailErrorCauseValues.includes(check as KnownGmailErrorCauseType);\r\n\r\n/**\r\n * Checks if the provided value is a known Gmail error.\r\n *\r\n * @param check - The value to check.\r\n * @returns A boolean indicating whether the value is a known Gmail error.\r\n */\r\nexport const isKnownGmailError = (\r\n  check: unknown,\r\n): check is Error & { cause: KnownGmailErrorCauseType } =>\r\n  isError(check) && isKnownGmailErrorCause(check.cause);\r\n\r\n/**\r\n * A callback type used to push error handling of expected types up to the called method.\r\n *\r\n * @callback ErrorFilter\r\n * @param {Error} error - The error object that needs to be filtered.\r\n * @returns {NextResponse | null | undefined} - Returns a NextResponse if the error is handled,\r\n *                                              otherwise returns null or undefined.\r\n */\r\nexport type ErrorFilter = (error: unknown) => NextResponse | null | undefined;\r\n\r\n/**\r\n * Provides a default error filter implementation for Gmail-related calls.\r\n * This function takes an error object and returns a NextResponse object\r\n * with an appropriate HTTP status code and error message based on the\r\n * specific cause of the error.\r\n *\r\n * @param {Error} error - The error object to be filtered.\r\n * @returns {NextResponse | null | undefined} - A NextResponse object with\r\n * the appropriate HTTP status code and error message, or null/undefined if\r\n * the error is not recognized.\r\n *\r\n * The function handles the following error causes:\r\n * - 'unauthorized': Returns a 401 Unauthorized response.\r\n * - 'email-exists': Returns a 409 Conflict response indicating the email already exists.\r\n * - 'email-not-found': Returns a 404 Not Found response indicating the email was not found.\r\n * - 'unknown-error': Returns a 500 Internal Server Error response for unknown errors.\r\n * - 'invalid-args': Returns a 400 Bad Request response for invalid arguments.\r\n * - 'gmail-failure': Returns a 500 Internal Server Error response for Gmail-specific failures.\r\n *\r\n * If the error cause is not recognized, the function returns null.\r\n */\r\nexport const defaultGmailErrorFilter = (\r\n  error: unknown,\r\n): NextResponse | null | undefined => {\r\n  if (!isKnownGmailError(error)) {\r\n    return undefined;\r\n  }\r\n  switch (error.cause) {\r\n    case 'unauthorized':\r\n      return NextResponse.json(\r\n        { error: error.message ?? 'Unauthorized' },\r\n        { status: 401 },\r\n      );\r\n    case 'email-exists':\r\n      return NextResponse.json(\r\n        { error: error.message ?? 'Email already exists' },\r\n        { status: 409 },\r\n      );\r\n    case 'email-not-found':\r\n    case 'source-not-found':\r\n      return NextResponse.json(\r\n        { error: error.message ?? 'Email not found' },\r\n        { status: 404 },\r\n      );\r\n    case 'unknown-error':\r\n      return NextResponse.json(\r\n        { error: error.message ?? 'Unknown error' },\r\n        { status: 500 },\r\n      );\r\n    case 'invalid-args':\r\n      return NextResponse.json(\r\n        { error: error.message ?? 'Invalid arguments' },\r\n        { status: 400 },\r\n      );\r\n    case 'gmail-failure':\r\n      return NextResponse.json(\r\n        { error: error.message ?? 'Gmail error' },\r\n        { status: 500 },\r\n      );\r\n    default:\r\n      break;\r\n  }\r\n  // If we make it this far we do not recognize the error\r\n  return undefined;\r\n};\r\n\r\ntype EmailAndUserId = {\r\n  userId: number;\r\n  email: GmailEmailImportSource;\r\n  mail: GmailMessagdApi;\r\n};\r\n\r\n/**\r\n * Retrieves a Gmail message using the provided provider and email ID.\r\n *\r\n * @param {Object} params - The parameters for the function.\r\n * @param {string} params.provider - The email provider name.\r\n * @param {string} params.emailId - The email ID to retrieve.\r\n * @returns {Promise<{ userId: number; email: any }>} The user ID and email data.\r\n * @throws {Error} If the user is not authenticated, if the provider or email ID is missing, if there is an error in the factory response, or if there is an error retrieving the email.\r\n */\r\nconst getGmailMessage = async ({\r\n  provider,\r\n  emailId,\r\n  req,\r\n}: {\r\n  emailId: string;\r\n  provider: string;\r\n  req: NextRequest | NextApiRequest;\r\n}): Promise<EmailAndUserId> => {\r\n  try {\r\n    const session = await auth();\r\n    if (!session || !session.user || !session.user.id) {\r\n      throw new Error('Must be authenticated to call this API', {\r\n        cause: 'unauthorized',\r\n      });\r\n    }\r\n    const userId = Number(session.user.id);\r\n\r\n    if (![provider, emailId].every(Boolean)) {\r\n      throw new TypeError('Missing provider name or provider email id', {\r\n        cause: 'invalid-args',\r\n      });\r\n    }\r\n\r\n    const factoryResponse = await googleProviderFactory(provider, { req });\r\n    if ('status' in factoryResponse) {\r\n      throw new Error('Error in factory response', { cause: 'gmail-failure' });\r\n    }\r\n\r\n    const { mail } = factoryResponse;\r\n    let googleMessageId = emailId;\r\n\r\n    if (emailId.includes('@')) {\r\n      const query = new MailQueryBuilder();\r\n      query.appendQueryParam('rfc822msgid', emailId);\r\n      const queryString = query.build();\r\n      const googleResponse = await mail.list({\r\n        userId: 'me',\r\n        q: queryString,\r\n      });\r\n\r\n      if (googleResponse.data.messages?.length) {\r\n        googleMessageId = googleResponse.data.messages[0].id!;\r\n      } else {\r\n        throw new Error('Email not found', { cause: 'email-not-found' });\r\n      }\r\n    }\r\n\r\n    const googleResponse = await mail.get({\r\n      userId: 'me',\r\n      id: googleMessageId,\r\n    });\r\n\r\n    if (googleResponse.status !== 200) {\r\n      if (googleResponse.status === 404) {\r\n        throw new Error('Email not found', { cause: 'email-not-found' });\r\n      }\r\n      throw new Error('Error retrieving email', { cause: 'unknown-error' });\r\n    }\r\n\r\n    if (!googleResponse?.data) {\r\n      throw new Error('No email data returned', { cause: 'email-not-found' });\r\n    }\r\n\r\n    return {\r\n      userId,\r\n      email: googleResponse.data,\r\n      mail,\r\n    };\r\n  } catch (error) {\r\n    if (isError(error)) {\r\n      if (isKnownGmailErrorCause(error.cause)) {\r\n        // rethrow known error types for caller to handle\r\n        throw error;\r\n      }\r\n    }\r\n    // For everything else, log the error and rethrow`\r\n    const le = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: 'getGmailMessage',\r\n      provider,\r\n      emailId,\r\n    });\r\n    throw le;\r\n  }\r\n};\r\n\r\n/**\r\n * Retrieves the current state of an email import process.\r\n *\r\n * @param {Object} params - The parameters for retrieving the current state.\r\n * @param {string} params.emailId - The ID of the email to retrieve the state for.\r\n * @param {number} params.userId - The ID of the user requesting the state.\r\n * @param {GmailEmailImportSource} [params.source] - The source of the email import, if available.\r\n * @returns {Promise<ImportSourceMessage | null>} - A promise that resolves to the current state of the email import, or null if not found.\r\n * @throws {Error} - Throws an error if the email has already been imported, if the email is not found, or if the user is unauthorized.\r\n */\r\nconst getCurrentState = async ({\r\n  emailId,\r\n  userId,\r\n  source,\r\n}: {\r\n  emailId: string;\r\n  userId: number;\r\n  source?: GmailEmailImportSource;\r\n}): Promise<ImportSourceMessage> => {\r\n  const refresh = !!source;\r\n  const messageField = refresh ? '' : ', to_json(s.message) AS message';\r\n  const currentStateRows = await query((sql) =>\r\n    sql<false, false>(\r\n      `\r\n          select s.external_id AS providerId, s.stage, s.id${messageField}, s.\"user_id\", m.email_id AS targetId from emails m \r\n            right join staging_message s on s.external_id = m.imported_from_id\r\n            where s.external_id = $1;`.toString(),\r\n      [emailId],\r\n    ),\r\n  );\r\n  if (!currentStateRows.length) {\r\n    const existingEmailRows = await query(\r\n      (sql) =>\r\n        sql`select email_id from emails where imported_from_id = ${emailId};`,\r\n    );\r\n    if (existingEmailRows.length) {\r\n      throw new Error(\r\n        `Gmail Message ${emailId} has already been imported as email ${existingEmailRows[0].email_id}; manually delete the email if you want to re-import it.`,\r\n        { cause: 'email-exists' },\r\n      );\r\n    }\r\n    if (!source) {\r\n      throw new Error(`Gmail message id ${emailId} not found.`, {\r\n        cause: 'source-not-found',\r\n      });\r\n    }\r\n    return {\r\n      raw: source,\r\n      stage: 'new',\r\n      providerId: emailId,\r\n      userId: userId,\r\n      id: undefined,\r\n    };\r\n  }\r\n  if (userId !== currentStateRows[0].userId) {\r\n    throw new Error('Unauthorized', { cause: 'unauthorized' });\r\n  }\r\n  const raw = source ?? (currentStateRows[0].message as GmailEmailImportSource);\r\n  if (!raw) {\r\n    throw new Error(`Gmail message id ${emailId} not found.`, {\r\n      cause: 'source-not-found',\r\n    });\r\n  }\r\n  return {\r\n    stage: currentStateRows[0].stage as ImportStage,\r\n    id: currentStateRows[0].id as string,\r\n    providerId: currentStateRows[0].providerid as string,\r\n    targetId: currentStateRows[0].targetid as string,\r\n    userId: userId,\r\n    raw,\r\n  };\r\n};\r\n\r\ninterface GetImportMessageSourceOverloads {\r\n  (params: {\r\n    req: NextRequest | NextApiRequest;\r\n    provider?: string;\r\n    emailId?: string;\r\n    refresh?: boolean;\r\n    errorFilter: ErrorFilter;\r\n  }): Promise<NextResponse | ImportSourceMessage | null>;\r\n  (params: {\r\n    req: NextRequest | NextApiRequest;\r\n    provider?: string;\r\n    emailId?: string;\r\n    refresh?: boolean;\r\n  }): Promise<ImportSourceMessage | null>;\r\n}\r\n\r\n/**\r\n * Retrieves the import message source for a given provider and email ID.\r\n *\r\n * @param params - The parameters for retrieving the import message source.\r\n * @param params.provider - The provider of the email import source.\r\n * @param params.emailId - The ID of the email to retrieve the import source for.\r\n * @param params.refresh - Whether to refresh the import source data. Defaults to `false`.\r\n * @param params.returnResponse - Whether to return a response object. Defaults to `true`.\r\n * @returns A promise that resolves to an `ImportSourceMessage`, `null`, or `NextResponse`.\r\n *\r\n * @throws {Error} If the user is not authenticated.\r\n * @throws {Error} If the provider or emailId is missing when refresh is `true`.\r\n * @throws {Error} If the user is unauthorized to access the email.\r\n * @throws {Error} If an error occurs during the process.\r\n */\r\nexport const getImportMessageSource: GetImportMessageSourceOverloads = async ({\r\n  req,\r\n  provider,\r\n  emailId,\r\n  refresh = false,\r\n  errorFilter,\r\n}: {\r\n  req: NextRequest | NextApiRequest;\r\n  provider?: string;\r\n  emailId?: string;\r\n  refresh?: boolean;\r\n  errorFilter?: undefined | ErrorFilter;\r\n}): Promise<(NextResponse & ImportSourceMessage) | null> => {\r\n  const getReturnValue = (\r\n    response: NextResponse | null,\r\n  ): NextResponse & ImportSourceMessage =>\r\n    (!!errorFilter ? response : null) as NextResponse & ImportSourceMessage;\r\n  try {\r\n    let source: GmailEmailImportSource | undefined = undefined;\r\n    const session = await auth();\r\n    if (!session || !session.user || !session.user.id) {\r\n      throw new Error('Must be authenticated to call this API', {\r\n        cause: 'unauthorized',\r\n      });\r\n    }\r\n    const userId = Number(session.user.id);\r\n    if (refresh) {\r\n      if (![provider, emailId].every(Boolean)) {\r\n        return getReturnValue(\r\n          NextResponse.json(\r\n            { error: 'missing provider or emailId' },\r\n            { status: 400 },\r\n          ),\r\n        );\r\n      }\r\n      const factoryResponse = await googleProviderFactory(provider as string, {\r\n        req,\r\n      });\r\n      if ('status' in factoryResponse) {\r\n        return getReturnValue(factoryResponse);\r\n      }\r\n      // read from sql\r\n      const { mail } = factoryResponse;\r\n      const googleResponse = await mail.get({\r\n        userId: 'me',\r\n        id: emailId,\r\n      });\r\n      source = googleResponse.data;\r\n    }\r\n    const theCurrentState = await getCurrentState({\r\n      emailId: emailId!,\r\n      source,\r\n      userId,\r\n    });\r\n    if (!theCurrentState) {\r\n      throw new Error('No current state found', { cause: 'email-not-found' });\r\n    }\r\n    return {\r\n      stage: theCurrentState.stage as ImportStage,\r\n      id: theCurrentState.id,\r\n      providerId: theCurrentState.providerId,\r\n      targetId: theCurrentState.targetId,\r\n      userId: theCurrentState.userId,\r\n      raw: theCurrentState.raw,\r\n    } as NextResponse & ImportSourceMessage;\r\n  } catch (error) {\r\n    // Check to see if this was thrown by us, and if so, handle it.\r\n    if (errorFilter) {\r\n      const checkFilter = errorFilter(error);\r\n      if (checkFilter !== undefined) {\r\n        return getReturnValue(checkFilter);\r\n      }\r\n    }\r\n    // If this is a known gmail error rethrow for caller to process\r\n    if (isKnownGmailError(error)) {\r\n      throw error;\r\n    }\r\n    // Otherwise log the error\r\n    const le = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: 'getImportMessageSource',\r\n    });\r\n    /// And rethrow or convert to a response\r\n    if (errorFilter) {\r\n      return getReturnValue(\r\n        NextResponse.json({ error: le.message }, { status: 500 }),\r\n      );\r\n    }\r\n    throw le;\r\n  }\r\n};\r\n\r\nconst getImportStatusForExternalId = async (\r\n  providerId: string,\r\n): Promise<{ status: ImportStatusType; emailId: string | null }> => {\r\n  let emailId: string | null;\r\n  let status: ImportStatusType;\r\n  const statusRecords = await query(\r\n    (sql) => sql`\r\n          SELECT e.email_id, s.id AS staged_id \r\n          FROM emails e \r\n            FULL OUTER JOIN staging_message s \r\n              ON e.imported_from_id = s.external_id\r\n          WHERE e.imported_from_id=${providerId} OR s.external_id=${providerId};`,\r\n  );\r\n  if (statusRecords.length) {\r\n    const { email_id: recordEmailId, staged_id: recordStagedId } =\r\n      statusRecords[0];\r\n    // Are we currently staged for processing?\r\n    if (recordStagedId) {\r\n      status = 'in-progress';\r\n      emailId = recordEmailId as string | null;\r\n    } else if (recordEmailId) {\r\n      emailId = String(recordEmailId);\r\n      status = 'imported';\r\n    } else {\r\n      // Logically it should not be possible to get here, but just in case...\r\n      emailId = null;\r\n      status = 'pending';\r\n    }\r\n  } else {\r\n    // no match - email is pending import processing\r\n    emailId = null;\r\n    status = 'pending';\r\n  }\r\n  return { status, emailId };\r\n};\r\n\r\nconst checkReferencedEmailStatus = async ({\r\n  email,\r\n  mail,\r\n}: {\r\n  email: GmailEmailImportSource;\r\n  mail: GmailMessagdApi;\r\n}) => {\r\n  // First search headers for any references to other email id's\r\n  const extractHeaders = (\r\n    payload: GmailEmailMessagePayload | undefined,\r\n  ): ParsedHeaderMap => {\r\n    const headers: Array<GmailEmailMessageHeader> = [];\r\n    const extractHeadersFromPart = (part: GmailEmailMessagePart): void => {\r\n      if (part.headers) {\r\n        headers.push(...part.headers);\r\n      }\r\n      if (part.parts) {\r\n        part.parts.forEach(extractHeadersFromPart);\r\n      }\r\n    };\r\n\r\n    if (payload) {\r\n      extractHeadersFromPart(payload);\r\n    }\r\n    return ParsedHeaderMap.fromHeaders(headers, {\r\n      parseContacts: true,\r\n      expandArrays: true,\r\n      extractBrackets: true,\r\n    });\r\n  };\r\n\r\n  //const lookFor = ['references', 'in-reply-to'];\r\n  const headerMap = extractHeaders(email.payload);\r\n  // Extract every known message id from headers\r\n  const referencedEmailIds = Array.from(\r\n    new Set([\r\n      ...(headerMap.getAllStringValues('References') ?? []),\r\n      ...(headerMap.getAllStringValues('In-Reply-To') ?? []),\r\n    ]),\r\n  );\r\n  const recipients = Array.from(\r\n    new Set([\r\n      ...(headerMap.getAllContactValues('To') ?? []),\r\n      ...(headerMap.getAllContactValues('Cc') ?? []),\r\n      ...(headerMap.getAllContactValues('Bcc') ?? []),\r\n    ]),\r\n  );\r\n  // Lookup any existing emails matching these ids\r\n  const importedRecordset = new Map<string, string>(\r\n    (\r\n      await query(\r\n        (sql) =>\r\n          sql`select email_id, global_message_id from emails where global_message_id = any(${referencedEmailIds});`,\r\n      )\r\n    ).map((x) => [x.global_message_id as string, x.email_id as string]),\r\n  );\r\n  let parseImported = referencedEmailIds.reduce(\r\n    (acc, id) => {\r\n      const emailId = importedRecordset.get(id);\r\n      if (emailId) {\r\n        acc.processed.push({\r\n          emailId,\r\n          provider: 'google',\r\n          providerId: id,\r\n          status: 'imported',\r\n        });\r\n      } else {\r\n        acc.unsorted.push(id);\r\n      }\r\n      return acc;\r\n    },\r\n    { processed: [], unsorted: [] } as {\r\n      processed: Array<MessageImportStatus>;\r\n      unsorted: Array<string>;\r\n    },\r\n  );\r\n  const operations = await Promise.all(\r\n    parseImported.unsorted.map((id) => {\r\n      const queryBuilder = new MailQueryBuilder();\r\n      queryBuilder.appendMessageId(id);\r\n      return mail\r\n        .list({ q: queryBuilder.build(), userId: 'me' })\r\n        .then((matches) => ({\r\n          status: 'succeeded',\r\n          provider: 'google',\r\n          id: id,\r\n          data: matches?.data?.messages?.at(0),\r\n        }))\r\n        .catch((error) => ({ status: 'failed', id: id, error }));\r\n    }),\r\n  );\r\n  // If we still have unsorted id's, lets try to look them up with the provider\r\n  parseImported = parseImported.unsorted.reduce(\r\n    (acc, id) => {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const match = operations.find((o) => o.id === id) as any;\r\n      if (match && match.status === 'succeeded' && match.data) {\r\n        acc.processed.push({\r\n          emailId: id,\r\n          provider: 'google',\r\n          providerId: match!.data!.id!,\r\n          status: 'pending',\r\n        });\r\n      } else {\r\n        acc.unsorted.push(id);\r\n      }\r\n      return acc;\r\n    },\r\n    { processed: parseImported.processed, unsorted: [] } as {\r\n      processed: Array<MessageImportStatus>;\r\n      unsorted: Array<string>;\r\n    },\r\n  );\r\n  // Parse received date\r\n  const date = headerMap.getFirstStringValue('Date');\r\n  const receivedDate = date ? new Date(date) : new Date(0);\r\n\r\n  // Return final result\r\n  return {\r\n    processed: parseImported.processed,\r\n    recipients,\r\n    receivedDate,\r\n    subject: headerMap.getFirstStringValue('Subject') ?? '[No Subject]',\r\n    sender: headerMap.getFirstContactValue('From') ?? { email: 'No Sender' },\r\n  };\r\n};\r\n\r\nexport const getImportMessageStatus = async ({\r\n  provider,\r\n  emailId: emailIdFromProps,\r\n  req,\r\n}: {\r\n  provider: string;\r\n  emailId: string;\r\n  req: NextRequest | NextApiRequest;\r\n}): Promise<MessageImportStatusWithChildren> => {\r\n  try {\r\n    // First off load the email from the provider\r\n    const { email, mail } = await getGmailMessage({\r\n      provider,\r\n      emailId: emailIdFromProps,\r\n      req,\r\n    });\r\n    // Extract the provider id...\r\n    const providerId = email.id!;\r\n    // and use it to query for import state and our system's email id\r\n    const { emailId, status } = await getImportStatusForExternalId(providerId);\r\n    // Finally, scan referenced emails to locate any additional items pending imoprt\r\n    const { processed, recipients, sender, subject, receivedDate } =\r\n      await checkReferencedEmailStatus({ email, mail });\r\n    return {\r\n      emailId,\r\n      providerId,\r\n      provider,\r\n      status,\r\n      recipients,\r\n      sender,\r\n      subject,\r\n      receivedDate,\r\n      references: processed,\r\n    };\r\n  } catch (error) {\r\n    if (isError(error)) {\r\n      if (isKnownGmailErrorCause(error.cause)) {\r\n        // We handle email not found\r\n        if (error.cause === 'email-not-found') {\r\n          return {\r\n            emailId: null,\r\n            providerId: emailIdFromProps,\r\n            provider,\r\n            status: 'not-found',\r\n            sender: { email: 'unknown' },\r\n            recipients: [],\r\n            subject: 'unknown',\r\n            receivedDate: new Date(0),\r\n            references: [],\r\n          };\r\n        }\r\n        // rethrow all other known error types for caller to handle\r\n        throw error;\r\n      }\r\n    }\r\n    // For everything else, log the error and rethrow\r\n    throw LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: 'getImportMessageStatus',\r\n      provider,\r\n      emailId: emailIdFromProps,\r\n    });\r\n  }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\import\\[provider]\\message\\[emailId]\\route.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":168,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport {\r\n  defaultGmailErrorFilter,\r\n  getImportMessageSource,\r\n} from '../../_utilitites';\r\nimport { query, queryExt } from '@/lib/neondb';\r\nimport { newUuid } from '@/lib/typescript';\r\nimport {\r\n  DefaultImportManager,\r\n  queueStagedAttachments,\r\n} from '@/lib/email/import/google';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\n\r\nexport const dynamic = 'force-dynamic';\r\n\r\n/**\r\n * Handles GET requests to retrieve an importable email message from the associated provider (e.g., Gmail).\r\n *\r\n * @param req - The incoming Next.js request object.\r\n * @param params - A promise resolving to an object containing the provider name and email ID.\r\n * @returns A response containing the importable message source or an error/status object.\r\n */\r\nexport const GET = async (\r\n  req: NextRequest,\r\n  { params }: { params: Promise<{ provider: string; emailId: string }> },\r\n) => {\r\n  const { provider, emailId } = await params;\r\n  const result = await getImportMessageSource({\r\n    req,\r\n    provider,\r\n    emailId,\r\n    refresh: true,\r\n    errorFilter: defaultGmailErrorFilter,\r\n  });\r\n  return 'status' in result!\r\n    ? result\r\n    : NextResponse.json(result, { status: 200 });\r\n};\r\n\r\n/**\r\n * Handles the POST request to initiate the import process for a staged email.\r\n *\r\n * @param req - The incoming Next.js request object.\r\n * @param params - A promise resolving to an object containing the email provider and email ID.\r\n * @returns A JSON response with the result of the import operation.\r\n *\r\n * This API endpoint triggers the import process for a specific staged email, identified by the provider and emailId.\r\n */\r\nexport const POST = async (\r\n  req: NextRequest,\r\n  { params }: { params: Promise<{ provider: string; emailId: string }> },\r\n) => {\r\n  const { provider, emailId } = await params;\r\n  const importInstance = new DefaultImportManager(provider);\r\n  const result = await importInstance.importEmail(emailId, { req });\r\n  return NextResponse.json(result, { status: 200 });\r\n};\r\n\r\n/**\r\n * Handles the PUT request to stage an email message for import.\r\n *\r\n * This API endpoint processes an email message identified by the given provider and emailId,\r\n * stages it for import, and stores it in the `staging_message` table. If the message has already\r\n * been imported and the `refresh` query parameter is not set, it returns an error. If `refresh`\r\n * is set, it deletes the previous staging record and stages the message again.\r\n *\r\n * The endpoint also processes and stages any attachments associated with the email message.\r\n * If attachment processing fails, the staged message is rolled back and an error is returned.\r\n *\r\n * @param req - The Next.js request object.\r\n * @param params - An object containing the provider and emailId as route parameters.\r\n * @returns A JSON response with the staged message details and status code 201 on success,\r\n *          or an error message with the appropriate status code on failure.\r\n */\r\nexport const PUT = async (\r\n  req: NextRequest,\r\n  { params }: { params: Promise<{ provider: string; emailId: string }> },\r\n) => {\r\n  const { provider, emailId } = await params;\r\n  const result = await getImportMessageSource({\r\n    req,\r\n    provider,\r\n    emailId,\r\n    refresh: true,\r\n    errorFilter: defaultGmailErrorFilter,\r\n  });\r\n  if (!result) {\r\n    return NextResponse.json({ error: 'message not found' }, { status: 404 });\r\n  }\r\n  if ('status' in result) {\r\n    return result;\r\n  }\r\n\r\n  if (result.stage !== 'new') {\r\n    if (req.nextUrl.searchParams.get('refresh')) {\r\n      await query(\r\n        (sql) =>\r\n          sql`delete from staging_message where external_id = ${emailId}`,\r\n      );\r\n      result.stage = 'new';\r\n    } else {\r\n      return NextResponse.json(\r\n        { error: 'message already imported' },\r\n        { status: 400 },\r\n      );\r\n    }\r\n  }\r\n  const id = newUuid();\r\n  const payload = JSON.stringify({\r\n    external_id: emailId,\r\n    id: id,\r\n    stage: 'staged',\r\n    message: result.raw,\r\n    userId: result.userId,\r\n  });\r\n  const records = await queryExt((sql) =>\r\n    sql(\r\n      \"INSERT INTO staging_message SELECT * FROM  \\\r\n      jsonb_populate_record(null::staging_message, '\" +\r\n        payload.replaceAll(\"'\", \"''\") +\r\n        \"'::jsonb)\",\r\n    ),\r\n  );\r\n  if (records.rowCount !== 1) {\r\n    return NextResponse.json(\r\n      { error: 'Unexpected failure updating staging table.' },\r\n      { status: 500 },\r\n    );\r\n  }\r\n  // Stage attachments\r\n  try {\r\n    const attachments = await Promise.all(\r\n      (result.raw.payload?.parts ?? []).flatMap((part) =>\r\n        queueStagedAttachments({ req, stagedMessageId: id, part }),\r\n      ),\r\n    );\r\n    if (!attachments.every((attachment) => attachment.status === 'success')) {\r\n      throw new Error('Failed to stage attachments', { cause: attachments });\r\n    }\r\n  } catch (error) {\r\n    LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: 'email-import',\r\n      data: { emailId, attachments: result.raw.payload?.parts },\r\n    });\r\n    try {\r\n      await query((sql) => sql`delete from staging_message where id = ${id}`);\r\n    } catch (suppress) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(suppress, {\r\n        log: true,\r\n        source: 'email-import',\r\n      });\r\n    }\r\n    return NextResponse.json(\r\n      { error: 'Failed to process attachments' },\r\n      { status: 500 },\r\n    );\r\n  }\r\n  return NextResponse.json(\r\n    {\r\n      ...result,\r\n      id,\r\n      stage: 'staged',\r\n    },\r\n    { status: 201 },\r\n  );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\import\\[provider]\\message\\[emailId]\\status\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\import\\[provider]\\search\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\import\\list\\route.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":118,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse, NextRequest } from 'next/server';\r\nimport { wrapRouteRequest } from '@/lib/nextjs-util/server/utils';\r\nimport { log } from '@/lib/logger';\r\nimport { query } from '@/lib/neondb';\r\nimport { parsePaginationStats } from '@/lib/components/mui/data-grid/queryHelpers/utility';\r\n\r\nimport type {\r\n  ImportStage,\r\n  StagedMessageSummary,\r\n} from '@/data-models/api/import/email-message';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\n\r\n/**\r\n * Handles GET requests to fetch a paginated list of emails with sender and recipient information.\r\n *\r\n * @param {NextRequest} req - The incoming request object.\r\n * @returns {Promise<NextResponse>} - A promise that resolves to a NextResponse object containing the paginated list of emails.\r\n *\r\n * The function performs the following steps:\r\n * 1. Parses pagination parameters (num, offset, page) from the request URL.\r\n * 2. Executes a SQL query to fetch a list of emails with sender and recipient information.\r\n * 3. Transforms the query result to a structured format.\r\n * 4. Executes a SQL query to count the total number of records.\r\n * 5. Logs the results and pagination information.\r\n * 6. Returns a JSON response with the paginated list of emails and pagination statistics.\r\n *\r\n * If an error occurs during the process, it logs the error and returns a 500 Internal Server Error response.\r\n */\r\nexport const GET = wrapRouteRequest(\r\n  async (req: NextRequest): Promise<NextResponse> => {\r\n    try {\r\n      const { num, offset, page } = parsePaginationStats(new URL(req.url));\r\n\r\n      // Fetch list of emails with sender info\r\n      const result = await query(\r\n        (sql) =>\r\n          sql`SELECT \r\n      s.stage, s.id, m.email_id AS targetId, s.\"user_id\",\r\n      (SELECT h.value \r\n        FROM staging_message, \r\n        LATERAL unnest((message).payload.headers) AS h(name, value) \r\n        WHERE h.name='Date') AS timestamp,\r\n      (SELECT h.value FROM staging_message, LATERAL unnest((message).payload.headers) AS h(name, value) WHERE h.name='From') AS Sender,\r\n        concat(\r\n          (SELECT h.value FROM staging_message, LATERAL unnest((message).payload.headers) AS h(name, value) WHERE h.name='To'),\r\n          ',',\r\n          (SELECT h.value FROM staging_message, LATERAL unnest((message).payload.headers) AS h(name, value) WHERE h.name='Cc')\r\n        ) AS Recipients\r\n      FROM emails m \r\n      RIGHT JOIN staging_message s ON s.external_id = m.imported_from_id\r\n      LIMIT ${num} OFFSET ${offset};`,\r\n        {\r\n          transform: (result) => {\r\n            let recipients: Array<string> | string | null;\r\n            if (result.recipients === null || result.recipients === undefined) {\r\n              recipients = null;\r\n            } else if (typeof result.recipients === 'string') {\r\n              recipients = result.recipients\r\n                .split(',')\r\n                .map((r: string) => r.trim());\r\n              if (recipients.length === 1) {\r\n                recipients = recipients[0];\r\n              }\r\n            } else {\r\n              log((l) =>\r\n                l.warn({\r\n                  msg: '[[WARNING]] - Unexpected recipient type detected:',\r\n                  recipients,\r\n                }),\r\n              );\r\n              recipients = null;\r\n            }\r\n            const ret: StagedMessageSummary = {\r\n              stage: result.stage as ImportStage,\r\n              id: result.id as string,\r\n              targetId: result.targetid as string,\r\n              timestamp: result.timestamp as Date,\r\n              sender: result.sender as string,\r\n              userId: result.userId as number,\r\n              recipients,\r\n            };\r\n            return ret;\r\n          },\r\n        },\r\n      );\r\n\r\n      const total = await query(\r\n        (q) => q`SELECT COUNT(*) AS records FROM staging_message;`,\r\n      );\r\n      log((l) =>\r\n        l.verbose({\r\n          msg: '[[AUDIT]] -  Import list:',\r\n          resultset: result,\r\n          num,\r\n          offset,\r\n          cbTotal: total,\r\n        }),\r\n      );\r\n\r\n      return NextResponse.json(\r\n        { pageStats: { page, num, total: total[0].records }, results: result },\r\n        { status: 200 },\r\n      );\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'GET email/import/list',\r\n      });\r\n      return NextResponse.json(\r\n        { error: 'Internal Server Error' },\r\n        { status: 500 },\r\n      );\r\n    }\r\n  },\r\n);\r\n\r\nexport const dynamic = 'force-dynamic';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\route.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":282,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { log } from '@/lib/logger';\r\n// (normalizeNullableNumeric no longer needed directly; handled in validation module)\r\nimport { ValidationError } from '@/lib/react-util/errors/validation-error';\r\n\r\nimport { EmailService } from '@/lib/api/email/email-service';\r\nimport {\r\n  validateCreateEmail,\r\n  validateUpdateEmail,\r\n} from '@/lib/api/email/email-validation';\r\nimport {\r\n  buildFallbackGrid,\r\n  wrapRouteRequest,\r\n} from '@/lib/nextjs-util/server/utils';\r\nimport { drizDbWithInit, schema } from '@/lib/drizzle-db';\r\nimport {\r\n  count_kpi,\r\n  count_attachments,\r\n  count_notes,\r\n  count_responsive_actions,\r\n  count_cta,\r\n} from '@/lib/api/email/drizzle/query-parts';\r\nimport { eq } from 'drizzle-orm';\r\n// count_kpi import removed; not used in this route currently\r\nimport {\r\n  DrizzleSelectQuery,\r\n  getEmailColumn,\r\n  selectForGrid,\r\n} from '@/lib/components/mui/data-grid/queryHelpers';\r\nimport { ContactSummary, EmailMessageSummary } from '@/data-models';\r\n\r\nexport const dynamic = 'force-dynamic';\r\n\r\n/**\r\n * Handles the GET request to fetch a list of emails with sender and recipient information.\r\n *\r\n * This function uses the EmailService to retrieve emails with their sender's details and\r\n * a list of recipients. The results are returned as a JSON response with pagination support.\r\n *\r\n * @param req - The incoming request object\r\n * @returns {Promise<NextResponse>} A promise that resolves to a JSON response containing the\r\n * list of emails with sender and recipient information, or an error message if the request fails.\r\n *\r\n * @throws {Error} If there is an issue with the service operation or any other error occurs during\r\n * the execution of the function, an error is logged and a 500 Internal Server Error response is returned.\r\n */\r\nexport const GET = wrapRouteRequest(\r\n  async (req: NextRequest) => {\r\n    const results = await drizDbWithInit(async (db) => {\r\n      // Correlated subquery returning a JSONB array of recipient objects for each email\r\n      const attachments = count_attachments({ db });\r\n      const countKpi = count_kpi({ db });\r\n      const countNotes = count_notes({ db });\r\n      const countRa = count_responsive_actions({ db });\r\n      const countCta = count_cta({ db });\r\n\r\n      const getColumn = (columnName: string) => {\r\n        switch (columnName) {\r\n          case 'sentOn':\r\n            return schema.emails.sentTimestamp;\r\n          case 'count_attachments':\r\n            return attachments.countAttachments;\r\n          case 'count_kpi':\r\n            return countKpi.targetCount;\r\n          case 'count_notes':\r\n            return countNotes.targetCount;\r\n          case 'count_cta':\r\n            return countCta.targetCount;\r\n          case 'count_responsive_actions':\r\n            return countRa.targetCount;\r\n          case 'sender':\r\n            return schema.contacts.name;\r\n          default:\r\n            return getEmailColumn({ columnName, table: schema.emails });\r\n        }\r\n      };\r\n\r\n      const bq = db\r\n        .select({\r\n          emailId: schema.emails.emailId,\r\n          senderId: schema.emails.senderId,\r\n          senderName: schema.contacts.name,\r\n          senderEmai: schema.contacts.email,\r\n          subject: schema.emails.subject,\r\n          sentOn: schema.emails.sentTimestamp,\r\n          threadId: schema.emails.threadId,\r\n          parentEmailId: schema.emails.parentId,\r\n          importedFromId: schema.emails.importedFromId,\r\n          globalMessageId: schema.emails.globalMessageId,\r\n          count_kpi: countKpi.targetCount,\r\n          count_notes: countNotes.targetCount,\r\n          count_cta: countCta.targetCount,\r\n          count_responsive_actions: countRa.targetCount,\r\n          count_attachments: attachments.countAttachments,\r\n        })\r\n        .from(schema.emails)\r\n        .innerJoin(\r\n          schema.contacts,\r\n          eq(schema.emails.senderId, schema.contacts.contactId),\r\n        )\r\n        .fullJoin(attachments, eq(schema.emails.emailId, attachments.emailId))\r\n        .fullJoin(countKpi, eq(schema.emails.emailId, countKpi.targetId))\r\n        .fullJoin(countNotes, eq(schema.emails.emailId, countNotes.targetId))\r\n        .fullJoin(countCta, eq(schema.emails.emailId, countCta.targetId))\r\n        .fullJoin(countRa, eq(schema.emails.emailId, countRa.targetId));\r\n      return await selectForGrid<EmailMessageSummary>({\r\n        req,\r\n        query: bq as unknown as DrizzleSelectQuery,\r\n        getColumn,\r\n        defaultSort: 'sentOn',\r\n        recordMapper: (emailDomain) => ({\r\n          emailId: String(emailDomain.emailId),\r\n          sender: {\r\n            contactId: Number(emailDomain.senderId),\r\n            name: String(emailDomain.senderName),\r\n            email: String(emailDomain.senderEmail),\r\n          } as ContactSummary,\r\n          subject: String(emailDomain.subject ?? ''),\r\n          sentOn: new Date(\r\n            emailDomain.sentOn\r\n              ? Date.parse(String(emailDomain.sentOn))\r\n              : Date.now(),\r\n          ),\r\n          threadId: emailDomain.threadId\r\n            ? Number(emailDomain.threadId)\r\n            : undefined,\r\n          parentEmailId: emailDomain.parentId\r\n            ? String(emailDomain.parentId)\r\n            : undefined,\r\n          importedFromId: emailDomain.importedFromId\r\n            ? String(emailDomain.importedFromId)\r\n            : undefined,\r\n          globalMessageId: emailDomain.globalMessageId\r\n            ? String(emailDomain.globalMessageId)\r\n            : undefined,\r\n          recipients: emailDomain.recipients as Array<ContactSummary>,\r\n          count_attachments: Number(emailDomain.count_attachments) ?? 0,\r\n          count_kpi: Number(emailDomain.count_kpi) ?? 0,\r\n          count_notes: Number(emailDomain.count_notes) ?? 0,\r\n          count_cta: Number(emailDomain.count_cta) ?? 0,\r\n          count_responsive_actions:\r\n            Number(emailDomain.count_responsive_actions) ?? 0,\r\n        }),\r\n      });\r\n    });\r\n\r\n    return Response.json(results);\r\n  },\r\n  { buildFallback: buildFallbackGrid },\r\n);\r\n\r\n/**\r\n * Handles the POST request to create a new email.\r\n *\r\n * This function uses the EmailService to create a new email with recipients and\r\n * automatically creates the associated document unit for content storage.\r\n *\r\n * @param {NextRequest} req - The incoming request object.\r\n * @returns {Promise<NextResponse>} - The response object containing the result of the email creation.\r\n * @throws {Error} - If there is an issue with the email creation process.\r\n */\r\nexport const POST = wrapRouteRequest(\r\n  async (req: NextRequest): Promise<NextResponse> => {\r\n    try {\r\n      const raw = await req.json();\r\n      const validated = validateCreateEmail(raw);\r\n      if (!validated.success) {\r\n        return NextResponse.json(\r\n          { error: 'Validation failed', details: validated.error.flatten() },\r\n          { status: 400 },\r\n        );\r\n      }\r\n      const emailService = new EmailService();\r\n      const createdEmail = await emailService.createEmail(validated.data);\r\n\r\n      return NextResponse.json(\r\n        {\r\n          message: 'Email created successfully',\r\n          email: createdEmail,\r\n        },\r\n        { status: 201 },\r\n      );\r\n    } catch (error) {\r\n      if (ValidationError.isValidationError(error)) {\r\n        return NextResponse.json({ error: error.message }, { status: 400 });\r\n      }\r\n      log((l) =>\r\n        l.error({\r\n          source: 'POST email',\r\n          error,\r\n        }),\r\n      );\r\n      return NextResponse.json(\r\n        { error: 'Internal Server Error' },\r\n        { status: 500 },\r\n      );\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Handles the PUT request to update an existing email.\r\n *\r\n * This function uses the EmailService to update an existing email with new data\r\n * and optionally update recipients.\r\n *\r\n * @param {NextRequest} req - The incoming request object.\r\n * @returns {Promise<NextResponse>} - The response object containing the result of the email update.\r\n * @throws {Error} - If there is an issue with the email update process.\r\n */\r\nexport const PUT = wrapRouteRequest(\r\n  async (req: NextRequest): Promise<NextResponse> => {\r\n    try {\r\n      const raw = await req.json();\r\n      const validated = validateUpdateEmail(raw);\r\n      if (!validated.success) {\r\n        return NextResponse.json(\r\n          { error: 'Validation failed', details: validated.error.flatten() },\r\n          { status: 400 },\r\n        );\r\n      }\r\n      const emailService = new EmailService();\r\n      const updatedEmail = await emailService.updateEmail(validated.data);\r\n\r\n      return NextResponse.json(\r\n        { message: 'Email updated successfully', email: updatedEmail },\r\n        { status: 200 },\r\n      );\r\n    } catch (error) {\r\n      if (ValidationError.isValidationError(error)) {\r\n        return NextResponse.json({ error: error.message }, { status: 400 });\r\n      }\r\n      log((l) => l.error({ source: 'PUT email', error }));\r\n      return NextResponse.json(\r\n        { error: 'Internal Server Error' },\r\n        { status: 500 },\r\n      );\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Handles the DELETE request to remove an email.\r\n *\r\n * This function uses the EmailService to delete an email by ID.\r\n *\r\n * @param {NextRequest} req - The incoming request object.\r\n * @returns {Promise<NextResponse>} - The response object containing the result of the email deletion.\r\n */\r\nexport const DELETE = wrapRouteRequest(\r\n  async (req: NextRequest): Promise<NextResponse> => {\r\n    try {\r\n      const { emailId } = await req.json();\r\n\r\n      if (!emailId) {\r\n        return NextResponse.json(\r\n          { error: 'Email ID is required' },\r\n          { status: 400 },\r\n        );\r\n      }\r\n\r\n      const emailService = new EmailService();\r\n      const deleted = await emailService.deleteEmail(emailId);\r\n\r\n      if (!deleted) {\r\n        return NextResponse.json({ error: 'Email not found' }, { status: 404 });\r\n      }\r\n\r\n      return NextResponse.json(\r\n        { message: 'Email deleted successfully' },\r\n        { status: 200 },\r\n      );\r\n    } catch (error) {\r\n      log((l) => l.error({ source: 'DELETE email', error }));\r\n      return NextResponse.json(\r\n        { error: 'Internal Server Error' },\r\n        { status: 500 },\r\n      );\r\n    }\r\n  },\r\n);\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\search\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\stats\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\email\\thread\\[threadId]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\health\\route.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":232,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { wrapRouteRequest } from '@/lib/nextjs-util/server';\r\nimport { NextResponse } from 'next/server';\r\nimport {\r\n  ExtendedMemoryClient,\r\n  memoryClientFactory,\r\n} from '@/lib/ai/mem0/memoryclient-factory';\r\nimport {\r\n  determineHealthStatus,\r\n  type HealthStatus,\r\n} from '@/lib/ai/mem0/types/health-check';\r\n\r\n/**\r\n * Health Check Route (GET /api/health)\r\n * -------------------------------------------------------------\r\n * Provides a lightweight, synchronous snapshot of core platform subsystem status.\r\n * Designed to be:\r\n *  - Fast (no outbound network calls here – delegate deeper checks elsewhere)\r\n *  - Deterministic (always resolves a JSON payload)\r\n *  - Simple schema (stable keys for external monitoring / k8s / uptime pings)\r\n *\r\n * Current Subsystems:\r\n *  - database: Indicates DB layer reachability (placeholder: assumed OK here)\r\n *  - chat: Aggregated status for chat‑related infrastructure\r\n *      - cache: In‑process / external cache layer (placeholder)\r\n *      - queue: Background processing / queue subsystem (placeholder)\r\n *\r\n * NOTE: This endpoint intentionally does NOT perform real connectivity probes in this\r\n * implementation to avoid cascading failures or latency amplification. If deeper\r\n * diagnostics are required, consider a separate /api/health/deep or /api/diagnostics route.\r\n *\r\n * Example Successful Response:\r\n * {\r\n *   \"database\": { \"status\": \"ok\" },\r\n *   \"chat\": {\r\n *     \"status\": \"ok\",\r\n *     \"cache\": { \"status\": \"ok\" },\r\n *     \"queue\": { \"status\": \"ok\" }\r\n *   }\r\n * }\r\n *\r\n * Build / Deployment Considerations:\r\n *  - Wrapped with wrapRouteRequest, which provides:\r\n *      * Consistent logging (when enabled)\r\n *      * Structured error handling returning a JSON errorResponseFactory on failures\r\n *      * Build‑phase fallback short‑circuit (returns a neutral JSON object when\r\n *        NEXT_PHASE === 'phase-production-build' or IS_BUILDING=1 unless explicitly overridden)\r\n *\r\n * Testing:\r\n *  - See: __tests__/app/api/health/route.test.ts for validation of:\r\n *      * Successful payload shape\r\n *      * Build fallback behavior\r\n *      * Logging invocation path\r\n *\r\n * Extending:\r\n *  - Introduce real checks by replacing static assignments with async probes, e.g.:\r\n *      const database = await dbPing();\r\n *      const cache = await cacheClient.ping();\r\n *    Ensure added calls are timeout‑bounded to preserve endpoint responsiveness.\r\n */\r\n\r\n/**\r\n * Narrow set of status codes surfaced by the health layer.\r\n * Keep deliberately small to simplify external automation.\r\n */\r\ntype HealthCheckStatusCode = 'ok' | 'warning' | 'error';\r\n\r\n/**\r\n * Enumerates discrete systems (or system groups) represented in the response.\r\n */\r\ntype HealthCheckSystem = 'database' | 'cache' | 'queue' | 'chat' | 'memory';\r\n\r\n/**\r\n * Base shape for any status entry.\r\n */\r\ntype HealthCheckStatusEntryBase = {\r\n  /** Current coarse status value */\r\n  status: HealthCheckStatusCode;\r\n};\r\ntype HealthCheckStatusEntry<K extends string = never> =\r\n  HealthCheckStatusEntryBase & {\r\n    [key in K]?: HealthCheckStatusEntryBase;\r\n  };\r\n\r\n/**\r\n * Maps each system to its expected nested structure.\r\n * chat includes embedded sub‑systems (cache, queue) to express grouped health.\r\n * memory includes embedded sub‑systems (db, vectorStore, graphStore, historyStore, authService) to express grouped health.\r\n */\r\ntype HealthSystemResponseTypeMap = {\r\n  database: HealthCheckStatusEntry<never>;\r\n  chat: HealthCheckStatusEntry<'cache' | 'queue'>;\r\n  cache: HealthCheckStatusEntry<never>;\r\n  queue: HealthCheckStatusEntry<never>;\r\n  memory: HealthCheckStatusEntry<\r\n    'db' | 'vectorStore' | 'graphStore' | 'historyStore' | 'authService'\r\n  >;\r\n};\r\n\r\n/**\r\n * Final JSON response contract. Each top-level key is optional to allow\r\n * progressive enhancement without breaking consumers (absent key = not reported).\r\n */\r\ntype HealthCheckResponse = {\r\n  [key in HealthCheckSystem]?: HealthSystemResponseTypeMap[key];\r\n};\r\n\r\n/**\r\n * Maps health status to health check status code\r\n */\r\nfunction mapHealthStatusToCode(status: HealthStatus): HealthCheckStatusCode {\r\n  switch (status) {\r\n    case 'healthy':\r\n      return 'ok';\r\n    case 'warning':\r\n      return 'warning';\r\n    case 'error':\r\n      return 'error';\r\n    default:\r\n      return 'error';\r\n  }\r\n}\r\n\r\n/**\r\n * Checks memory system health by calling the Mem0 health check endpoint\r\n * Returns granular subsystem health information\r\n */\r\nasync function checkMemoryHealth(): Promise<\r\n  HealthCheckStatusEntry<\r\n    'db' | 'vectorStore' | 'graphStore' | 'historyStore' | 'authService'\r\n  >\r\n> {\r\n  try {\r\n    const memoryClient = await memoryClientFactory<ExtendedMemoryClient>({});\r\n    const healthResponse = await memoryClient.healthCheck({\r\n      strict: false,\r\n      verbose: 1,\r\n    });\r\n\r\n    const { details } = healthResponse;\r\n\r\n    // Create granular subsystem status entries\r\n    const subsystems = {\r\n      db: {\r\n        status: details.system_db_available\r\n          ? ('ok' as const)\r\n          : ('error' as const),\r\n      },\r\n      vectorStore: {\r\n        status: details.vector_store_available\r\n          ? ('ok' as const)\r\n          : ('error' as const),\r\n      },\r\n      graphStore: {\r\n        status: details.graph_store_available\r\n          ? ('ok' as const)\r\n          : ('error' as const),\r\n      },\r\n      historyStore: {\r\n        status: details.history_store_available\r\n          ? ('ok' as const)\r\n          : ('error' as const),\r\n      },\r\n      authService: {\r\n        status: details.auth_service.healthy\r\n          ? ('ok' as const)\r\n          : ('error' as const),\r\n      },\r\n    };\r\n\r\n    // Determine overall memory system status\r\n    const overallHealthStatus = determineHealthStatus(details);\r\n    const overallStatusCode = mapHealthStatusToCode(overallHealthStatus);\r\n\r\n    return {\r\n      status: overallStatusCode,\r\n      ...subsystems,\r\n    };\r\n  } catch (error) {\r\n    // If we can't reach the memory service, consider everything an error\r\n    console.error('Memory health check failed:', error);\r\n    return {\r\n      status: 'error',\r\n      db: { status: 'error' },\r\n      vectorStore: { status: 'error' },\r\n      graphStore: { status: 'error' },\r\n      historyStore: { status: 'error' },\r\n      authService: { status: 'error' },\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * GET /api/health\r\n * Returns a structured snapshot of subsystem statuses.\r\n * Wrapped for unified logging / error semantics.\r\n */\r\nexport const GET = wrapRouteRequest(async () => {\r\n  // Get memory health asynchronously with timeout\r\n  const memoryHealthPromise = Promise.race([\r\n    checkMemoryHealth(),\r\n    new Promise<\r\n      HealthCheckStatusEntry<\r\n        'db' | 'vectorStore' | 'graphStore' | 'historyStore' | 'authService'\r\n      >\r\n    >(\r\n      (resolve) =>\r\n        setTimeout(\r\n          () =>\r\n            resolve({\r\n              status: 'error',\r\n              db: { status: 'error' },\r\n              vectorStore: { status: 'error' },\r\n              graphStore: { status: 'error' },\r\n              historyStore: { status: 'error' },\r\n              authService: { status: 'error' },\r\n            }),\r\n          15000,\r\n        ), // 15 second timeout\r\n    ),\r\n  ]);\r\n\r\n  const [memoryHealth] = await Promise.all([memoryHealthPromise]);\r\n\r\n  const healthCheckResponse: HealthCheckResponse = {\r\n    database: { status: 'ok' },\r\n    chat: { status: 'ok', cache: { status: 'ok' }, queue: { status: 'ok' } },\r\n    memory: memoryHealth,\r\n  };\r\n\r\n  return NextResponse.json(healthCheckResponse, { status: 200 });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\health\\tools\\route.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":48,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { auth } from '@/auth';\r\nimport { setupDefaultTools } from '@/lib/ai/mcp/providers';\r\nimport { User } from 'next-auth';\r\nimport { wrapRouteRequest } from '@/lib/nextjs-util/server';\r\nimport { NextRequest } from 'next/server';\r\n\r\nconst toolProviderFactory = async ({\r\n  req,\r\n  user,\r\n}: {\r\n  req: NextRequest;\r\n  chatHistoryId: string;\r\n  writeEnabled?: boolean;\r\n  memoryDisabled?: boolean;\r\n  user: User;\r\n  sessionId: string;\r\n}) =>\r\n  setupDefaultTools({\r\n    user,\r\n    writeEnabled: false,\r\n    req,\r\n    chatHistoryId: 'health-check',\r\n    memoryEnabled: true,\r\n  });\r\n\r\n/**\r\n * GET /api/health\r\n * Returns a structured snapshot of subsystem statuses.\r\n * Wrapped for unified logging / error semantics.\r\n */\r\nexport const GET = wrapRouteRequest(async (req: NextRequest) => {\r\n  const session = await auth();\r\n  if (!session?.user) {\r\n    return Response.json(\r\n      { status: 401, message: 'Unauthorized' },\r\n      { status: 401 },\r\n    );\r\n  }\r\n  const toolProviders = await toolProviderFactory({\r\n    req,\r\n    chatHistoryId: 'health-check',\r\n    user: session.user,\r\n    sessionId: 'test-session',\r\n  });\r\n  const tools = Object.keys(toolProviders.tools);\r\n  return Response.json({ status: 200, message: 'OK', tools }, { status: 200 });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\api\\memory\\[...action]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\auth\\signin\\page.tsx","messages":[],"suppressedMessages":[{"ruleId":"jsx-a11y/alt-text","severity":1,"message":"Image elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","line":24,"column":3,"nodeType":"JSXOpeningElement","endLine":24,"endColumn":68,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"jsx-a11y/alt-text","severity":1,"message":"Image elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","line":28,"column":3,"nodeType":"JSXOpeningElement","endLine":28,"endColumn":67,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\bulk-edit\\page.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":2,"column":1,"nodeType":"Program","endLine":119,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/** @jsxImportSource @emotion/react */\r\n'use client';\r\n\r\nimport BulkEmailForm from '@/components/email-message/bulk-form';\r\nimport Image from 'next/image';\r\nimport { css } from '@emotion/react';\r\n\r\nconst pageStyles = {\r\n  container: css`\r\n    display: grid;\r\n    align-items: center;\r\n    justify-items: center;\r\n    min-height: 100vh;\r\n    padding: 2rem;\r\n    gap: 4rem;\r\n    font-family: var(--font-geist-sans);\r\n\r\n    @media (min-width: 640px) {\r\n      padding: 5rem;\r\n      padding-bottom: 5rem;\r\n    }\r\n  `,\r\n  main: css`\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 2rem;\r\n    align-items: center;\r\n\r\n    @media (min-width: 640px) {\r\n      align-items: flex-start;\r\n    }\r\n  `,\r\n  mainWrapper: css`\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 0.5rem;\r\n    width: 100%;\r\n    max-width: 100%;\r\n  `,\r\n  buttonContainer: css`\r\n    display: flex;\r\n    gap: 1rem;\r\n    align-items: center;\r\n    flex-direction: column;\r\n\r\n    @media (min-width: 640px) {\r\n      flex-direction: row;\r\n    }\r\n  `,\r\n  footer: css`\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 1rem;\r\n    align-items: center;\r\n\r\n    @media (min-width: 640px) {\r\n      flex-direction: row;\r\n    }\r\n  `,\r\n  link: css`\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 0.5rem;\r\n\r\n    &:hover {\r\n      text-decoration: underline;\r\n      text-underline-offset: 4px;\r\n    }\r\n  `,\r\n};\r\n\r\nexport default function Home() {\r\n  return (\r\n    <div css={pageStyles.container}>\r\n      <main css={pageStyles.main}>\r\n        <div css={pageStyles.mainWrapper}>\r\n          <BulkEmailForm />\r\n        </div>\r\n\r\n        <div css={pageStyles.buttonContainer}></div>\r\n      </main>\r\n      <footer css={pageStyles.footer}>\r\n        <a\r\n          css={pageStyles.link}\r\n          href=\"/\"\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n          data-id=\"link-examples\"\r\n        >\r\n          <Image\r\n            aria-hidden\r\n            src=\"/window.svg\"\r\n            alt=\"Window icon\"\r\n            width={16}\r\n            height={16}\r\n          />\r\n          Examples\r\n        </a>\r\n        <a\r\n          css={pageStyles.link}\r\n          href=\"https://education.mn.gov/MDE/index.htm\"\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n          data-id=\"link-mn-dept-of-ed\"\r\n        >\r\n          <Image\r\n            aria-hidden\r\n            src=\"/globe.svg\"\r\n            alt=\"Globe icon\"\r\n            width={16}\r\n            height={16}\r\n          />\r\n          Go to MN Dept of Ed →\r\n        </a>\r\n      </footer>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\error.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":34,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client'; // Error boundaries must be Client Components\r\n\r\nimport { useEffect } from 'react';\r\nimport { RenderErrorBoundaryFallback } from '@/components/error-boundaries/renderFallback';\r\nimport { errorReporter, ErrorSeverity } from '@/lib/error-monitoring';\r\n\r\ntype ErrorProps = {\r\n  error: Error & { digest?: string };\r\n  reset: () => void;\r\n};\r\n\r\n/**\r\n * Root-level error boundary that catches errors throughout the app\r\n * This provides a fallback UI for any unhandled errors in the app router\r\n */\r\nexport default function Error({ error, reset }: ErrorProps) {\r\n  useEffect(() => {\r\n    // Report the error with high severity since it reached the root level\r\n    errorReporter.reportBoundaryError(\r\n      error,\r\n      {\r\n        errorBoundary: 'RootError',\r\n      },\r\n      ErrorSeverity.HIGH,\r\n    );\r\n  }, [error]);\r\n\r\n  return (\r\n    <div>\r\n      <RenderErrorBoundaryFallback error={error} resetErrorBoundary={reset} />\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\global-error.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":58,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client'; // Error boundaries must be Client Components\r\n\r\nimport * as React from 'react';\r\nimport { useEffect } from 'react';\r\nimport { errorReporter, ErrorSeverity } from '@/lib/error-monitoring';\r\nimport { RenderErrorBoundaryFallback } from '@/components/error-boundaries/renderFallback';\r\nimport { FlagProvider } from '@/components/general/flags/flag-provider';\r\n\r\ntype GlobalErrorProps = {\r\n  error: Error & { digest?: string };\r\n  reset: () => void;\r\n};\r\n\r\n/**\r\n * Global error boundary that catches errors in the root layout\r\n * This is a last resort fallback for critical application errors\r\n */\r\nexport default function GlobalError({ error, reset }: GlobalErrorProps) {\r\n  useEffect(() => {\r\n    // Report the critical error - this is the last line of defense\r\n    errorReporter.reportBoundaryError(\r\n      error,\r\n      {\r\n        errorBoundary: 'GlobalError',\r\n      },\r\n      ErrorSeverity.CRITICAL,\r\n    );\r\n  }, [error]);\r\n\r\n  return (\r\n    <html lang=\"en\">\r\n      <head>\r\n        <title>Application Error - School Case Tracker</title>\r\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\r\n      </head>\r\n      <body style={{ margin: 0, fontFamily: 'system-ui, sans-serif' }}>\r\n        {/* Provide feature flags context so the error UI and any children can call */}\r\n        <FlagProvider>\r\n          <div\r\n            style={{\r\n              minHeight: '100vh',\r\n              display: 'flex',\r\n              alignItems: 'center',\r\n              justifyContent: 'center',\r\n              backgroundColor: '#fafafa',\r\n            }}\r\n          >\r\n            <RenderErrorBoundaryFallback\r\n              error={error}\r\n              resetErrorBoundary={reset}\r\n            />\r\n          </div>\r\n        </FlagProvider>\r\n      </body>\r\n    </html>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\chat\\[chatId]\\page.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":49,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\r\nimport { Box } from '@mui/material';\r\nimport { auth } from '@/auth';\r\nimport { EmailDashboardLayout } from '@/components/email-message/dashboard-layout/email-dashboard-layout';\r\nimport { ChatHistory } from '@/components/chat/history';\r\nimport { extractParams } from '@/lib/nextjs-util/utils';\r\nimport { getChatDetails } from '@/lib/ai/chat/history';\r\nimport { notFound, unauthorized } from 'next/navigation';\r\n\r\n/**\r\n * Server-rendered inner component that performs async auth/permission checks.\r\n * Returns either Access Denied UI or the dashboard content.\r\n */\r\nconst ChatDetailPage = async (req: { params: Promise<{ chatId: string }> }) => {\r\n  const props = { session: await auth() };\r\n\r\n  if (!props.session) {\r\n    return unauthorized();\r\n  }\r\n\r\n  const { user: { id: userIdFromProps } = {} } = props.session;\r\n  const userId = Number(userIdFromProps);\r\n  if (!userId || isNaN(userId)) {\r\n    return notFound();\r\n  }\r\n\r\n  const { chatId } = await extractParams(req);\r\n  if (!chatId) {\r\n    return notFound();\r\n  }\r\n\r\n  // Try direct id first\r\n  const details = await getChatDetails({ chatId, userId });\r\n  if (!details.ok) {\r\n    return notFound();\r\n  }\r\n\r\n  // success\r\n  return (\r\n    <EmailDashboardLayout session={props.session}>\r\n      <Box sx={{ p: 2 }}>\r\n        <ChatHistory chatId={chatId} title={details.title} />\r\n      </Box>\r\n    </EmailDashboardLayout>\r\n  );\r\n};\r\n\r\nexport default ChatDetailPage;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\chat\\chat-page-client.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\chat\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\chat\\stats\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\email\\[emailId]\\call-to-action-response\\grid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\email\\[emailId]\\call-to-action-response\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\email\\[emailId]\\call-to-action-response\\panel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\email\\[emailId]\\call-to-action\\[propertyId]\\timeline\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\email\\[emailId]\\call-to-action\\grid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\email\\[emailId]\\call-to-action\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\email\\[emailId]\\call-to-action\\panel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\email\\[emailId]\\email-header\\grid-columns.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\email\\[emailId]\\email-header\\grid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\email\\[emailId]\\email-header\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\email\\[emailId]\\email-header\\panel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\email\\[emailId]\\key-points\\grid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\email\\[emailId]\\key-points\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\email\\[emailId]\\key-points\\panel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\email\\[emailId]\\notes copy\\grid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\email\\[emailId]\\notes copy\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\email\\[emailId]\\notes\\grid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\email\\[emailId]\\notes\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\email\\[emailId]\\notes\\panel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\email\\[emailId]\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\error.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\import\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\import\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\messages\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\not-found.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":198,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React from 'react';\r\nimport {\r\n  Box,\r\n  Container,\r\n  Typography,\r\n  Button,\r\n  Paper,\r\n  useTheme,\r\n  useMediaQuery,\r\n} from '@mui/material';\r\nimport { useRouter } from 'next/navigation';\r\nimport HomeIcon from '@mui/icons-material/Home';\r\nimport SearchIcon from '@mui/icons-material/Search';\r\nimport ArrowBackIcon from '@mui/icons-material/ArrowBack';\r\nimport ErrorOutlineIcon from '@mui/icons-material/ErrorOutline';\r\n\r\n/**\r\n * Custom 404 Not Found page with Material UI styling\r\n * Follows the application's design system and provides helpful navigation options\r\n */\r\nexport default function NotFound() {\r\n  const router = useRouter();\r\n  const theme = useTheme();\r\n  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));\r\n\r\n  const handleGoHome = () => {\r\n    router.push('/');\r\n  };\r\n\r\n  const handleGoBack = () => {\r\n    router.back();\r\n  };\r\n\r\n  const handleSearch = () => {\r\n    router.push('/messages'); // Navigate to main email search\r\n  };\r\n\r\n  return (\r\n    <Container maxWidth=\"md\">\r\n      <Box\r\n        sx={{\r\n          minHeight: '100vh',\r\n          display: 'flex',\r\n          flexDirection: 'column',\r\n          justifyContent: 'center',\r\n          alignItems: 'center',\r\n          textAlign: 'center',\r\n          py: 4,\r\n        }}\r\n      >\r\n        <Paper\r\n          elevation={6}\r\n          sx={{\r\n            p: 4,\r\n            borderRadius: 3,\r\n            maxWidth: 600,\r\n            width: '100%',\r\n            background:\r\n              theme.palette.mode === 'dark'\r\n                ? 'linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%)'\r\n                : 'linear-gradient(135deg, #ffffff 0%, #f5f5f5 100%)',\r\n          }}\r\n        >\r\n          {/* 404 Icon */}\r\n          <Box sx={{ mb: 3 }}>\r\n            <ErrorOutlineIcon\r\n              sx={{\r\n                fontSize: isMobile ? 80 : 120,\r\n                color: theme.palette.primary.main,\r\n                opacity: 0.8,\r\n              }}\r\n            />\r\n          </Box>\r\n\r\n          {/* Main heading */}\r\n          <Typography\r\n            variant={isMobile ? 'h3' : 'h2'}\r\n            component=\"h1\"\r\n            gutterBottom\r\n            sx={{\r\n              fontWeight: 700,\r\n              background: `linear-gradient(45deg, ${theme.palette.primary.main}, ${theme.palette.secondary.main})`,\r\n              backgroundClip: 'text',\r\n              WebkitBackgroundClip: 'text',\r\n              WebkitTextFillColor: 'transparent',\r\n              mb: 2,\r\n            }}\r\n          >\r\n            404\r\n          </Typography>\r\n\r\n          {/* Subheading */}\r\n          <Typography\r\n            variant=\"h5\"\r\n            component=\"h2\"\r\n            gutterBottom\r\n            sx={{\r\n              fontWeight: 500,\r\n              color: theme.palette.text.primary,\r\n              mb: 2,\r\n            }}\r\n          >\r\n            Page Not Found\r\n          </Typography>\r\n\r\n          {/* Description */}\r\n          <Typography\r\n            variant=\"body1\"\r\n            color=\"text.secondary\"\r\n            sx={{\r\n              mb: 4,\r\n              lineHeight: 1.6,\r\n              maxWidth: 400,\r\n              mx: 'auto',\r\n            }}\r\n          >\r\n            The page you&apos;re looking for doesn&apos;t exist or may have been\r\n            moved. Let&apos;s get you back on track with your case management.\r\n          </Typography>\r\n\r\n          {/* Action buttons */}\r\n          <Box\r\n            sx={{\r\n              display: 'flex',\r\n              gap: 2,\r\n              justifyContent: 'center',\r\n              flexDirection: isMobile ? 'column' : 'row',\r\n              alignItems: 'center',\r\n            }}\r\n          >\r\n            <Button\r\n              variant=\"contained\"\r\n              size=\"large\"\r\n              startIcon={<HomeIcon />}\r\n              onClick={handleGoHome}\r\n              sx={{\r\n                px: 3,\r\n                py: 1.5,\r\n                borderRadius: 2,\r\n                textTransform: 'none',\r\n                minWidth: isMobile ? '100%' : 160,\r\n              }}\r\n            >\r\n              Go Home\r\n            </Button>\r\n\r\n            <Button\r\n              variant=\"outlined\"\r\n              size=\"large\"\r\n              startIcon={<SearchIcon />}\r\n              onClick={handleSearch}\r\n              sx={{\r\n                px: 3,\r\n                py: 1.5,\r\n                borderRadius: 2,\r\n                textTransform: 'none',\r\n                minWidth: isMobile ? '100%' : 160,\r\n              }}\r\n            >\r\n              Search Cases\r\n            </Button>\r\n\r\n            <Button\r\n              variant=\"text\"\r\n              size=\"large\"\r\n              startIcon={<ArrowBackIcon />}\r\n              onClick={handleGoBack}\r\n              sx={{\r\n                px: 3,\r\n                py: 1.5,\r\n                borderRadius: 2,\r\n                textTransform: 'none',\r\n                minWidth: isMobile ? '100%' : 160,\r\n              }}\r\n            >\r\n              Go Back\r\n            </Button>\r\n          </Box>\r\n        </Paper>\r\n\r\n        {/* Additional help text */}\r\n        <Typography\r\n          variant=\"body2\"\r\n          color=\"text.secondary\"\r\n          sx={{\r\n            mt: 3,\r\n            opacity: 0.7,\r\n          }}\r\n        >\r\n          Need help? Contact support or check the documentation.\r\n        </Typography>\r\n      </Box>\r\n    </Container>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\standalone-chat-test\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\test-chat\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\test-docking\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\app\\unauthorized.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":199,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React from 'react';\r\nimport {\r\n  Box,\r\n  Container,\r\n  Typography,\r\n  Button,\r\n  Paper,\r\n  useTheme,\r\n  useMediaQuery,\r\n} from '@mui/material';\r\nimport { useRouter } from 'next/navigation';\r\nimport HomeIcon from '@mui/icons-material/Home';\r\nimport SearchIcon from '@mui/icons-material/Search';\r\nimport ArrowBackIcon from '@mui/icons-material/ArrowBack';\r\nimport ErrorOutlineIcon from '@mui/icons-material/ErrorOutline';\r\n\r\n/**\r\n * Custom 404 Not Found page with Material UI styling\r\n * Follows the application's design system and provides helpful navigation options\r\n */\r\nexport default function Unauthorized() {\r\n  const router = useRouter();\r\n  const theme = useTheme();\r\n  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));\r\n\r\n  const handleGoHome = () => {\r\n    router.push('/');\r\n  };\r\n\r\n  const handleGoBack = () => {\r\n    router.back();\r\n  };\r\n\r\n  const handleSearch = () => {\r\n    router.push('/messages'); // Navigate to main email search\r\n  };\r\n\r\n  return (\r\n    <Container maxWidth=\"md\">\r\n      <Box\r\n        sx={{\r\n          minHeight: '100vh',\r\n          display: 'flex',\r\n          flexDirection: 'column',\r\n          justifyContent: 'center',\r\n          alignItems: 'center',\r\n          textAlign: 'center',\r\n          py: 4,\r\n        }}\r\n      >\r\n        <Paper\r\n          elevation={6}\r\n          sx={{\r\n            p: 4,\r\n            borderRadius: 3,\r\n            maxWidth: 600,\r\n            width: '100%',\r\n            background:\r\n              theme.palette.mode === 'dark'\r\n                ? 'linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%)'\r\n                : 'linear-gradient(135deg, #ffffff 0%, #f5f5f5 100%)',\r\n          }}\r\n        >\r\n          {/* 404 Icon */}\r\n          <Box sx={{ mb: 3 }}>\r\n            <ErrorOutlineIcon\r\n              sx={{\r\n                fontSize: isMobile ? 80 : 120,\r\n                color: theme.palette.primary.main,\r\n                opacity: 0.8,\r\n              }}\r\n            />\r\n          </Box>\r\n\r\n          {/* Main heading */}\r\n          <Typography\r\n            variant={isMobile ? 'h3' : 'h2'}\r\n            component=\"h1\"\r\n            gutterBottom\r\n            sx={{\r\n              fontWeight: 700,\r\n              background: `linear-gradient(45deg, ${theme.palette.primary.main}, ${theme.palette.secondary.main})`,\r\n              backgroundClip: 'text',\r\n              WebkitBackgroundClip: 'text',\r\n              WebkitTextFillColor: 'transparent',\r\n              mb: 2,\r\n            }}\r\n          >\r\n            403\r\n          </Typography>\r\n\r\n          {/* Subheading */}\r\n          <Typography\r\n            variant=\"h5\"\r\n            component=\"h2\"\r\n            gutterBottom\r\n            sx={{\r\n              fontWeight: 500,\r\n              color: theme.palette.text.primary,\r\n              mb: 2,\r\n            }}\r\n          >\r\n            Unauthorized Access\r\n          </Typography>\r\n\r\n          {/* Description */}\r\n          <Typography\r\n            variant=\"body1\"\r\n            color=\"text.secondary\"\r\n            sx={{\r\n              mb: 4,\r\n              lineHeight: 1.6,\r\n              maxWidth: 400,\r\n              mx: 'auto',\r\n            }}\r\n          >\r\n            You do not have permission to access this page. It may have been\r\n            moved or is restricted. Let&apos;s get you back on track with your\r\n            case management.\r\n          </Typography>\r\n\r\n          {/* Action buttons */}\r\n          <Box\r\n            sx={{\r\n              display: 'flex',\r\n              gap: 2,\r\n              justifyContent: 'center',\r\n              flexDirection: isMobile ? 'column' : 'row',\r\n              alignItems: 'center',\r\n            }}\r\n          >\r\n            <Button\r\n              variant=\"contained\"\r\n              size=\"large\"\r\n              startIcon={<HomeIcon />}\r\n              onClick={handleGoHome}\r\n              sx={{\r\n                px: 3,\r\n                py: 1.5,\r\n                borderRadius: 2,\r\n                textTransform: 'none',\r\n                minWidth: isMobile ? '100%' : 160,\r\n              }}\r\n            >\r\n              Go Home\r\n            </Button>\r\n\r\n            <Button\r\n              variant=\"outlined\"\r\n              size=\"large\"\r\n              startIcon={<SearchIcon />}\r\n              onClick={handleSearch}\r\n              sx={{\r\n                px: 3,\r\n                py: 1.5,\r\n                borderRadius: 2,\r\n                textTransform: 'none',\r\n                minWidth: isMobile ? '100%' : 160,\r\n              }}\r\n            >\r\n              Search Cases\r\n            </Button>\r\n\r\n            <Button\r\n              variant=\"text\"\r\n              size=\"large\"\r\n              startIcon={<ArrowBackIcon />}\r\n              onClick={handleGoBack}\r\n              sx={{\r\n                px: 3,\r\n                py: 1.5,\r\n                borderRadius: 2,\r\n                textTransform: 'none',\r\n                minWidth: isMobile ? '100%' : 160,\r\n              }}\r\n            >\r\n              Go Back\r\n            </Button>\r\n          </Box>\r\n        </Paper>\r\n\r\n        {/* Additional help text */}\r\n        <Typography\r\n          variant=\"body2\"\r\n          color=\"text.secondary\"\r\n          sx={{\r\n            mt: 3,\r\n            opacity: 0.7,\r\n          }}\r\n        >\r\n          Need help? Contact support or check the documentation.\r\n        </Typography>\r\n      </Box>\r\n    </Container>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\auth.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":219,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":37,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1536,1539],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1536,1539],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":114,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5107,5110],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5107,5110],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":143,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5955,5958],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5955,5958],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import NextAuth, { Account, NextAuthConfig, Profile, User } from 'next-auth'; // Added NextAuthConfig\r\nimport type { Adapter, AdapterSession, AdapterUser } from '@auth/core/adapters';\r\nimport type { CredentialInput, Provider } from '@auth/core/providers';\r\nimport { isRunningOnEdge } from '@/lib/site-util/env';\r\nimport { logEvent } from '@/lib/logger';\r\n\r\nimport { setupKeyCloakProvider } from './lib/auth/keycloak-provider';\r\nimport { authorized } from './lib/auth/authorized';\r\nimport { JWT } from '@auth/core/jwt';\r\nimport { Awaitable, DefaultSession, Session } from '@auth/core/types';\r\n\r\ntype DynamicImports = {\r\n  drizzleAdapter: {\r\n    setupDrizzleAdapter: () => Promise<Adapter>;\r\n  };\r\n  auth: {\r\n    session: {\r\n      session: (\r\n        params: ({\r\n          session: { user: AdapterUser } & AdapterSession;\r\n          /** Available when {@link AuthConfig.session} is set to `strategy: \"database\"`. */\r\n          user: AdapterUser;\r\n        } & {\r\n          session: Session;\r\n          /** Available when {@link AuthConfig.session} is set to `strategy: \"jwt\"` */\r\n          token: JWT;\r\n        }) & {\r\n          /**\r\n           * Available when using {@link AuthConfig.session} `strategy: \"database\"` and an update is triggered for the session.\r\n           *\r\n           * :::note\r\n           * You should validate this data before using it.\r\n           * :::\r\n           */\r\n          // Using any for library compatibility\r\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n          newSession: any;\r\n          trigger?: 'update';\r\n        },\r\n      ) => Awaitable<Session | DefaultSession>;\r\n    };\r\n    signIn: {\r\n      signIn: (params: {\r\n        user: User | AdapterUser;\r\n        account?: Account | null;\r\n        /**\r\n         * If OAuth provider is used, it contains the full\r\n         * OAuth profile returned by your provider.\r\n         */\r\n        profile?: Profile;\r\n        /**\r\n         * If Email provider is used, on the first call, it contains a\r\n         * `verificationRequest: true` property to indicate it is being triggered in the verification request flow.\r\n         * When the callback is invoked after a user has clicked on a sign in link,\r\n         * this property will not be present. You can check for the `verificationRequest` property\r\n         * to avoid sending emails to addresses or domains on a blocklist or to only explicitly generate them\r\n         * for email address in an allow list.\r\n         */\r\n        email?: {\r\n          verificationRequest?: boolean;\r\n        };\r\n        /** If Credentials provider is used, it contains the user credentials */\r\n        credentials?: Record<string, CredentialInput>;\r\n      }) => Awaitable<boolean | string>;\r\n    };\r\n    jwt: {\r\n      jwt: (params: {\r\n        /**\r\n         * When `trigger` is `\"signIn\"` or `\"signUp\"`, it will be a subset of {@link JWT},\r\n         * `name`, `email` and `image` will be included.\r\n         *\r\n         * Otherwise, it will be the full {@link JWT} for subsequent calls.\r\n         */\r\n        token: JWT;\r\n        /**\r\n         * Either the result of the {@link OAuthConfig.profile} or the {@link CredentialsConfig.authorize} callback.\r\n         * @note available when `trigger` is `\"signIn\"` or `\"signUp\"`.\r\n         *\r\n         * Resources:\r\n         * - [Credentials Provider](https://authjs.dev/getting-started/authentication/credentials)\r\n         * - [User database model](https://authjs.dev/guides/creating-a-database-adapter#user-management)\r\n         */\r\n        user: User | AdapterUser;\r\n        /**\r\n         * Contains information about the provider that was used to sign in.\r\n         * Also includes {@link TokenSet}\r\n         * @note available when `trigger` is `\"signIn\"` or `\"signUp\"`\r\n         */\r\n        account?: Account | null;\r\n        /**\r\n         * The OAuth profile returned from your provider.\r\n         * (In case of OIDC it will be the decoded ID Token or /userinfo response)\r\n         * @note available when `trigger` is `\"signIn\"`.\r\n         */\r\n        profile?: Profile;\r\n        /**\r\n         * Check why was the jwt callback invoked. Possible reasons are:\r\n         * - user sign-in: First time the callback is invoked, `user`, `profile` and `account` will be present.\r\n         * - user sign-up: a user is created for the first time in the database (when {@link AuthConfig.session}.strategy is set to `\"database\"`)\r\n         * - update event: Triggered by the `useSession().update` method.\r\n         * In case of the latter, `trigger` will be `undefined`.\r\n         */\r\n        trigger?: 'signIn' | 'signUp' | 'update';\r\n        /** @deprecated use `trigger === \"signUp\"` instead */\r\n        isNewUser?: boolean;\r\n        /**\r\n         * When using {@link AuthConfig.session} `strategy: \"jwt\"`, this is the data\r\n         * sent from the client via the `useSession().update` method.\r\n         *\r\n         * ⚠ Note, you should validate this data before using it.\r\n         */\r\n        // Using any for library compatibility\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        session?: any;\r\n      }) => Awaitable<JWT | null>;\r\n    };\r\n    redirect: {\r\n      redirect: (params: { url: string; baseUrl: string }) => Awaitable<string>;\r\n    };\r\n  };\r\n};\r\n\r\nconst dynamicImports: DynamicImports = {\r\n  auth: {},\r\n} as DynamicImports;\r\n\r\nconst providers: Provider[] = [...setupKeyCloakProvider()];\r\n\r\nexport const providerMap = providers.map((provider) => {\r\n  if (typeof provider === 'function') {\r\n    const providerData = provider();\r\n    return { id: providerData.id, name: providerData.name };\r\n  }\r\n  return { id: provider.id, name: provider.name };\r\n});\r\n\r\nexport const { handlers, auth, signIn, signOut } = NextAuth(\r\n  async (): Promise<NextAuthConfig> => {\r\n    // Added NextAuthConfig return type\r\n    let adapter: Adapter | undefined;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    let signInImpl: any;\r\n\r\n    // Skip database adapter during build process, on edge, or client-side (which should never happen)\r\n    if (\r\n      process.env.NEXT_RUNTIME === 'nodejs' &&\r\n      typeof window === 'undefined' &&\r\n      !isRunningOnEdge() &&\r\n      process.env.NEXT_PHASE !== 'phase-production-build'\r\n    ) {\r\n      if (!dynamicImports.drizzleAdapter) {\r\n        dynamicImports.drizzleAdapter = await import(\r\n          '@/lib/auth/drizzle-adapter'\r\n        );\r\n      }\r\n      if (!dynamicImports.auth.signIn) {\r\n        dynamicImports.auth.signIn = await import('@/lib/auth/sign-in');\r\n      }\r\n      const {\r\n        auth: {\r\n          signIn: { signIn },\r\n        },\r\n        drizzleAdapter: { setupDrizzleAdapter },\r\n      } = dynamicImports;\r\n      adapter = await setupDrizzleAdapter();\r\n      // Custom signIn implementation to handle authentication callbacks\r\n      signInImpl = signIn;\r\n    } else {\r\n      adapter = undefined; // No adapter for edge runtime, client, or build\r\n      signInImpl = async () => {\r\n        logEvent('signIn');\r\n        return false;\r\n      };\r\n    }\r\n    if (!dynamicImports.auth.session) {\r\n      dynamicImports.auth.session = await import('@/lib/auth/session');\r\n      if (!dynamicImports.auth.session.session) {\r\n        throw new Error('Failed to load session callback');\r\n      }\r\n    }\r\n    const session = dynamicImports.auth.session.session;\r\n    if (!dynamicImports.auth.jwt) {\r\n      dynamicImports.auth.jwt = await import('@/lib/auth/jwt');\r\n      if (!dynamicImports.auth.jwt.jwt) {\r\n        throw new Error('Failed to load jwt callback');\r\n      }\r\n    }\r\n    const jwt = dynamicImports.auth.jwt.jwt;\r\n    if (!dynamicImports.auth.redirect) {\r\n      dynamicImports.auth.redirect = await import('@/lib/auth/redirect');\r\n      if (!dynamicImports.auth.redirect.redirect) {\r\n        throw new Error('Failed to load redirect callback');\r\n      }\r\n    }\r\n    const redirect = dynamicImports.auth.redirect.redirect;\r\n    return {\r\n      adapter,\r\n      callbacks: {\r\n        authorized,\r\n        signIn: signInImpl,\r\n        jwt,\r\n        session,\r\n        redirect,\r\n      },\r\n      providers,\r\n      pages: {\r\n        signIn: '/auth/signin',\r\n      },\r\n      session: { strategy: 'jwt' },\r\n      theme: {\r\n        colorScheme: 'auto', // 'auto' for system preference, 'light' or 'dark'\r\n        logo: '/static/logo/logo-dark.png',\r\n        brandColor: '#1898a8', // Custom brand color\r\n      },\r\n    };\r\n  },\r\n);\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\ai\\chat-panel\\chat-menu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\ai\\chat-panel\\chat-message.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\ai\\chat-panel\\chat-panel-context.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":29,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { createContext, useContext } from 'react';\r\nimport { ChatPanelContextValue } from './types';\r\n\r\n/**\r\n * Create the context\r\n */\r\nexport const ChatPanelContext = createContext<ChatPanelContextValue | null>(\r\n  null,\r\n);\r\n\r\n/**\r\n * Hook to use the chat panel context\r\n */\r\nexport const useChatPanelContext = ({\r\n  required = true,\r\n}: { required?: boolean } = {}): ChatPanelContextValue => {\r\n  const context = useContext(ChatPanelContext);\r\n  if (!context && required) {\r\n    throw new Error(\r\n      'useChatPanelContext must be used within a ChatPanelProvider',\r\n    );\r\n  }\r\n  return context as unknown as ChatPanelContextValue;\r\n};\r\n\r\nexport { default as ChatPanelProvider } from './chat-panel-provider';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\ai\\chat-panel\\chat-panel-layout.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":85,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React from 'react';\r\nimport { Box, styled } from '@mui/material';\r\nimport { useChatPanelContext } from './chat-panel-context';\r\n\r\n/**\r\n * Props for the ChatPanelLayout component\r\n */\r\nexport interface ChatPanelLayoutProps {\r\n  children: React.ReactNode;\r\n}\r\n\r\n/**\r\n * Styled component that adjusts layout based on chat panel state\r\n */\r\nconst LayoutContainer = styled(Box, {\r\n  shouldForwardProp: (prop) => !['chatPanelPosition', 'chatPanelSize', 'isDashboardLayout'].includes(prop as string)\r\n})<{ \r\n  chatPanelPosition: string;\r\n  chatPanelSize: number;\r\n}>(({ chatPanelPosition, chatPanelSize }) => {\r\n  const baseStyles = {\r\n    width: '100%',\r\n    height: '100%',\r\n    transition: 'all 0.3s ease-in-out',\r\n  };\r\n\r\n\r\n\r\n  // For regular layouts, use viewport-based adjustments\r\n  switch (chatPanelPosition) {\r\n    case 'left':\r\n      return {\r\n        ...baseStyles,\r\n        width: `calc(100vw - ${chatPanelSize}px)`,\r\n        marginLeft: `${chatPanelSize}px`,\r\n      };\r\n    case 'right':\r\n      return {\r\n        ...baseStyles,\r\n        width: `calc(100vw - ${chatPanelSize}px)`,\r\n        marginRight: `${chatPanelSize}px`,\r\n      };\r\n    case 'top':\r\n      return {\r\n        ...baseStyles,\r\n        height: `calc(100vh - ${chatPanelSize}px)`,\r\n        marginTop: `${chatPanelSize}px`,\r\n      };\r\n    case 'bottom':\r\n      return {\r\n        ...baseStyles,\r\n        height: `calc(100vh - ${chatPanelSize}px)`,\r\n        marginBottom: `${chatPanelSize}px`,\r\n      };\r\n    default:\r\n      return baseStyles;\r\n  }\r\n});\r\n\r\n/**\r\n * Layout component that automatically adjusts spacing based on chat panel state\r\n */\r\nexport const ChatPanelLayout: React.FC<ChatPanelLayoutProps> = ({ \r\n  children, \r\n}) => {\r\n  \r\n  const { config, setDockPanel } = useChatPanelContext();\r\n  \r\n  // Only apply spacing adjustments for docked positions\r\n  const isDocked = config.position !== 'inline' && config.position !== 'floating';\r\n  const chatPanelSize = isDocked ? (config.dockSize || 300) : 0;\r\n\r\n  return (\r\n    <LayoutContainer      \r\n      ref={(node) => setDockPanel(node as HTMLDivElement)}\r\n      chatPanelPosition={config.position}\r\n      chatPanelSize={chatPanelSize}\r\n    >\r\n      {children}\r\n    </LayoutContainer>\r\n  );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\ai\\chat-panel\\chat-panel-provider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\ai\\chat-panel\\chat-panel-retry-stats.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\ai\\chat-panel\\chat-panel.tsx","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'onDock' is assigned a value but never used.","line":393,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":393,"endColumn":15,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\ai\\chat-panel\\chat-window.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\ai\\chat-panel\\docked-panel.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":281,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { useCallback, useState, useRef, useEffect } from 'react';\r\nimport { Box, IconButton, Paper, styled } from '@mui/material';\r\nimport { Resizable } from 'react-resizable';\r\nimport CloseIcon from '@mui/icons-material/Close';\r\nimport OpenInFullIcon from '@mui/icons-material/OpenInFull';\r\nimport { useChatPanelContext } from './chat-panel-context';\r\nimport type { DockPosition } from './types';\r\n\r\n/**\r\n * Props for the DockedPanel component\r\n */\r\nexport interface DockedPanelProps {\r\n  children: React.ReactNode;\r\n  position: DockPosition;\r\n  onUndock: () => void;\r\n  onFloat: () => void;\r\n  title?: string;\r\n}\r\n\r\n/**\r\n * Styled components\r\n */\r\nconst DockedContainer = styled(Paper, {\r\n  shouldForwardProp: (prop) => !['dockPosition'].includes(prop as string)\r\n})<{ dockPosition: DockPosition }>(({ theme, dockPosition }) => {\r\n  const baseStyles = {\r\n    position: 'fixed' as const,\r\n    zIndex: theme.zIndex.drawer,\r\n    backgroundColor: theme.palette.background.paper,\r\n    borderRadius: 0,\r\n    boxShadow: theme.shadows[8],\r\n    display: 'flex',\r\n    flexDirection: 'column' as const,\r\n  };\r\n\r\n  // Position-specific styles  \r\n  // Account for header height (approximately 64px for MUI AppBar)\r\n  const headerHeight = 64;\r\n  \r\n  switch (dockPosition) {\r\n    case 'top':\r\n      return {\r\n        ...baseStyles,\r\n        top: headerHeight,\r\n        left: 0,\r\n        right: 0,\r\n        maxHeight: `calc(50vh - ${headerHeight}px)`, // Constrain height accounting for header\r\n        borderBottom: `1px solid ${theme.palette.divider}`,\r\n      };\r\n    case 'bottom':\r\n      return {\r\n        ...baseStyles,\r\n        bottom: 0,\r\n        left: 0,\r\n        right: 0,\r\n        maxHeight: '50vh', // Constrain height to half viewport\r\n        borderTop: `1px solid ${theme.palette.divider}`,\r\n      };\r\n    case 'left':\r\n      return {\r\n        ...baseStyles,\r\n        top: headerHeight,\r\n        left: 0,\r\n        bottom: 0,\r\n        borderRight: `1px solid ${theme.palette.divider}`,\r\n      };\r\n    case 'right':\r\n      return {\r\n        ...baseStyles,\r\n        top: headerHeight,\r\n        right: 0,\r\n        bottom: 0,\r\n        borderLeft: `1px solid ${theme.palette.divider}`,\r\n      };\r\n    case 'top-left':\r\n      return {\r\n        ...baseStyles,\r\n        top: headerHeight,\r\n        left: 0,\r\n        borderBottom: `1px solid ${theme.palette.divider}`,\r\n        borderRight: `1px solid ${theme.palette.divider}`,\r\n      };\r\n    case 'top-right':\r\n      return {\r\n        ...baseStyles,\r\n        top: headerHeight,\r\n        right: 0,\r\n        borderBottom: `1px solid ${theme.palette.divider}`,\r\n        borderLeft: `1px solid ${theme.palette.divider}`,\r\n      };\r\n    case 'bottom-left':\r\n      return {\r\n        ...baseStyles,\r\n        bottom: 0,\r\n        left: 0,\r\n        borderTop: `1px solid ${theme.palette.divider}`,\r\n        borderRight: `1px solid ${theme.palette.divider}`,\r\n      };\r\n    case 'bottom-right':\r\n      return {\r\n        ...baseStyles,\r\n        bottom: 0,\r\n        right: 0,\r\n        borderTop: `1px solid ${theme.palette.divider}`,\r\n        borderLeft: `1px solid ${theme.palette.divider}`,\r\n      };\r\n    default:\r\n      return baseStyles;\r\n  }\r\n});\r\n\r\nconst DockedHeader = styled(Box)(({ theme }) => ({\r\n  display: 'flex',\r\n  alignItems: 'center',\r\n  justifyContent: 'space-between',\r\n  padding: theme.spacing(1, 2),\r\n  backgroundColor: theme.palette.grey[100],\r\n  borderBottom: `1px solid ${theme.palette.divider}`,\r\n  minHeight: 40,\r\n  '&:hover': {\r\n    backgroundColor: theme.palette.grey[200],\r\n  },\r\n}));\r\n\r\nconst DockedContent = styled(Box)({\r\n  flex: 1,\r\n  overflow: 'auto', // Allow scrolling within the docked panel\r\n  display: 'flex',\r\n  flexDirection: 'column',\r\n  minHeight: 0, // Ensure flex shrinking works properly\r\n});\r\n\r\nconst HeaderControls = styled(Box)({\r\n  display: 'flex',\r\n  alignItems: 'center',\r\n  gap: 4,\r\n});\r\n\r\n/**\r\n * Get resize handles based on dock position\r\n */\r\nconst getResizeHandles = (position: DockPosition): string => {\r\n  switch (position) {\r\n    case 'top':\r\n      return 's'; // bottom handle\r\n    case 'bottom':\r\n      return 'n'; // top handle\r\n    case 'left':\r\n      return 'e'; // right handle\r\n    case 'right':\r\n      return 'w'; // left handle\r\n    case 'top-left':\r\n      return 'se'; // bottom-right handle\r\n    case 'top-right':\r\n      return 'sw'; // bottom-left handle\r\n    case 'bottom-left':\r\n      return 'ne'; // top-right handle\r\n    case 'bottom-right':\r\n      return 'nw'; // top-left handle\r\n    default:\r\n      return '';\r\n  }\r\n};\r\n\r\n/**\r\n * Get initial size based on dock position\r\n */\r\nconst getInitialSize = (position: DockPosition, defaultSize: number) => {\r\n  const isVertical = ['left', 'right'].includes(position);\r\n  const isHorizontal = ['top', 'bottom'].includes(position);\r\n  \r\n  if (isVertical) {\r\n    return { width: defaultSize, height: window.innerHeight };\r\n  } else if (isHorizontal) {\r\n    return { width: window.innerWidth, height: defaultSize };\r\n  } else {\r\n    // Corner positions\r\n    return { width: defaultSize, height: defaultSize };\r\n  }\r\n};\r\n\r\n/**\r\n * DockedPanel component that handles docked chat panel positioning and resizing\r\n */\r\nexport const DockedPanel: React.FC<DockedPanelProps> = ({\r\n  children,\r\n  position,\r\n  onUndock,\r\n  onFloat,\r\n  title = 'Chat Panel',\r\n}) => {\r\n  const { config, setDockSize } = useChatPanelContext();\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n  \r\n  const [size, setSize] = useState(() => \r\n    getInitialSize(position, config.dockSize || 300)\r\n  );\r\n\r\n  // Update size when dock size changes\r\n  useEffect(() => {\r\n    setSize(getInitialSize(position, config.dockSize || 300));\r\n  }, [position, config.dockSize]);\r\n\r\n  // Handle resize\r\n  const handleResize = useCallback((event: React.SyntheticEvent, { size: newSize }: { size: { width: number; height: number } }) => {\r\n    setSize(newSize);\r\n    \r\n    // Update dock size in context based on position\r\n    let dockSize: number;\r\n    if (['left', 'right'].includes(position)) {\r\n      dockSize = newSize.width;\r\n    } else if (['top', 'bottom'].includes(position)) {\r\n      dockSize = newSize.height;\r\n    } else {\r\n      // Corner positions - use the larger dimension\r\n      dockSize = Math.max(newSize.width, newSize.height);\r\n    }\r\n    \r\n    setDockSize(dockSize);\r\n  }, [position, setDockSize]);\r\n\r\n  // Get resize handles for this position\r\n  const resizeHandles = getResizeHandles(position);\r\n\r\n  // Create resizable constraints\r\n  const minConstraints: [number, number] = [200, 150];\r\n  const maxConstraints: [number, number] = [\r\n    window.innerWidth * 0.8,\r\n    window.innerHeight * 0.8\r\n  ];\r\n\r\n  return (\r\n    <Resizable\r\n      width={size.width}\r\n      height={size.height}\r\n      onResize={handleResize}\r\n      resizeHandles={resizeHandles.split('') as Array<'s' | 'w' | 'e' | 'n' | 'sw' | 'nw' | 'se' | 'ne'>}\r\n      minConstraints={minConstraints}\r\n      maxConstraints={maxConstraints}\r\n    >\r\n      <DockedContainer\r\n        ref={containerRef}\r\n        dockPosition={position}\r\n        style={{\r\n          width: size.width,\r\n          height: size.height,\r\n        }}\r\n      >\r\n        <DockedHeader>\r\n          <Box sx={{ fontWeight: 'medium', fontSize: '0.875rem' }}>\r\n            {title}\r\n          </Box>\r\n          <HeaderControls>\r\n            <IconButton\r\n              size=\"small\"\r\n              onClick={onFloat}\r\n              aria-label=\"Float panel\"\r\n              sx={{ padding: '2px' }}\r\n            >\r\n              <OpenInFullIcon fontSize=\"small\" />\r\n            </IconButton>\r\n            <IconButton\r\n              size=\"small\"\r\n              onClick={onUndock}\r\n              aria-label=\"Close panel\"\r\n              sx={{ padding: '2px' }}\r\n            >\r\n              <CloseIcon fontSize=\"small\" />\r\n            </IconButton>\r\n          </HeaderControls>\r\n        </DockedHeader>\r\n        <DockedContent>\r\n          {children}\r\n        </DockedContent>\r\n      </DockedContainer>\r\n    </Resizable>\r\n  );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\ai\\chat-panel\\docking-overlay.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":250,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { useState, useCallback, useRef, useEffect } from 'react';\r\nimport { Box, styled } from '@mui/material';\r\nimport type { DockPosition } from './types';\r\n\r\n/**\r\n * Docking zone data\r\n */\r\nexport interface DockZone {\r\n  position: DockPosition;\r\n  rect: DOMRect;\r\n  element: HTMLElement;\r\n}\r\n\r\n/**\r\n * Props for the DockingOverlay component\r\n */\r\nexport interface DockingOverlayProps {\r\n  isActive: boolean;\r\n  onDock: (position: DockPosition) => void;\r\n  isDashboardLayout?: boolean;\r\n}\r\n\r\n/**\r\n * Styled components for docking zones\r\n */\r\nconst DockZoneOverlay = styled(Box, {\r\n  shouldForwardProp: (prop) => prop !== 'isHighlighted'\r\n})<{ isHighlighted: boolean }>(({ theme, isHighlighted }) => ({\r\n  position: 'fixed',\r\n  backgroundColor: isHighlighted \r\n    ? theme.palette.primary.main \r\n    : 'transparent',\r\n  border: `2px dashed ${theme.palette.primary.main}`,\r\n  opacity: isHighlighted ? 0.7 : 0.3,\r\n  transition: 'all 0.2s ease-in-out',\r\n  pointerEvents: 'none',\r\n  zIndex: theme.zIndex.tooltip,\r\n  display: 'flex',\r\n  alignItems: 'center',\r\n  justifyContent: 'center',\r\n  color: theme.palette.primary.contrastText,\r\n  fontWeight: 'bold',\r\n  fontSize: '0.875rem',\r\n}));\r\n\r\n/**\r\n * Zone labels for display\r\n */\r\nconst ZONE_LABELS = {\r\n  top: 'Dock Top',\r\n  bottom: 'Dock Bottom', \r\n  left: 'Dock Left',\r\n  right: 'Dock Right',\r\n  'top-left': 'Top Left',\r\n  'top-right': 'Top Right',\r\n  'bottom-left': 'Bottom Left',\r\n  'bottom-right': 'Bottom Right',\r\n} as const;\r\n\r\n/**\r\n * Get docking zone rect based on current window dimensions\r\n */\r\nconst getDockZoneRect = (zoneName: keyof typeof ZONE_LABELS, windowWidth: number, windowHeight: number) => {\r\n  switch (zoneName) {\r\n    case 'top':\r\n      return { left: 0, top: 0, width: windowWidth, height: 100 };\r\n    case 'bottom':\r\n      return { left: 0, top: windowHeight - 100, width: windowWidth, height: 100 };\r\n    case 'left':\r\n      return { left: 0, top: 100, width: 100, height: windowHeight - 200 };\r\n    case 'right':\r\n      return { left: windowWidth - 100, top: 100, width: 100, height: windowHeight - 200 };\r\n    case 'top-left':\r\n      return { left: 0, top: 0, width: 100, height: 100 };\r\n    case 'top-right':\r\n      return { left: windowWidth - 100, top: 0, width: 100, height: 100 };\r\n    case 'bottom-left':\r\n      return { left: 0, top: windowHeight - 100, width: 100, height: 100 };\r\n    case 'bottom-right':\r\n      return { left: windowWidth - 100, top: windowHeight - 100, width: 100, height: 100 };\r\n    default:\r\n      return { left: 0, top: 0, width: 0, height: 0 };\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Calculate zone bounds for dashboard layout\r\n */\r\nconst getDashboardZoneBounds = (zone: { getRect: () => { left: number; top: number; width: number; height: number }, label: string }, dashboardRect: DOMRect) => {\r\n  const rect = zone.getRect();\r\n  \r\n  // For dashboard layout, adjust zones to be relative to dashboard container\r\n  return {\r\n    left: Math.max(rect.left, dashboardRect.left),\r\n    top: Math.max(rect.top, dashboardRect.top),\r\n    width: Math.min(rect.width, dashboardRect.width),\r\n    height: Math.min(rect.height, dashboardRect.height),\r\n  };\r\n};\r\n\r\n/**\r\n * DockingOverlay component that shows docking zones during drag operations\r\n */\r\nexport const DockingOverlay: React.FC<DockingOverlayProps> = ({ \r\n  isActive, \r\n  onDock, \r\n  isDashboardLayout = false \r\n}) => {\r\n  const [highlightedZone, setHighlightedZone] = useState<DockPosition | null>(null);\r\n  const [windowDimensions, setWindowDimensions] = useState({ width: 0, height: 0 });\r\n  const dashboardRef = useRef<HTMLElement | null>(null);\r\n\r\n  // Update window dimensions\r\n  useEffect(() => {\r\n    const updateDimensions = () => {\r\n      setWindowDimensions({ width: window.innerWidth, height: window.innerHeight });\r\n    };\r\n    \r\n    updateDimensions();\r\n    window.addEventListener('resize', updateDimensions);\r\n    \r\n    return () => {\r\n      window.removeEventListener('resize', updateDimensions);\r\n    };\r\n  }, []);\r\n\r\n  // Find dashboard container when in dashboard layout\r\n  useEffect(() => {\r\n    if (isDashboardLayout) {\r\n      // Look for the dashboard container - adjust selector as needed\r\n      const dashboard = document.querySelector('[role=\"main\"]') as HTMLElement ||\r\n                       document.querySelector('.MuiContainer-root') as HTMLElement ||\r\n                       document.body;\r\n      dashboardRef.current = dashboard;\r\n    }\r\n  }, [isDashboardLayout]);\r\n\r\n  // Handle mouse movement to determine highlighted zone\r\n  const handleMouseMove = useCallback((event: MouseEvent) => {\r\n    if (!isActive || windowDimensions.width === 0 || windowDimensions.height === 0) return;\r\n\r\n    const { clientX: x, clientY: y } = event;\r\n\r\n    // Check which zone the mouse is in\r\n    let foundZone: DockPosition | null = null;\r\n    \r\n    for (const zoneName of Object.keys(ZONE_LABELS) as Array<keyof typeof ZONE_LABELS>) {\r\n      let rect;\r\n      if (isDashboardLayout && dashboardRef.current) {\r\n        const baseRect = getDockZoneRect(zoneName, windowDimensions.width, windowDimensions.height);\r\n        rect = getDashboardZoneBounds({ getRect: () => baseRect, label: ZONE_LABELS[zoneName] }, dashboardRef.current.getBoundingClientRect());\r\n      } else {\r\n        rect = getDockZoneRect(zoneName, windowDimensions.width, windowDimensions.height);\r\n      }\r\n        \r\n      if (x >= rect.left && x <= rect.left + rect.width && y >= rect.top && y <= rect.top + rect.height) {\r\n        foundZone = zoneName as DockPosition;\r\n        break;\r\n      }\r\n    }\r\n\r\n    setHighlightedZone(foundZone);\r\n  }, [isActive, isDashboardLayout, windowDimensions.width, windowDimensions.height]);\r\n\r\n  // Handle mouse up to trigger docking\r\n  const handleMouseUp = useCallback(() => {\r\n    if (highlightedZone && highlightedZone !== 'inline' && highlightedZone !== 'floating') {\r\n      onDock(highlightedZone);\r\n    }\r\n    setHighlightedZone(null);\r\n  }, [highlightedZone, onDock]);\r\n\r\n  // Add/remove event listeners\r\n  useEffect(() => {\r\n    if (!isActive) {\r\n      setHighlightedZone(null);\r\n      return;\r\n    }\r\n\r\n    document.addEventListener('mousemove', handleMouseMove);\r\n    document.addEventListener('mouseup', handleMouseUp);\r\n\r\n    return () => {\r\n      document.removeEventListener('mousemove', handleMouseMove);\r\n      document.removeEventListener('mouseup', handleMouseUp);\r\n    };\r\n  }, [isActive, handleMouseMove, handleMouseUp]);\r\n\r\n  if (!isActive) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <>\r\n      {Object.keys(ZONE_LABELS).map((zoneName) => {\r\n        const dockPosition = zoneName as keyof typeof ZONE_LABELS;\r\n        const isHighlighted = highlightedZone === dockPosition;\r\n        \r\n        // Calculate final zone bounds\r\n        let rect;\r\n        if (isDashboardLayout && dashboardRef.current) {\r\n          const baseRect = getDockZoneRect(dockPosition, windowDimensions.width, windowDimensions.height);\r\n          rect = getDashboardZoneBounds({ getRect: () => baseRect, label: ZONE_LABELS[dockPosition] }, dashboardRef.current.getBoundingClientRect());\r\n        } else {\r\n          rect = getDockZoneRect(dockPosition, windowDimensions.width, windowDimensions.height);\r\n        }\r\n\r\n        return (\r\n          <DockZoneOverlay\r\n            key={zoneName}\r\n            isHighlighted={isHighlighted}\r\n            sx={{\r\n              left: rect.left,\r\n              top: rect.top,\r\n              width: rect.width,\r\n              height: rect.height,\r\n            }}\r\n          >\r\n            {isHighlighted && ZONE_LABELS[dockPosition]}\r\n          </DockZoneOverlay>\r\n        );\r\n      })}\r\n    </>\r\n  );\r\n};\r\n\r\n/**\r\n * Hook to use docking functionality\r\n */\r\nexport const useDocking = () => {\r\n  const [isDragging, setIsDragging] = useState(false);\r\n\r\n  const startDragging = useCallback(() => {\r\n    setIsDragging(true);\r\n  }, []);\r\n\r\n  const stopDragging = useCallback(() => {\r\n    setIsDragging(false);\r\n  }, []);\r\n\r\n  return {\r\n    isDragging,\r\n    startDragging,\r\n    stopDragging,\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\ai\\chat-panel\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\ai\\chat-panel\\tool-invocation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\ai\\chat-panel\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":84,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Dispatch, SetStateAction } from 'react';\r\n\r\n/**\r\n * Available AI providers\r\n */\r\nexport type AiProvider = 'azure' | 'google' | 'openai';\r\n\r\n/**\r\n * Model types available across providers\r\n */\r\nexport type ModelType = 'lofi' | 'hifi' | 'reasoning-medium' | 'reasoning-high';\r\n\r\n/**\r\n * Provider configuration with display name and available models\r\n */\r\nexport interface ProviderConfig {\r\n  id: AiProvider;\r\n  displayName: string;\r\n  models: Array<{\r\n    id: ModelType;\r\n    displayName: string;\r\n    available: boolean;\r\n  }>;\r\n}\r\n\r\n/**\r\n * Combined model selection state\r\n */\r\nexport interface ModelSelection {\r\n  provider: AiProvider;\r\n  model: ModelType;\r\n}\r\n\r\n/**\r\n * Chat panel docking positions\r\n */\r\nexport type DockPosition =\r\n  | 'inline' // Default inline position\r\n  | 'floating' // Floating dialog\r\n  | 'top' // Docked to top edge\r\n  | 'bottom' // Docked to bottom edge\r\n  | 'left' // Docked to left edge\r\n  | 'right' // Docked to right edge\r\n  | 'top-left' // Docked to top-left corner\r\n  | 'top-right' // Docked to top-right corner\r\n  | 'bottom-left' // Docked to bottom-left corner\r\n  | 'bottom-right'; // Docked to bottom-right corner\r\n\r\n/**\r\n * Chat panel configuration interface\r\n */\r\nexport interface ChatPanelConfig {\r\n  position: DockPosition;\r\n  size: {\r\n    width: number;\r\n    height: number;\r\n  };\r\n  // For docked panels, this represents the panel size along the docked edge\r\n  dockSize?: number;\r\n}\r\n\r\nexport type Size = ChatPanelConfig['size'];\r\n\r\n/**\r\n * Context value interface\r\n */\r\nexport interface ChatPanelContextValue {\r\n  config: ChatPanelConfig;\r\n  setPosition: (position: SetStateAction<DockPosition>) => void;\r\n  setSize: (width: number, height: number) => void;\r\n  setDockSize: (size: SetStateAction<number | undefined>) => void;\r\n  setFloating: (isFloating: SetStateAction<boolean>) => void;\r\n  setCaseFileId: Dispatch<SetStateAction<string | null>>;\r\n  isDocked: boolean;\r\n  isFloating: boolean;\r\n  isInline: boolean;\r\n  caseFileId: string | null; // ID of the active case file, if any\r\n  debounced: {\r\n    setSize: (width: number, height: number) => Promise<void>;\r\n  };\r\n  dockPanel: HTMLDivElement | null;\r\n  setDockPanel: (panel: HTMLDivElement | null) => void;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\ai\\model-context\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\ai\\timeline-agent\\index.tsx","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":123,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":123,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3013,3016],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3013,3016],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":125,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3108,3111],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3108,3111],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\auth\\key-refresh-notify\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\auth\\key-refresh-notify\\key-refresh-notify.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\auth\\key-refresh-notify\\wrapper.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\auth\\session-provider\\hooks.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":17,"endColumn":3}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useContext } from \"react\";\r\nimport { SessionContext } from \"./provider\";\r\nimport { type SessionContextType } from \"./types\";\r\n\r\n/**\r\n * Hook to access session context\r\n * \r\n * This hook provides read-only access to session state managed by SessionProvider.\r\n * All session management logic (polling, key validation, etc.) is handled by the provider.\r\n */\r\nexport const useSession = <TSessionData extends object>(): SessionContextType<TSessionData> => {\r\n  const session = useContext(SessionContext);\r\n  if (!session) {\r\n    throw new Error(\"useSession must be used within a SessionProvider\");\r\n  }\r\n  return session as SessionContextType<TSessionData>;\r\n};","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\auth\\session-provider\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\auth\\session-provider\\provider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\auth\\session-provider\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":27,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ValidKeyValidationStatusValues } from './values';\r\n\r\n/**\r\n * Key validation states for user session\r\n */\r\nexport type KeyValidationStatus = typeof ValidKeyValidationStatusValues[number]\r\n\r\nexport type SessionResponse<TSessionData extends object> = {\r\n  status: 'authenticated' | 'unauthenticated';\r\n  data: TSessionData | null;\r\n  publicKeys?: string[];\r\n};\r\n\r\nexport type SessionContextType<TSessionData extends object> = {\r\n  status: 'loading' | 'authenticated' | 'unauthenticated';\r\n  data: TSessionData | null;\r\n  isFetching: boolean;\r\n  refetch: () => void;\r\n  publicKeys?: string[];\r\n  keyValidation: {\r\n    status: KeyValidationStatus;\r\n    lastValidated?: Date;\r\n    error?: string;\r\n  };\r\n};\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\auth\\session-provider\\values.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\chat\\chat-export-menu.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":8,"column":1,"nodeType":"Program","endLine":131,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Chat Export Menu Component\r\n *\r\n * Provides export functionality for selected chat messages\r\n * Similar to the existing email-property-toolbar export pattern\r\n */\r\n\r\n'use client';\r\n\r\nimport React, { useRef, useState, useMemo } from 'react';\r\nimport Tooltip from '@mui/material/Tooltip';\r\nimport Menu from '@mui/material/Menu';\r\nimport MenuItem from '@mui/material/MenuItem';\r\nimport IconButton from '@mui/material/IconButton';\r\nimport FileDownloadIcon from '@mui/icons-material/FileDownload';\r\nimport {\r\n  exportToCsv,\r\n  exportToMarkdown,\r\n  type SelectedChatItem,\r\n} from '../../lib/ai/chat/export';\r\nimport type { ChatTurn } from '@/lib/ai/chat/types';\r\n\r\ninterface ChatExportMenuProps {\r\n  turns: ChatTurn[];\r\n  selectedItems: SelectedChatItem[];\r\n  chatTitle?: string;\r\n  chatCreatedAt?: string;\r\n  disabled?: boolean;\r\n}\r\n\r\nconst stableOrigin = {\r\n  bottomRight: { vertical: 'bottom', horizontal: 'right' } as const,\r\n  topRight: { vertical: 'top', horizontal: 'right' } as const,\r\n};\r\n\r\nexport const ChatExportMenu: React.FC<ChatExportMenuProps> = ({\r\n  turns,\r\n  selectedItems,\r\n  chatTitle,\r\n  chatCreatedAt,\r\n  disabled = false,\r\n}) => {\r\n  const [exportMenuOpen, setExportMenuOpen] = useState(false);\r\n  const exportMenuTriggerRef = useRef<HTMLButtonElement>(null);\r\n\r\n  const { onSetExportMenuOpen, onSetExportMenuClosed } = useMemo(() => {\r\n    const onSetExportMenuOpen = () => {\r\n      if (!exportMenuOpen) {\r\n        setExportMenuOpen(true);\r\n      }\r\n    };\r\n    const onSetExportMenuClosed = () => {\r\n      if (exportMenuOpen) {\r\n        setExportMenuOpen(false);\r\n      }\r\n    };\r\n    return {\r\n      onSetExportMenuOpen,\r\n      onSetExportMenuClosed,\r\n    };\r\n  }, [exportMenuOpen]);\r\n\r\n  const handleExportCsv = () => {\r\n    try {\r\n      exportToCsv(turns, selectedItems, chatTitle);\r\n      onSetExportMenuClosed();\r\n    } catch (error) {\r\n      console.error('Failed to export CSV:', error);\r\n      // In a real app, you'd want to show a proper error message to the user\r\n      alert(error instanceof Error ? error.message : 'Failed to export CSV');\r\n    }\r\n  };\r\n\r\n  const handleExportMarkdown = () => {\r\n    try {\r\n      exportToMarkdown(turns, selectedItems, chatTitle, chatCreatedAt);\r\n      onSetExportMenuClosed();\r\n    } catch (error) {\r\n      console.error('Failed to export Markdown:', error);\r\n      // In a real app, you'd want to show a proper error message to the user\r\n      alert(\r\n        error instanceof Error ? error.message : 'Failed to export Markdown',\r\n      );\r\n    }\r\n  };\r\n\r\n  const hasSelection = selectedItems.length > 0;\r\n\r\n  return (\r\n    <>\r\n      <Tooltip\r\n        title={\r\n          hasSelection\r\n            ? 'Export selected messages'\r\n            : 'Select messages to export'\r\n        }\r\n      >\r\n        <span>\r\n          <IconButton\r\n            ref={exportMenuTriggerRef}\r\n            id=\"chat-export-menu-trigger\"\r\n            aria-controls=\"chat-export-menu\"\r\n            aria-haspopup=\"true\"\r\n            aria-expanded={exportMenuOpen ? 'true' : undefined}\r\n            onClick={onSetExportMenuOpen}\r\n            disabled={disabled || !hasSelection}\r\n          >\r\n            <FileDownloadIcon fontSize=\"small\" />\r\n          </IconButton>\r\n        </span>\r\n      </Tooltip>\r\n      <Menu\r\n        id=\"chat-export-menu\"\r\n        anchorEl={exportMenuTriggerRef.current}\r\n        open={exportMenuOpen}\r\n        onClose={onSetExportMenuClosed}\r\n        anchorOrigin={stableOrigin.bottomRight}\r\n        transformOrigin={stableOrigin.topRight}\r\n        sx={{\r\n          '& .MuiPaper-root': {\r\n            minWidth: 180,\r\n          },\r\n        }}\r\n      >\r\n        <MenuItem onClick={handleExportCsv}>Export as CSV</MenuItem>\r\n        <MenuItem onClick={handleExportMarkdown}>Export as Markdown</MenuItem>\r\n      </Menu>\r\n    </>\r\n  );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\chat\\chat-message-display.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\chat\\chat-message-filters.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":12,"column":1,"nodeType":"Program","endLine":379,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module ChatMessageFilters\r\n * @fileoverview\r\n * Reusable component for message filtering in chat interfaces.\r\n *\r\n * Provides filtering by:\r\n * - Message type (user, assistant, system, tool)\r\n * - Content text search across all message fields\r\n *\r\n * Used by both global chat-level filtering and per-turn filtering.\r\n */\r\n'use client';\r\n\r\nimport * as React from 'react';\r\nimport {\r\n  Box,\r\n  Typography,\r\n  FormControlLabel,\r\n  Switch,\r\n  Button,\r\n  Badge,\r\n  Chip,\r\n  TextField,\r\n  InputAdornment,\r\n} from '@mui/material';\r\nimport { FilterList, Search } from '@mui/icons-material';\r\nimport type { ChatMessage } from '@/lib/ai/chat/types';\r\n\r\n// Available message types for filtering\r\nexport const MESSAGE_TYPES = ['user', 'assistant', 'system', 'tool'] as const;\r\nexport type MessageType = (typeof MESSAGE_TYPES)[number];\r\n\r\nexport interface ChatMessageFiltersProps {\r\n  // Data\r\n  messages: ChatMessage[];\r\n\r\n  // Filter state\r\n  enableFilters: boolean;\r\n  onEnableFiltersChange: (enabled: boolean) => void;\r\n  activeTypeFilters: Set<MessageType>;\r\n  onTypeFiltersChange: (filters: Set<MessageType>) => void;\r\n  contentFilter: string;\r\n  onContentFilterChange: (filter: string) => void;\r\n\r\n  // UI customization\r\n  title: string;\r\n  size?: 'small' | 'medium';\r\n  showStatusMessage?: boolean;\r\n}\r\n\r\n/**\r\n * Searches for text across all searchable fields in a message\r\n */\r\nexport const searchMessageContent = (\r\n  message: ChatMessage,\r\n  searchTerm: string,\r\n): boolean => {\r\n  if (!searchTerm.trim()) return true;\r\n\r\n  const searchLower = searchTerm.toLowerCase();\r\n\r\n  // Search in content fields\r\n  if (message.content && message.content.toLowerCase().includes(searchLower))\r\n    return true;\r\n  if (\r\n    message.optimizedContent &&\r\n    message.optimizedContent.toLowerCase().includes(searchLower)\r\n  )\r\n    return true;\r\n  if (message.toolName && message.toolName.toLowerCase().includes(searchLower))\r\n    return true;\r\n\r\n  // Search in structured data\r\n  if (message.functionCall) {\r\n    try {\r\n      const functionCallStr = JSON.stringify(\r\n        message.functionCall,\r\n      ).toLowerCase();\r\n      if (functionCallStr.includes(searchLower)) return true;\r\n    } catch {\r\n      // Ignore JSON stringify errors\r\n    }\r\n  }\r\n\r\n  if (message.toolResult) {\r\n    try {\r\n      const toolResultStr = JSON.stringify(message.toolResult).toLowerCase();\r\n      if (toolResultStr.includes(searchLower)) return true;\r\n    } catch {\r\n      // Ignore JSON stringify errors\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * Get available message types from the provided messages\r\n * Pure function for better performance\r\n */\r\nconst getAvailableMessageTypes = (messages: ChatMessage[]): MessageType[] => {\r\n  const typesInMessages = new Set<MessageType>();\r\n  messages.forEach((message) => {\r\n    if (MESSAGE_TYPES.includes(message.role as MessageType)) {\r\n      typesInMessages.add(message.role as MessageType);\r\n    }\r\n  });\r\n  return Array.from(typesInMessages).sort();\r\n};\r\n\r\nexport const ChatMessageFilters: React.FC<ChatMessageFiltersProps> = ({\r\n  messages,\r\n  enableFilters,\r\n  onEnableFiltersChange,\r\n  activeTypeFilters,\r\n  onTypeFiltersChange,\r\n  contentFilter,\r\n  onContentFilterChange,\r\n  title,\r\n  size = 'medium',\r\n  showStatusMessage = true,\r\n}) => {\r\n  // Memoize available message types computation\r\n  const availableTypes = React.useMemo(\r\n    () => getAvailableMessageTypes(messages),\r\n    [messages],\r\n  );\r\n\r\n  // Stable filter handling functions\r\n  const toggleFilter = React.useCallback(\r\n    (messageType: MessageType) => {\r\n      const newFilters = new Set(activeTypeFilters);\r\n      if (newFilters.has(messageType)) {\r\n        newFilters.delete(messageType);\r\n      } else {\r\n        newFilters.add(messageType);\r\n      }\r\n      onTypeFiltersChange(newFilters);\r\n    },\r\n    [activeTypeFilters, onTypeFiltersChange],\r\n  );\r\n\r\n  const clearAllFilters = React.useCallback(() => {\r\n    onTypeFiltersChange(new Set());\r\n    onContentFilterChange('');\r\n  }, [onTypeFiltersChange, onContentFilterChange]);\r\n\r\n  // Stable switch handler\r\n  const handleEnableFiltersChange = React.useCallback(\r\n    (e: React.ChangeEvent<HTMLInputElement>) => {\r\n      onEnableFiltersChange(e.target.checked);\r\n      if (!e.target.checked) {\r\n        clearAllFilters();\r\n      }\r\n    },\r\n    [onEnableFiltersChange, clearAllFilters],\r\n  );\r\n\r\n  // Stable content filter handler\r\n  const handleContentFilterChange = React.useCallback(\r\n    (e: React.ChangeEvent<HTMLInputElement>) => {\r\n      onContentFilterChange(e.target.value);\r\n    },\r\n    [onContentFilterChange],\r\n  );\r\n\r\n  // Pre-calculate size-dependent values\r\n  const isSmall = size === 'small';\r\n\r\n  // Memoize style objects to prevent re-creation\r\n  const containerSx = React.useMemo(\r\n    () => ({\r\n      display: 'flex',\r\n      alignItems: 'center',\r\n      gap: 2,\r\n      mb: isSmall ? 1 : 2,\r\n    }),\r\n    [isSmall],\r\n  );\r\n\r\n  const textFieldSx = React.useMemo(\r\n    () => ({\r\n      minWidth: 200,\r\n    }),\r\n    [],\r\n  );\r\n\r\n  const typesSectionSx = React.useMemo(\r\n    () => ({\r\n      display: 'flex',\r\n      flexWrap: 'wrap',\r\n      gap: 1,\r\n      alignItems: 'center',\r\n    }),\r\n    [],\r\n  );\r\n\r\n  const clearButtonSx = React.useMemo(\r\n    () => ({\r\n      ml: 1,\r\n      fontSize: isSmall ? '0.75rem' : '0.875rem',\r\n      py: isSmall ? 0.5 : undefined,\r\n    }),\r\n    [isSmall],\r\n  );\r\n\r\n  const statusMessageSx = React.useMemo(\r\n    () => ({\r\n      mt: isSmall ? 0.5 : 1,\r\n    }),\r\n    [isSmall],\r\n  );\r\n\r\n  // Memoize status message text\r\n  const statusMessage = React.useMemo(() => {\r\n    if (\r\n      !showStatusMessage ||\r\n      (activeTypeFilters.size === 0 && !contentFilter.trim())\r\n    ) {\r\n      return null;\r\n    }\r\n\r\n    if (contentFilter.trim() && activeTypeFilters.size > 0) {\r\n      return `Filtering by content \"${contentFilter}\" and ${activeTypeFilters.size} of ${availableTypes.length} message types`;\r\n    } else if (contentFilter.trim()) {\r\n      return `Filtering by content \"${contentFilter}\"`;\r\n    } else {\r\n      return `Showing ${activeTypeFilters.size} of ${availableTypes.length} message types`;\r\n    }\r\n  }, [\r\n    showStatusMessage,\r\n    activeTypeFilters.size,\r\n    contentFilter,\r\n    availableTypes.length,\r\n  ]);\r\n\r\n  return (\r\n    <Box sx={containerSx}>\r\n      <FilterList color=\"action\" fontSize={isSmall ? 'small' : 'medium'} />\r\n      <Typography\r\n        variant={isSmall ? 'body2' : 'h6'}\r\n        sx={{ fontWeight: isSmall ? 'medium' : 'normal' }}\r\n      >\r\n        {title}\r\n      </Typography>\r\n      <FormControlLabel\r\n        control={\r\n          <Switch\r\n            size={isSmall ? 'small' : 'medium'}\r\n            checked={enableFilters}\r\n            onChange={handleEnableFiltersChange}\r\n          />\r\n        }\r\n        label=\"Enable Filtering\"\r\n      />\r\n\r\n      {enableFilters && (\r\n        <>\r\n          {/* Content Filter Input */}\r\n          <TextField\r\n            size={isSmall ? 'small' : 'medium'}\r\n            placeholder=\"Search message content...\"\r\n            value={contentFilter}\r\n            onChange={handleContentFilterChange}\r\n            InputProps={{\r\n              startAdornment: (\r\n                <InputAdornment position=\"start\">\r\n                  <Search fontSize={isSmall ? 'small' : 'medium'} />\r\n                </InputAdornment>\r\n              ),\r\n            }}\r\n            sx={textFieldSx}\r\n          />\r\n\r\n          {/* Type Filter Badges */}\r\n          <Box sx={typesSectionSx}>\r\n            <Typography\r\n              variant=\"body2\"\r\n              color=\"text.secondary\"\r\n              sx={{ mr: 1, fontSize: isSmall ? '0.75rem' : '0.875rem' }}\r\n            >\r\n              Types:\r\n            </Typography>\r\n            {availableTypes.map((messageType) => {\r\n              const isActive = activeTypeFilters.has(messageType);\r\n              const messageCount = messages.filter(\r\n                (msg) => msg.role === messageType,\r\n              ).length;\r\n\r\n              return (\r\n                <MessageTypeBadge\r\n                  key={messageType}\r\n                  messageType={messageType}\r\n                  messageCount={messageCount}\r\n                  isActive={isActive}\r\n                  isSmall={isSmall}\r\n                  onToggle={toggleFilter}\r\n                />\r\n              );\r\n            })}\r\n\r\n            {(activeTypeFilters.size > 0 || contentFilter.trim()) && (\r\n              <Button\r\n                size=\"small\"\r\n                variant=\"outlined\"\r\n                onClick={clearAllFilters}\r\n                sx={clearButtonSx}\r\n              >\r\n                Clear All\r\n              </Button>\r\n            )}\r\n          </Box>\r\n\r\n          {statusMessage && (\r\n            <Box sx={statusMessageSx}>\r\n              <Typography\r\n                variant=\"body2\"\r\n                color=\"text.secondary\"\r\n                sx={{ fontSize: isSmall ? '0.75rem' : '0.875rem' }}\r\n              >\r\n                {statusMessage}\r\n              </Typography>\r\n            </Box>\r\n          )}\r\n        </>\r\n      )}\r\n    </Box>\r\n  );\r\n};\r\n\r\n// Separate memoized component for message type badges to prevent unnecessary re-renders\r\nconst MessageTypeBadge = React.memo<{\r\n  messageType: MessageType;\r\n  messageCount: number;\r\n  isActive: boolean;\r\n  isSmall: boolean;\r\n  onToggle: (messageType: MessageType) => void;\r\n}>(function MessageTypeBadge({\r\n  messageType,\r\n  messageCount,\r\n  isActive,\r\n  isSmall,\r\n  onToggle,\r\n}) {\r\n  const handleClick = React.useCallback(() => {\r\n    onToggle(messageType);\r\n  }, [messageType, onToggle]);\r\n\r\n  const badgeSx = React.useMemo(() => ({ cursor: 'pointer' }), []);\r\n\r\n  const chipSx = React.useMemo(\r\n    () => ({\r\n      textTransform: 'capitalize' as const,\r\n      '&:hover': {\r\n        backgroundColor: isActive ? 'primary.dark' : 'action.hover',\r\n      },\r\n    }),\r\n    [isActive],\r\n  );\r\n\r\n  return (\r\n    <Badge\r\n      badgeContent={messageCount}\r\n      color={isActive ? 'primary' : 'default'}\r\n      sx={badgeSx}\r\n      onClick={handleClick}\r\n    >\r\n      <Chip\r\n        label={messageType}\r\n        variant={isActive ? 'filled' : 'outlined'}\r\n        color={isActive ? 'primary' : 'default'}\r\n        size={isSmall ? 'small' : 'medium'}\r\n        onClick={handleClick}\r\n        sx={chipSx}\r\n      />\r\n    </Badge>\r\n  );\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\chat\\chat-turn-display.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":603,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { useState } from 'react';\r\nimport {\r\n  Box,\r\n  Typography,\r\n  Chip,\r\n  Card,\r\n  CardContent,\r\n  IconButton,\r\n  Collapse,\r\n  Paper,\r\n  Grid,\r\n  Divider,\r\n  Alert,\r\n  Checkbox,\r\n  FormControlLabel,\r\n} from '@mui/material';\r\nimport {\r\n  Settings as SettingsIcon,\r\n  Schedule as ScheduleIcon,\r\n  Warning as WarningIcon,\r\n  Error as ErrorIcon,\r\n} from '@mui/icons-material';\r\nimport { ChatMessageDisplay } from './chat-message-display';\r\nimport { ChatTurn } from '@/lib/ai/chat/types';\r\nimport type { SelectedChatItem } from '../../lib/ai/chat/export';\r\nimport {\r\n  ChatMessageFilters,\r\n  MESSAGE_TYPES,\r\n  type MessageType,\r\n  searchMessageContent,\r\n} from './chat-message-filters';\r\n\r\n/**\r\n * Get available message types in a turn after global filtering\r\n * Pure function for better performance\r\n */\r\nconst getAvailableMessageTypesInTurn = (\r\n  turn: ChatTurn,\r\n  globalFilters: { typeFilters: Set<MessageType>; contentFilter: string },\r\n): MessageType[] => {\r\n  // First, get messages that pass global filters (or all if no global filters)\r\n  const globallyFilteredMessages =\r\n    globalFilters.typeFilters.size > 0 || globalFilters.contentFilter.trim()\r\n      ? turn.messages.filter((message) => {\r\n          // Type filter\r\n          const passesTypeFilter =\r\n            globalFilters.typeFilters.size === 0 ||\r\n            globalFilters.typeFilters.has(message.role as MessageType);\r\n          // Content filter\r\n          const passesContentFilter = searchMessageContent(\r\n            message,\r\n            globalFilters.contentFilter,\r\n          );\r\n\r\n          return passesTypeFilter && passesContentFilter;\r\n        })\r\n      : turn.messages;\r\n\r\n  // Then find unique types in those messages\r\n  const typesInTurn = new Set<MessageType>();\r\n  globallyFilteredMessages.forEach((message) => {\r\n    if (MESSAGE_TYPES.includes(message.role as MessageType)) {\r\n      typesInTurn.add(message.role as MessageType);\r\n    }\r\n  });\r\n  return Array.from(typesInTurn).sort();\r\n};\r\n\r\n/**\r\n * Apply both global and per-turn filters to messages\r\n * Pure function for better performance\r\n */\r\nconst getFilteredMessages = (\r\n  turn: ChatTurn,\r\n  globalFilters: { typeFilters: Set<MessageType>; contentFilter: string },\r\n  enableTurnFilters: boolean,\r\n  activeTurnFilters: Set<MessageType>,\r\n  turnContentFilter: string,\r\n) => {\r\n  let filteredMessages = turn.messages;\r\n\r\n  // First apply global filters if active\r\n  if (\r\n    globalFilters.typeFilters.size > 0 ||\r\n    globalFilters.contentFilter.trim()\r\n  ) {\r\n    filteredMessages = filteredMessages.filter((message) => {\r\n      // Type filter\r\n      const passesTypeFilter =\r\n        globalFilters.typeFilters.size === 0 ||\r\n        globalFilters.typeFilters.has(message.role as MessageType);\r\n      // Content filter\r\n      const passesContentFilter = searchMessageContent(\r\n        message,\r\n        globalFilters.contentFilter,\r\n      );\r\n\r\n      return passesTypeFilter && passesContentFilter;\r\n    });\r\n  }\r\n\r\n  // Then apply per-turn filters if active\r\n  if (\r\n    enableTurnFilters &&\r\n    (activeTurnFilters.size > 0 || turnContentFilter.trim())\r\n  ) {\r\n    filteredMessages = filteredMessages.filter((message) => {\r\n      // Type filter\r\n      const passesTypeFilter =\r\n        activeTurnFilters.size === 0 ||\r\n        activeTurnFilters.has(message.role as MessageType);\r\n      // Content filter\r\n      const passesContentFilter = searchMessageContent(\r\n        message,\r\n        turnContentFilter,\r\n      );\r\n\r\n      return passesTypeFilter && passesContentFilter;\r\n    });\r\n  }\r\n\r\n  return filteredMessages;\r\n};\r\n\r\n/**\r\n * Get messages available after global filtering for the per-turn filter component\r\n * Pure function for better performance\r\n */\r\nconst getGloballyFilteredMessages = (\r\n  turn: ChatTurn,\r\n  globalFilters: { typeFilters: Set<MessageType>; contentFilter: string },\r\n) => {\r\n  return globalFilters.typeFilters.size > 0 ||\r\n    globalFilters.contentFilter.trim()\r\n    ? turn.messages.filter((message) => {\r\n        // Type filter\r\n        const passesTypeFilter =\r\n          globalFilters.typeFilters.size === 0 ||\r\n          globalFilters.typeFilters.has(message.role as MessageType);\r\n        // Content filter\r\n        const passesContentFilter = searchMessageContent(\r\n          message,\r\n          globalFilters.contentFilter,\r\n        );\r\n\r\n        return passesTypeFilter && passesContentFilter;\r\n      })\r\n    : turn.messages;\r\n};\r\n\r\n/**\r\n * Format duration between start and end times\r\n * Pure function for better performance\r\n */\r\nconst formatDuration = (startTime: string, endTime: string | null) => {\r\n  if (!endTime) return 'In progress...';\r\n  const start = new Date(startTime);\r\n  const end = new Date(endTime);\r\n  const durationMs = end.getTime() - start.getTime();\r\n  return `${durationMs}ms`;\r\n};\r\n\r\ninterface ChatTurnDisplayProps {\r\n  turn: ChatTurn;\r\n  showTurnProperties?: boolean;\r\n  showMessageMetadata?: boolean;\r\n  enableSelection?: boolean;\r\n  selectedItems?: SelectedChatItem[];\r\n  onSelectionChange?: (selectedItems: SelectedChatItem[]) => void;\r\n  globalFilters?: {\r\n    typeFilters: Set<MessageType>;\r\n    contentFilter: string;\r\n  };\r\n}\r\n\r\nexport const ChatTurnDisplay: React.FC<ChatTurnDisplayProps> = ({\r\n  turn,\r\n  showTurnProperties = false,\r\n  showMessageMetadata = false,\r\n  enableSelection = false,\r\n  selectedItems = [],\r\n  onSelectionChange,\r\n  globalFilters = { typeFilters: new Set(), contentFilter: '' },\r\n}) => {\r\n  const [propertiesExpanded, setPropertiesExpanded] = useState(false);\r\n\r\n  // Per-turn filtering state\r\n  const [enableTurnFilters, setEnableTurnFilters] = useState(false);\r\n  const [activeTurnFilters, setActiveTurnFilters] = useState<Set<MessageType>>(\r\n    new Set(),\r\n  );\r\n  const [turnContentFilter, setTurnContentFilter] = useState('');\r\n\r\n  // Memoize expensive computations\r\n  const availableTypesInTurn = React.useMemo(\r\n    () => getAvailableMessageTypesInTurn(turn, globalFilters),\r\n    [turn, globalFilters],\r\n  );\r\n\r\n  const filteredMessages = React.useMemo(\r\n    () =>\r\n      getFilteredMessages(\r\n        turn,\r\n        globalFilters,\r\n        enableTurnFilters,\r\n        activeTurnFilters,\r\n        turnContentFilter,\r\n      ),\r\n    [\r\n      turn,\r\n      globalFilters,\r\n      enableTurnFilters,\r\n      activeTurnFilters,\r\n      turnContentFilter,\r\n    ],\r\n  );\r\n\r\n  const globallyFilteredMessages = React.useMemo(\r\n    () => getGloballyFilteredMessages(turn, globalFilters),\r\n    [turn, globalFilters],\r\n  );\r\n\r\n  // Memoize selection state\r\n  const isTurnSelected = React.useMemo(\r\n    () =>\r\n      selectedItems.some(\r\n        (item) => item.type === 'turn' && item.turnId === turn.turnId,\r\n      ),\r\n    [selectedItems, turn.turnId],\r\n  );\r\n\r\n  const selectedMessages = React.useMemo(\r\n    () =>\r\n      selectedItems.filter(\r\n        (item) => item.type === 'message' && item.turnId === turn.turnId,\r\n      ),\r\n    [selectedItems, turn.turnId],\r\n  );\r\n\r\n  const isPartiallySelected = React.useMemo(\r\n    () =>\r\n      selectedMessages.length > 0 &&\r\n      selectedMessages.length < turn.messages.length,\r\n    [selectedMessages.length, turn.messages.length],\r\n  );\r\n\r\n  // Stable event handlers\r\n  const handleTurnSelectionChange = React.useCallback(\r\n    (checked: boolean) => {\r\n      if (!onSelectionChange) return;\r\n\r\n      let newSelection = [...selectedItems];\r\n\r\n      if (checked) {\r\n        // Remove any individual message selections for this turn\r\n        newSelection = newSelection.filter(\r\n          (item) => !(item.type === 'message' && item.turnId === turn.turnId),\r\n        );\r\n        // Add turn selection\r\n        newSelection.push({ type: 'turn', turnId: turn.turnId });\r\n      } else {\r\n        // Remove turn selection\r\n        newSelection = newSelection.filter(\r\n          (item) => !(item.type === 'turn' && item.turnId === turn.turnId),\r\n        );\r\n      }\r\n\r\n      onSelectionChange(newSelection);\r\n    },\r\n    [onSelectionChange, selectedItems, turn.turnId],\r\n  );\r\n\r\n  const handleMessageSelectionChange = React.useCallback(\r\n    (messageId: number, checked: boolean) => {\r\n      if (!onSelectionChange) return;\r\n\r\n      let newSelection = [...selectedItems];\r\n\r\n      // Remove turn selection if it exists (since we're selecting individual messages)\r\n      newSelection = newSelection.filter(\r\n        (item) => !(item.type === 'turn' && item.turnId === turn.turnId),\r\n      );\r\n\r\n      if (checked) {\r\n        // Add message selection if not already present\r\n        if (\r\n          !newSelection.some(\r\n            (item) =>\r\n              item.type === 'message' &&\r\n              item.turnId === turn.turnId &&\r\n              item.messageId === messageId,\r\n          )\r\n        ) {\r\n          newSelection.push({\r\n            type: 'message',\r\n            turnId: turn.turnId,\r\n            messageId,\r\n          });\r\n        }\r\n      } else {\r\n        // Remove message selection\r\n        newSelection = newSelection.filter(\r\n          (item) =>\r\n            !(\r\n              item.type === 'message' &&\r\n              item.turnId === turn.turnId &&\r\n              item.messageId === messageId\r\n            ),\r\n        );\r\n      }\r\n\r\n      onSelectionChange(newSelection);\r\n    },\r\n    [onSelectionChange, selectedItems, turn.turnId],\r\n  );\r\n\r\n  const handlePropertiesToggle = React.useCallback(() => {\r\n    setPropertiesExpanded(!propertiesExpanded);\r\n  }, [propertiesExpanded]);\r\n\r\n  return (\r\n    <Card sx={{ mb: 2 }}>\r\n      <CardContent>\r\n        {/* Turn Header */}\r\n        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2, gap: 1 }}>\r\n          {enableSelection && (\r\n            <FormControlLabel\r\n              control={\r\n                <Checkbox\r\n                  size=\"small\"\r\n                  checked={isTurnSelected}\r\n                  indeterminate={isPartiallySelected && !isTurnSelected}\r\n                  onChange={(e) => handleTurnSelectionChange(e.target.checked)}\r\n                />\r\n              }\r\n              label=\"\"\r\n              sx={{\r\n                mr: 1,\r\n                '& .MuiFormControlLabel-label': { display: 'none' },\r\n              }}\r\n            />\r\n          )}\r\n          <Chip label={`Turn ${turn.turnId}`} variant=\"outlined\" size=\"small\" />\r\n          {turn.modelName && (\r\n            <Chip\r\n              label={turn.modelName}\r\n              variant=\"outlined\"\r\n              size=\"small\"\r\n              color=\"primary\"\r\n            />\r\n          )}\r\n          {turn.latencyMs && (\r\n            <Chip\r\n              label={`${turn.latencyMs}ms`}\r\n              variant=\"outlined\"\r\n              size=\"small\"\r\n              icon={<ScheduleIcon fontSize=\"small\" />}\r\n            />\r\n          )}\r\n          {turn.warnings && turn.warnings.length > 0 && (\r\n            <Chip\r\n              label={`${turn.warnings.length} warning${turn.warnings.length > 1 ? 's' : ''}`}\r\n              variant=\"outlined\"\r\n              size=\"small\"\r\n              icon={<WarningIcon fontSize=\"small\" />}\r\n              color=\"warning\"\r\n            />\r\n          )}\r\n          {turn.errors && turn.errors.length > 0 && (\r\n            <Chip\r\n              label={`${turn.errors.length} error${turn.errors.length > 1 ? 's' : ''}`}\r\n              variant=\"outlined\"\r\n              size=\"small\"\r\n              icon={<ErrorIcon fontSize=\"small\" />}\r\n              color=\"error\"\r\n            />\r\n          )}\r\n          {showTurnProperties && (\r\n            <IconButton\r\n              size=\"small\"\r\n              onClick={handlePropertiesToggle}\r\n              sx={{ ml: 'auto' }}\r\n            >\r\n              <SettingsIcon fontSize=\"small\" />\r\n            </IconButton>\r\n          )}\r\n        </Box>\r\n\r\n        {/* Turn Properties (when expanded) */}\r\n        {showTurnProperties && (\r\n          <Collapse in={propertiesExpanded}>\r\n            <Paper variant=\"outlined\" sx={{ p: 2, mb: 2 }} elevation={3}>\r\n              <Typography variant=\"subtitle2\" gutterBottom>\r\n                Turn Properties\r\n              </Typography>\r\n              <Grid container spacing={2}>\r\n                <Grid\r\n                  size={{\r\n                    xs: 6,\r\n                    md: 3,\r\n                  }}\r\n                >\r\n                  <Typography variant=\"caption\" display=\"block\">\r\n                    Status ID: {turn.statusId}\r\n                  </Typography>\r\n                </Grid>\r\n                <Grid\r\n                  size={{\r\n                    xs: 6,\r\n                    md: 3,\r\n                  }}\r\n                >\r\n                  <Typography variant=\"caption\" display=\"block\">\r\n                    Created: {new Date(turn.createdAt).toLocaleString()}\r\n                  </Typography>\r\n                </Grid>\r\n                {turn.completedAt && (\r\n                  <Grid\r\n                    size={{\r\n                      xs: 6,\r\n                      md: 3,\r\n                    }}\r\n                  >\r\n                    <Typography variant=\"caption\" display=\"block\">\r\n                      Completed: {new Date(turn.completedAt).toLocaleString()}\r\n                    </Typography>\r\n                  </Grid>\r\n                )}\r\n                <Grid\r\n                  size={{\r\n                    xs: 6,\r\n                    md: 3,\r\n                  }}\r\n                >\r\n                  <Typography variant=\"caption\" display=\"block\">\r\n                    Duration: {formatDuration(turn.createdAt, turn.completedAt)}\r\n                  </Typography>\r\n                </Grid>\r\n                {turn.temperature !== null && (\r\n                  <Grid\r\n                    size={{\r\n                      xs: 6,\r\n                      md: 3,\r\n                    }}\r\n                  >\r\n                    <Typography variant=\"caption\" display=\"block\">\r\n                      Temperature: {turn.temperature}\r\n                    </Typography>\r\n                  </Grid>\r\n                )}\r\n                {turn.topP !== null && (\r\n                  <Grid\r\n                    size={{\r\n                      xs: 6,\r\n                      md: 3,\r\n                    }}\r\n                  >\r\n                    <Typography variant=\"caption\" display=\"block\">\r\n                      Top P: {turn.topP}\r\n                    </Typography>\r\n                  </Grid>\r\n                )}\r\n                {turn.latencyMs !== null && (\r\n                  <Grid\r\n                    size={{\r\n                      xs: 6,\r\n                      md: 3,\r\n                    }}\r\n                  >\r\n                    <Typography variant=\"caption\" display=\"block\">\r\n                      Latency: {turn.latencyMs}ms\r\n                    </Typography>\r\n                  </Grid>\r\n                )}\r\n              </Grid>\r\n\r\n              {/* Warnings */}\r\n              {turn.warnings && turn.warnings.length > 0 && (\r\n                <Box sx={{ mt: 2 }}>\r\n                  <Typography variant=\"caption\" display=\"block\" gutterBottom>\r\n                    Warnings:\r\n                  </Typography>\r\n                  {turn.warnings.map((warning, index) => (\r\n                    <Alert key={index} severity=\"warning\" sx={{ mb: 1 }}>\r\n                      {warning}\r\n                    </Alert>\r\n                  ))}\r\n                </Box>\r\n              )}\r\n\r\n              {/* Errors */}\r\n              {turn.errors && turn.errors.length > 0 && (\r\n                <Box sx={{ mt: 2 }}>\r\n                  <Typography variant=\"caption\" display=\"block\" gutterBottom>\r\n                    Errors:\r\n                  </Typography>\r\n                  {turn.errors.map((error, index) => (\r\n                    <Alert key={index} severity=\"error\" sx={{ mb: 1 }}>\r\n                      {error}\r\n                    </Alert>\r\n                  ))}\r\n                </Box>\r\n              )}\r\n\r\n              {/* Turn Metadata */}\r\n              {turn.metadata && (\r\n                <Paper sx={{ mt: 2 }} elevation={4}>\r\n                  <Typography variant=\"caption\" display=\"block\" gutterBottom>\r\n                    Turn Metadata:\r\n                  </Typography>\r\n                  <Box\r\n                    component=\"pre\"\r\n                    sx={{\r\n                      fontSize: '0.75rem',\r\n                      // backgroundColor: 'grey.100',\r\n                      p: 1,\r\n                      borderRadius: 1,\r\n                      overflow: 'auto',\r\n                      maxHeight: 200,\r\n                      wordBreak: 'break-all',\r\n                      whiteSpace: 'pre-wrap',\r\n                      maxWidth: '100%',\r\n                    }}\r\n                  >\r\n                    {JSON.stringify(turn.metadata, null, 2)}\r\n                  </Box>\r\n                </Paper>\r\n              )}\r\n            </Paper>\r\n            <Divider sx={{ mb: 2 }} />\r\n          </Collapse>\r\n        )}\r\n\r\n        {/* Per-Turn Message Filtering Controls */}\r\n        {availableTypesInTurn.length > 1 && (\r\n          <Paper\r\n            variant=\"outlined\"\r\n            sx={{ p: 2, mb: 2, bgcolor: 'action.hover' }}\r\n          >\r\n            <ChatMessageFilters\r\n              messages={globallyFilteredMessages}\r\n              enableFilters={enableTurnFilters}\r\n              onEnableFiltersChange={setEnableTurnFilters}\r\n              activeTypeFilters={activeTurnFilters}\r\n              onTypeFiltersChange={setActiveTurnFilters}\r\n              contentFilter={turnContentFilter}\r\n              onContentFilterChange={setTurnContentFilter}\r\n              title=\"Turn Filters\"\r\n              size=\"small\"\r\n              showStatusMessage={true}\r\n            />\r\n          </Paper>\r\n        )}\r\n\r\n        {/* Messages */}\r\n        {filteredMessages.length === 0 ? (\r\n          <Typography\r\n            color=\"text.secondary\"\r\n            sx={{ textAlign: 'center', py: 2, fontStyle: 'italic' }}\r\n          >\r\n            {(globalFilters.typeFilters.size > 0 ||\r\n              globalFilters.contentFilter.trim()) &&\r\n            enableTurnFilters &&\r\n            (activeTurnFilters.size > 0 || turnContentFilter.trim())\r\n              ? 'No messages match the current global and turn filters.'\r\n              : globalFilters.typeFilters.size > 0 ||\r\n                  globalFilters.contentFilter.trim()\r\n                ? 'No messages match the current global filters.'\r\n                : enableTurnFilters &&\r\n                    (activeTurnFilters.size > 0 || turnContentFilter.trim())\r\n                  ? 'No messages match the current turn filters.'\r\n                  : 'No messages in this turn.'}\r\n          </Typography>\r\n        ) : (\r\n          filteredMessages.map((message) => {\r\n            const isMessageSelected =\r\n              isTurnSelected ||\r\n              selectedItems.some(\r\n                (item) =>\r\n                  item.type === 'message' &&\r\n                  item.turnId === turn.turnId &&\r\n                  item.messageId === message.messageId,\r\n              );\r\n\r\n            return (\r\n              <ChatMessageDisplay\r\n                key={`${message.turnId}-${message.messageId}`}\r\n                message={message}\r\n                showMetadata={showMessageMetadata}\r\n                enableSelection={enableSelection}\r\n                isSelected={isMessageSelected}\r\n                onSelectionChange={handleMessageSelectionChange}\r\n              />\r\n            );\r\n          })\r\n        )}\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\chat\\history\\chat-history.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":19,"column":1,"nodeType":"Program","endLine":442,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module ChatHistory\r\n * @fileoverview\r\n * ChatHistory component module: provides a full, virtualized, scrollable view of a single chat conversation's message history.\r\n *\r\n * - Fetches chat data (turns, title, creation time) by chatId using a custom React Query hook.\r\n * - Handles loading, error, and empty states with clear user feedback and retry affordance.\r\n * - Renders chat turns using a high-performance virtualized display for scalability.\r\n * - Title resolution logic prioritizes explicit prop, then fetched title, then fallback.\r\n *\r\n * Usage:\r\n * ```tsx\r\n * <ChatHistory chatId=\"abc123\" title=\"My Chat\" />\r\n * ```\r\n *\r\n * Exported Components:\r\n * - ChatHistory: Main React component for displaying a chat transcript by id.\r\n */\r\n'use client';\r\n\r\nimport * as React from 'react';\r\nimport {\r\n  Box,\r\n  Typography,\r\n  Grid,\r\n  Card,\r\n  CardContent,\r\n  Chip,\r\n  Accordion,\r\n  AccordionSummary,\r\n  AccordionDetails,\r\n  FormControlLabel,\r\n  Switch,\r\n  Button,\r\n  Paper,\r\n} from '@mui/material';\r\nimport { ExpandMore } from '@mui/icons-material';\r\nimport { VirtualizedChatDisplay } from '@/components/chat/virtualized-chat-display';\r\nimport { ChatExportMenu } from '@/components/chat/chat-export-menu';\r\nimport {\r\n  ChatMessageFilters,\r\n  type MessageType,\r\n  searchMessageContent,\r\n} from '@/components/chat/chat-message-filters';\r\nimport { useChatHistory } from './useChatHistory';\r\nimport { Loading } from '@/components/general/loading';\r\nimport type { ChatDetails, ChatTurn } from '@/lib/ai/chat/types';\r\nimport type { SelectedChatItem } from '@/lib/ai/chat/export';\r\n\r\n/**\r\n * Get all messages from the chat for filter component\r\n * Pure function for better performance\r\n */\r\nconst getAllMessages = (chatDetails: ChatDetails) => {\r\n  return chatDetails.turns.flatMap((turn) => turn.messages);\r\n};\r\n\r\n/**\r\n * Apply global chat-level filters to the chat data\r\n * Pure function for better performance\r\n */\r\nconst getFilteredTurns = (\r\n  chatDetails: ChatDetails,\r\n  enableFilters: boolean,\r\n  activeFilters: Set<MessageType>,\r\n  contentFilter: string,\r\n): ChatTurn[] => {\r\n  if (!enableFilters) {\r\n    return chatDetails.turns;\r\n  }\r\n\r\n  // Global filtering: only hide entire turns if ALL messages in the turn are filtered out\r\n  return chatDetails.turns.filter((turn) => {\r\n    // Apply global filters to the turn's messages\r\n    const filteredMessages = turn.messages.filter((message) => {\r\n      // Type filter\r\n      const passesTypeFilter =\r\n        activeFilters.size === 0 ||\r\n        activeFilters.has(message.role as MessageType);\r\n      // Content filter\r\n      const passesContentFilter = searchMessageContent(message, contentFilter);\r\n\r\n      return passesTypeFilter && passesContentFilter;\r\n    });\r\n    // Only hide the turn if no messages match the filters (all messages filtered out)\r\n    return filteredMessages.length > 0;\r\n  });\r\n};\r\n\r\n/**\r\n * Calculate chat statistics\r\n * Pure function for better performance\r\n */\r\nconst calculateStats = (chatDetails: ChatDetails) => {\r\n  const turns = chatDetails.turns;\r\n  const totalMessages = turns.reduce(\r\n    (sum, turn) => sum + turn.messages.length,\r\n    0,\r\n  );\r\n  const totalTokens = turns.reduce((sum, turn) => {\r\n    if (turn.metadata?.totalTokens) {\r\n      return sum + (turn.metadata.totalTokens as number);\r\n    }\r\n    return sum;\r\n  }, 0);\r\n\r\n  const toolUsage = turns.reduce(\r\n    (acc, turn) => {\r\n      turn.messages.forEach((msg) => {\r\n        if (msg.toolName) {\r\n          acc[msg.toolName] = (acc[msg.toolName] || 0) + 1;\r\n        }\r\n      });\r\n      return acc;\r\n    },\r\n    {} as Record<string, number>,\r\n  );\r\n\r\n  return {\r\n    totalTurns: turns.length,\r\n    totalMessages,\r\n    totalTokens,\r\n    toolUsage,\r\n    avgLatency:\r\n      turns\r\n        .filter((t) => t.latencyMs)\r\n        .reduce((sum, t) => sum + (t.latencyMs || 0), 0) /\r\n      Math.max(turns.filter((t) => t.latencyMs).length, 1),\r\n  };\r\n};\r\n\r\n/**\r\n * ChatHistory component: displays the full message history for a given chat, including title, creation time, and all turns/messages.\r\n *\r\n * @param chatId - Unique identifier for the chat transcript to load and display.\r\n * @param title - (Optional) Explicit title to display; if omitted, falls back to fetched title or a generated default.\r\n *\r\n * @remarks\r\n * - Uses `useChatHistory` hook for data fetching and error/loading state management.\r\n * - Renders a virtualized chat display for performance with large transcripts.\r\n * - Handles error and empty states with user-friendly messaging and retry option.\r\n *\r\n * @example\r\n * <ChatHistory chatId=\"abc123\" />\r\n * <ChatHistory chatId=\"abc123\" title=\"My Custom Title\" />\r\n */\r\n\r\nexport const ChatHistory = ({\r\n  chatId,\r\n  title: titleFromProps,\r\n}: {\r\n  chatId: string;\r\n  title?: string;\r\n}) => {\r\n  const { data, isLoading, isError, error, refetch } = useChatHistory(chatId);\r\n  const [enableSelection, setEnableSelection] = React.useState(false);\r\n  const [selectedItems, setSelectedItems] = React.useState<SelectedChatItem[]>(\r\n    [],\r\n  );\r\n\r\n  // Filter state - Global chat-level filtering\r\n  const [enableFilters, setEnableFilters] = React.useState(false);\r\n  const [activeFilters, setActiveFilters] = React.useState<Set<MessageType>>(\r\n    new Set(),\r\n  );\r\n  const [contentFilter, setContentFilter] = React.useState('');\r\n\r\n  // Memoize filtered data computation\r\n  const filteredData = React.useMemo(() => {\r\n    if (!data) return null;\r\n    return {\r\n      ...data,\r\n      turns: getFilteredTurns(\r\n        data,\r\n        enableFilters,\r\n        activeFilters,\r\n        contentFilter,\r\n      ),\r\n    };\r\n  }, [data, enableFilters, activeFilters, contentFilter]);\r\n\r\n  // Memoize all messages computation\r\n  const allMessages = React.useMemo(() => {\r\n    return data ? getAllMessages(data) : [];\r\n  }, [data]);\r\n\r\n  // Memoize stats computation\r\n  const stats = React.useMemo(() => {\r\n    return filteredData ? calculateStats(filteredData) : null;\r\n  }, [filteredData]);\r\n\r\n  // Title resolution rules - memoized to prevent re-computation\r\n  const effectiveTitle = React.useMemo(() => {\r\n    const resolvedTitleFromProps =\r\n      titleFromProps && titleFromProps.trim().length > 0\r\n        ? titleFromProps.trim()\r\n        : null;\r\n    return (\r\n      resolvedTitleFromProps ??\r\n      (data?.title && data.title.trim().length > 0 ? data.title : null)\r\n    );\r\n  }, [titleFromProps, data?.title]);\r\n\r\n  // Stable event handlers\r\n  const handleSelectAll = React.useCallback(() => {\r\n    if (!filteredData) return;\r\n\r\n    // Select all turns from filtered data\r\n    const allTurns: SelectedChatItem[] = filteredData.turns.map((turn) => ({\r\n      type: 'turn' as const,\r\n      turnId: turn.turnId,\r\n    }));\r\n    setSelectedItems(allTurns);\r\n  }, [filteredData]);\r\n\r\n  const handleClearSelection = React.useCallback(() => {\r\n    setSelectedItems([]);\r\n  }, []);\r\n\r\n  const handleEnableSelectionChange = React.useCallback(\r\n    (e: React.ChangeEvent<HTMLInputElement>) => {\r\n      setEnableSelection(e.target.checked);\r\n    },\r\n    [],\r\n  );\r\n\r\n  // Clear selection when disabling selection mode\r\n  React.useEffect(() => {\r\n    if (!enableSelection) {\r\n      setSelectedItems([]);\r\n    }\r\n  }, [enableSelection]);\r\n\r\n  // Clear selection when disabling selection mode\r\n  React.useEffect(() => {\r\n    if (!enableSelection) {\r\n      setSelectedItems([]);\r\n    }\r\n  }, [enableSelection]);\r\n\r\n  if (isError) {\r\n    return (\r\n      <Box>\r\n        <Typography color=\"error\" gutterBottom>\r\n          Failed to load chat\r\n        </Typography>\r\n        <Typography variant=\"body2\" gutterBottom>\r\n          {(error as Error).message}\r\n        </Typography>\r\n        <Typography\r\n          variant=\"body2\"\r\n          sx={{ cursor: 'pointer', textDecoration: 'underline' }}\r\n          onClick={() => refetch()}\r\n        >\r\n          Retry\r\n        </Typography>\r\n      </Box>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <Typography variant=\"h4\" gutterBottom>\r\n        {effectiveTitle || `Chat ${chatId.slice(-8)}`}\r\n      </Typography>\r\n      {data && (\r\n        <>\r\n          <Typography variant=\"body2\" color=\"text.secondary\" gutterBottom>\r\n            Created: {new Date(data.createdAt).toLocaleString()}\r\n          </Typography>\r\n\r\n          {/* Global Chat-Level Message Filtering Controls */}\r\n          <Paper sx={{ p: 2, mb: 3 }}>\r\n            <ChatMessageFilters\r\n              messages={allMessages}\r\n              enableFilters={enableFilters}\r\n              onEnableFiltersChange={setEnableFilters}\r\n              activeTypeFilters={activeFilters}\r\n              onTypeFiltersChange={setActiveFilters}\r\n              contentFilter={contentFilter}\r\n              onContentFilterChange={setContentFilter}\r\n              title=\"Global Message Filters\"\r\n              size=\"medium\"\r\n              showStatusMessage={true}\r\n            />\r\n          </Paper>\r\n\r\n          {/* Chat Statistics */}\r\n          <Accordion sx={{ mb: 3 }}>\r\n            <AccordionSummary expandIcon={<ExpandMore />}>\r\n              <Typography variant=\"h6\">Chat Statistics & Metadata</Typography>\r\n            </AccordionSummary>\r\n            <AccordionDetails>\r\n              <Grid container spacing={2}>\r\n                <Grid gridColumn={{ xs: 12, sm: 6, md: 3 }}>\r\n                  <Card variant=\"outlined\">\r\n                    <CardContent>\r\n                      <Typography variant=\"h6\" color=\"primary\">\r\n                        {stats?.totalTurns || 0}\r\n                      </Typography>\r\n                      <Typography variant=\"body2\" color=\"text.secondary\">\r\n                        Total Turns\r\n                      </Typography>\r\n                    </CardContent>\r\n                  </Card>\r\n                </Grid>\r\n                <Grid gridColumn={{ xs: 12, sm: 6, md: 3 }}>\r\n                  <Card variant=\"outlined\">\r\n                    <CardContent>\r\n                      <Typography variant=\"h6\" color=\"primary\">\r\n                        {stats?.totalMessages || 0}\r\n                      </Typography>\r\n                      <Typography variant=\"body2\" color=\"text.secondary\">\r\n                        Total Messages\r\n                      </Typography>\r\n                    </CardContent>\r\n                  </Card>\r\n                </Grid>\r\n                <Grid gridColumn={{ xs: 12, sm: 6, md: 3 }}>\r\n                  <Card variant=\"outlined\">\r\n                    <CardContent>\r\n                      <Typography variant=\"h6\" color=\"primary\">\r\n                        {stats?.totalTokens || 0}\r\n                      </Typography>\r\n                      <Typography variant=\"body2\" color=\"text.secondary\">\r\n                        Total Tokens\r\n                      </Typography>\r\n                    </CardContent>\r\n                  </Card>\r\n                </Grid>\r\n                <Grid gridColumn={{ xs: 12, sm: 6, md: 3 }}>\r\n                  <Card variant=\"outlined\">\r\n                    <CardContent>\r\n                      <Typography variant=\"h6\" color=\"primary\">\r\n                        {stats?.avgLatency ? Math.round(stats.avgLatency) : 0}ms\r\n                      </Typography>\r\n                      <Typography variant=\"body2\" color=\"text.secondary\">\r\n                        Avg Latency\r\n                      </Typography>\r\n                    </CardContent>\r\n                  </Card>\r\n                </Grid>\r\n                {stats?.toolUsage &&\r\n                  Object.keys(stats.toolUsage).length > 0 && (\r\n                    <Grid gridColumn={{ xs: 12 }}>\r\n                      <Typography variant=\"subtitle1\" gutterBottom>\r\n                        Tool Usage\r\n                      </Typography>\r\n                      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>\r\n                        {Object.entries(stats.toolUsage).map(\r\n                          ([tool, count]) => (\r\n                            <Chip\r\n                              key={tool}\r\n                              label={`${tool}: ${count}`}\r\n                              size=\"small\"\r\n                              variant=\"outlined\"\r\n                            />\r\n                          ),\r\n                        )}\r\n                      </Box>\r\n                    </Grid>\r\n                  )}\r\n              </Grid>\r\n            </AccordionDetails>\r\n          </Accordion>\r\n        </>\r\n      )}\r\n\r\n      {/* Export Controls */}\r\n      {filteredData && (\r\n        <Box\r\n          sx={{ mt: 3, mb: 2, display: 'flex', alignItems: 'center', gap: 2 }}\r\n        >\r\n          <FormControlLabel\r\n            control={\r\n              <Switch\r\n                checked={enableSelection}\r\n                onChange={handleEnableSelectionChange}\r\n              />\r\n            }\r\n            label=\"Enable Export Selection\"\r\n          />\r\n          {enableSelection && (\r\n            <>\r\n              <Button\r\n                size=\"small\"\r\n                variant=\"outlined\"\r\n                onClick={handleSelectAll}\r\n                disabled={selectedItems.length === filteredData.turns.length}\r\n              >\r\n                Select All Turns\r\n              </Button>\r\n              <Button\r\n                size=\"small\"\r\n                variant=\"outlined\"\r\n                onClick={handleClearSelection}\r\n                disabled={selectedItems.length === 0}\r\n              >\r\n                Clear Selection\r\n              </Button>\r\n              <Typography variant=\"body2\" color=\"text.secondary\">\r\n                {selectedItems.length} item\r\n                {selectedItems.length !== 1 ? 's' : ''} selected\r\n              </Typography>\r\n              <ChatExportMenu\r\n                turns={filteredData.turns}\r\n                selectedItems={selectedItems}\r\n                chatTitle={effectiveTitle || undefined}\r\n                chatCreatedAt={data?.createdAt}\r\n              />\r\n            </>\r\n          )}\r\n        </Box>\r\n      )}\r\n\r\n      <Box sx={{ mt: 1 }}>\r\n        <Loading loading={isLoading} />\r\n        {!filteredData ? (\r\n          !isLoading && <Typography>No chat found.</Typography>\r\n        ) : filteredData.turns.length === 0 ? (\r\n          <Typography color=\"text.secondary\">\r\n            No messages match the current filters.\r\n          </Typography>\r\n        ) : (\r\n          <VirtualizedChatDisplay\r\n            turns={filteredData.turns}\r\n            height={800}\r\n            enableSelection={enableSelection}\r\n            selectedItems={selectedItems}\r\n            onSelectionChange={setSelectedItems}\r\n            globalFilters={\r\n              enableFilters\r\n                ? { typeFilters: activeFilters, contentFilter }\r\n                : { typeFilters: new Set(), contentFilter: '' }\r\n            }\r\n          />\r\n        )}\r\n      </Box>\r\n    </>\r\n  );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\chat\\history\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\chat\\history\\useChatHistory.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":60,"column":1,"nodeType":"Program","endLine":144,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Chat History Data Hook Module\r\n * ==================================\r\n *\r\n * Purpose:\r\n *   Provides a single, typed React Query hook (`useChatHistory`) plus its\r\n *   underlying fetcher (`fetchChatDetails`) for retrieving an entire chat's\r\n *   conversational history (turns + messages) from the server API route:\r\n *     GET /api/ai/chat/history/[chatId]\r\n *\r\n * Exports:\r\n *   - fetchChatDetails(chatId): Low-level async function returning `ChatDetails | null`.\r\n *   - useChatHistory(chatId): High-level React Query hook with loading/error/empty semantics.\r\n *\r\n * State Semantics:\r\n *   - data === undefined  -> Initial load (isLoading true)\r\n *   - data === null       -> 404 (chat not found) empty state\r\n *   - isError === true    -> Network / non-404 HTTP failure (error contains detail)\r\n *\r\n * Design Decisions:\r\n *   - Returns `null` for 404 to distinguish \"missing resource\" from operational failures.\r\n *   - Uses `cache: 'no-store'` at fetch layer and delegates dedupe / caching to React Query.\r\n *   - Chooses a modest staleTime (30s) to reduce flicker without drift risk for user-facing chat titles.\r\n *   - Disables refetchOnWindowFocus to avoid unexpected bandwidth usage and preserve user scroll position.\r\n *\r\n * Error Handling Strategy:\r\n *   - All thrown errors are logged via `LoggedError.isTurtlesAllTheWayDownBaby` with context metadata.\r\n *   - Consumers should rely on `isError` + `error.message` for UI messaging; avoid parsing thrown error shapes.\r\n *\r\n * Performance Considerations:\r\n *   - Single network round-trip; JSON parsing only transformation.\r\n *   - Suitable for SSR hydration if integrated higher in tree (currently designed for client usage).\r\n *\r\n * Testing Notes:\r\n *   - Integration tests can mock global `fetch` and assert state transitions driven by React Query.\r\n *   - For retry flows, sequence `mockRejectedValueOnce` followed by `mockResolvedValueOnce` before triggering refetch.\r\n *\r\n * Accessibility / UX:\r\n *   - Hook supplies granular state flags letting UI implement progressive disclosure (spinner -> retry -> empty -> content).\r\n *\r\n * Security:\r\n *   - Relies on server route authentication (session check); client hook does not embed auth logic.\r\n *   - Ensure cookies / headers propagate automatically (Next.js fetch wrapper) for protected routes.\r\n *\r\n * Usage Example:\r\n *   const { data, isLoading, isError, error, refetch } = useChatHistory(chatId);\r\n *   if (isLoading) return <Loading/>;\r\n *   if (isError) return <ErrorView message={error.message} onRetry={refetch}/>;\r\n *   if (!data) return <EmptyChat/>; // 404\r\n *   return <Chat turns={data.turns}/>;\r\n *\r\n * Extension Points:\r\n *   - Add query options (e.g., refetchInterval) by exposing an overload accepting a partial UseQueryOptions.\r\n *   - Inject suspense boundaries by enabling `suspense: true` (ensure callers prepared for thrown promises).\r\n *\r\n * Maintainability Guidelines:\r\n *   - Keep business logic (title derivation, etc.) out of the data hook; place in presentation component.\r\n *   - Avoid adding UI concerns (formatting dates) here; return raw canonical data.\r\n */\r\nimport { type ChatDetails } from '@/lib/ai/chat/types';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { fetch } from '@/lib/nextjs-util/fetch';\r\nimport { useQuery, UseQueryResult } from '@tanstack/react-query';\r\n\r\n/**\r\n * Fetch full chat history details for a given chat id.\r\n *\r\n * Behavior:\r\n * - Executes a GET request to `/api/ai/chat/history/{chatId}`.\r\n * - Returns `null` when a 404 (not found) is received, allowing consumers to distinguish\r\n *   between an absent chat and an error condition.\r\n * - Throws for all other non-success HTTP statuses or network faults; React Query (or\r\n *   direct callers) can then surface error UI / retry affordances.\r\n *\r\n * Logging:\r\n * - All caught errors are passed to `LoggedError.isTurtlesAllTheWayDownBaby` with contextual metadata\r\n *   before being re-thrown to preserve original stack & semantics.\r\n *\r\n * @param chatId Unique identifier of the chat whose history is requested.\r\n * @returns Parsed `ChatDetails` object or `null` when the chat does not exist.\r\n * @throws Error on network issues or non-OK, non-404 responses.\r\n */\r\nasync function fetchChatDetails(chatId: string): Promise<ChatDetails | null> {\r\n  try {\r\n    const response = await fetch(\r\n      `/api/ai/chat/history/${encodeURIComponent(chatId)}`,\r\n      {\r\n        method: 'GET',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        cache: 'no-store',\r\n      },\r\n    );\r\n\r\n    if (response.status === 404) return null;\r\n    if (!response.ok)\r\n      throw new Error(`API request failed with status ${response.status}`);\r\n\r\n    return (await response.json()) as ChatDetails;\r\n  } catch (error) {\r\n    LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      context: 'Fetching chat details',\r\n      chatId,\r\n    });\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * React Query hook for retrieving a chat's history (turns + messages) with typed\r\n * loading / error / empty (404) states.\r\n *\r\n * Query Key: ['chatDetails', chatId]\r\n * Cache Strategy:\r\n *   - `staleTime: 30_000` (30s) prevents jittery refetches after initial load.\r\n *   - `refetchOnWindowFocus: false` to avoid unexpected network traffic on tab focus.\r\n *\r\n * State Semantics:\r\n *   - `data === undefined` -> initial / loading state (use `isLoading`).\r\n *   - `data === null` -> chat definitively not found (404).\r\n *   - `isError` -> fetch failed; `error` contains detail.\r\n *\r\n * Usage Pattern:\r\n *   const { data, isLoading, isError, error, refetch } = useChatHistory(id);\r\n *   if (isLoading) return <Spinner/>;\r\n *   if (isError) return <ErrorView message={error.message} onRetry={refetch}/>;\r\n *   if (!data) return <EmptyChat/>; // 404\r\n *   return <Chat turns={data.turns}/>;\r\n *\r\n * @param chatId Unique chat identifier.\r\n * @returns React Query result descriptor for the asynchronous fetch.\r\n */\r\nexport function useChatHistory(\r\n  chatId: string,\r\n): UseQueryResult<ChatDetails | null, Error> {\r\n  return useQuery<ChatDetails | null, Error>({\r\n    queryKey: ['chatDetails', chatId],\r\n    queryFn: () => fetchChatDetails(chatId),\r\n    // We want a fresh fetch each mount but still allow quick refetches w/out loading flash.\r\n    staleTime: 30_000,\r\n    refetchOnWindowFocus: false,\r\n  });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\chat\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\chat\\list.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":191,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\nimport { JSX, useMemo, useCallback } from 'react';\r\nimport { ServerBoundDataGrid } from '@/components/mui/data-grid/server-bound-data-grid';\r\nimport siteMap from '@/lib/site-util/url-builder';\r\nimport Box from '@mui/material/Box';\r\n\r\nimport type { MuiEvent } from '@mui/x-internals/types';\r\nimport type {\r\n  GridCallbackDetails,\r\n  GridColDef,\r\n  GridRowParams,\r\n} from '@mui/x-data-grid/models';\r\nimport { useRouter } from 'next/navigation';\r\nimport Link from 'next/link';\r\nimport siteBuilder from '@/lib/site-util/url-builder';\r\n\r\n/**\r\n * Chat summary interface matching the API response\r\n */\r\ninterface ChatSummary {\r\n  id: string;\r\n  title: string | null;\r\n  userId: number;\r\n  createdAt: string;\r\n  chatMetadata: object | null;\r\n  totalTokens: number;\r\n  totalMessages: number;\r\n  totalTurns: number;\r\n}\r\n\r\n/**\r\n * Props for the chat grid component\r\n */\r\ninterface ChatGridProps {\r\n  maxHeight?: number | string;\r\n  viewType?: 'user' | 'system';\r\n  onRowDoubleClick?: (\r\n    params: GridRowParams<ChatSummary>,\r\n    event: MuiEvent<React.MouseEvent<HTMLElement, MouseEvent>>,\r\n    details: GridCallbackDetails,\r\n  ) => void;\r\n}\r\n\r\n/**\r\n * Defines the column configuration for the chat history list grid.\r\n */\r\nconst stableColumns: GridColDef<ChatSummary>[] = [\r\n  {\r\n    field: 'title',\r\n    headerName: 'Chat Title',\r\n    editable: false,\r\n    flex: 1,\r\n    renderCell: (params) => {\r\n      const title = params.value || `Chat ${params.row.id.slice(-8)}`;\r\n      return (\r\n        <Link\r\n          href={siteBuilder.messages.chat.page(\r\n            encodeURIComponent(params.row.id),\r\n          )}\r\n          title=\"Open chat\"\r\n          style={{\r\n            // color: '#2563eb',\r\n            textDecoration: 'none',\r\n          }}\r\n          onMouseEnter={(e) =>\r\n            ((e.target as HTMLElement).style.textDecoration = 'underline')\r\n          }\r\n          onMouseLeave={(e) =>\r\n            ((e.target as HTMLElement).style.textDecoration = 'none')\r\n          }\r\n        >\r\n          {title}\r\n        </Link>\r\n      );\r\n    },\r\n  },\r\n  {\r\n    field: 'totalTurns',\r\n    headerName: 'Turns',\r\n    editable: false,\r\n  },\r\n  {\r\n    field: 'totalMessages',\r\n    headerName: 'Messages',\r\n    editable: false,\r\n  },\r\n  {\r\n    field: 'totalTokens',\r\n    headerName: 'Tokens',\r\n    editable: false,\r\n  },\r\n  {\r\n    field: 'createdAt',\r\n    headerName: 'Created',\r\n    editable: false,\r\n    width: 160,\r\n    type: 'date',\r\n    valueGetter: (v: string | Date) => {\r\n      return v ? new Date(v) : v;\r\n    },\r\n    valueFormatter: (v: Date) => {\r\n      if (!v || isNaN(v.getTime())) return '';\r\n      const mm = String(v.getMonth() + 1).padStart(2, '0');\r\n      const dd = String(v.getDate()).padStart(2, '0');\r\n      const yyyy = v.getFullYear();\r\n      return `${mm}/${dd}/${yyyy}`;\r\n    },\r\n  },\r\n];\r\n\r\n/**\r\n * Displays a list of chat histories in a data grid.\r\n *\r\n * @param {ChatGridProps} props - Props for configuring the chat data grid.\r\n * @returns {JSX.Element} The rendered chat list component.\r\n */\r\nexport const ChatList = ({\r\n  maxHeight = undefined,\r\n  viewType = 'user',\r\n  onRowDoubleClick: onRowDoubleClickProps,\r\n  ...props\r\n}: ChatGridProps): JSX.Element => {\r\n  const containerSx = useMemo(\r\n    () => ({\r\n      maxHeight,\r\n    }),\r\n    [maxHeight],\r\n  );\r\n  const { push } = useRouter();\r\n\r\n  // Build URL with viewType parameter (only add if not default 'user')\r\n  const gridUrl = useMemo(() => {\r\n    const url = new URL(\r\n      siteMap.api.ai.chat.history().toString(),\r\n      window.location.origin,\r\n    );\r\n    if (viewType !== 'user') {\r\n      url.searchParams.set('viewType', viewType);\r\n    }\r\n    return url.toString();\r\n  }, [viewType]);\r\n\r\n  const onRowDoubleClick = useCallback(\r\n    (\r\n      params: GridRowParams<ChatSummary>,\r\n      event: MuiEvent<React.MouseEvent<HTMLElement, MouseEvent>>,\r\n      details: GridCallbackDetails,\r\n    ) => {\r\n      if (onRowDoubleClickProps) {\r\n        onRowDoubleClickProps(params, event, details);\r\n      }\r\n      if (!event.isPropagationStopped()) {\r\n        const chatId = params.row.id;\r\n        if (chatId) {\r\n          push(\r\n            String(\r\n              siteBuilder.messages.chat\r\n                .detail(encodeURIComponent(chatId))\r\n                .toString(),\r\n            ),\r\n          );\r\n        }\r\n      }\r\n    },\r\n    [onRowDoubleClickProps, push],\r\n  );\r\n\r\n  return (\r\n    <>\r\n      <Box\r\n        sx={{\r\n          display: 'flex',\r\n          flexDirection: 'column',\r\n          width: '100%',\r\n          ...containerSx,\r\n        }}\r\n      >\r\n        <ServerBoundDataGrid<ChatSummary>\r\n          {...props}\r\n          columns={stableColumns}\r\n          url={gridUrl}\r\n          idColumn=\"id\"\r\n          onRowDoubleClick={onRowDoubleClick}\r\n        />\r\n      </Box>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default ChatList;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\chat\\test-virtualized-chat.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\chat\\virtualized-chat-display.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":403,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\n/**\r\n * Module: Virtualized Chat Display\r\n * -------------------------------------------------------------\r\n * High‑performance, scroll‑virtualized rendering of chat turns/messages.\r\n *\r\n * Why virtualization?\r\n *  - Large chats (hundreds of turns, thousands of messages) can cause DOM bloat,\r\n *    expensive layout / paint cycles, and sluggish interaction if fully rendered.\r\n *  - Virtualization keeps only the visible (plus a small overscan buffer) portion\r\n *    of the chat in the DOM while still preserving accurate scrollbar size and\r\n *    scroll position semantics.\r\n *\r\n * Height Strategy:\r\n *  - We provide an initial optimistic size estimate per chat turn via the\r\n *    `estimateSize` callback. This attempts to approximate the total rendered\r\n *    height of the turn (header, messages, metadata panels, warnings/errors, etc.)\r\n *    using a markdown + text measurement utility.\r\n *  - When `ResizeObserver` is available, the virtualization library can refine\r\n *    the measurement with the actual DOM height (via `measureElement`). This\r\n *    produces smooth, low-jitter scrolling even for highly variable content.\r\n *\r\n * Key Trade‑offs / Assumptions:\r\n *  - Estimation favors slight overestimation to avoid visual jump when the real\r\n *    measurement arrives. (Underestimation creates more noticeable layout shifts.)\r\n *  - We intentionally removed arbitrary maximum height caps so very long AI\r\n *    responses remain fully accessible.\r\n *  - Width is derived dynamically from the scroll container (falling back to a\r\n *    viewport or constant fallback during first render / SSR boundary cases).\r\n *\r\n * Accessibility & UX:\r\n *  - Message and metadata toggles allow users to progressively disclose\r\n *    diagnostic / system information without penalizing initial load cost.\r\n *  - Empty state messaging clarifies when a chat has no turns/messages.\r\n *\r\n * Performance Notes:\r\n *  - `overscan` is tuned (currently 3) to balance scroll fluidity and memory\r\n *    usage. Increase for faster wheels / touchpad momentum; decrease for tight\r\n *    memory environments.\r\n *  - Height estimation leverages a shared `textMeasurer` to avoid creating\r\n *    repeated canvas contexts / DOM nodes.\r\n *\r\n * Extension Points:\r\n *  - Additional per‑message adornments (e.g., token usage bars) should factor\r\n *    their vertical contribution into `estimateSize` for accuracy.\r\n *  - Alternate rendering modes (collapsing tool / system messages) can be added\r\n *    behind new toggles – ensure both estimation and actual DOM reflect changes.\r\n *\r\n * Error Handling:\r\n *  - This component assumes `turns` integrity (e.g., arrays present). Defensive\r\n *    fallbacks (default heights) ensure resilience if partial data arrives.\r\n */\r\n\r\nimport React, { useRef, useState, useCallback } from 'react';\r\nimport { useVirtualizer } from '@tanstack/react-virtual';\r\nimport { Box, Switch, FormControlLabel, FormGroup, Paper } from '@mui/material';\r\nimport { ChatTurnDisplay } from './chat-turn-display';\r\nimport {\r\n  createTextMeasurer,\r\n  estimateMarkdownHeight,\r\n} from '@/lib/components/ai/height-estimators';\r\nimport { ChatTurn } from '@/lib/ai/chat/types';\r\nimport type { SelectedChatItem } from '../../lib/ai/chat/export';\r\nimport { type MessageType, searchMessageContent } from './chat-message-filters';\r\n\r\n/**\r\n * Fallback container width for virtualized chat display\r\n */\r\nexport const FALLBACK_CONTAINER_WIDTH = 1200;\r\n\r\n/**\r\n * Text measurement utility for estimating heights of chat messages\r\n */\r\nconst textMeasurer = createTextMeasurer();\r\n\r\n/**\r\n * Props for `VirtualizedChatDisplay`.\r\n */\r\ninterface VirtualizedChatDisplayProps {\r\n  /** Ordered collection of turns to render */\r\n  turns: ChatTurn[];\r\n  /** Explicit pixel height of the scroll container (defaults to 600) */\r\n  height?: number;\r\n  /** Enable selection mode for export functionality */\r\n  enableSelection?: boolean;\r\n  /** Currently selected chat items */\r\n  selectedItems?: SelectedChatItem[];\r\n  /** Callback when selection changes */\r\n  onSelectionChange?: (selectedItems: SelectedChatItem[]) => void;\r\n  /** Global message filters to apply to all turns */\r\n  globalFilters?: {\r\n    typeFilters: Set<MessageType>;\r\n    contentFilter: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Virtualized chat transcript component rendering only the visible subset of\r\n * turns for scalability. Supports optional disclosure of diagnostic metadata\r\n * (turn properties, message metadata) without compromising baseline performance.\r\n *\r\n * Rendering Flow:\r\n *  1. Derive an estimated height for each turn synchronously (fast path).\r\n *  2. Virtualizer positions absolute containers within a tall spacer box.\r\n *  3. Each visible item mounts `ChatTurnDisplay`, after which (when supported)\r\n *     a `ResizeObserver` refines the actual measured height.\r\n *\r\n * Interaction Toggles:\r\n *  - Show Turn Properties: reveals model parameters + warnings/errors + metadata.\r\n *  - Show Message Metadata: reveals per‑message diagnostic JSON blocks.\r\n *\r\n * Performance Considerations:\r\n *  - Avoid injecting heavy synchronous parsing or large JSON serialization into\r\n *    the `estimateSize` callback; keep it deterministic and CPU‑light.\r\n *  - For additional data (e.g., token usage charts) remember to adjust both the\r\n *    estimator and the actual DOM height contributions.\r\n */\r\nexport const VirtualizedChatDisplay: React.FC<VirtualizedChatDisplayProps> = ({\r\n  turns,\r\n  height = 600,\r\n  enableSelection = false,\r\n  selectedItems = [],\r\n  onSelectionChange,\r\n  globalFilters = { typeFilters: new Set(), contentFilter: '' },\r\n}) => {\r\n  const parentRef = useRef<HTMLDivElement>(null);\r\n  const [showTurnProperties, setShowTurnProperties] = useState(false);\r\n  const [showMessageMetadata, setShowMessageMetadata] = useState(false);\r\n\r\n  // Estimate size for each turn based on content using improved measurement\r\n  /**\r\n   * Estimate (optimistically) the vertical pixel footprint of a turn.\r\n   *\r\n   * Goals:\r\n   *  - Be fast (no DOM writes, minimal JSON work) to keep scroll perf smooth.\r\n   *  - Slightly overestimate to reduce post‑measurement visual shifts.\r\n   *  - Account for filtering that may hide messages within the turn.\r\n   *\r\n   * Fallback Paths:\r\n   *  - If a turn or container width is unavailable (initial prerender), uses\r\n   *    conservative defaults and a global fallback width.\r\n   *\r\n   * @param index Index of the virtualized row (turn)\r\n   * @returns Estimated height in pixels (never less than the minimum of 150)\r\n   */\r\n  const estimateSize = useCallback(\r\n    (index: number) => {\r\n      const turn = turns[index];\r\n      if (!turn) return 200; // default fallback\r\n\r\n      let width = 0;\r\n      // Get container width for accurate measurement\r\n      if (parentRef.current === null) {\r\n        // Handle case where parentRef is not yet available\r\n        if (typeof window !== 'undefined') {\r\n          width = window.innerWidth * 0.9; // Fallback to 90% of viewport width\r\n        } else {\r\n          width = FALLBACK_CONTAINER_WIDTH; // Fallback to a default width\r\n        }\r\n      } else {\r\n        width = parentRef.current.getBoundingClientRect().width;\r\n      }\r\n\r\n      // Base size for turn header and card structure\r\n      let totalHeight = 120; // Increased base turn header height to account for chips and spacing\r\n\r\n      // Calculate content width accounting for Card padding and margins\r\n      const contentWidth = Math.max(width * 0.85 - 48, 300); // 85% width minus Card padding, min 300px\r\n\r\n      // Filter messages based on global filters if active\r\n      const visibleMessages =\r\n        globalFilters.typeFilters.size > 0 || globalFilters.contentFilter.trim()\r\n          ? turn.messages.filter((message) => {\r\n              // Type filter\r\n              const passesTypeFilter =\r\n                globalFilters.typeFilters.size === 0 ||\r\n                globalFilters.typeFilters.has(message.role as MessageType);\r\n              // Content filter\r\n              const passesContentFilter = searchMessageContent(\r\n                message,\r\n                globalFilters.contentFilter,\r\n              );\r\n\r\n              return passesTypeFilter && passesContentFilter;\r\n            })\r\n          : turn.messages;\r\n\r\n      // If no messages are visible after filtering, return a minimal height\r\n      if (visibleMessages.length === 0) {\r\n        return Math.max(totalHeight + 60, 150); // Just turn header + empty message indicator\r\n      }\r\n\r\n      // Measure each visible message content using sophisticated height estimation\r\n      visibleMessages.forEach((message) => {\r\n        if (message.content && message.content.trim()) {\r\n          // Use sophisticated markdown height estimation\r\n          const estimatedHeight = estimateMarkdownHeight(\r\n            message.content,\r\n            contentWidth,\r\n            textMeasurer,\r\n          );\r\n\r\n          // Add message container padding and margins\r\n          totalHeight += estimatedHeight + 32; // content height + message container padding\r\n        } else {\r\n          // Base message height for messages without content (tool calls, etc)\r\n          totalHeight += 60; // Increased from 40 to account for message container\r\n        }\r\n\r\n        // Add height for optimized content accordion if present and different from main content\r\n        if (\r\n          message.optimizedContent &&\r\n          message.optimizedContent !== message.content\r\n        ) {\r\n          // Add height for accordion header (collapsed state)\r\n          totalHeight += 48; // Accordion header height with padding\r\n\r\n          // Add potential expanded content height - we need to be generous here\r\n          // because the accordion can be expanded by the user\r\n          const optimizedContentHeight = estimateMarkdownHeight(\r\n            message.optimizedContent,\r\n            contentWidth,\r\n            textMeasurer,\r\n          );\r\n\r\n          // Add space for the optimized content when expanded\r\n          // We estimate for expanded state to avoid content being cut off\r\n          totalHeight += optimizedContentHeight + 24; // content + accordion details padding\r\n        }\r\n\r\n        // Add spacing between messages\r\n        totalHeight += 16;\r\n      });\r\n\r\n      // Add size if properties are shown\r\n      if (showTurnProperties) {\r\n        totalHeight += 150; // Increased space for model, temperature, latency etc\r\n\r\n        // Add space for warnings and errors using proper estimation\r\n        if (turn.warnings?.length) {\r\n          turn.warnings.forEach((warning) => {\r\n            const warningHeight = estimateMarkdownHeight(\r\n              warning,\r\n              contentWidth * 0.9, // Slightly narrower for alerts\r\n              textMeasurer,\r\n            );\r\n            totalHeight += warningHeight + 24; // Alert padding\r\n          });\r\n        }\r\n\r\n        if (turn.errors?.length) {\r\n          turn.errors.forEach((error) => {\r\n            const errorHeight = estimateMarkdownHeight(\r\n              error,\r\n              contentWidth * 0.9, // Slightly narrower for alerts\r\n              textMeasurer,\r\n            );\r\n            totalHeight += errorHeight + 24; // Alert padding\r\n          });\r\n        }\r\n\r\n        // Add space for metadata if present\r\n        if (turn.metadata) {\r\n          const metadataLines = JSON.stringify(turn.metadata, null, 2).split(\r\n            '\\n',\r\n          ).length;\r\n          totalHeight += Math.min(metadataLines * 16, 200); // Cap metadata display at 200px\r\n        }\r\n      }\r\n\r\n      // Add space for message metadata display if enabled (only for visible messages)\r\n      if (showMessageMetadata) {\r\n        visibleMessages.forEach((message) => {\r\n          totalHeight += 80; // Base metadata panel height\r\n\r\n          // Add space for function call and metadata JSON\r\n          if (message.functionCall) {\r\n            const funcCallLines = JSON.stringify(\r\n              message.functionCall,\r\n              null,\r\n              2,\r\n            ).split('\\n').length;\r\n            totalHeight += Math.min(funcCallLines * 16, 200); // Cap at 200px\r\n          }\r\n\r\n          if (message.metadata) {\r\n            const msgMetadataLines = JSON.stringify(\r\n              message.metadata,\r\n              null,\r\n              2,\r\n            ).split('\\n').length;\r\n            totalHeight += Math.min(msgMetadataLines * 16, 200); // Cap at 200px\r\n          }\r\n        });\r\n      }\r\n\r\n      // Add padding for Paper component and margins\r\n      totalHeight += 48; // Card padding and margins\r\n\r\n      // Remove artificial cap - let content be as tall as it needs to be\r\n      // Only set a reasonable minimum height\r\n      return Math.max(totalHeight, 150);\r\n    },\r\n    [turns, showTurnProperties, showMessageMetadata, globalFilters],\r\n  );\r\n\r\n  /**\r\n   * Virtualization controller from TanStack Virtual handling item measurement,\r\n   * scroll range projection, and overscan buffering.\r\n   */\r\n  const rowVirtualizer = useVirtualizer({\r\n    count: turns.length,\r\n    getScrollElement: () => parentRef.current,\r\n    estimateSize,\r\n    overscan: 3, // Render more items outside visible area for smoother scrolling\r\n    measureElement:\r\n      typeof window !== 'undefined' && window.ResizeObserver\r\n        ? (element) => element?.getBoundingClientRect().height\r\n        : undefined, // Enable dynamic measurement when ResizeObserver is available\r\n  });\r\n\r\n  return (\r\n    <Box>\r\n      {/* Controls */}\r\n      <Paper sx={{ p: 2, mb: 2 }}>\r\n        <FormGroup row>\r\n          <FormControlLabel\r\n            control={\r\n              <Switch\r\n                checked={showTurnProperties}\r\n                onChange={(e) => setShowTurnProperties(e.target.checked)}\r\n              />\r\n            }\r\n            label=\"Show Turn Properties (model, temp, latency, warnings, errors, token usage)\"\r\n          />\r\n          <FormControlLabel\r\n            control={\r\n              <Switch\r\n                checked={showMessageMetadata}\r\n                onChange={(e) => setShowMessageMetadata(e.target.checked)}\r\n              />\r\n            }\r\n            label=\"Show Message Metadata\"\r\n          />\r\n        </FormGroup>\r\n      </Paper>\r\n\r\n      {/* Virtualized Chat Display */}\r\n      <Box\r\n        ref={parentRef}\r\n        sx={{\r\n          height: `${height}px`,\r\n          overflow: 'auto',\r\n          width: '100%',\r\n        }}\r\n      >\r\n        <Box\r\n          sx={{\r\n            height: `${rowVirtualizer.getTotalSize()}px`,\r\n            width: '100%',\r\n            position: 'relative',\r\n          }}\r\n        >\r\n          {rowVirtualizer.getVirtualItems().map((virtualItem) => {\r\n            const turn = turns[virtualItem.index];\r\n\r\n            return (\r\n              <Box\r\n                key={virtualItem.key}\r\n                data-index={virtualItem.index}\r\n                sx={{\r\n                  position: 'absolute',\r\n                  top: 0,\r\n                  left: 0,\r\n                  width: '100%',\r\n                  transform: `translateY(${virtualItem.start}px)`,\r\n                }}\r\n              >\r\n                <ChatTurnDisplay\r\n                  turn={turn}\r\n                  showTurnProperties={showTurnProperties}\r\n                  showMessageMetadata={showMessageMetadata}\r\n                  enableSelection={enableSelection}\r\n                  selectedItems={selectedItems}\r\n                  onSelectionChange={onSelectionChange}\r\n                  globalFilters={globalFilters}\r\n                />\r\n              </Box>\r\n            );\r\n          })}\r\n        </Box>\r\n      </Box>\r\n\r\n      {turns.length === 0 && (\r\n        <Paper sx={{ p: 4, textAlign: 'center' }}>\r\n          No messages found in this chat.\r\n        </Paper>\r\n      )}\r\n    </Box>\r\n  );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\contact\\contact-dropdown.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":2,"column":1,"nodeType":"Program","endLine":128,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/** @jsxImportSource @emotion/react */\r\nimport React, { useEffect, useState } from 'react';\r\nimport ContactForm from './contact-form';\r\nimport { Contact, ContactSummary } from '@/data-models/api/contact';\r\nimport { createContactSummary } from '@/data-models/api';\r\nimport { log } from '@/lib/logger';\r\nimport { css, SerializedStyles } from '@emotion/react';\r\nimport { fetch } from '@/lib/nextjs-util/fetch';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\n\r\ninterface ContactDropdownProps {\r\n  displayValue?: 'name' | 'email' | 'both';\r\n  contact: number | ContactSummary;\r\n  setValue: (value: ContactSummary) => void;\r\n  filter?: (contact: ContactSummary) => boolean;\r\n  className?: SerializedStyles;\r\n  style?: React.CSSProperties;\r\n}\r\n\r\nconst dropdownStyles = {\r\n  select: css`\r\n    width: 100%;\r\n  `,\r\n};\r\n\r\nconst emptyContact = createContactSummary();\r\n\r\nconst ContactDropdown = ({\r\n  displayValue = 'name',\r\n  className,\r\n  contact,\r\n  setValue,\r\n  filter = () => true,\r\n  style,\r\n}: ContactDropdownProps) => {\r\n  const [contacts, setContacts] = useState<ContactSummary[]>([]);\r\n  const [showContactForm, setShowContactForm] = useState(false);\r\n\r\n  const getContact = (contactId: number) =>\r\n    contacts.find((c) => c.contactId === contactId) ?? emptyContact;\r\n\r\n  const contactId =\r\n    typeof contact === 'number' ? contact : (contact ?? emptyContact).contactId;\r\n\r\n  useEffect(() => {\r\n    const controller = new AbortController();\r\n    const signal = controller.signal;\r\n\r\n    fetch('/api/contact', { signal })\r\n      .then((response) => response.json())\r\n      .then((data) => setContacts(data))\r\n      .catch((error) => {\r\n        if (error.name !== 'AbortError') {\r\n          LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n            log: true,\r\n            source: 'chat-panel',\r\n          });\r\n        }\r\n      });\r\n\r\n    return () => controller.abort();\r\n  }, []);\r\n\r\n  const handleSelectChange = (event: React.ChangeEvent<HTMLSelectElement>) => {\r\n    switch (event.target.value) {\r\n      case 'select-contact':\r\n        setValue(emptyContact);\r\n        break;\r\n      case 'add-contact':\r\n        setShowContactForm(true);\r\n        break;\r\n      default:\r\n        const newValue = getContact(Number(event.target.value));\r\n        if (!newValue || newValue.contactId < 1) {\r\n          log((l) => l.error('Contact not found:', event.target.value));\r\n        }\r\n        setValue(newValue);\r\n        break;\r\n    }\r\n  };\r\n\r\n  const handleContactSaved = (newContact: Contact) => {\r\n    setContacts([...contacts, newContact]);\r\n    setValue(newContact);\r\n    setShowContactForm(false);\r\n  };\r\n\r\n  const renderContactOption = (contact: ContactSummary) => {\r\n    switch (displayValue) {\r\n      case 'name':\r\n        return contact.name;\r\n      case 'email':\r\n        return contact.email;\r\n      case 'both':\r\n        return `${contact.name} (${contact.email})`;\r\n      default:\r\n        return contact.name;\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div css={className} style={style}>\r\n      <select\r\n        title=\"Select contact\"\r\n        value={contactId}\r\n        onChange={handleSelectChange}\r\n        css={dropdownStyles.select}\r\n      >\r\n        <option value=\"-1\">Select...</option>\r\n        {Array.isArray(contacts) ? contacts.filter(filter).map((contact) => (\r\n          <option key={contact.contactId} value={contact.contactId}>\r\n            {renderContactOption(contact)}\r\n          </option>\r\n        )) : null}\r\n        <option value=\"add-contact\">Add contact</option>\r\n      </select>\r\n      {showContactForm && (\r\n        <ContactForm\r\n          onSave={handleContactSaved}\r\n          onCancel={() => setShowContactForm(false)}\r\n        />\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ContactDropdown;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\contact\\contact-form.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\contact\\contact-recipients.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":3,"column":1,"nodeType":"Program","endLine":118,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/** @jsxImportSource @emotion/react */\r\n\r\nimport React, { useCallback, useState } from 'react';\r\nimport ContactDropdown from './contact-dropdown';\r\nimport { ContactSummary } from '@/data-models/api/contact';\r\nimport { css } from '@emotion/react';\r\nimport fastEqual from 'fast-deep-equal';\r\nimport Modal from '../general/modal';\r\n\r\ntype ContactRecipientsProps = {\r\n  id?: string;\r\n  contacts: ContactSummary[];\r\n  onContactsUpdate: (updatedContacts: ContactSummary[]) => void;\r\n};\r\n\r\nconst styles = {\r\n  contactItem: css`\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    padding: 0.5rem 0;\r\n  `,\r\n};\r\n\r\nconst ContactRecipients: React.FC<ContactRecipientsProps> = ({\r\n  contacts,\r\n  onContactsUpdate,\r\n  id: ariaTargetId,\r\n}) => {\r\n  const [isEditing, setIsEditing] = useState(false);\r\n  const [contactsFromProps, setContactsFromProps] =\r\n    useState<ContactSummary[]>(contacts);\r\n  const [currentContacts, setCurrentContacts] =\r\n    useState<ContactSummary[]>(contacts);\r\n  const enableEditMode = useCallback(() => setIsEditing(true), [setIsEditing]);\r\n  const disableEditMode = useCallback(\r\n    () => setIsEditing(false),\r\n    [setIsEditing],\r\n  );\r\n  const filterContacts = useCallback(\r\n    (contact: ContactSummary) =>\r\n      currentContacts.findIndex((c) => c.contactId === contact.contactId) ===\r\n      -1,\r\n    [currentContacts],\r\n  );\r\n  const handleAddContact = useCallback(\r\n    (newContact: ContactSummary) =>\r\n      setCurrentContacts([...currentContacts, newContact]),\r\n    [currentContacts],\r\n  );\r\n  const handleRemoveContact = useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      const contactId = parseInt(event.currentTarget.dataset.target ?? '');\r\n      setCurrentContacts(\r\n        currentContacts.filter((contact) => contact.contactId !== contactId),\r\n      );\r\n    },\r\n    [currentContacts],\r\n  );\r\n  const handleSave = useCallback(() => {\r\n    onContactsUpdate(currentContacts);\r\n    setIsEditing(false);\r\n  }, [currentContacts, onContactsUpdate]);\r\n\r\n  // Check to see if our parent component has updated contacts - if so, update our state\r\n  if (!fastEqual(contactsFromProps, contacts)) {\r\n    setContactsFromProps(contacts);\r\n    if (!fastEqual(currentContacts, contacts)) {\r\n      setCurrentContacts(contacts);\r\n    }\r\n  }\r\n  return (\r\n    <div>\r\n      <div>\r\n        {currentContacts\r\n          .map((contact) => `${contact.name} (${contact.email})`)\r\n          .join('; ')}\r\n        <button\r\n          aria-haspopup=\"dialog\"\r\n          className=\"btn btn-primary\"\r\n          onClick={enableEditMode}\r\n          id={ariaTargetId}\r\n        >\r\n          Edit\r\n        </button>\r\n      </div>\r\n      <Modal\r\n        isOpen={isEditing}\r\n        onSave={handleSave}\r\n        onClose={disableEditMode}\r\n        title=\"Edit Recipients\"\r\n      >\r\n        {currentContacts.map((contact) => (\r\n          <div key={contact.contactId} css={styles.contactItem}>\r\n            <span>\r\n              {contact.name} ({contact.email})\r\n            </span>\r\n            <button\r\n              className=\"btn btn-angry\"\r\n              data-target={contact.contactId.toString()}\r\n              onClick={handleRemoveContact}\r\n            >\r\n              Remove\r\n            </button>\r\n          </div>\r\n        ))}\r\n        <ContactDropdown\r\n          contact={-1}\r\n          setValue={handleAddContact}\r\n          filter={filterContacts}\r\n        />\r\n      </Modal>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ContactRecipients;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-import\\import-session\\import-record.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-import\\import-session\\import-session.tsx","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":436,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":436,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12870,12873],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12870,12873],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-import\\import-session\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-import\\import-session\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":94,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  MessageImportStatusWithChildren,\r\n  MessageImportStatus,\r\n} from '@/data-models/api/import/email-message';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\n\r\n/**\r\n * Represents the session data for an email import.\r\n *\r\n * @property {string} providerId - The ID of the provider.\r\n * @property {MessageImportStatusWithChildren} [status] - The status of the message import, including any child statuses.\r\n * @property {boolean} isActive - Indicates whether the session is active.\r\n * @property {Promise<Response>} [activeRequest] - The active request associated with the session.\r\n */\r\nexport type SessionData = {\r\n  providerId: string;\r\n  status?: MessageImportStatusWithChildren;\r\n  isActive: boolean;\r\n  activeRequest?: Promise<Response>;\r\n};\r\n\r\n/**\r\n * Represents the state of an import record job.\r\n *\r\n * Possible values:\r\n * - 'pending': The job is pending and has not started yet.\r\n * - 'loading-message': The job is in the process of loading a message.\r\n * - 'waiting-for-slot': The job is waiting for an available slot to proceed.\r\n * - 'waiting-for-import': The job is waiting for the import process to start.\r\n * - 'done': The job has completed successfully.\r\n */\r\nexport type ImportRecordJobState =\r\n  | 'pending'\r\n  | 'loading-message'\r\n  | 'waiting-for-slot'\r\n  | 'waiting-for-import'\r\n  | 'ready-for-import'\r\n  | 'error'\r\n  | 'done';\r\n\r\n/**\r\n * Properties for the ImportRecordNotify component.\r\n *\r\n * @property {string} providerId - The ID of the provider.\r\n * @property {'check-changed' | 'references-loaded'} action - The action type.\r\n *\r\n * If `action` is 'check-changed':\r\n * @property {boolean} checked - Indicates whether the item is checked.\r\n *\r\n * If `action` is 'references-loaded':\r\n * @property {Array<MessageImportStatus>} references - The list of message import statuses.\r\n */\r\nexport type ImportRecordNotifyProps = {\r\n  providerId: string;\r\n} & (\r\n  | {\r\n      action: 'check-changed';\r\n      checked: boolean;\r\n    }\r\n  | {\r\n      action: 'references-loaded';\r\n      downloaded: boolean;\r\n      references: Array<MessageImportStatus>;\r\n    }\r\n  | {\r\n      action: 'download-complete';\r\n      successful: true;\r\n    }\r\n  | {\r\n      action: 'download-complete';\r\n      successful: false;\r\n      error: LoggedError;\r\n    }\r\n  | {\r\n      action: 'import-error';\r\n      error: LoggedError;\r\n    }\r\n);\r\n\r\n/**\r\n * Properties for an import record.\r\n *\r\n * @property {Partial<MessageImportStatus> & Required<Pick<MessageImportStatus, 'providerId'>>} importStatus - The status of the import, which includes all properties of `MessageImportStatus` except for `providerId`, which is required.\r\n * @property {(props: ImportRecordNotifyProps) => void} notify - Function to notify about the import record.\r\n * @property {boolean} canImport - Indicates whether the import can be performed.\r\n */\r\nexport type ImportRecordProps = {\r\n  importStatus: Partial<MessageImportStatus> &\r\n    Required<Pick<MessageImportStatus, 'providerId'>>;\r\n  notify: (props: ImportRecordNotifyProps) => void;\r\n  isChecked: boolean;\r\n  canImport: boolean;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\_types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\bulk-form\\index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\dashboard-layout\\branding.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":12,"column":1,"nodeType":"Program","endLine":48,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Branding configuration for Email Dashboard Layout\r\n *\r\n * This module provides the branding configuration used in the email dashboard\r\n * layout, including the application title and logo displayed in the header.\r\n *\r\n * @module components/email-message/dashboard-layout/branding\r\n * @version 1.0.0\r\n * @since 2025-07-19\r\n */\r\n\r\nimport * as React from 'react';\r\nimport Image from 'next/image';\r\nimport { BrandingConfig } from './types';\r\n\r\n/**\r\n * Branding configuration for the email dashboard layout.\r\n *\r\n * @constant Branding\r\n * @description Defines the title and logo displayed in the dashboard header.\r\n * The logo uses a 40x40 pixel badge image located in the public directory.\r\n * Uses Next.js Image component for optimized loading and performance.\r\n *\r\n * @example\r\n * ```tsx\r\n * // Used in NextAppProvider\r\n * <NextAppProvider branding={Branding}>\r\n *   <DashboardLayout>\r\n *     {children}\r\n *   </DashboardLayout>\r\n * </NextAppProvider>\r\n * ```\r\n */\r\nexport const Branding: BrandingConfig = {\r\n  title: 'Mystery Compliance Theater 2000',\r\n  logo: (\r\n    <>\r\n      <Image\r\n        src=\"/static/logo/badge_40x40.png\"\r\n        alt=\"Mystery Compliance Theater 2000 Logo\"\r\n        width={40}\r\n        height={40}\r\n        priority\r\n      />\r\n    </>\r\n  ),\r\n} as const;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\dashboard-layout\\custom-email-page-item.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":13,"column":1,"nodeType":"Program","endLine":217,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Custom Email Page Item Component for Email Dashboard Layout\r\n *\r\n * This module provides the CustomEmailPageItem component used in the email dashboard\r\n * navigation sidebar. It renders email-specific navigation items with their children,\r\n * supporting both mini and full sidebar modes.\r\n *\r\n * @module components/email-message/dashboard-layout/custom-email-page-item\r\n * @version 1.0.0\r\n * @since 2025-07-19\r\n */\r\n\r\nimport { memo, useMemo } from 'react';\r\nimport { DashboardSidebarPageItem } from '@toolpad/core/DashboardLayout';\r\nimport { NavigationPageItem } from '@toolpad/core/AppProvider';\r\nimport siteBuilder from '@/lib/site-util/url-builder';\r\nimport type { CustomEmailPageItemProps } from './types';\r\nimport Box from '@mui/material/Box';\r\nimport IconButton from '@mui/material/IconButton';\r\nimport Link from '@mui/material/Link';\r\nimport NextLink from 'next/link';\r\nimport List from '@mui/material/List';\r\nimport ListItem from '@mui/material/ListItem';\r\nimport ListItemButton from '@mui/material/ListItemButton';\r\nimport ListItemIcon from '@mui/material/ListItemIcon';\r\nimport type { SxProps, Theme } from '@mui/material/styles';\r\nimport Tooltip from '@mui/material/Tooltip';\r\nimport { getLastPathSegment, normalizePath } from '@/lib/react-util/url';\r\n\r\nconst stableSx = {\r\n  activeText: {\r\n    color: 'warning.main',\r\n  } satisfies SxProps<Theme>,\r\n  primaryText: {\r\n    color: 'text.primary',\r\n  } satisfies SxProps<Theme>,\r\n  rootItemBase: {\r\n    color: 'primary.main',\r\n    overflowX: 'hidden',\r\n    paddingY: 0,\r\n  } satisfies SxProps<Theme>,\r\n  rootItemPadMini: { pl: 0 } satisfies SxProps<Theme>,\r\n  rootItemPadFull: { pl: 1 } satisfies SxProps<Theme>,\r\n  childContainerBase: {\r\n    color: 'text.primary',\r\n    overflowX: 'hidden',\r\n    paddingY: 0,\r\n    paddingRight: 0,\r\n    width: 1,\r\n  } satisfies SxProps<Theme>,\r\n  childPadMini: { pl: 0 } satisfies SxProps<Theme>,\r\n  childPadFull: { pl: 4 } satisfies SxProps<Theme>,\r\n  secondaryIcon: {\r\n    color: 'secondary.main',\r\n  } satisfies SxProps<Theme>,\r\n  link: {\r\n    color: 'warning.main',\r\n    textDecoration: 'none',\r\n    width: 1,\r\n    display: 'flex',\r\n    alignItems: 'center',\r\n    paddingRight: 0,\r\n    '&:hover': { textDecoration: 'underline' },\r\n    '&:focusVisible': {\r\n      outline: '2px solid',\r\n      outlineColor: 'primary.main',\r\n      outlineOffset: 2,\r\n    },\r\n  } satisfies SxProps<Theme>,\r\n  listReset: {\r\n    padding: 0,\r\n    margin: 0,\r\n    width: 1,\r\n  } satisfies SxProps<Theme>,\r\n  listItemButton: { pr: 0 } satisfies SxProps<Theme>,\r\n  iconBox: { maxWidth: 40, pr: 0 } satisfies SxProps<Theme>,\r\n} as const;\r\n\r\n/**\r\n * CustomEmailPageItem renders a navigation item for an email, including its children.\r\n *\r\n * @description This component creates a specialized navigation item in the email dashboard\r\n * sidebar that can display email-specific information and child navigation items.\r\n * It supports both mini (icon-only) and full sidebar modes, and handles the hierarchical\r\n * display of email navigation items.\r\n *\r\n * @component\r\n * @param props - The properties for the custom email page item\r\n * @param props.item - The navigation page item containing title, icon, and children\r\n * @param props.mini - Whether the sidebar is in mini (collapsed) mode\r\n * @param props.emailId - The ID of the email for generating navigation links\r\n * @returns A React element representing the custom email page item\r\n *\r\n * @example\r\n * ```tsx\r\n * <CustomEmailPageItem\r\n *   item={{\r\n *     title: 'View Email',\r\n *     icon: <DraftsIcon />,\r\n *     children: [\r\n *       { title: 'Key Points', segment: 'key-points', icon: <KeyIcon /> },\r\n *       { title: 'Notes', segment: 'notes', icon: <TextSnippetIcon /> }\r\n *     ]\r\n *   }}\r\n *   mini={false}\r\n *   emailId=\"email-123\"\r\n * />\r\n * ```\r\n */\r\nexport const CustomEmailPageItem = memo(\r\n  ({\r\n    item: { children = [], ...item },\r\n    mini,\r\n    pathname,\r\n    emailId,\r\n  }: CustomEmailPageItemProps): React.JSX.Element => {\r\n    const itemId = `navmenu-email-${item.title?.toLocaleLowerCase()?.replaceAll(' ', '-')}`;\r\n    const parentHref = String(\r\n      emailId && (item.title === 'View Email' || item.title === 'Email')\r\n        ? siteBuilder.messages.email(emailId)\r\n        : `/${item.segment ?? ''}`,\r\n    );\r\n    const lastSegment = useMemo(() => getLastPathSegment(pathname), [pathname]);\r\n    return (\r\n      <>\r\n        <ListItem\r\n          sx={[\r\n            stableSx.rootItemBase,\r\n            mini ? stableSx.rootItemPadMini : stableSx.rootItemPadFull,\r\n          ]}\r\n        >\r\n          {mini ? (\r\n            item.icon ? (\r\n              <Tooltip\r\n                title={item.title ?? 'Open'}\r\n                placement=\"right\"\r\n                describeChild\r\n                arrow\r\n              >\r\n                <IconButton\r\n                  aria-label={item.title ?? 'Open'}\r\n                  data-id={itemId}\r\n                  sx={stableSx.secondaryIcon}\r\n                >\r\n                  {item.icon}\r\n                </IconButton>\r\n              </Tooltip>\r\n            ) : null\r\n          ) : (\r\n            <ListItemButton sx={stableSx.listItemButton}>\r\n              <Link\r\n                data-id={itemId}\r\n                component={NextLink}\r\n                href={parentHref}\r\n                aria-current={\r\n                  normalizePath(pathname ?? '') === normalizePath(parentHref)\r\n                    ? 'page'\r\n                    : undefined\r\n                }\r\n                sx={stableSx.link}\r\n              >\r\n                {item.icon ? (\r\n                  <Box sx={stableSx.iconBox}>\r\n                    <ListItemIcon sx={stableSx.primaryText}>\r\n                      {item.icon}\r\n                    </ListItemIcon>\r\n                  </Box>\r\n                ) : null}\r\n\r\n                {item.title}\r\n              </Link>\r\n            </ListItemButton>\r\n          )}\r\n        </ListItem>\r\n        <ListItem\r\n          sx={[\r\n            stableSx.childContainerBase,\r\n            mini ? stableSx.childPadMini : stableSx.childPadFull,\r\n          ]}\r\n        >\r\n          <List\r\n            sx={stableSx.listReset}\r\n            aria-label={\r\n              item.title ? `${item.title} sections` : 'Email sections'\r\n            }\r\n          >\r\n            {children.map((child, idx) => {\r\n              const key =\r\n                'segment' in child && child.segment ? child.segment : idx;\r\n              const childSegment = typeof key === 'string' ? key : undefined;\r\n              const cleanPath = (pathname ?? '').split('?')[0].split('#')[0];\r\n              const isActive =\r\n                !!childSegment &&\r\n                (lastSegment === childSegment ||\r\n                  cleanPath.endsWith(`/${childSegment}`));\r\n              const sx = isActive ? stableSx.activeText : undefined;\r\n              return (\r\n                <Box\r\n                  key={key}\r\n                  sx={sx}\r\n                  data-active={isActive ? 'true' : undefined}\r\n                >\r\n                  <DashboardSidebarPageItem\r\n                    item={child as NavigationPageItem}\r\n                  />\r\n                </Box>\r\n              );\r\n            })}\r\n          </List>\r\n        </ListItem>\r\n      </>\r\n    );\r\n  },\r\n);\r\n\r\nCustomEmailPageItem.displayName = 'CustomEmailPageItem';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\dashboard-layout\\email-dashboard-layout.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":208,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { NextAppProvider } from '@toolpad/core/nextjs';\r\nimport {\r\n  DashboardLayout,\r\n  DashboardSidebarPageItem,\r\n} from '@toolpad/core/DashboardLayout';\r\n\r\nimport Sync from '@mui/icons-material/Sync';\r\nimport DashboardIcon from '@mui/icons-material/Dashboard';\r\nimport DraftsIcon from '@mui/icons-material/Drafts';\r\nimport ChatIcon from '@mui/icons-material/Chat';\r\nimport BarChartIcon from '@mui/icons-material/BarChart';\r\nimport { NavigationItem, NavigationPageItem } from '@toolpad/core/AppProvider';\r\nimport KeyIcon from '@mui/icons-material/Key';\r\nimport TextSnippetIcon from '@mui/icons-material/TextSnippet';\r\nimport CallToActionIcon from '@mui/icons-material/CallToAction';\r\nimport ReplyIcon from '@mui/icons-material/Reply';\r\nimport PrivacyTipIcon from '@mui/icons-material/PrivacyTip';\r\nimport { Session } from 'next-auth';\r\nimport { EmailContextProvider } from '@/components/email-message/email-context';\r\nimport { useCallback, useMemo } from 'react';\r\nimport { useParams, usePathname } from 'next/navigation';\r\nimport { useTheme } from '@/lib/themes/provider';\r\n\r\n// Import extracted components\r\nimport { CustomEmailPageItem } from './custom-email-page-item';\r\nimport { EmailDashboardToolbarAction } from './email-dashboard-toolbar-action';\r\nimport { Branding } from './branding';\r\nimport { NotificationsProvider } from '@toolpad/core';\r\nimport { KeyRefreshNotifyWrapper } from '@/components/auth/key-refresh-notify/wrapper';\r\nimport ServerSafeErrorManager from '@/components/error-boundaries/ServerSafeErrorManager';\r\n\r\n/**\r\n * Slots for the dashboard layout, such as toolbar actions.\r\n * @type {{ toolbarActions: typeof EmailDashboardToolbarAction }}\r\n */\r\nconst stableDashboardSlots = {\r\n  toolbarActions: EmailDashboardToolbarAction,\r\n};\r\nconst stableDashboardSx = {\r\n  '& > .MuiDrawer-root .MuiToolbar-gutters': {\r\n    minHeight: '82px',\r\n  },\r\n  '& > .MuiBox-root > .MuiToolbar-gutters': {\r\n    minHeight: '82px',\r\n  },\r\n};\r\n\r\n/**\r\n * Props for EmailDashboardLayout component.\r\n * @typedef {Object} EmailDashboardLayoutProps\r\n * @property {React.ReactNode} children - The child components to render inside the layout.\r\n * @property {Session | null} session - The current user session.\r\n */\r\n/**\r\n * EmailDashboardLayout is the main layout component for the email dashboard pages.\r\n * @param {EmailDashboardLayoutProps} props\r\n * @returns {JSX.Element}\r\n */\r\nexport const EmailDashboardLayout = ({\r\n  children,\r\n  session,\r\n}: {\r\n  children: React.ReactNode;\r\n  session: Session | null;\r\n}): React.JSX.Element => {\r\n  const { emailId } = useParams<{ emailId: string }>();\r\n  const pathname = usePathname();\r\n  const { theme } = useTheme();\r\n  const dashboardNavigation = useMemo<NavigationItem[]>(() => {\r\n    const isChatPage = pathname?.startsWith('/messages/chat');\r\n    const viewEmailNavigation: NavigationItem[] = emailId\r\n      ? [\r\n          {\r\n            segment: `messages/email/${emailId}`,\r\n            title: 'View Email',\r\n            icon: <DraftsIcon key=\"view-email-icon\" />,\r\n            children: [\r\n              {\r\n                segment: 'key-points',\r\n                icon: <KeyIcon key=\"key-points-icon\" />,\r\n                title: 'Key Points',\r\n              },\r\n              {\r\n                segment: 'notes',\r\n                icon: <TextSnippetIcon key=\"notes-icon\" />,\r\n                title: 'Notes',\r\n              },\r\n              {\r\n                segment: 'call-to-action',\r\n                icon: <CallToActionIcon key=\"call-to-action-icon\" />,\r\n                title: 'Calls to Action',\r\n              },\r\n              {\r\n                segment: 'call-to-action-response',\r\n                icon: <ReplyIcon key=\"call-to-action-response-icon\" />,\r\n                title: 'Follow-up Activity',\r\n              },\r\n              {\r\n                segment: 'email-header',\r\n                icon: <PrivacyTipIcon key=\"header-icon\" />,\r\n                title: 'Headers',\r\n              },\r\n            ],\r\n          },\r\n        ]\r\n      : [];\r\n    const chatNavigation: NavigationItem[] = [\r\n      {\r\n        title: 'Chat History',\r\n        icon: <ChatIcon key=\"chats-icon\" />,\r\n        segment: 'messages/chat',\r\n        children: isChatPage\r\n          ? [\r\n              {\r\n                segment: 'stats',\r\n                icon: <BarChartIcon key=\"statistics-icon\" />,\r\n                title: 'View chat statistics',\r\n              },\r\n            ]\r\n          : [],\r\n      },\r\n    ];\r\n\r\n    return [\r\n      { kind: 'header', title: 'Available Records' },\r\n      {\r\n        title: 'List Emails',\r\n        icon: <DashboardIcon key=\"list-emails-icon\" />,\r\n        segment: 'messages',\r\n      },\r\n      ...viewEmailNavigation,\r\n      { kind: 'divider' },\r\n      { kind: 'header', title: 'Chat' },\r\n      ...chatNavigation,\r\n      { kind: 'divider' },\r\n      { kind: 'header', title: 'Acquisition' },\r\n      {\r\n        segment: 'messages/import',\r\n        title: 'Import Emails',\r\n        icon: <Sync key=\"import-emails-icon\" />,\r\n      },\r\n    ];\r\n  }, [emailId, pathname]);\r\n  /**\r\n   * Renders a navigation page item in the sidebar.\r\n   * @param {NavigationPageItem} item - The navigation item to render.\r\n   * @param {{ mini: boolean }} options - Sidebar options.\r\n   * @returns {JSX.Element | null}\r\n   */\r\n  const renderPageItem = useCallback(\r\n    (\r\n      item: NavigationPageItem,\r\n      { mini }: { mini: boolean },\r\n    ): React.JSX.Element | null => {\r\n      const emailChildren = [\r\n        'key-points',\r\n        'notes',\r\n        'call-to-action',\r\n        'call-to-action-response',\r\n        'email-header',\r\n      ];\r\n      const dynamicMenus = ['View Email', 'Chat History'];\r\n      if (\r\n        'segment' in item &&\r\n        !!item.segment &&\r\n        emailChildren.includes(item.segment)\r\n      ) {\r\n        return null;\r\n      }\r\n      if (dynamicMenus.includes(item.title ?? '')) {\r\n        return (\r\n          <CustomEmailPageItem\r\n            item={item}\r\n            mini={mini}\r\n            emailId={emailId}\r\n            data-id={`navmenu-email-${item.segment}`}\r\n            pathname={pathname}\r\n          />\r\n        );\r\n      }\r\n      return <DashboardSidebarPageItem item={item} />;\r\n    },\r\n    [emailId, pathname],\r\n  );\r\n  return (\r\n    <EmailContextProvider>\r\n      <ServerSafeErrorManager />\r\n      <NextAppProvider\r\n        theme={theme}\r\n        navigation={dashboardNavigation}\r\n        branding={Branding}\r\n        session={session ?? null}\r\n      >\r\n        <DashboardLayout\r\n          renderPageItem={renderPageItem}\r\n          slots={stableDashboardSlots}\r\n          sx={stableDashboardSx}\r\n        >\r\n          <KeyRefreshNotifyWrapper />\r\n          <NotificationsProvider>{children}</NotificationsProvider>\r\n        </DashboardLayout>\r\n      </NextAppProvider>\r\n    </EmailContextProvider>\r\n  );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\dashboard-layout\\email-dashboard-toolbar-action.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":13,"column":1,"nodeType":"Program","endLine":56,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Email Dashboard Toolbar Action Component\r\n *\r\n * This module provides the EmailDashboardToolbarAction component used in the email\r\n * dashboard layout toolbar. It renders action elements like theme selector and\r\n * account controls in the dashboard header.\r\n *\r\n * @module components/email-message/dashboard-layout/email-dashboard-toolbar-action\r\n * @version 1.0.0\r\n * @since 2025-07-19\r\n */\r\n\r\nimport * as React from 'react';\r\nimport { Stack } from '@mui/material';\r\nimport { ThemeSelector } from '@/components/theme/theme-selector';\r\nimport { Account } from '@toolpad/core/Account';\r\n\r\n/**\r\n * EmailDashboardToolbarAction renders the toolbar actions for the email dashboard.\r\n *\r\n * @description This component provides the action elements displayed in the dashboard\r\n * toolbar, including the theme selector for switching between light/dark themes,\r\n * the memory status indicator for monitoring memory service health, and the\r\n * account component for user account management and authentication controls.\r\n * The elements are arranged horizontally using a Stack layout.\r\n *\r\n * @component\r\n * @returns A React element containing the toolbar actions\r\n *\r\n * @example\r\n * ```tsx\r\n * // Used as a slot in DashboardLayout\r\n * const dashboardSlots = {\r\n *   toolbarActions: EmailDashboardToolbarAction,\r\n * };\r\n *\r\n * <DashboardLayout slots={dashboardSlots}>\r\n *   {children}\r\n * </DashboardLayout>\r\n * ```\r\n *\r\n * @see {@link ThemeSelector} - Component for theme switching functionality\r\n * @see {@link MemoryStatusIndicator} - Component for memory service health monitoring\r\n * @see {@link Account} - Component for user account management\r\n */\r\nexport const EmailDashboardToolbarAction = React.memo((): React.JSX.Element => {\r\n  return (\r\n    <Stack direction=\"row\" spacing={1} alignItems=\"center\">\r\n      <ThemeSelector />\r\n      <Account />\r\n    </Stack>\r\n  );\r\n});\r\n\r\nEmailDashboardToolbarAction.displayName = 'EmailDashboardToolbarAction';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\dashboard-layout\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":14,"column":1,"nodeType":"Program","endLine":32,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Email Dashboard Layout Module Exports\r\n * \r\n * This module provides the main exports for the email dashboard layout system,\r\n * including all components, types, and configurations needed to implement\r\n * a complete email management dashboard interface.\r\n * \r\n * @module components/email-message/dashboard-layout\r\n * @version 1.0.0\r\n * @since 2025-07-19\r\n */\r\n\r\n// Main layout component\r\nexport { EmailDashboardLayout } from './email-dashboard-layout';\r\n\r\n// Sub-components\r\nexport { CustomEmailPageItem } from './custom-email-page-item';\r\nexport { EmailDashboardToolbarAction } from './email-dashboard-toolbar-action';\r\n\r\n// Configuration and branding\r\nexport { Branding } from './branding';\r\n\r\n// Type definitions\r\nexport type {\r\n  CustomEmailPageItemProps,\r\n  EmailDashboardLayoutProps,\r\n  BrandingConfig,\r\n  DashboardSlots,\r\n  RenderPageItemFunction,\r\n  RenderPageItemOptions,\r\n} from './types';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\dashboard-layout\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":13,"column":1,"nodeType":"Program","endLine":97,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Type definitions for Email Dashboard Layout components\r\n * \r\n * This module provides TypeScript interfaces and type definitions used across\r\n * the email dashboard layout system, ensuring type safety and consistency\r\n * in component props and data structures.\r\n * \r\n * @module components/email-message/dashboard-layout/types\r\n * @version 1.0.0\r\n * @since 2025-07-19\r\n */\r\n\r\nimport { NavigationPageItem } from '@toolpad/core/AppProvider';\r\nimport { Session } from 'next-auth';\r\nimport * as React from 'react';\r\n\r\n/**\r\n * Props for the CustomEmailPageItem component.\r\n * \r\n * @interface CustomEmailPageItemProps\r\n * @description Defines the properties required for rendering a custom email page item\r\n * in the dashboard navigation sidebar.\r\n */\r\nexport interface CustomEmailPageItemProps {\r\n  /** The navigation page item containing title, icon, and children */\r\n  item: NavigationPageItem;\r\n  /** Whether the sidebar is in minimized (mini) mode */\r\n  mini: boolean;\r\n  /** The unique identifier of the email being viewed */\r\n  emailId: string;\r\n  /** The active pathname  */\r\n  pathname: string;\r\n}\r\n\r\n/**\r\n * Props for the EmailDashboardLayout component.\r\n * \r\n * @interface EmailDashboardLayoutProps\r\n * @description Defines the properties required for the main email dashboard layout component.\r\n */\r\nexport interface EmailDashboardLayoutProps {\r\n  /** The child components to render inside the layout */\r\n  children: React.ReactNode;\r\n  /** The current user session information, null if not authenticated */\r\n  session: Session | null;\r\n}\r\n\r\n/**\r\n * Configuration object for dashboard branding.\r\n * \r\n * @interface BrandingConfig\r\n * @description Defines the structure for branding elements in the dashboard header.\r\n */\r\nexport interface BrandingConfig {\r\n  /** The application title displayed in the dashboard header */\r\n  title: string;\r\n  /** The logo component/element to display in the dashboard header */\r\n  logo: React.ReactElement;\r\n}\r\n\r\n/**\r\n * Slots configuration for the dashboard layout.\r\n * \r\n * @interface DashboardSlots\r\n * @description Defines the available slots that can be customized in the dashboard layout.\r\n */\r\nexport interface DashboardSlots {\r\n  /** Component to render in the toolbar actions area */\r\n  toolbarActions: React.ComponentType;\r\n}\r\n\r\n/**\r\n * Options for rendering navigation page items.\r\n * \r\n * @interface RenderPageItemOptions\r\n * @description Configuration options passed to the page item renderer function.\r\n */\r\nexport interface RenderPageItemOptions {\r\n  /** Whether the sidebar is in minimized mode */\r\n  mini: boolean;\r\n}\r\n\r\n/**\r\n * Type definition for the render page item function.\r\n * \r\n * @typedef RenderPageItemFunction\r\n * @description Function signature for custom page item rendering in the dashboard sidebar.\r\n * \r\n * @param item - The navigation page item to render\r\n * @param options - Rendering options and configuration\r\n * @returns The rendered React element or null if the item should not be rendered\r\n */\r\nexport type RenderPageItemFunction = (\r\n  item: NavigationPageItem,\r\n  options: RenderPageItemOptions\r\n) => React.JSX.Element | null;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\dashboard-layout\\url-utils.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":4,"column":1,"nodeType":"Program","endLine":16,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Normalize a path by removing trailing slashes (except root).\r\n */\r\nexport const normalizePath = (s: string): string =>\r\n  s.endsWith('/') && s !== '/' ? s.replace(/\\/+$/, '') : s;\r\n\r\n/**\r\n * Get the last path segment from a pathname, ignoring query/hash.\r\n */\r\nexport const getLastPathSegment = (pathname?: string): string | undefined => {\r\n  if (!pathname) return undefined;\r\n  const withoutQuery = pathname.split('?')[0].split('#')[0];\r\n  const parts = withoutQuery.split('/').filter(Boolean);\r\n  return parts[parts.length - 1];\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\email-context\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\email-context\\provider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\email-context\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\email-viewer\\attachments.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\email-viewer\\container.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\email-viewer\\email-body.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\email-viewer\\hooks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\email-viewer\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\email-viewer\\loading.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":7,"column":1,"nodeType":"Program","endLine":20,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Email viewer loading indicators.\r\n *\r\n * Small wrappers around the generic `Loading` component with pre-set text\r\n * for email-specific contexts, keeping call-sites concise and consistent.\r\n */\r\nimport { Loading } from '@/components/general/loading';\r\n\r\n/**\r\n * Displays a standard loading card while an email message is being fetched.\r\n */\r\nexport const LoadingEmail = () => <Loading text=\"Loading Email...\" loading />;\r\n\r\n/**\r\n * Displays a standard loading card while email attachments are being fetched.\r\n */\r\nexport const LoadingAttachments = () => (\r\n  <Loading text=\"Loading Attachments...\" loading />\r\n);\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\email-viewer\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\form.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":424,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { log } from '@/lib/logger';\r\nimport { isError } from '@/lib/react-util/utility-methods';\r\nimport {\r\n  useState,\r\n  useCallback,\r\n  Dispatch,\r\n  ChangeEvent,\r\n  forwardRef,\r\n  useImperativeHandle,\r\n  ForwardRefRenderFunction,\r\n  useId,\r\n  useEffect,\r\n} from 'react';\r\n\r\nimport { EmailMessage } from '@/data-models/api/email-message';\r\nimport ContactDropdown from '@/components/contact/contact-dropdown';\r\nimport { ContactSummary } from '@/data-models/api/contact';\r\nimport { createContactSummary } from '@/data-models/api/factories';\r\nimport { normalizeDateAndTime } from '@/data-models/_utilities';\r\nimport ContactRecipients from '../contact/contact-recipients';\r\nimport EmailSelect from './select';\r\nimport { SubmitRefCallbackInstance } from './_types';\r\nimport { useEmail, useWriteEmail } from '@/lib/hooks/use-email';\r\nimport siteMap from '@/lib/site-util/url-builder';\r\nimport { useRouter } from 'next/navigation';\r\nimport { LoggedError } from '@/lib/react-util';\r\n\r\ntype EmailFormAfterSaveBehavior = 'none' | 'redirect';\r\n\r\n/**\r\n * Props for the EmailForm component.\r\n *\r\n * @interface EmailFormProps\r\n *\r\n * @property {number} [emailId] - Optional ID of the email.\r\n * @property {(email: Partial<EmailMessage>) => void} [onSaved] - Optional callback function that is called when the email is saved.\r\n *                                                                It receives a partial EmailMessage object as an argument.\r\n */\r\ninterface EmailFormProps {\r\n  emailId: string | null;\r\n  // Note this will have to go if we stick with this architecture\r\n  onSaved?: (email: Partial<EmailMessage>) => void;\r\n  afterSaveBehavior?: EmailFormAfterSaveBehavior;\r\n  withButtons: boolean;\r\n}\r\n\r\n// Define stable style objects outside component to avoid re-renders\r\nconst stableStyles = {\r\n  container: {\r\n    maxWidth: '512px',\r\n    margin: '0 auto',\r\n    padding: '1.5rem',\r\n    borderRadius: '0.5rem',\r\n    boxShadow:\r\n      '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',\r\n  } as const,\r\n  input: {\r\n    width: '100%',\r\n    border: '1px solid #d1d5db',\r\n    borderRadius: '0.375rem',\r\n    padding: '0.5rem',\r\n    '&:focus': {\r\n      outline: 'none',\r\n      boxShadow: '0 0 0 3px rgb(59 130 246 / 0.3)',\r\n    },\r\n  } as const,\r\n  label: {\r\n    display: 'block',\r\n    fontWeight: 500,\r\n    marginBottom: '0.25rem',\r\n  } as const,\r\n  button: {\r\n    width: '100%',\r\n    padding: '0.5rem',\r\n    borderRadius: '0.375rem',\r\n    color: 'white',\r\n    transition: 'opacity 0.15s ease-in-out',\r\n    backgroundColor: '#3b82f6',\r\n    border: 'none',\r\n    cursor: 'pointer',\r\n    '&:hover': {\r\n      backgroundColor: '#2563eb',\r\n    },\r\n    '&:disabled': {\r\n      backgroundColor: '#9ca3af',\r\n      cursor: 'not-allowed',\r\n    },\r\n  } as const,\r\n  errorText: {\r\n    marginBottom: '0.5rem',\r\n    color: '#ef4444',\r\n  } as const,\r\n  formContainer: {\r\n    display: 'flex',\r\n    flexDirection: 'column',\r\n    gap: '1rem',\r\n  } as const,\r\n  title: {\r\n    marginBottom: '1rem',\r\n    fontSize: '1.25rem',\r\n    fontWeight: 600,\r\n  } as const,\r\n} as const;\r\n\r\nconst useElementUpdateDispatchCallback = <\r\n  TElementType extends HTMLElement = HTMLElement,\r\n  TDispatchType = string,\r\n>(\r\n  dispatch: Dispatch<TDispatchType>,\r\n) =>\r\n  useCallback(\r\n    (e: ChangeEvent<TElementType>) => {\r\n      if ('target' in e && 'value' in e.target) {\r\n        dispatch(e.target.value as TDispatchType);\r\n      }\r\n    },\r\n    [dispatch],\r\n  );\r\n\r\nconst EmailForm: ForwardRefRenderFunction<\r\n  SubmitRefCallbackInstance,\r\n  EmailFormProps\r\n> = (\r\n  { emailId = null, withButtons = true, onSaved, afterSaveBehavior = 'none' },\r\n  ref,\r\n) => {\r\n  const [sender, setSender] = useState<ContactSummary>(createContactSummary());\r\n  const [recipients, setRecipients] = useState<ContactSummary[]>([]);\r\n  const [subject, setSubject] = useState('');\r\n  const [emailContents, setEmailContents] = useState('');\r\n  const [sentTimestamp, setSentTimestamp] = useState('');\r\n  const [threadId, setThreadId] = useState<number | null>(null);\r\n  const [parentEmailId, setParentEmailId] = useState<string | null>(null);\r\n  const [message, setMessage] = useState('');\r\n  const { replace: routerReplace, back: routerBack } = useRouter();\r\n\r\n  // Generate unique IDs for form elements\r\n  const uniqueId = useId();\r\n\r\n  // Utility function to generate combined IDs\r\n  const generateCombinedId = (childId: string) => `${childId}-${uniqueId}`;\r\n\r\n  // Use React Query to fetch email data\r\n  const {\r\n    data: emailData,\r\n    isLoading: isLoadingEmail,\r\n    error: emailError,\r\n  } = useEmail(emailId);\r\n\r\n  // Use React Query mutation for saving email\r\n  const writeEmailMutation = useWriteEmail({\r\n    onSuccess: (result) => {\r\n      const isNewEmail = !emailId;\r\n      if (isNewEmail) {\r\n        routerReplace(siteMap.email.edit(result.emailId).toString());\r\n      } else {\r\n        switch (afterSaveBehavior) {\r\n          case 'redirect':\r\n            routerBack();\r\n            break;\r\n          case 'none':\r\n          default:\r\n            // NO-OP\r\n            break;\r\n        }\r\n      }\r\n      setMessage(`Email ${isNewEmail ? 'created' : 'updated'} successfully!`);\r\n      if (onSaved) {\r\n        onSaved({ ...result });\r\n      }\r\n    },\r\n    onError: (error) => {\r\n      const errorMessage = isError(error)\r\n        ? error.message\r\n        : 'Error saving email.';\r\n      setMessage(errorMessage);\r\n    },\r\n  });\r\n\r\n  // Update form state when email data is loaded\r\n  useEffect(() => {\r\n    if (emailData) {\r\n      setSender(emailData.sender ?? createContactSummary());\r\n      setSubject(emailData.subject);\r\n      setEmailContents(emailData.body);\r\n      setRecipients(emailData.recipients ?? []);\r\n      setSentTimestamp(\r\n        typeof emailData.sentOn === 'string'\r\n          ? emailData.sentOn\r\n          : emailData.sentOn.toISOString(),\r\n      );\r\n      setThreadId(emailData.threadId ?? null);\r\n      setParentEmailId(emailData.parentEmailId ?? null);\r\n      setMessage(''); // Clear any previous error messages\r\n    }\r\n  }, [emailData]);\r\n\r\n  // Handle loading error\r\n  useEffect(() => {\r\n    if (emailError) {\r\n      const errorMessage = isError(emailError)\r\n        ? emailError.message\r\n        : 'Error fetching email details.';\r\n      setMessage(errorMessage);\r\n    }\r\n  }, [emailError]);\r\n\r\n  // Determine if form is loading (either fetching or saving)\r\n  const isLoading = isLoadingEmail || writeEmailMutation.isPending;\r\n\r\n  const setSubjectCallback = useElementUpdateDispatchCallback(setSubject);\r\n  const setEmailContentsCallback =\r\n    useElementUpdateDispatchCallback<HTMLTextAreaElement>(setEmailContents);\r\n  const setSentTimestampCallback =\r\n    useElementUpdateDispatchCallback(setSentTimestamp);\r\n\r\n  const saveEmailCallback = useCallback(() => {\r\n    log((l) => l.debug({ message: 'Saving email...' }));\r\n    setMessage('');\r\n\r\n    const emailData = {\r\n      emailId: emailId ? emailId : undefined,\r\n      sender,\r\n      senderId: sender?.contactId,\r\n      recipients,\r\n      subject,\r\n      body: emailContents,\r\n      sentOn: sentTimestamp,\r\n      threadId,\r\n      parentEmailId,\r\n    };\r\n\r\n    return writeEmailMutation.mutateAsync(emailData).catch((error) => {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'EmailForm.saveEmailCallback',\r\n      });\r\n      return emailData;\r\n    });\r\n  }, [\r\n    emailId,\r\n    sender,\r\n    recipients,\r\n    subject,\r\n    emailContents,\r\n    sentTimestamp,\r\n    threadId,\r\n    parentEmailId,\r\n    writeEmailMutation,\r\n  ]);\r\n\r\n  const handleSubmit = useCallback(\r\n    async (e: React.MouseEvent<HTMLButtonElement>) => {\r\n      e.preventDefault();\r\n      await saveEmailCallback();\r\n    },\r\n    [saveEmailCallback],\r\n  );\r\n\r\n  useImperativeHandle(\r\n    ref,\r\n    () => ({\r\n      saveEmailCallback,\r\n    }),\r\n    [saveEmailCallback],\r\n  );\r\n\r\n  return (\r\n    <div style={stableStyles.container}>\r\n      <h2 style={stableStyles.title}>\r\n        {emailId ? 'Edit Email' : 'Create Email'}\r\n      </h2>\r\n      {message && <p style={stableStyles.errorText}>{message}</p>}\r\n      <div style={stableStyles.formContainer}>\r\n        <div>\r\n          <label\r\n            id={generateCombinedId('senderIdLabel')}\r\n            htmlFor={generateCombinedId('senderId')}\r\n            style={stableStyles.label}\r\n          >\r\n            Sent By\r\n          </label>\r\n          <ContactDropdown contact={sender} setValue={setSender} />\r\n        </div>\r\n        <div>\r\n          <label\r\n            id={generateCombinedId('recipientsIdLabel')}\r\n            htmlFor={generateCombinedId('recipientsId')}\r\n            style={stableStyles.label}\r\n          >\r\n            Recipients\r\n          </label>\r\n          <ContactRecipients\r\n            id={generateCombinedId('recipientsId')}\r\n            contacts={recipients}\r\n            onContactsUpdate={setRecipients}\r\n          />\r\n        </div>\r\n        <div>\r\n          <label\r\n            htmlFor={generateCombinedId('subject')}\r\n            id={generateCombinedId('subjectLabel')}\r\n            style={stableStyles.label}\r\n          >\r\n            Subject\r\n          </label>\r\n          <input\r\n            id={generateCombinedId('subject')}\r\n            type=\"text\"\r\n            value={subject ?? ''}\r\n            onChange={setSubjectCallback}\r\n            style={stableStyles.input}\r\n            aria-labelledby={generateCombinedId('subjectLabel')}\r\n            required\r\n          />\r\n        </div>\r\n        <div>\r\n          <label\r\n            id={generateCombinedId('sentTimestampLabel')}\r\n            htmlFor={generateCombinedId('sentTimestamp')}\r\n            style={stableStyles.label}\r\n          >\r\n            Sent Timestamp\r\n          </label>\r\n          <input\r\n            id={generateCombinedId('sentTimestamp')}\r\n            type=\"datetime-local\"\r\n            value={normalizeDateAndTime(sentTimestamp)}\r\n            onChange={setSentTimestampCallback}\r\n            style={stableStyles.input}\r\n            aria-labelledby={generateCombinedId('sentTimestampLabel')}\r\n            required\r\n          />\r\n        </div>\r\n        <div>\r\n          <label\r\n            htmlFor={generateCombinedId('parentEmailId')}\r\n            id={generateCombinedId('parentEmailIdLabel')}\r\n            style={stableStyles.label}\r\n          >\r\n            Parent Email ID (optional)\r\n          </label>\r\n          <EmailSelect\r\n            id={generateCombinedId('parentEmailId')}\r\n            selectedEmail={parentEmailId}\r\n            onEmailSelect={setParentEmailId}\r\n          />\r\n        </div>\r\n        <div>\r\n          <label\r\n            htmlFor={generateCombinedId('threadId')}\r\n            id={generateCombinedId('threadIdLabel')}\r\n            style={stableStyles.label}\r\n          >\r\n            Thread ID (updated by parent email)\r\n          </label>\r\n          <input\r\n            id={generateCombinedId('threadId')}\r\n            type=\"number\"\r\n            readOnly={true}\r\n            disabled={true}\r\n            value={threadId ?? ''}\r\n            style={stableStyles.input}\r\n            aria-labelledby={generateCombinedId('threadIdLabel')}\r\n            aria-readonly=\"true\"\r\n            aria-disabled=\"true\"\r\n          />\r\n        </div>\r\n        <div>\r\n          <label\r\n            htmlFor={generateCombinedId('emailContents')}\r\n            id={generateCombinedId('emailContentsLabel')}\r\n            style={stableStyles.label}\r\n          >\r\n            Email Contents\r\n          </label>\r\n          <textarea\r\n            id={generateCombinedId('emailContents')}\r\n            value={emailContents ?? ''}\r\n            onChange={setEmailContentsCallback}\r\n            style={stableStyles.input}\r\n            aria-labelledby={generateCombinedId('emailContentsLabel')}\r\n            required\r\n          />\r\n        </div>\r\n        {withButtons ? (\r\n          <button\r\n            type=\"button\"\r\n            data-testid=\"submit-button\"\r\n            style={stableStyles.button}\r\n            disabled={isLoading}\r\n            aria-roledescription=\"Submit Form\"\r\n            onClick={handleSubmit}\r\n          >\r\n            {writeEmailMutation.isPending\r\n              ? 'Submitting...'\r\n              : isLoadingEmail\r\n                ? 'Loading...'\r\n                : emailId\r\n                  ? 'Update Email'\r\n                  : 'Create Email'}\r\n          </button>\r\n        ) : isLoading ? (\r\n          writeEmailMutation.isPending ? (\r\n            'Submitting...'\r\n          ) : isLoadingEmail ? (\r\n            'Loading...'\r\n          ) : (\r\n            ''\r\n          )\r\n        ) : emailId ? (\r\n          'Update Email'\r\n        ) : (\r\n          'Create Email'\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default forwardRef(EmailForm);\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\list\\email-detail-panel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\list\\index.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":248,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\nimport {\r\n  JSX,\r\n  useMemo,\r\n  useCallback,\r\n  MouseEvent as ReactMouseEvent,\r\n} from 'react';\r\nimport { ServerBoundDataGrid } from '@/components/mui/data-grid/server-bound-data-grid';\r\nimport siteMap from '@/lib/site-util/url-builder';\r\nimport { Box } from '@mui/material';\r\nimport { EmailGridProps } from '@/components/mui/data-grid/types';\r\nimport {\r\n  GridCallbackDetails,\r\n  GridColDef,\r\n  GridRowParams,\r\n  MuiEvent,\r\n  DataGridProProps,\r\n} from '@mui/x-data-grid-pro';\r\nimport { ContactSummary } from '@/data-models/api/contact';\r\nimport { EmailMessageSummary } from '@/data-models/api/email-message';\r\nimport AttachEmailIcon from '@mui/icons-material/AttachEmail';\r\nimport KeyIcon from '@mui/icons-material/Key';\r\nimport TextSnippetIcon from '@mui/icons-material/TextSnippet';\r\nimport CallToActionIcon from '@mui/icons-material/CallToAction';\r\nimport { useRouter } from 'next/navigation';\r\nimport NextLink from 'next/link';\r\nimport Link from '@mui/material/Link';\r\nimport type { SxProps, Theme } from '@mui/material/styles';\r\nimport EmailDetailPanel from './email-detail-panel';\r\nimport { usePrefetchEmail } from '@/lib/hooks/use-email';\r\n\r\nconst stableSx = {\r\n  containerBase: {\r\n    display: 'flex',\r\n    flexDirection: 'column',\r\n    width: 1,\r\n  } satisfies SxProps<Theme>,\r\n  subjectLink: {\r\n    color: 'primary.main',\r\n    textDecoration: 'none',\r\n    '&:hover': { textDecoration: 'underline' },\r\n    '&:focusVisible': {\r\n      outline: '2px solid',\r\n      outlineColor: 'primary.main',\r\n      outlineOffset: 2,\r\n    },\r\n  } satisfies SxProps<Theme>,\r\n} as const;\r\n\r\n/**\r\n * Defines the column configuration for the email message list grid.\r\n *\r\n * Each column is represented as a `GridColDef` object specifying:\r\n * - `field`: The property name in the data source.\r\n * - `headerName`: The display name for the column header.\r\n * - `editable`: Whether the column is editable by the user.\r\n *\r\n * Columns included:\r\n * - `sender`: Displays the sender of the email.\r\n * - `subject`: Displays the subject of the email.\r\n * - `sentDate`: Displays the date the email was sent.\r\n */\r\nconst createColumns = (\r\n  prefetchEmail: (emailId: string) => void,\r\n): GridColDef<EmailMessageSummary>[] => [\r\n  {\r\n    field: 'count_attachments',\r\n    headerName: 'Attachments',\r\n    description: '# attachments',\r\n    renderHeader: () => <AttachEmailIcon fontSize=\"small\" />,\r\n    valueFormatter: (v: number) => (v ? v : ''),\r\n    width: 30,\r\n    minWidth: 48,\r\n    headerAlign: 'center',\r\n    align: 'center',\r\n    type: 'number',\r\n  },\r\n  {\r\n    field: 'threadId',\r\n    headerName: 'Thread',\r\n    editable: false,\r\n    width: 20,\r\n    minWidth: 56,\r\n    headerAlign: 'center',\r\n    align: 'center',\r\n  },\r\n  {\r\n    field: 'sender',\r\n    headerName: 'From',\r\n    editable: false,\r\n    flex: 0.2,\r\n    valueGetter: (sender: ContactSummary) => {\r\n      return sender ? sender.name : 'Unknown';\r\n    },\r\n  },\r\n  {\r\n    field: 'subject',\r\n    headerName: 'Subject',\r\n    editable: false,\r\n    flex: 1,\r\n    renderCell: (params) => {\r\n      return params.value ? (\r\n        <Link\r\n          onMouseEnter={() => prefetchEmail(params.row.emailId)}\r\n          component={NextLink}\r\n          href={siteMap.messages.email(params.row.emailId).toString()}\r\n          title=\"Open email message\"\r\n          aria-label={\r\n            params.value ? `Open email: ${params.value}` : 'Open email'\r\n          }\r\n          sx={stableSx.subjectLink}\r\n        >\r\n          {params.value}\r\n        </Link>\r\n      ) : (\r\n        <></>\r\n      );\r\n    },\r\n  },\r\n  {\r\n    field: 'count_kpi',\r\n    description: '# KPI',\r\n    renderHeader: () => <KeyIcon fontSize=\"small\" />,\r\n    valueFormatter: (v: number) => (v ? v : '-'),\r\n    width: 10,\r\n    minWidth: 56,\r\n    headerAlign: 'center',\r\n    align: 'center',\r\n    type: 'number',\r\n  },\r\n  {\r\n    field: 'count_notes',\r\n    description: '# Notes',\r\n    renderHeader: () => <TextSnippetIcon fontSize=\"small\" />,\r\n    valueFormatter: (v: number) => (v ? v : '-'),\r\n    width: 10,\r\n    minWidth: 56,\r\n    headerAlign: 'center',\r\n    align: 'center',\r\n    type: 'number',\r\n  },\r\n  {\r\n    field: 'count_cta',\r\n    description: '# CTA',\r\n    renderHeader: () => <CallToActionIcon fontSize=\"small\" />,\r\n    valueGetter: (v: number, row: EmailMessageSummary) => {\r\n      return (v ?? 0) + (row.count_responsive_actions ?? 0);\r\n    },\r\n    valueFormatter: (v: number) => (v ? v : '-'),\r\n    width: 10,\r\n    minWidth: 56,\r\n    headerAlign: 'center',\r\n    align: 'center',\r\n    type: 'number',\r\n  },\r\n  {\r\n    field: 'sentOn',\r\n    headerName: 'Sent',\r\n    editable: false,\r\n    width: 160,\r\n    type: 'date',\r\n    valueGetter: (v: string | Date) => {\r\n      return v ? new Date(v) : v;\r\n    },\r\n    valueFormatter: (v: Date) => {\r\n      if (isNaN(v.getTime())) return '';\r\n      const mm = String(v.getMonth() + 1).padStart(2, '0');\r\n      const dd = String(v.getDate()).padStart(2, '0');\r\n      const yyyy = v.getFullYear();\r\n      return `${mm}/${dd}/${yyyy}`;\r\n    },\r\n  },\r\n];\r\n\r\n/**\r\n * Displays a list of email messages in a data grid with columns for sender, subject, and sent date.\r\n *\r\n * @param {EmailGridProps} props - Props for configuring the email data grid.\r\n * @param {number | string | undefined} [maxHeight] - Optional maximum height for the grid container.\r\n * @returns {JSX.Element} The rendered email list component.\r\n *\r\n * @remarks\r\n * - Uses a server-bound data grid to fetch and display email data.\r\n * - Columns are fixed and non-editable.\r\n * - The grid fetches data from the email API endpoint defined in the site map.\r\n */\r\nexport const EmailList = ({\r\n  maxHeight = undefined,\r\n  onRowDoubleClick: onRowDoubleClickProps,\r\n  ...props\r\n}: EmailGridProps): JSX.Element => {\r\n  const containerSx = useMemo(\r\n    () => ({\r\n      maxHeight,\r\n    }),\r\n    [maxHeight],\r\n  );\r\n  const { push } = useRouter();\r\n  const prefetchEmail = usePrefetchEmail();\r\n\r\n  const onRowDoubleClick = useCallback(\r\n    (\r\n      params: GridRowParams<EmailMessageSummary>,\r\n      event: MuiEvent<ReactMouseEvent<HTMLElement, MouseEvent>>,\r\n      details: GridCallbackDetails,\r\n    ) => {\r\n      if (onRowDoubleClickProps) {\r\n        onRowDoubleClickProps(params, event, details);\r\n      }\r\n      if (!event.isPropagationStopped()) {\r\n        const emailId = params.row.emailId;\r\n        if (emailId) {\r\n          push(siteMap.messages.email(emailId).toString());\r\n        }\r\n      }\r\n    },\r\n    [onRowDoubleClickProps, push],\r\n  );\r\n\r\n  // Add detail panel support\r\n  const getDetailPanelContent = useCallback<\r\n    NonNullable<DataGridProProps['getDetailPanelContent']>\r\n  >(({ row }) => <EmailDetailPanel row={row} />, []);\r\n\r\n  const getDetailPanelHeight = useCallback(() => 'auto', []);\r\n\r\n  // Create columns with prefetching capability\r\n  const columns = useMemo(() => createColumns(prefetchEmail), [prefetchEmail]);\r\n\r\n  return (\r\n    <>\r\n      <Box sx={[stableSx.containerBase, containerSx]}>\r\n        <ServerBoundDataGrid<EmailMessageSummary>\r\n          {...props}\r\n          columns={columns}\r\n          url={siteMap.api.email.url}\r\n          idColumn=\"emailId\"\r\n          onRowDoubleClick={onRowDoubleClick}\r\n          getDetailPanelContent={getDetailPanelContent}\r\n          getDetailPanelHeight={getDetailPanelHeight}\r\n        />\r\n      </Box>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default EmailList;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\email-message\\select.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\error-boundaries\\ClientErrorManager.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":453,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport {\r\n  useEffect,\r\n  useState,\r\n  useRef,\r\n  useCallback,\r\n  SetStateAction,\r\n  Dispatch,\r\n} from 'react';\r\nimport { errorReporter, ErrorSeverity } from '@/lib/error-monitoring';\r\nimport {\r\n  asErrorLike,\r\n  ErrorLike,\r\n  isErrorLike,\r\n  StringOrErrorLike,\r\n} from '@/lib/react-util/errors/error-like';\r\n\r\n/**\r\n * Configuration for error suppression patterns\r\n */\r\nexport interface ErrorSuppressionRule {\r\n  /** Unique identifier for this rule */\r\n  id: string;\r\n  /** Pattern to match against error messages (string contains or regex) */\r\n  pattern: string | RegExp;\r\n  /** Optional: match against error source/filename */\r\n  source?: string | RegExp;\r\n  /** Whether to completely suppress (no logging) or just prevent UI display */\r\n  suppressCompletely?: boolean;\r\n  /** Description of why this error is suppressed */\r\n  reason?: string;\r\n}\r\n\r\n/**\r\n * Configuration for ClientErrorManager\r\n */\r\nexport interface ClientErrorManagerConfig {\r\n  /** Array of error suppression rules */\r\n  suppressionRules?: ErrorSuppressionRule[];\r\n  /** Whether to surface non-suppressed errors to React error boundaries */\r\n  surfaceToErrorBoundary?: boolean;\r\n  /** Whether to report suppressed errors (with low severity) */\r\n  reportSuppressedErrors?: boolean;\r\n  /** Debounce time for duplicate errors (ms) */\r\n  debounceMs?: number;\r\n}\r\n\r\n/**\r\n * Default suppression rules for common known issues\r\n */\r\nconst DEFAULT_SUPPRESSION_RULES: ErrorSuppressionRule[] = [\r\n  {\r\n    id: 'ai-content-blob-error',\r\n    pattern: /AI \\(Internal\\): 102 message/i,\r\n    suppressCompletely: true,\r\n    reason: 'Known AI service issue that does not affect functionality',\r\n  },\r\n  {\r\n    id: 'script-load-errors',\r\n    pattern: /Loading chunk \\d+ failed/i,\r\n    source: /chunk/i,\r\n    suppressCompletely: false,\r\n    reason: 'Chunk loading failures should be logged but not displayed',\r\n  },\r\n  {\r\n    id: 'extension-errors',\r\n    pattern: /extension|chrome-extension|moz-extension/i,\r\n    suppressCompletely: true,\r\n    reason: 'Browser extension errors not related to our application',\r\n  },\r\n];\r\n\r\n/**\r\n * Normalize error messages by removing repeating 'Uncaught ' prefixes\r\n * Example: 'Uncaught Uncaught Uncaught [object] test Uncaught' -> '[object] test Uncaught'\r\n */\r\nconst normalizeErrorMessage = (message: string): string => {\r\n  // Remove repeating 'Uncaught ' at the beginning of the string\r\n  return message.replace(/^(?:Uncaught\\s+)+/g, '');\r\n};\r\n\r\nconst normalizeDebounceKey = (key: string) => {\r\n  // Normalize the key by removing repeating 'Uncaught ' prefixes\r\n  return normalizeErrorMessage(key).toLowerCase().trim();\r\n};\r\n\r\ntype SuppressionResult = {\r\n  suppress: boolean;\r\n  rule?: ErrorSuppressionRule;\r\n  completely?: boolean;\r\n};\r\n\r\nconst shouldSuppressError = ({\r\n  error,\r\n  suppressionRules,\r\n}: {\r\n  error: ErrorLike;\r\n  suppressionRules: ErrorSuppressionRule[];\r\n}): SuppressionResult => {\r\n  const testMatch = (pattern: string | RegExp, value: string): boolean => {\r\n    return (\r\n      !!value &&\r\n      (typeof pattern === 'string'\r\n        ? value.includes(pattern)\r\n        : pattern.test(value))\r\n    );\r\n  };\r\n  const errorMessage = normalizeErrorMessage(error.message);\r\n  const errorSource = error.source;\r\n  const matchedRule = suppressionRules.find((rule) => {\r\n    // Check if the error message matches the rule pattern\r\n    const messageMatches = testMatch(rule.pattern, errorMessage);\r\n    if (!messageMatches) {\r\n      return false;\r\n    }\r\n    // If rule contains a source then it must match as well\r\n    if (rule.source) {\r\n      const sourceMatches = testMatch(rule.source, errorSource || '');\r\n      if (!sourceMatches) {\r\n        return false;\r\n      }\r\n    }\r\n    // If we reach here, the rule is a match.\r\n    return true;\r\n  });\r\n  return matchedRule\r\n    ? {\r\n        suppress: true,\r\n        rule: matchedRule,\r\n        completely: matchedRule.suppressCompletely,\r\n      }\r\n    : { suppress: false };\r\n};\r\n\r\nclass LastErrorMap {\r\n  #lastErrorTime: Map<string, number>;\r\n  #lastErrorKeys: Map<string, Array<string>>;\r\n\r\n  constructor() {\r\n    this.#lastErrorTime = new Map();\r\n    this.#lastErrorKeys = new Map();\r\n  }\r\n  lastErrorAt(\r\n    error: StringOrErrorLike,\r\n    allowLooseMatch = true,\r\n  ): number | undefined {\r\n    const errorKey = LastErrorMap.makeErrorKey(error);\r\n    let ret = this.#lastErrorTime.get(errorKey);\r\n    if (ret === undefined && allowLooseMatch) {\r\n      // Try to find a loose match if exact key not found\r\n      for (const [key, time] of this.#lastErrorTime.entries()) {\r\n        if (time > (ret ?? 0) && key.includes(errorKey)) {\r\n          ret = time;\r\n          continue;\r\n        }\r\n      }\r\n    }\r\n    return ret;\r\n  }\r\n\r\n  add(error: StringOrErrorLike, now: number): void {\r\n    const errorKey = LastErrorMap.makeErrorKey(error);\r\n    this.#lastErrorTime.set(errorKey, now);\r\n    const messagePart = errorKey.split(LastErrorMap.KeyDelimiter)[0];\r\n    const errorKeys = this.#lastErrorKeys.get(messagePart) || [];\r\n    if (!errorKeys.includes(errorKey)) {\r\n      errorKeys.push(errorKey);\r\n      this.#lastErrorKeys.set(messagePart, errorKeys);\r\n    }\r\n  }\r\n  /**\r\n   * Check if this error should be debounced (duplicate within time window)\r\n   */\r\n  shouldDebounce(error: StringOrErrorLike, debounceMs: number): boolean {\r\n    const now = Date.now();\r\n    const lastTime = this.lastErrorAt(error);\r\n    this.add(error, now);\r\n    return !!lastTime && now - lastTime < debounceMs;\r\n  }\r\n\r\n  static makeErrorKey(\r\n    error: StringOrErrorLike,\r\n    filename?: string,\r\n    [line = 0, column = 0]: [number, number] = [0, 0],\r\n  ): string {\r\n    let errorMessage: string;\r\n    let errorSource: string;\r\n    if (isErrorLike(error)) {\r\n      // TODO: if line/column is empty we could theoretically try to pull it out of the stack\r\n      errorMessage = error.message;\r\n      errorSource = filename ?? error.stack ?? '';\r\n    } else {\r\n      errorMessage = error;\r\n      errorSource = filename ?? '';\r\n    }\r\n    const theColumn = column > 0 ? `-${column}` : '';\r\n    const lineAndColumn = line > 0 ? String(line) + theColumn : theColumn;\r\n    return normalizeDebounceKey(\r\n      normalizeErrorMessage(errorMessage) +\r\n        LastErrorMap.KeyDelimiter +\r\n        errorSource +\r\n        LastErrorMap.KeyDelimiter +\r\n        lineAndColumn,\r\n    );\r\n  }\r\n\r\n  static readonly KeyDelimiter = '~~-~~';\r\n}\r\n\r\nconst processError = ({\r\n  errorObj,\r\n  lastErrorMap,\r\n  suppressionRules,\r\n  reportSuppressedErrors,\r\n  surfaceToErrorBoundary,\r\n  debounceMs,\r\n  setErrorToThrow,\r\n}: {\r\n  errorObj: ErrorLike;\r\n  lastErrorMap: LastErrorMap;\r\n  suppressionRules: ErrorSuppressionRule[];\r\n  reportSuppressedErrors: boolean;\r\n  surfaceToErrorBoundary: boolean;\r\n  debounceMs: number;\r\n  setErrorToThrow: Dispatch<SetStateAction<Error | null>>;\r\n}): boolean => {\r\n  // Should the error be debounced?\r\n  if (lastErrorMap.shouldDebounce(errorObj, debounceMs)) {\r\n    return false;\r\n  }\r\n  // Should the error be suppressed?\r\n  const suppressionResult = shouldSuppressError({\r\n    error: errorObj,\r\n    suppressionRules,\r\n  });\r\n  // Process a suppressed result\r\n  if (suppressionResult.suppress) {\r\n    // Log suppressed errors with low severity if configured\r\n    if (reportSuppressedErrors && !suppressionResult.completely) {\r\n      errorReporter.reportError(errorObj, ErrorSeverity.LOW, {\r\n        source: errorObj.source,\r\n        breadcrumbs: ['global-error-suppressed'],\r\n        additionalData: {\r\n          suppression_rule: suppressionResult.rule?.id,\r\n          suppression_reason: suppressionResult.rule?.reason,\r\n          lineno: errorObj.line,\r\n          colno: errorObj.column,\r\n        },\r\n      });\r\n    }\r\n    return false;\r\n  }\r\n  // Report non-suppressed errors\r\n  errorReporter.reportError(errorObj, ErrorSeverity.HIGH, {\r\n    source: errorObj.source,\r\n    breadcrumbs: ['global-error-handler'],\r\n    additionalData: {\r\n      type: 'javascript-error',\r\n      lineno: errorObj.line,\r\n      colno: errorObj.column,\r\n    },\r\n  });\r\n  // If we are surfacing to a parent boundary then we don't want to log (avoid duplicate logs)\r\n  if (surfaceToErrorBoundary) {\r\n    // Surface to React error boundary if configured\r\n    setErrorToThrow(errorObj);\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * ClientErrorManager component that catches errors outside of React's render cycle\r\n * and surfaces them to the nearest error boundary while allowing suppression of known issues.\r\n */\r\nexport const ClientErrorManager = ({\r\n  suppressionRules = DEFAULT_SUPPRESSION_RULES,\r\n  surfaceToErrorBoundary = true,\r\n  reportSuppressedErrors = false,\r\n  debounceMs = 1000,\r\n}: ClientErrorManagerConfig = {}) => {\r\n  const [errorToThrow, setErrorToThrow] = useState<ErrorLike | null>(null);\r\n  const lastErrorMap = useRef<LastErrorMap>(new LastErrorMap());\r\n  const isInitialized = useRef(false);\r\n\r\n  /**\r\n   * Check if an error should be suppressed based on configured rules\r\n  \r\n  const shouldSuppressError = useCallback((\r\n    error: ErrorLike | string,\r\n    source?: string,\r\n    lineno?: number, // eslint-disable-line @typescript-eslint/no-unused-vars\r\n    colno?: number   // eslint-disable-line @typescript-eslint/no-unused-vars\r\n  ): { suppress: boolean; rule?: ErrorSuppressionRule; completely?: boolean } => {\r\n    const likeError = asErrorLike(error)!;\r\n    const errorMessage = likeError.message;\r\n    const errorSource = source || '';\r\n\r\n    for (const rule of suppressionRules) {\r\n      // Check message pattern\r\n      const messageMatches = typeof rule.pattern === 'string'\r\n        ? errorMessage.includes(rule.pattern)\r\n        : rule.pattern.test(errorMessage);\r\n\r\n      if (!messageMatches) continue;\r\n\r\n      // Check source pattern if specified\r\n      if (rule.source) {\r\n        const sourceMatches = typeof rule.source === 'string'\r\n          ? errorSource.includes(rule.source)\r\n          : rule.source.test(errorSource);\r\n        \r\n        if (!sourceMatches) continue;\r\n      }\r\n\r\n      return {\r\n        suppress: true,\r\n        rule,\r\n        completely: rule.suppressCompletely,\r\n      };\r\n    }\r\n\r\n    return { suppress: false };\r\n  }, [suppressionRules]);\r\n */\r\n\r\n  /**\r\n   * Handle global JavaScript errors\r\n   */\r\n  const handleGlobalError = useCallback(\r\n    (event: ErrorEvent) => {\r\n      // Safely extract properties from event\r\n      const errorObj = asErrorLike(event.error ? event.error : event.message, {\r\n        filename: event.filename || 'unknown',\r\n        lineno: event.lineno || 0,\r\n        colno: event.colno || 0,\r\n      });\r\n      if (errorObj) {\r\n        if (\r\n          !processError({\r\n            errorObj,\r\n            lastErrorMap: lastErrorMap.current,\r\n            suppressionRules,\r\n            reportSuppressedErrors,\r\n            surfaceToErrorBoundary,\r\n            debounceMs,\r\n            setErrorToThrow,\r\n          })\r\n        ) {\r\n          // Error was suppressed\r\n          event.preventDefault();\r\n        }\r\n      }\r\n    },\r\n    [\r\n      debounceMs,\r\n      suppressionRules,\r\n      surfaceToErrorBoundary,\r\n      reportSuppressedErrors,\r\n    ],\r\n  );\r\n\r\n  /**\r\n   * Handle unhandled promise rejections\r\n   */\r\n  const handleUnhandledRejection = useCallback(\r\n    (event: PromiseRejectionEvent) => {\r\n      const error = asErrorLike(event.reason);\r\n      if (error) {\r\n        processError({\r\n          errorObj: error,\r\n          lastErrorMap: lastErrorMap.current,\r\n          suppressionRules,\r\n          setErrorToThrow,\r\n          reportSuppressedErrors,\r\n          surfaceToErrorBoundary,\r\n          debounceMs,\r\n        });\r\n      }\r\n    },\r\n    [\r\n      suppressionRules,\r\n      reportSuppressedErrors,\r\n      surfaceToErrorBoundary,\r\n      debounceMs,\r\n    ],\r\n  );\r\n\r\n  // Set up global error listeners\r\n  useEffect(() => {\r\n    if (isInitialized.current) return;\r\n\r\n    window.addEventListener('error', handleGlobalError);\r\n    window.addEventListener('unhandledrejection', handleUnhandledRejection);\r\n\r\n    isInitialized.current = true;\r\n\r\n    return () => {\r\n      window.removeEventListener('error', handleGlobalError);\r\n      window.removeEventListener(\r\n        'unhandledrejection',\r\n        handleUnhandledRejection,\r\n      );\r\n      isInitialized.current = false;\r\n    };\r\n  }, [handleGlobalError, handleUnhandledRejection]);\r\n\r\n  // Throw error in React's render cycle to trigger error boundary\r\n  useEffect(() => {\r\n    if (errorToThrow) {\r\n      // Clear the error state first to prevent infinite loops\r\n      setErrorToThrow(null);\r\n\r\n      // Throw in next tick to ensure it's caught by error boundary\r\n      setTimeout(() => {\r\n        throw errorToThrow;\r\n      }, 0);\r\n    }\r\n  }, [errorToThrow]);\r\n\r\n  // This component renders nothing\r\n  return null;\r\n};\r\n\r\n/**\r\n * Utility function to create custom suppression rules\r\n */\r\nexport function createSuppressionRule(\r\n  id: string,\r\n  pattern: string | RegExp,\r\n  options: Partial<Omit<ErrorSuppressionRule, 'id' | 'pattern'>> = {},\r\n): ErrorSuppressionRule {\r\n  return {\r\n    id,\r\n    pattern,\r\n    ...options,\r\n  };\r\n}\r\n\r\n/**\r\n * Hook to add a suppression rule dynamically\r\n */\r\nexport function useErrorSuppression(rules: ErrorSuppressionRule[]) {\r\n  useEffect(() => {\r\n    // This would require a global error manager instance\r\n    // For now, just log that rules were added\r\n    console.debug(\r\n      'Added error suppression rules:',\r\n      rules.map((r) => r.id),\r\n    );\r\n  }, [rules]);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\error-boundaries\\ErrorManagerProvider.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":60,"endColumn":2}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport dynamic from 'next/dynamic';\r\nimport type { ClientErrorManagerConfig } from './ClientErrorManager';\r\n\r\n// Dynamically import ClientErrorManager with SSR disabled\r\nconst ClientErrorManager = dynamic(\r\n  () => import('./ClientErrorManager').then(mod => ({ default: mod.ClientErrorManager })),\r\n  { \r\n    ssr: false,\r\n    loading: () => null, // No loading component needed\r\n  }\r\n);\r\n\r\n/**\r\n * Provider wrapper for ClientErrorManager that can be safely used in server components\r\n * without causing them to become client components\r\n */\r\nexport function ErrorManagerProvider(props: ClientErrorManagerConfig) {\r\n  return <ClientErrorManager {...props} />;\r\n}\r\n\r\n/**\r\n * Default error manager with common configuration\r\n */\r\nexport function DefaultErrorManager() {\r\n  return (\r\n    <ErrorManagerProvider\r\n      surfaceToErrorBoundary={true}\r\n      reportSuppressedErrors={false}\r\n      debounceMs={1000}\r\n    />\r\n  );\r\n}\r\n\r\n/**\r\n * Error manager specifically configured for development\r\n */\r\nexport function DevErrorManager() {\r\n  return (\r\n    <ErrorManagerProvider\r\n      surfaceToErrorBoundary={true}\r\n      reportSuppressedErrors={true} // Show suppressed errors in dev\r\n      debounceMs={500}\r\n    />\r\n  );\r\n}\r\n\r\n/**\r\n * Error manager specifically configured for production\r\n */\r\nexport function ProdErrorManager() {\r\n  return (\r\n    <ErrorManagerProvider\r\n      surfaceToErrorBoundary={true}\r\n      reportSuppressedErrors={false}\r\n      debounceMs={2000} // Longer debounce in production\r\n    />\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\error-boundaries\\ServerSafeErrorManager.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":73,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import dynamic from 'next/dynamic';\r\nimport type { ClientErrorManagerConfig } from './ClientErrorManager';\r\n\r\n/**\r\n * Server-safe error manager that can be imported into server components\r\n * without causing them to become client components\r\n */\r\nconst ServerSafeErrorManager = dynamic(\r\n  () =>\r\n    import('./ErrorManagerProvider').then((mod) => ({\r\n      default: mod.DefaultErrorManager,\r\n    })),\r\n  {\r\n    ssr: true,\r\n    loading: () => null,\r\n  },\r\n);\r\n\r\n/**\r\n * Server-safe error manager with custom configuration\r\n */\r\nconst ConfigurableServerSafeErrorManager = dynamic(\r\n  () =>\r\n    import('./ErrorManagerProvider').then((mod) => ({\r\n      default: mod.ErrorManagerProvider,\r\n    })),\r\n  {\r\n    ssr: true,\r\n    loading: () => null,\r\n  },\r\n);\r\n\r\n/**\r\n * Development-specific error manager (shows more details)\r\n */\r\nconst DevServerSafeErrorManager = dynamic(\r\n  () =>\r\n    import('./ErrorManagerProvider').then((mod) => ({\r\n      default: mod.DevErrorManager,\r\n    })),\r\n  {\r\n    ssr: true,\r\n    loading: () => null,\r\n  },\r\n);\r\n\r\n/**\r\n * Production-specific error manager (more conservative)\r\n */\r\nconst ProdServerSafeErrorManager = dynamic(\r\n  () =>\r\n    import('./ErrorManagerProvider').then((mod) => ({\r\n      default: mod.ProdErrorManager,\r\n    })),\r\n  {\r\n    ssr: true,\r\n    loading: () => null,\r\n  },\r\n);\r\n\r\n// Default export for easy importing\r\nexport default ServerSafeErrorManager;\r\n\r\n// Named exports for specific configurations\r\nexport {\r\n  ConfigurableServerSafeErrorManager as ConfigurableErrorManager,\r\n  DevServerSafeErrorManager as DevErrorManager,\r\n  ProdServerSafeErrorManager as ProdErrorManager,\r\n};\r\n\r\n// Export config type for TypeScript\r\nexport type { ClientErrorManagerConfig as ErrorManagerConfig };\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\error-boundaries\\default-suppression-rules.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":27,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { ErrorSuppressionRule } from './types';\r\n\r\n/**\r\n * Default suppression rules for common known issues\r\n */\r\nexport const DEFAULT_SUPPRESSION_RULES: ErrorSuppressionRule[] = [\r\n  {\r\n    id: 'ai-content-blob-error',\r\n    pattern: /AI \\(Internal\\): 102 message/i,\r\n    suppressCompletely: true,\r\n    reason: 'Known AI service issue that does not affect functionality',\r\n  },\r\n  {\r\n    id: 'script-load-errors',\r\n    pattern: /Loading chunk \\d+ failed/i,\r\n    source: /chunk/i,\r\n    suppressCompletely: false,\r\n    reason: 'Chunk loading failures should be logged but not displayed',\r\n  },\r\n  {\r\n    id: 'extension-errors',\r\n    pattern: /extension|chrome-extension|moz-extension/i,\r\n    suppressCompletely: true,\r\n    reason: 'Browser extension errors not related to our application',\r\n  },\r\n];\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\error-boundaries\\defaultErrorBoundary.tsx","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":7,"column":68,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":7,"endColumn":70,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[317,319],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[317,319],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\error-boundaries\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":6,"column":1,"nodeType":"Program","endLine":35,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Error boundary and error management system exports\r\n */\r\n\r\n// Main error boundary fallback component\r\nexport { RenderErrorBoundaryFallback } from './renderFallback';\r\n\r\n// Client-side error management\r\nexport { ClientErrorManager } from './ClientErrorManager';\r\nexport type { ClientErrorManagerConfig, ErrorSuppressionRule } from './types';\r\nexport {\r\n  createSuppressionRule,\r\n  useErrorSuppression,\r\n} from './ClientErrorManager';\r\n\r\n// Server-safe error managers for use in server components\r\nexport { default as ErrorManager } from './ServerSafeErrorManager';\r\nexport {\r\n  ConfigurableErrorManager,\r\n  DevErrorManager,\r\n  ProdErrorManager,\r\n} from './ServerSafeErrorManager';\r\nexport type { ErrorManagerConfig } from './ServerSafeErrorManager';\r\n\r\n// Provider components\r\nexport {\r\n  ErrorManagerProvider,\r\n  DefaultErrorManager,\r\n  DevErrorManager as DevErrorManagerClient,\r\n  ProdErrorManager as ProdErrorManagerClient,\r\n} from './ErrorManagerProvider';\r\n\r\n// HOC and wrapper components\r\n// export { withErrorBoundary, ErrorBoundaryWrapper } from './with-error-boundary';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\error-boundaries\\last-error-map.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":81,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  isErrorLike,\r\n  StringOrErrorLike,\r\n} from '@/lib/react-util/errors/error-like';\r\nimport { normalizeDebounceKey, normalizeErrorMessage } from './utility';\r\n\r\nexport class LastErrorMap {\r\n  #lastErrorTime: Map<string, number>;\r\n  #lastErrorKeys: Map<string, Array<string>>;\r\n\r\n  constructor() {\r\n    this.#lastErrorTime = new Map();\r\n    this.#lastErrorKeys = new Map();\r\n  }\r\n  lastErrorAt(\r\n    error: StringOrErrorLike,\r\n    allowLooseMatch = true,\r\n  ): number | undefined {\r\n    const errorKey = LastErrorMap.makeErrorKey(error);\r\n    let ret = this.#lastErrorTime.get(errorKey);\r\n    if (ret === undefined && allowLooseMatch) {\r\n      // Try to find a loose match if exact key not found\r\n      for (const [key, time] of this.#lastErrorTime.entries()) {\r\n        if (time > (ret ?? 0) && key.includes(errorKey)) {\r\n          ret = time;\r\n          continue;\r\n        }\r\n      }\r\n    }\r\n    return ret;\r\n  }\r\n\r\n  add(error: StringOrErrorLike, now: number): void {\r\n    const errorKey = LastErrorMap.makeErrorKey(error);\r\n    this.#lastErrorTime.set(errorKey, now);\r\n    const messagePart = errorKey.split(LastErrorMap.KeyDelimiter)[0];\r\n    const errorKeys = this.#lastErrorKeys.get(messagePart) || [];\r\n    if (!errorKeys.includes(errorKey)) {\r\n      errorKeys.push(errorKey);\r\n      this.#lastErrorKeys.set(messagePart, errorKeys);\r\n    }\r\n  }\r\n  /**\r\n   * Check if this error should be debounced (duplicate within time window)\r\n   */\r\n  shouldDebounce(error: StringOrErrorLike, debounceMs: number): boolean {\r\n    const now = Date.now();\r\n    const lastTime = this.lastErrorAt(error);\r\n    this.add(error, now);\r\n    return !!lastTime && now - lastTime < debounceMs;\r\n  }\r\n\r\n  static makeErrorKey(\r\n    error: StringOrErrorLike,\r\n    filename?: string,\r\n    [line = 0, column = 0]: [number, number] = [0, 0],\r\n  ): string {\r\n    let errorMessage: string;\r\n    let errorSource: string;\r\n    if (isErrorLike(error)) {\r\n      // TODO: if line/column is empty we could theoretically try to pull it out of the stack\r\n      errorMessage = error.message;\r\n      errorSource = filename ?? error.stack ?? '';\r\n    } else {\r\n      errorMessage = error;\r\n      errorSource = filename ?? '';\r\n    }\r\n    const theColumn = column > 0 ? `-${column}` : '';\r\n    const lineAndColumn = line > 0 ? String(line) + theColumn : theColumn;\r\n    return normalizeDebounceKey(\r\n      normalizeErrorMessage(errorMessage) +\r\n        LastErrorMap.KeyDelimiter +\r\n        errorSource +\r\n        LastErrorMap.KeyDelimiter +\r\n        lineAndColumn,\r\n    );\r\n  }\r\n\r\n  static readonly KeyDelimiter = '~~-~~';\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\error-boundaries\\renderFallback.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\error-boundaries\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":4,"column":1,"nodeType":"Program","endLine":36,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Configuration for error suppression patterns\r\n */\r\nexport interface ErrorSuppressionRule {\r\n  /** Unique identifier for this rule */\r\n  id: string;\r\n  /** Pattern to match against error messages (string contains or regex) */\r\n  pattern: string | RegExp;\r\n  /** Optional: match against error source/filename */\r\n  source?: string | RegExp;\r\n  /** Whether to completely suppress (no logging) or just prevent UI display */\r\n  suppressCompletely?: boolean;\r\n  /** Description of why this error is suppressed */\r\n  reason?: string;\r\n}\r\n\r\n/**\r\n * Configuration for ClientErrorManager\r\n */\r\nexport interface ClientErrorManagerConfig {\r\n  /** Array of error suppression rules */\r\n  suppressionRules?: ErrorSuppressionRule[];\r\n  /** Whether to surface non-suppressed errors to React error boundaries */\r\n  surfaceToErrorBoundary?: boolean;\r\n  /** Whether to report suppressed errors (with low severity) */\r\n  reportSuppressedErrors?: boolean;\r\n  /** Debounce time for duplicate errors (ms) */\r\n  debounceMs?: number;\r\n}\r\n\r\nexport type SuppressionResult = {\r\n  suppress: boolean;\r\n  rule?: ErrorSuppressionRule;\r\n  completely?: boolean;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\error-boundaries\\utility.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":121,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { ErrorLike } from '@/lib/react-util/errors/error-like';\r\nimport type { ErrorSuppressionRule, SuppressionResult } from './types';\r\n\r\n/**\r\n * @module components/error-boundaries/utility\r\n *\r\n * Utility helpers used by the error-boundary system for normalizing\r\n * error text keys and evaluating suppression rules.\r\n *\r\n * The functions in this module are intentionally small and pure so they\r\n * are easy to test and reason about. They normalize noisy error messages\r\n * (for example multiple \"Uncaught \" prefixes that browsers sometimes add)\r\n * and provide a stable debounce key for deduplication. They also implement\r\n * the matching logic used to decide whether an incoming error should be\r\n * suppressed based on configured suppression rules.\r\n */\r\n\r\n/**\r\n * Normalize an error message by removing repeated leading \"Uncaught \"\r\n * prefixes that some browsers and environments prepend to thrown errors.\r\n *\r\n * Example:\r\n *   normalizeErrorMessage('Uncaught Uncaught FooError: boom')\r\n *   // -> 'FooError: boom'\r\n *\r\n * @param message - The raw error message to normalize.\r\n * @returns The normalized message with any leading repeated\r\n *          \"Uncaught \" fragments removed.\r\n */\r\nexport const normalizeErrorMessage = (message: string): string => {\r\n  // Remove repeating 'Uncaught ' at the beginning of the string\r\n  return message.replace(/^(?:Uncaught\\s+)+/g, '');\r\n};\r\n\r\n/**\r\n * Create a normalized debounce key suitable for grouping/deduplicating\r\n * errors. The key is lower-cased, trimmed and cleaned of repeated leading\r\n * \"Uncaught \" prefixes so the same logical error maps to the same key\r\n * even when different runtimes attach different prefixes.\r\n *\r\n * @param key - The raw key or message to normalize.\r\n * @returns A stable, lower-cased, trimmed key for use as a debounce id.\r\n */\r\nexport const normalizeDebounceKey = (key: string) => {\r\n  // Normalize the key by removing repeating 'Uncaught ' prefixes\r\n  return normalizeErrorMessage(key).toLowerCase().trim();\r\n};\r\n\r\n/**\r\n * Evaluate whether an incoming error should be suppressed based on a set\r\n * of configured suppression rules.\r\n *\r\n * A suppression rule has at minimum a `pattern` (string or RegExp). If the\r\n * rule also specifies a `source`, that source must match the error's\r\n * `source` (if present) for the rule to apply. When a rule matches it may\r\n * also indicate `suppressCompletely` to indicate whether the error should\r\n * be completely ignored or merely suppressed from reporting but kept in\r\n * other internal stores.\r\n *\r\n * This function is intentionally tolerant at runtime (it performs\r\n * best-effort string/RegExp matching) and returns the first matching\r\n * rule; callers should ensure suppression rules are ordered by priority.\r\n *\r\n * @param params - An object containing the error to test and an array of\r\n *                 suppression rules to evaluate in order.\r\n * @param params.error - The error-like object to test. Only `message`\r\n *                        and optional `source` are used.\r\n * @param params.suppressionRules - An ordered list of suppression rules.\r\n *\r\n * @returns A `SuppressionResult` indicating whether the error should be\r\n *          suppressed and, if so, which rule matched and whether the\r\n *          suppression is complete.\r\n *\r\n * @example\r\n * const result = shouldSuppressError({\r\n *   error: { message: 'Uncaught TypeError: failed', source: 'vendor.js' },\r\n *   suppressionRules: [ { pattern: /TypeError/, source: 'vendor', suppressCompletely: true } ]\r\n * });\r\n */\r\nexport const shouldSuppressError = ({\r\n  error,\r\n  suppressionRules,\r\n}: {\r\n  error: ErrorLike;\r\n  suppressionRules: ErrorSuppressionRule[];\r\n}): SuppressionResult => {\r\n  const testMatch = (pattern: string | RegExp, value: string): boolean => {\r\n    return (\r\n      !!value &&\r\n      (typeof pattern === 'string'\r\n        ? value.includes(pattern)\r\n        : pattern.test(value))\r\n    );\r\n  };\r\n  const errorMessage = normalizeErrorMessage(error.message);\r\n  const errorSource = error.source;\r\n  const matchedRule = suppressionRules.find((rule) => {\r\n    // Check if the error message matches the rule pattern\r\n    const messageMatches = testMatch(rule.pattern, errorMessage);\r\n    if (!messageMatches) {\r\n      return false;\r\n    }\r\n    // If rule contains a source then it must match as well\r\n    if (rule.source) {\r\n      const sourceMatches = testMatch(rule.source, errorSource || '');\r\n      if (!sourceMatches) {\r\n        return false;\r\n      }\r\n    }\r\n    // If we reach here, the rule is a match.\r\n    return true;\r\n  });\r\n  return matchedRule\r\n    ? {\r\n        suppress: true,\r\n        rule: matchedRule,\r\n        completely: matchedRule.suppressCompletely,\r\n      }\r\n    : { suppress: false };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\general\\auth\\session-expired.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\general\\enhanced-table-head.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":70,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import TableHead from \"@mui/material/TableHead\";\r\nimport TableRow from \"@mui/material/TableRow\";\r\nimport TableCell from \"@mui/material/TableCell\";\r\nimport Checkbox from \"@mui/material/Checkbox\";\r\n\r\n/**\r\n * Represents a header cell in a table.\r\n *\r\n * @property {string} id - The unique identifier for the cell.\r\n * @property {string} label - The label for the cell.\r\n * @property {boolean} numeric - Indicates whether the cell contains numeric data.\r\n * @property {boolean} disablePadding - Indicates whether padding is disabled for the cell.\r\n */\r\nexport interface HeadCell {\r\n  id: string;\r\n  label: string;\r\n  numeric: boolean;\r\n  disablePadding: boolean;\r\n  maxWidth?: string;\r\n}\r\n\r\n\r\ninterface EnhancedTableProps {\r\n  numSelected: number;\r\n  onSelectAllClick?: (event: React.ChangeEvent<HTMLInputElement>) => void;\r\n  rowCount: number;\r\n  headCells: HeadCell[];\r\n}\r\n\r\nconst EnhancedTableHead: React.FC<EnhancedTableProps> = ({\r\n  headCells,\r\n  ...props\r\n}) => {\r\n  const { onSelectAllClick, numSelected, rowCount } = props;\r\n\r\n  return (\r\n    <TableHead>\r\n      <TableRow>\r\n        {onSelectAllClick && (\r\n          <TableCell padding=\"checkbox\">\r\n            <Checkbox\r\n              color=\"primary\"\r\n              indeterminate={numSelected > 0 && numSelected < rowCount}\r\n              checked={rowCount > 0 && numSelected === rowCount}\r\n              onChange={onSelectAllClick}\r\n              inputProps={{\r\n                'aria-label': 'select all emails',\r\n              }}\r\n            />\r\n          </TableCell>\r\n        )}\r\n        {headCells.map((headCell) => (\r\n          <TableCell\r\n            key={headCell.id}\r\n            align={headCell.numeric ? 'right' : 'left'}\r\n            vertical-align={'center'}\r\n            sx={{ maxWidth: headCell.maxWidth }}\r\n            sortDirection={false}\r\n            padding={headCell.disablePadding ? 'none' : 'normal'}\r\n          >\r\n            {headCell.label}\r\n          </TableCell>\r\n        ))}\r\n      </TableRow>\r\n    </TableHead>\r\n  );\r\n};\r\n\r\nexport default EnhancedTableHead;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\general\\flags\\flag-provider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\general\\loading\\index.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":100,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\n/**\r\n * General-purpose loading and error indicator components.\r\n *\r\n * This module provides a compact UI primitive to render a Material UI Card with\r\n * a LinearProgress while an operation is in progress, and a lightweight inline\r\n * error presentation when an error occurs. When neither loading nor error is\r\n * active, it renders nothing (an empty fragment) so it can be dropped into any\r\n * layout without affecting spacing.\r\n */\r\nimport Card from '@mui/material/Card';\r\nimport CardContent from '@mui/material/CardContent';\r\nimport LinearProgress from '@mui/material/LinearProgress';\r\nimport Typography from '@mui/material/Typography';\r\nimport Box from '@mui/material/Box';\r\nimport { useEffect, useId, useRef } from 'react';\r\nimport type { SxProps, Theme } from '@mui/material/styles';\r\n\r\n/**\r\n * Stable, hoisted styles used by the error view to avoid re-allocating\r\n * style objects on every render.\r\n */\r\nconst stableSx = {\r\n  error: {\r\n    color: 'error.main',\r\n    marginBottom: 2,\r\n    textAlign: 'center',\r\n  } satisfies SxProps<Theme>,\r\n} as const;\r\n\r\n/**\r\n * Loading\r\n *\r\n * Renders one of three states:\r\n * - Loading state: Card with title text and a determinate LinearProgress.\r\n * - Error state: Inline red error message when `errorMessage` is provided and `loading` is falsey.\r\n * - Idle state: Empty fragment when neither `loading` nor `errorMessage` is present.\r\n *\r\n * Accessibility: Loading and Error states contain appropriate ARIA roles and properties for screen readers.\r\n *\r\n * @param props Component props\r\n * @param props.loading Whether to display the loading Card. When true, `errorMessage` is ignored.\r\n * @param props.text Optional text shown above the progress bar (defaults to \"Loading...\")\r\n * @param props.errorMessage Optional error string. When truthy and not loading, renders an inline error.\r\n */\r\nexport const Loading = ({\r\n  loading,\r\n  errorMessage,\r\n  text,\r\n}: {\r\n  loading?: boolean;\r\n  text?: string;\r\n  errorMessage?: string | null;\r\n}) => {\r\n  const titleId = useId();\r\n  const errorRef = useRef<HTMLDivElement | null>(null);\r\n\r\n  // Move focus to the alert when an error appears so SR/keyboard users notice it\r\n  useEffect(() => {\r\n    if (errorMessage && errorRef.current) {\r\n      errorRef.current.focus();\r\n    }\r\n  }, [errorMessage]);\r\n\r\n  if (loading) {\r\n    return (\r\n      <Card\r\n        role=\"status\"\r\n        aria-live=\"polite\"\r\n        aria-busy={true}\r\n        aria-labelledby={titleId}\r\n      >\r\n        <CardContent>\r\n          <Typography id={titleId} variant=\"h6\" gutterBottom>\r\n            {text ?? 'Loading...'}\r\n          </Typography>\r\n          <LinearProgress aria-describedby={titleId} />\r\n        </CardContent>\r\n      </Card>\r\n    );\r\n  }\r\n  if (errorMessage) {\r\n    return (\r\n      <Box\r\n        sx={stableSx.error}\r\n        role=\"alert\"\r\n        aria-atomic=\"true\"\r\n        tabIndex={-1}\r\n        ref={errorRef}\r\n      >\r\n        <Typography variant=\"body2\" color=\"error\">\r\n          <strong>Error:</strong> {errorMessage}\r\n        </Typography>\r\n      </Box>\r\n    );\r\n  }\r\n  return <></>;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\general\\modal.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":2,"column":1,"nodeType":"Program","endLine":130,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/** @jsxImportSource @emotion/react */\r\nimport { FunctionComponent, ReactNode } from 'react';\r\nimport { css } from '@emotion/react';\r\n\r\nconst modalStyles = {\r\n  overlay: css`\r\n    position: fixed;\r\n    inset: 0;\r\n    z-index: 50;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    background-color: rgba(0, 0, 0, 0.5);\r\n  `,\r\n  content: css`\r\n    background-color: #1f2937;\r\n    color: #ffffff;\r\n    border-radius: 0.5rem;\r\n    box-shadow:\r\n      0 20px 25px -5px rgba(0, 0, 0, 0.1),\r\n      0 10px 10px -5px rgba(0, 0, 0, 0.04);\r\n    overflow: hidden;\r\n    width: 91.666667%;\r\n\r\n    @media (min-width: 768px) {\r\n      width: 50%;\r\n    }\r\n\r\n    @media (min-width: 1024px) {\r\n      width: 33.333333%;\r\n    }\r\n  `,\r\n  header: css`\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    padding: 1rem;\r\n    border-bottom: 1px solid #374151;\r\n  `,\r\n  title: css`\r\n    font-size: 1.25rem;\r\n    line-height: 1.75rem;\r\n    font-weight: 600;\r\n  `,\r\n  closeButton: css`\r\n    color: #9ca3af;\r\n\r\n    &:hover {\r\n      color: #e5e7eb;\r\n    }\r\n  `,\r\n  body: css`\r\n    padding: 1rem;\r\n  `,\r\n  footer: css`\r\n    display: flex;\r\n    justify-content: flex-end;\r\n    padding: 1rem;\r\n    border-top: 1px solid #374151;\r\n  `,\r\n  saveButton: css`\r\n    background-color: #059669;\r\n    color: #ffffff;\r\n    font-weight: 600;\r\n    padding: 0.5rem 1rem;\r\n    margin-right: 0.5rem;\r\n\r\n    &:hover {\r\n      background-color: #047857;\r\n    }\r\n  `,\r\n  closeFooterButton: css`\r\n    background-color: #2563eb;\r\n    color: #ffffff;\r\n    font-weight: 600;\r\n    padding: 0.5rem 1rem;\r\n    margin-right: 0.5rem;\r\n\r\n    &:hover {\r\n      background-color: #1d4ed8;\r\n    }\r\n  `,\r\n};\r\n\r\nexport interface ModalProps {\r\n  isOpen: boolean;\r\n  onClose: () => void;\r\n  onSave?: (args: unknown) => unknown;\r\n  title: string;\r\n  closeButtonText?: string;\r\n  children: ReactNode;\r\n}\r\n\r\nconst Modal: FunctionComponent<ModalProps> = ({\r\n  isOpen,\r\n  onClose,\r\n  onSave,\r\n  title,\r\n  children,\r\n  closeButtonText = 'Close',\r\n}) => {\r\n  if (!isOpen) return null;\r\n\r\n  return (\r\n    <div css={modalStyles.overlay}>\r\n      <div css={modalStyles.content}>\r\n        <div css={modalStyles.header}>\r\n          <h2 css={modalStyles.title}>{title}</h2>\r\n          <button css={modalStyles.closeButton} onClick={onClose}>\r\n            &times;\r\n          </button>\r\n        </div>\r\n        <div css={modalStyles.body}>{children}</div>\r\n        <div css={modalStyles.footer}>\r\n          {onSave && (\r\n            <button css={modalStyles.saveButton} onClick={onSave}>\r\n              Save\r\n            </button>\r\n          )}\r\n          <button css={modalStyles.closeFooterButton} onClick={onClose}>\r\n            {closeButtonText}\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Modal;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\general\\react-query\\query-provider.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":36,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\r\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools';\r\nimport type { FC, ReactNode } from 'react';\r\ninterface DataGridQueryProviderProps {\r\n  children: ReactNode;\r\n  showDevtools?: boolean;\r\n}\r\n\r\nlet queryClient: QueryClient | undefined = undefined;\r\n//...................................................................................'''''''''''const queryClient = new QueryClient();\r\n\r\n/**\r\n * Provider component that wraps the application with React Query context for data grid operations.\r\n *\r\n * This component provides a QueryClient specifically configured for data grid use cases,\r\n * including optimized caching and retry strategies.\r\n *\r\n * @param children - The child components to wrap with the query provider\r\n * @param showDevtools - Whether to show React Query DevTools (default: false in production, true in development)\r\n */\r\nexport const QueryProvider: FC<DataGridQueryProviderProps> = ({\r\n  children,\r\n  showDevtools = process.env.NODE_ENV === 'development',\r\n}) => {\r\n  queryClient ??= new QueryClient({})\r\n  return (\r\n    <QueryClientProvider client={queryClient}>\r\n      {children}\r\n      {showDevtools && <ReactQueryDevtools initialIsOpen={false} />}\r\n    </QueryClientProvider>\r\n  );\r\n};\r\n\r\nexport default QueryProvider;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\general\\telemetry\\track-with-app-insight.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\health\\chat-status\\chat-status-indicator.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":10,"column":1,"nodeType":"Program","endLine":206,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Chat Status Indicator Component\r\n *\r\n * This component provides a visual indicator for chat service health status.\r\n *\r\n * @module components/chat-status/chat-status-indicator\r\n * @version 1.0.0\r\n */\r\n\r\n'use client';\r\n\r\nimport * as React from 'react';\r\nimport { Chip, Tooltip, CircularProgress, Box } from '@mui/material';\r\nimport {\r\n  CheckCircle as HealthyIcon,\r\n  Warning as WarningIcon,\r\n  Error as ErrorIcon,\r\n  Chat as ChatIcon,\r\n} from '@mui/icons-material';\r\nimport { useChatHealth } from '@/lib/hooks/use-chat-health';\r\nimport { BOX_SX_VARIANTS, BoxSxVariantKey } from '../health-status-styles';\r\n\r\n/**\r\n * Props for the ChatStatusIndicator component\r\n */\r\ninterface ChatStatusIndicatorProps {\r\n  /**\r\n   * Whether to show detailed status text alongside the icon\r\n   */\r\n  showLabel?: boolean;\r\n\r\n  /**\r\n   * Size variant for the indicator\r\n   */\r\n  size?: 'small' | 'medium';\r\n}\r\n\r\ntype ChatHealthStatus = 'ok' | 'warning' | 'error';\r\n\r\n/**\r\n * Gets the appropriate icon for the health status\r\n */\r\nfunction getStatusIcon(status: ChatHealthStatus, isLoading: boolean) {\r\n  if (isLoading) {\r\n    return <CircularProgress size={16} />;\r\n  }\r\n\r\n  switch (status) {\r\n    case 'ok':\r\n      return <HealthyIcon fontSize=\"small\" />;\r\n    case 'warning':\r\n      return <WarningIcon fontSize=\"small\" />;\r\n    case 'error':\r\n      return <ErrorIcon fontSize=\"small\" />;\r\n    default:\r\n      return <ChatIcon fontSize=\"small\" />;\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the appropriate color for the health status\r\n */\r\nfunction getStatusColor(\r\n  status: ChatHealthStatus,\r\n): 'success' | 'warning' | 'error' | 'default' {\r\n  switch (status) {\r\n    case 'ok':\r\n      return 'success';\r\n    case 'warning':\r\n      return 'warning';\r\n    case 'error':\r\n      return 'error';\r\n    default:\r\n      return 'default';\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the human-readable label for the health status\r\n */\r\nfunction getStatusLabel(status: ChatHealthStatus): string {\r\n  switch (status) {\r\n    case 'ok':\r\n      return 'Chat: Healthy';\r\n    case 'warning':\r\n      return 'Chat: Warning';\r\n    case 'error':\r\n      return 'Chat: Error';\r\n    default:\r\n      return 'Chat: Unknown';\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the detailed tooltip message based on health status\r\n */\r\nfunction getTooltipMessage(\r\n  status: ChatHealthStatus,\r\n  subsystems:\r\n    | {\r\n        cache: ChatHealthStatus;\r\n        queue: ChatHealthStatus;\r\n      }\r\n    | undefined,\r\n  isLoading: boolean,\r\n  isError: boolean,\r\n  error: Error | null,\r\n  refreshInterval: number,\r\n): string {\r\n  if (isLoading) {\r\n    return 'Checking chat service health...';\r\n  }\r\n\r\n  if (isError && error) {\r\n    return `Chat health check failed: ${error.message}`;\r\n  }\r\n\r\n  const refreshSeconds = Math.round(refreshInterval / 1000);\r\n\r\n  let baseMessage: string;\r\n  let systemDetails = '';\r\n\r\n  switch (status) {\r\n    case 'ok':\r\n      baseMessage = 'Chat service is healthy and operational.';\r\n      break;\r\n    case 'warning':\r\n    case 'error':\r\n      baseMessage =\r\n        status === 'warning'\r\n          ? 'Chat service has warnings. Some features may be unavailable.'\r\n          : 'Chat service is experiencing errors.';\r\n\r\n      if (subsystems) {\r\n        const failingSystems: string[] = [];\r\n        if (subsystems.cache !== 'ok') {\r\n          failingSystems.push(`Cache (${subsystems.cache})`);\r\n        }\r\n        if (subsystems.queue !== 'ok') {\r\n          failingSystems.push(`Queue (${subsystems.queue})`);\r\n        }\r\n\r\n        if (failingSystems.length > 0) {\r\n          systemDetails = `\\n\\nAffected systems:\\n• ${failingSystems.join('\\n• ')}`;\r\n        }\r\n      }\r\n      break;\r\n    default:\r\n      baseMessage = 'Chat service status unknown.';\r\n  }\r\n\r\n  return `${baseMessage}${systemDetails}\\n\\nRefreshes every ${refreshSeconds}s.`;\r\n}\r\n\r\n/**\r\n * ChatStatusIndicator displays the current health status of the chat service\r\n */\r\nexport const ChatStatusIndicator = React.memo<ChatStatusIndicatorProps>(\r\n  ({ showLabel = false, size = 'medium' }) => {\r\n    const {\r\n      healthStatus,\r\n      subsystems,\r\n      isLoading,\r\n      isError,\r\n      error,\r\n      refreshInterval,\r\n    } = useChatHealth();\r\n\r\n    const statusIcon = getStatusIcon(healthStatus, isLoading);\r\n    const statusColor = getStatusColor(healthStatus);\r\n    const statusLabel = getStatusLabel(healthStatus);\r\n    const tooltipMessage = getTooltipMessage(\r\n      healthStatus,\r\n      subsystems,\r\n      isLoading,\r\n      isError,\r\n      error,\r\n      refreshInterval,\r\n    );\r\n\r\n    const boxSx = BOX_SX_VARIANTS[`${statusColor}-${size}` as BoxSxVariantKey];\r\n\r\n    if (showLabel) {\r\n      return (\r\n        <Tooltip title={tooltipMessage} arrow>\r\n          <Chip\r\n            icon={statusIcon}\r\n            label={statusLabel}\r\n            color={statusColor}\r\n            size={size}\r\n            variant=\"outlined\"\r\n          />\r\n        </Tooltip>\r\n      );\r\n    }\r\n\r\n    return (\r\n      <Tooltip title={tooltipMessage} arrow>\r\n        <Box sx={boxSx}>{statusIcon}</Box>\r\n      </Tooltip>\r\n    );\r\n  },\r\n);\r\n\r\nChatStatusIndicator.displayName = 'ChatStatusIndicator';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\health\\chat-status\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\health\\database-status\\database-status-indicator.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":10,"column":1,"nodeType":"Program","endLine":177,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Database Status Indicator Component\r\n *\r\n * This component provides a visual indicator for database service health status.\r\n *\r\n * @module components/database-status/database-status-indicator\r\n * @version 1.0.0\r\n */\r\n\r\n'use client';\r\n\r\nimport * as React from 'react';\r\nimport { Chip, Tooltip, CircularProgress, Box } from '@mui/material';\r\nimport {\r\n  CheckCircle as HealthyIcon,\r\n  Warning as WarningIcon,\r\n  Error as ErrorIcon,\r\n  Storage as DatabaseIcon,\r\n} from '@mui/icons-material';\r\nimport { useDatabaseHealth } from '@/lib/hooks/use-database-health';\r\nimport { BOX_SX_VARIANTS, type BoxSxVariantKey } from '../health-status-styles';\r\n\r\n/**\r\n * Props for the DatabaseStatusIndicator component\r\n */\r\ninterface DatabaseStatusIndicatorProps {\r\n  /**\r\n   * Whether to show detailed status text alongside the icon\r\n   */\r\n  showLabel?: boolean;\r\n\r\n  /**\r\n   * Size variant for the indicator\r\n   */\r\n  size?: 'small' | 'medium';\r\n}\r\n\r\ntype DatabaseHealthStatus = 'ok' | 'warning' | 'error';\r\n\r\n/**\r\n * Gets the appropriate icon for the health status\r\n */\r\nfunction getStatusIcon(status: DatabaseHealthStatus, isLoading: boolean) {\r\n  if (isLoading) {\r\n    return <CircularProgress size={16} />;\r\n  }\r\n\r\n  switch (status) {\r\n    case 'ok':\r\n      return <HealthyIcon fontSize=\"small\" />;\r\n    case 'warning':\r\n      return <WarningIcon fontSize=\"small\" />;\r\n    case 'error':\r\n      return <ErrorIcon fontSize=\"small\" />;\r\n    default:\r\n      return <DatabaseIcon fontSize=\"small\" />;\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the appropriate color for the health status\r\n */\r\nfunction getStatusColor(\r\n  status: DatabaseHealthStatus,\r\n): 'success' | 'warning' | 'error' | 'default' {\r\n  switch (status) {\r\n    case 'ok':\r\n      return 'success';\r\n    case 'warning':\r\n      return 'warning';\r\n    case 'error':\r\n      return 'error';\r\n    default:\r\n      return 'default';\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the human-readable label for the health status\r\n */\r\nfunction getStatusLabel(status: DatabaseHealthStatus): string {\r\n  switch (status) {\r\n    case 'ok':\r\n      return 'Database: Healthy';\r\n    case 'warning':\r\n      return 'Database: Warning';\r\n    case 'error':\r\n      return 'Database: Error';\r\n    default:\r\n      return 'Database: Unknown';\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the detailed tooltip message based on health status\r\n */\r\nfunction getTooltipMessage(\r\n  status: DatabaseHealthStatus,\r\n  isLoading: boolean,\r\n  isError: boolean,\r\n  error: Error | null,\r\n  refreshInterval: number,\r\n): string {\r\n  if (isLoading) {\r\n    return 'Checking database service health...';\r\n  }\r\n\r\n  if (isError && error) {\r\n    return `Database health check failed: ${error.message}`;\r\n  }\r\n\r\n  const refreshSeconds = Math.round(refreshInterval / 1000);\r\n\r\n  let baseMessage: string;\r\n  switch (status) {\r\n    case 'ok':\r\n      baseMessage = 'Database service is healthy and operational.';\r\n      break;\r\n    case 'warning':\r\n      baseMessage =\r\n        'Database service has warnings. Some operations may be slow.';\r\n      break;\r\n    case 'error':\r\n      baseMessage = 'Database service is experiencing errors.';\r\n      break;\r\n    default:\r\n      baseMessage = 'Database service status unknown.';\r\n  }\r\n\r\n  return `${baseMessage}\\n\\nRefreshes every ${refreshSeconds}s.`;\r\n}\r\n\r\n/**\r\n * DatabaseStatusIndicator displays the current health status of the database service\r\n */\r\nexport const DatabaseStatusIndicator = React.memo<DatabaseStatusIndicatorProps>(\r\n  ({ showLabel = false, size = 'medium' }) => {\r\n    const { healthStatus, isLoading, isError, error, refreshInterval } =\r\n      useDatabaseHealth();\r\n\r\n    const statusIcon = getStatusIcon(healthStatus, isLoading);\r\n    const statusColor = getStatusColor(healthStatus);\r\n    const statusLabel = getStatusLabel(healthStatus);\r\n    const tooltipMessage = getTooltipMessage(\r\n      healthStatus,\r\n      isLoading,\r\n      isError,\r\n      error,\r\n      refreshInterval,\r\n    );\r\n\r\n    const boxSx = BOX_SX_VARIANTS[`${statusColor}-${size}` as BoxSxVariantKey];\r\n\r\n    if (showLabel) {\r\n      return (\r\n        <Tooltip title={tooltipMessage} arrow>\r\n          <Chip\r\n            icon={statusIcon}\r\n            label={statusLabel}\r\n            color={statusColor}\r\n            size={size}\r\n            variant=\"outlined\"\r\n          />\r\n        </Tooltip>\r\n      );\r\n    }\r\n\r\n    return (\r\n      <Tooltip title={tooltipMessage} arrow>\r\n        <Box sx={boxSx}>{statusIcon}</Box>\r\n      </Tooltip>\r\n    );\r\n  },\r\n);\r\n\r\nDatabaseStatusIndicator.displayName = 'DatabaseStatusIndicator';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\health\\database-status\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\health\\health-status-styles.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":10,"column":1,"nodeType":"Program","endLine":73,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Memory Status Indicator Styles\r\n *\r\n * Pre-computed stable sx objects for memory status indicators.\r\n * Generated at module load time for zero runtime object creation.\r\n *\r\n * @module components/memory-status/memory-status-styles\r\n */\r\n\r\nimport type { Theme } from '@mui/material';\r\n\r\n/**\r\n * Status color variants that map to Material-UI theme colors\r\n */\r\ntype StatusColor = 'success' | 'warning' | 'error' | 'default';\r\n\r\n/**\r\n * Size variants for the memory status indicator\r\n */\r\ntype Size = 'small' | 'medium';\r\n\r\n/**\r\n * Creates a Box sx object for the given status color and size\r\n *\r\n * @param status - The status color variant\r\n * @param size - The size variant\r\n * @returns Pre-configured sx object for Material-UI Box\r\n */\r\nfunction createBoxSx(status: StatusColor, size: Size) {\r\n  const sizeProps =\r\n    size === 'small'\r\n      ? { minWidth: 24, minHeight: 24 }\r\n      : { minWidth: 32, minHeight: 32 };\r\n\r\n  const colorProp =\r\n    status === 'default'\r\n      ? (theme: Theme) => theme.palette.text.primary\r\n      : (theme: Theme) => theme.palette[status].main;\r\n\r\n  return {\r\n    display: 'inline-flex',\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    ...sizeProps,\r\n    borderRadius: 1,\r\n    cursor: 'pointer',\r\n    color: colorProp,\r\n    '&:hover': {\r\n      backgroundColor: 'action.hover',\r\n    },\r\n  } as const;\r\n}\r\n\r\n/**\r\n * All possible status-size combinations generated at module load time.\r\n * Zero object creation during React renders!\r\n */\r\nexport const BOX_SX_VARIANTS = {\r\n  'success-small': createBoxSx('success', 'small'),\r\n  'success-medium': createBoxSx('success', 'medium'),\r\n  'warning-small': createBoxSx('warning', 'small'),\r\n  'warning-medium': createBoxSx('warning', 'medium'),\r\n  'error-small': createBoxSx('error', 'small'),\r\n  'error-medium': createBoxSx('error', 'medium'),\r\n  'default-small': createBoxSx('default', 'small'),\r\n  'default-medium': createBoxSx('default', 'medium'),\r\n} as const;\r\n\r\n/**\r\n * Type for accessing BOX_SX_VARIANTS keys in a type-safe manner\r\n */\r\nexport type BoxSxVariantKey = keyof typeof BOX_SX_VARIANTS;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\health\\memory-status\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":5,"column":1,"nodeType":"Program","endLine":7,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Memory Status Component Exports\r\n */\r\n\r\nexport { MemoryStatusIndicator } from './memory-status-indicator';\r\nexport type { HealthStatus } from '@/lib/ai/mem0/types/health-check';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\health\\memory-status\\memory-status-indicator.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":11,"column":1,"nodeType":"Program","endLine":249,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Memory Status Indicator Component\r\n *\r\n * This component provides a visual indicator for memory service health status\r\n * with automatic refresh based on health status and integration with react-query.\r\n *\r\n * @module components/memory-status/memory-status-indicator\r\n * @version 1.0.0\r\n */\r\n\r\n'use client';\r\n\r\nimport * as React from 'react';\r\nimport { Chip, Tooltip, CircularProgress, Box } from '@mui/material';\r\nimport {\r\n  CheckCircle as HealthyIcon,\r\n  Warning as WarningIcon,\r\n  Error as ErrorIcon,\r\n  Memory as MemoryIcon,\r\n} from '@mui/icons-material';\r\nimport { useMemoryHealth } from '@/lib/hooks/use-memory-health';\r\nimport type { HealthStatus } from '@/lib/ai/mem0/types/health-check';\r\nimport { BOX_SX_VARIANTS, type BoxSxVariantKey } from '../health-status-styles';\r\n\r\n/**\r\n * Props for the MemoryStatusIndicator component\r\n */\r\ninterface MemoryStatusIndicatorProps {\r\n  /**\r\n   * Whether to show detailed status text alongside the icon\r\n   */\r\n  showLabel?: boolean;\r\n\r\n  /**\r\n   * Size variant for the indicator\r\n   */\r\n  size?: 'small' | 'medium';\r\n}\r\n\r\n/**\r\n * Gets the appropriate icon for the health status\r\n */\r\nfunction getStatusIcon(status: HealthStatus, isLoading: boolean) {\r\n  if (isLoading) {\r\n    return <CircularProgress size={16} />;\r\n  }\r\n\r\n  switch (status) {\r\n    case 'healthy':\r\n      return <HealthyIcon fontSize=\"small\" />;\r\n    case 'warning':\r\n      return <WarningIcon fontSize=\"small\" />;\r\n    case 'error':\r\n      return <ErrorIcon fontSize=\"small\" />;\r\n    default:\r\n      return <MemoryIcon fontSize=\"small\" />;\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the appropriate color for the health status\r\n */\r\nfunction getStatusColor(\r\n  status: HealthStatus,\r\n): 'success' | 'warning' | 'error' | 'default' {\r\n  switch (status) {\r\n    case 'healthy':\r\n      return 'success';\r\n    case 'warning':\r\n      return 'warning';\r\n    case 'error':\r\n      return 'error';\r\n    default:\r\n      return 'default';\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the human-readable label for the health status\r\n */\r\nfunction getStatusLabel(status: HealthStatus): string {\r\n  switch (status) {\r\n    case 'healthy':\r\n      return 'Memory: Healthy';\r\n    case 'warning':\r\n      return 'Memory: Warning';\r\n    case 'error':\r\n      return 'Memory: Error';\r\n    default:\r\n      return 'Memory: Unknown';\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the detailed tooltip message based on health status\r\n */\r\nfunction getTooltipMessage(\r\n  status: HealthStatus,\r\n  subsystems:\r\n    | {\r\n        db: string;\r\n        vectorStore: string;\r\n        graphStore: string;\r\n        historyStore: string;\r\n        authService: string;\r\n      }\r\n    | undefined,\r\n  isLoading: boolean,\r\n  isError: boolean,\r\n  error: Error | null,\r\n  refreshInterval: number,\r\n): string {\r\n  if (isLoading) {\r\n    return 'Checking memory service health...';\r\n  }\r\n\r\n  if (isError && error) {\r\n    return `Memory health check failed: ${error.message}`;\r\n  }\r\n\r\n  const refreshSeconds = Math.round(refreshInterval / 1000);\r\n\r\n  // Build detailed status message with failing systems information\r\n  let baseMessage: string;\r\n  let systemDetails = '';\r\n\r\n  switch (status) {\r\n    case 'healthy':\r\n      baseMessage = 'Memory service is healthy. All systems operational.';\r\n      break;\r\n    case 'warning':\r\n    case 'error':\r\n      baseMessage =\r\n        status === 'warning'\r\n          ? 'Memory service has warnings. Some services may be unavailable.'\r\n          : 'Memory service is experiencing errors. Client may be inactive.';\r\n\r\n      // Add details about failing systems if subsystem data is available\r\n      if (subsystems) {\r\n        const failingSystems: string[] = [];\r\n        const systemNames = {\r\n          db: 'Database',\r\n          vectorStore: 'Vector Store',\r\n          graphStore: 'Graph Store',\r\n          historyStore: 'History Store',\r\n          authService: 'Auth Service',\r\n        };\r\n\r\n        // Check each subsystem for errors or warnings\r\n        Object.entries(subsystems).forEach(([key, systemStatus]) => {\r\n          if (systemStatus === 'error') {\r\n            failingSystems.push(\r\n              `${systemNames[key as keyof typeof systemNames]} (error)`,\r\n            );\r\n          } else if (systemStatus === 'warning') {\r\n            failingSystems.push(\r\n              `${systemNames[key as keyof typeof systemNames]} (warning)`,\r\n            );\r\n          }\r\n        });\r\n\r\n        if (failingSystems.length > 0) {\r\n          systemDetails = `\\n\\nAffected systems:\\n• ${failingSystems.join('\\n• ')}`;\r\n        }\r\n      }\r\n      break;\r\n    default:\r\n      baseMessage = 'Memory service status unknown.';\r\n  }\r\n\r\n  return `${baseMessage}${systemDetails}\\n\\nRefreshes every ${refreshSeconds}s.`;\r\n}\r\n\r\n/**\r\n * MemoryStatusIndicator displays the current health status of the memory service\r\n *\r\n * @description This component monitors memory service health and provides visual\r\n * feedback through color-coded indicators. It automatically refreshes at different\r\n * intervals based on the health status:\r\n * - Healthy: Every 3 minutes\r\n * - Warning: Every 30 seconds\r\n * - Error: Every 5 seconds\r\n *\r\n * @component\r\n * @param props - Component props\r\n * @returns A React element showing memory service health status\r\n *\r\n * @example\r\n * ```tsx\r\n * // Basic usage with icon only\r\n * <MemoryStatusIndicator />\r\n *\r\n * // With label text\r\n * <MemoryStatusIndicator showLabel />\r\n *\r\n * // Small size variant\r\n * <MemoryStatusIndicator size=\"small\" />\r\n * ```\r\n */\r\nexport const MemoryStatusIndicator = React.memo<MemoryStatusIndicatorProps>(\r\n  ({ showLabel = false, size = 'medium' }) => {\r\n    const {\r\n      healthStatus,\r\n      subsystems,\r\n      isLoading,\r\n      isError,\r\n      error,\r\n      refreshInterval,\r\n    } = useMemoryHealth();\r\n\r\n    const statusIcon = getStatusIcon(healthStatus, isLoading);\r\n    const statusColor = getStatusColor(healthStatus);\r\n    const statusLabel = getStatusLabel(healthStatus);\r\n    const tooltipMessage = getTooltipMessage(\r\n      healthStatus,\r\n      subsystems,\r\n      isLoading,\r\n      isError,\r\n      error,\r\n      refreshInterval,\r\n    );\r\n\r\n    // Direct lookup of pre-computed stable object - zero object creation!\r\n    const boxSx = BOX_SX_VARIANTS[`${statusColor}-${size}` as BoxSxVariantKey];\r\n\r\n    if (showLabel) {\r\n      return (\r\n        <Tooltip title={tooltipMessage} arrow>\r\n          <Chip\r\n            icon={statusIcon}\r\n            label={statusLabel}\r\n            color={statusColor}\r\n            size={size}\r\n            variant=\"outlined\"\r\n          />\r\n        </Tooltip>\r\n      );\r\n    }\r\n\r\n    return (\r\n      <Tooltip title={tooltipMessage} arrow>\r\n        <Box sx={boxSx}>{statusIcon}</Box>\r\n      </Tooltip>\r\n    );\r\n  },\r\n);\r\n\r\nMemoryStatusIndicator.displayName = 'MemoryStatusIndicator';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\MuiXLicense.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\cellRenderers\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\cellRenderers\\progress\\bar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\cellRenderers\\progress\\element.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\cellRenderers\\progress\\render.tsx","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1145,1148],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1145,1148],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":43,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1254,1257],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1254,1257],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\cellRenderers\\progress\\renderEdit.tsx","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":50,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1378,1381],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1378,1381],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":107,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3032,3035],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3032,3035],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\cellRenderers\\progress\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\cellRenderers\\progress\\value-label-component.tsx","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[224,227],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[224,227],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\cellRenderers\\progress\\value.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\cellRenderers\\render-helpers\\center.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\cellRenderers\\renderArrayAsChips.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has a missing dependency: 'params?.value'. Either include it or remove the dependency array.","line":17,"column":5,"nodeType":"ArrayExpression","endLine":17,"endColumn":59,"suggestions":[{"desc":"Update the dependencies array to be: [params?.value]","fix":{"range":[705,759],"text":"[params?.value]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","line":17,"column":6,"nodeType":"ConditionalExpression","endLine":17,"endColumn":58,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\cellRenderers\\renderSeverity.tsx","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":110,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":110,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2980,2983],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2980,2983],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":122,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":122,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3281,3284],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3281,3284],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":182,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":182,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4991,4994],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4991,4994],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":184,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5100,5103],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5100,5103],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":200,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5469,5472],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5469,5472],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\email-properties\\EmailMasterPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\email-properties\\email-property-grid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\email-properties\\email-property-toolbar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\email-properties\\helpers\\QuickFilterSearch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\email-properties\\helpers\\QuickFilterTriggerSearch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\email-properties\\shared-cells-defs.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":153,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GridColDef } from '@mui/x-data-grid-pro';\r\nimport { Chips as renderArrayAsChips } from '../cellRenderers';\r\nimport renderSeverity from '../cellRenderers/renderSeverity';\r\nimport renderProgress from '../cellRenderers/progress/render';\r\n\r\nexport const defineReasonsColumn = (\r\n  {\r\n    field,\r\n    headerName = field,\r\n    width,\r\n    description,\r\n  }: {\r\n    field: string;\r\n    headerName?: string;\r\n    width?: number;\r\n    description?: string;\r\n  },\r\n  args?: object,\r\n): GridColDef => {\r\n  return {\r\n    field,\r\n    headerName,\r\n    width,\r\n    description,\r\n    editable: false,\r\n    ...(args ?? {}),\r\n  };\r\n};\r\n\r\n/**\r\n * A collection of shared column definitions for use in MUI Data Grid components.\r\n *\r\n * Each entry in the `SharedCellDefinitions` object defines the configuration for a specific column,\r\n * including its field name, header label, editability, width, and custom cell rendering logic.\r\n *\r\n * @remarks\r\n * - The `renderCell` property uses the `renderArrayAsChips` function to display array values as chips.\r\n * - The definitions are marked as `const` to ensure immutability.\r\n *\r\n * @example\r\n * ```tsx\r\n * <DataGrid columns={[SharedCellDefinitions.policyBasis, SharedCellDefinitions.tags]} ... />\r\n * ```\r\n */\r\n\r\nexport const SharedCellDefinitions = {\r\n  compliance: {\r\n    chapter_13: {\r\n      field: 'compliance_average_chapter_13',\r\n      headerName: 'Chpt 13',\r\n      description: 'Chpt 13 Compliance (Avg)',\r\n      editable: false,\r\n      type: 'number',\r\n      renderCell: renderProgress,\r\n    },\r\n    chapter_13_reasons: defineReasonsColumn({\r\n      field: 'compliance_chapter_13_reasons',\r\n      headerName: 'Chpt 13 Reasons',\r\n      description: 'Reasons for Chpt 13 Compliance',\r\n    }),\r\n  },\r\n  /**\r\n   * Column definition for the `compliance_rating` field.\r\n   * Displays the compliance rating of an email property.\r\n   */\r\n  complianceRating: {\r\n    field: 'compliance',\r\n    headerName: 'Compliance Rating',\r\n    editable: false,\r\n    type: 'number',\r\n    renderCell: renderProgress,\r\n  },\r\n  /**\r\n   * Column definition for the `compliance_rating_reasons` field.\r\n   * Displays the reasons for the compliance rating assigned to a document.\r\n   */\r\n  complianceRatingReasons: defineReasonsColumn({\r\n    field: 'complianceReasons',\r\n    headerName: 'Compliance Rating Reasons',\r\n  }),\r\n  created_on: {\r\n    field: 'created_on',\r\n    headerName: 'Date',\r\n    editable: false,\r\n    type: 'dateTime',\r\n    width: 120,\r\n  },\r\n  inferred: {\r\n    field: 'inferred',\r\n    headerName: 'Inferred',\r\n    type: 'boolean',\r\n    editable: false,\r\n  },\r\n  /**\r\n   * Column definition for the `policy_basis` field.\r\n   * Displays the policy basis of an email property as chips.\r\n   */\r\n  policyBasis: {\r\n    field: 'policy_basis',\r\n    headerName: 'Policy Basis',\r\n    editable: false,\r\n    width: 300,\r\n    renderCell: renderArrayAsChips,\r\n  },\r\n  /**\r\n   * Column definition for the `sentiment` field.\r\n   * Displays the sentiment of an email property.\r\n   */\r\n  sentiment: {\r\n    field: 'sentiment',\r\n    headerName: 'Sentiment',\r\n    editable: false,\r\n    type: 'number',\r\n    renderCell: renderProgress,\r\n  },\r\n  /**\r\n   * Column definition for the `sentiment_reasons` field.\r\n   * Displays the reasons for the sentiment rating assigned to a document.\r\n   */\r\n  sentimentReasons: defineReasonsColumn({\r\n    field: 'sentiment_reasons',\r\n    headerName: 'Sentiment Reasons',\r\n  }),\r\n  severity: {\r\n    field: 'severity',\r\n    headerName: 'Severity',\r\n    description:\r\n      'Degree to which this item has potential to expose the District to liability',\r\n    width: 80,\r\n    editable: false,\r\n    type: 'number',\r\n    renderCell: renderSeverity,\r\n  },\r\n  severityReason: {\r\n    ...defineReasonsColumn({\r\n      field: 'severity_reason',\r\n      description: 'Reasons the Severity rating was assigned',\r\n      headerName: 'Severity Reasons',\r\n    }),\r\n  },\r\n  /**\r\n   * Column definition for the `tags` field.\r\n   * Displays the tags of an email property as chips.\r\n   */\r\n  tags: {\r\n    field: 'tags',\r\n    headerName: 'Tags',\r\n    editable: false,\r\n    width: 400,\r\n    renderCell: renderArrayAsChips,\r\n  },\r\n} as const;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\server-bound-data-grid-props-schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\server-bound-data-grid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\data-grid\\valueGetters.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":11,"column":1,"nodeType":"Program","endLine":76,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Converts an unknown value to a `Date` object if possible.\r\n *\r\n * - If the input is a number, it is treated as a timestamp (milliseconds since epoch).\r\n * - If the input is not a number, it is converted to a string and passed to the `Date` constructor.\r\n * - If the input is falsy (e.g., `null`, `undefined`, `0`, `''`), returns `null`.\r\n *\r\n * @param v - The value to convert to a `Date`.\r\n * @returns The corresponding `Date` object, or `null` if the input is falsy.\r\n */\r\nexport const valueGetterDate = (v: unknown) => {\r\n  if (v) {\r\n    if (typeof v === 'number' && !isNaN(v)) {\r\n      return new Date(v);\r\n    }\r\n    if (typeof v === 'string' && v.trim() !== '') {\r\n      const check = new Date(v);\r\n      if (isNaN(check.getTime())) {\r\n        return new Date(Number(v));\r\n      }\r\n      return check;\r\n    }\r\n    if (v instanceof Date) {\r\n      return v;\r\n    }\r\n    if (typeof v === 'object' && v !== null) {\r\n      return new Date(String(v));\r\n    }\r\n  }\r\n  return null;\r\n};\r\n\r\nexport const valueGetterPercentageFactory = ({\r\n  base = 100,\r\n  precision = 1,\r\n  includePercent = true,\r\n}: {\r\n  base?: number;\r\n  precision?: number;\r\n  includePercent?: boolean;\r\n}) => {\r\n  return (v: unknown) => {\r\n    if (v === null || v === undefined) {\r\n      return null;\r\n    }\r\n    if (typeof v === 'string') {\r\n      const parsedValue = parseFloat(v);\r\n      if (!isNaN(parsedValue)) {\r\n        v = parsedValue;\r\n      }\r\n    }\r\n    if (typeof v === 'number') {\r\n      return includePercent\r\n        ? `${(v * base).toFixed(precision)}%`\r\n        : (v * base).toFixed(precision);\r\n    }\r\n    return null;\r\n  };\r\n};\r\n\r\nexport const valueFormatterPercentageDecimal = valueGetterPercentageFactory({\r\n  base: 100,\r\n  precision: 1,\r\n});\r\nexport const valueFormatterPercentageIntegerBaseTen =\r\n  valueGetterPercentageFactory({\r\n    base: 10,\r\n    precision: 0,\r\n    includePercent: true,\r\n  });\r\nexport const valueFormatterPercentageInteger = valueGetterPercentageFactory({\r\n  base: 1,\r\n  precision: 0,\r\n  includePercent: true,\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\resizeable-draggable-dialog\\dialog.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":11,"column":1,"nodeType":"Program","endLine":434,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Resizable and draggable dialog component built on top of Material-UI Dialog.\r\n * This module provides a customizable dialog that can be resized and dragged around the screen,\r\n * with support for both modal and non-modal behaviors.\r\n *\r\n * @author NoEducation Team\r\n * @version 1.0.0\r\n * @since 2025-07-07\r\n */\r\n\r\n'use client';\r\n\r\nimport * as React from 'react';\r\nimport Dialog from '@mui/material/Dialog';\r\nimport DialogContent from '@mui/material/DialogContent';\r\nimport { PaperProps } from '@mui/material/Paper';\r\nimport { styled } from '@mui/material/styles';\r\nimport { useCallback, useId, useState, useRef, useMemo } from 'react';\r\nimport { IconButton, Typography } from '@mui/material';\r\nimport MinimizeIcon from '@mui/icons-material/Minimize';\r\nimport MaximizeIcon from '@mui/icons-material/CropSquare';\r\nimport RestoreIcon from '@mui/icons-material/FilterNone';\r\nimport CloseIcon from '@mui/icons-material/Close';\r\nimport ResizeableDraggablePaper from './resizeable-draggable-paper';\r\nimport { ResizeableDraggableDialogProps } from './types';\r\nimport { log } from '@/lib/logger';\r\n\r\n/**\r\n * Enum for dialog window state\r\n */\r\nenum WindowState {\r\n  Normal = 'normal',\r\n  Minimized = 'minimized',\r\n  Maximized = 'maximized',\r\n}\r\n\r\n/**\r\n * Styled component for the draggable handle area at the top of the dialog.\r\n * Uses Material-UI's styled API for consistent theming integration.\r\n *\r\n * Features:\r\n * - Move cursor to indicate draggable area\r\n * - Focus styles for keyboard navigation\r\n * - Proper padding for touch targets\r\n *\r\n * @component\r\n * @example\r\n * ```tsx\r\n * <DraggableHandle id=\"my-dialog-handle\">\r\n *   Drag me to move the dialog\r\n * </DraggableHandle>\r\n * ```\r\n */\r\nconst DraggableHandle = styled('div')`\r\n  cursor: move;\r\n  padding: 8px;\r\n  min-height: 24px;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n\r\n  &:focus {\r\n    outline: 2px solid ${({ theme }) => theme.palette.primary.main};\r\n    outline-offset: 2px;\r\n    background-color: ${({ theme }) => theme.palette.action.hover};\r\n  }\r\n\r\n  &:focus-visible {\r\n    outline: 2px solid ${({ theme }) => theme.palette.primary.main};\r\n    outline-offset: 2px;\r\n  }\r\n`;\r\n\r\nconst stableStyles = {\r\n  dialogTitle: {\r\n    marginY: 0,\r\n    marginLeft: '1em',\r\n  },\r\n};\r\n\r\n/**\r\n * Container for window control buttons (minimize, maximize, close)\r\n */\r\nconst WindowControls = styled('div')`\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 4px;\r\n`;\r\n\r\n/**\r\n * A resizable and draggable dialog component that extends Material-UI's Dialog functionality.\r\n *\r\n * This component provides:\r\n * - Drag functionality via a designated handle area\r\n * - Resize capability with configurable constraints\r\n * - Modal and non-modal modes\r\n * - Integration with Material-UI theming\r\n * - Accessibility features with proper ARIA labeling\r\n *\r\n * @component\r\n * @example\r\n * ```tsx\r\n * const [isOpen, setIsOpen] = useState(false);\r\n *\r\n * return (\r\n *   <ResizableDraggableDialog\r\n *     isOpenState={[isOpen, setIsOpen]}\r\n *     title=\"My Dialog\"\r\n *     initialWidth={500}\r\n *     initialHeight={400}\r\n *     modal={false}\r\n *   >\r\n *     <p>Dialog content goes here</p>\r\n *   </ResizableDraggableDialog>\r\n * );\r\n * ```\r\n *\r\n * @param {ResizeableDraggableDialogProps} props - The component props\r\n * @param {[boolean, React.Dispatch<React.SetStateAction<boolean>>]} props.isOpenState - Tuple containing open state and setter\r\n * @param {string} props.title - Dialog title displayed in the header\r\n * @param {React.ReactNode} props.children - Content to be rendered inside the dialog\r\n * @param {boolean} [props.modal=false] - Whether the dialog should be modal (blocking interaction with background)\r\n * @param {number} [props.initialHeight=300] - Initial height of the dialog in pixels\r\n * @param {number} [props.initialWidth=400] - Initial width of the dialog in pixels\r\n * @param {() => typeof DialogActions} [props.dialogActions] - Function returning dialog actions component\r\n * @param {SetRefineSizeFunction} [props.setRefineSizeProps] - Callback for external size control\r\n * @param {function} [props.onClose] - Custom close handler\r\n * @param {object} [props.paperProps] - Additional props to pass to the underlying Paper component\r\n *\r\n * @returns {JSX.Element} The rendered resizable draggable dialog\r\n */\r\nconst ResizableDraggableDialog = ({\r\n  isOpenState: open,\r\n  paperProps,\r\n  children,\r\n  title,\r\n  modal = false,\r\n  width: width = 400,\r\n  height: height = 300,\r\n  dialogActions,\r\n  onClose,\r\n  onResize,\r\n  minConstraints = [200, 200],\r\n}: ResizeableDraggableDialogProps) => {\r\n  const thisItemId = useId();\r\n  const { dialogTitleId, dialogDraggableHandleId } = {\r\n    dialogTitleId: `${thisItemId}-draggable-dialog-title`,\r\n    dialogDraggableHandleId: `${thisItemId}-draggable-dialog`,\r\n  } as const;\r\n\r\n  // State for tracking keyboard drag position\r\n  const dragHandleRef = useRef<HTMLDivElement>(null);\r\n\r\n  // State for window functionality\r\n  const [windowState, setWindowState] = useState<WindowState>(\r\n    WindowState.Normal,\r\n  );\r\n\r\n  /**\r\n   * Type definition for the handleClose function overloads.\r\n   * Supports both simple close events and close events with reasons.\r\n   *\r\n   * @interface HandleCloseOverloads\r\n   */\r\n  interface HandleCloseOverloads {\r\n    /**\r\n     * Handle close event without reason\r\n     * @param {React.MouseEvent<HTMLAnchorElement>} evt - The mouse event\r\n     */\r\n    (evt: React.MouseEvent<HTMLAnchorElement | HTMLButtonElement>): void;\r\n    /**\r\n     * Handle close event with reason\r\n     * @param {React.MouseEvent<HTMLAnchorElement>} evt - The mouse event\r\n     * @param {'backdropClick' | 'escapeKeyDown'} reason - The reason for closing\r\n     */\r\n    (\r\n      evt: React.MouseEvent<HTMLAnchorElement | HTMLButtonElement>,\r\n      reason: 'backdropClick' | 'escapeKeyDown',\r\n    ): void;\r\n  }\r\n\r\n  /**\r\n   * Handles dialog close events with support for modal/non-modal behavior.\r\n   *\r\n   * In non-modal mode, backdrop clicks are ignored to allow interaction with\r\n   * elements behind the dialog. Only explicit close actions or escape key\r\n   * will close the dialog.\r\n   *\r\n   * @function handleClose\r\n   * @param {React.MouseEvent<HTMLAnchorElement>} evt - The triggering mouse event\r\n   * @param {'backdropClick' | 'escapeKeyDown'} [reason] - Optional reason for the close event\r\n   */\r\n  const handleClose = useCallback<HandleCloseOverloads>(\r\n    (\r\n      evt: React.MouseEvent<HTMLAnchorElement | HTMLButtonElement>,\r\n      reason?: 'backdropClick' | 'escapeKeyDown',\r\n    ) => {\r\n      if (!open) {\r\n        return;\r\n      }\r\n      // For modal dialogs, allow all close reasons\r\n      // For non-modal dialogs, ignore backdrop clicks\r\n      if (modal === true || reason !== 'backdropClick') {\r\n        onClose(evt, reason ?? '');\r\n      }\r\n    },\r\n    [open, onClose, modal],\r\n  );\r\n\r\n  /**\r\n   * Handle minimize button click\r\n   */\r\n  const handleMinimize = useCallback(() => {\r\n    setWindowState(WindowState.Minimized);\r\n  }, [setWindowState]);\r\n\r\n  /**\r\n   * Handle maximize button click\r\n   */\r\n  const handleMaximize = useCallback(() => {\r\n    if (windowState === WindowState.Maximized) {\r\n      // Restore to normal state\r\n      setWindowState(WindowState.Normal);\r\n    } else {\r\n      setWindowState(WindowState.Maximized);\r\n    }\r\n  }, [windowState]);\r\n\r\n  /**\r\n   * Handle close button click\r\n   */\r\n  const handleCloseClick = useCallback(\r\n    (evt: React.MouseEvent<HTMLButtonElement | HTMLAnchorElement>) => {\r\n      handleClose(evt as React.MouseEvent<HTMLAnchorElement>);\r\n    },\r\n    [handleClose],\r\n  );\r\n\r\n  /**\r\n   * Memoized render function for the resizable draggable paper component.\r\n   *\r\n   * This component serves as the custom Paper component for the Material-UI Dialog,\r\n   * providing the resize and drag functionality. The memoization prevents unnecessary\r\n   * re-renders when the dialog props haven't changed.\r\n   *\r\n   * @function RenderResizeableDraggablePaper\r\n   * @returns {JSX.Element} The resizable draggable paper component\r\n   */\r\n  const RenderResizeableDraggablePaper = useCallback(\r\n    (muiPaperProps: PaperProps) => {\r\n      let dialogHeight = height;\r\n      let dialogWidth = width;\r\n\r\n      if (windowState === WindowState.Maximized) {\r\n        // Use full viewport dimensions for maximized state\r\n        dialogHeight = window.innerHeight - 20; // Minimal margin\r\n        dialogWidth = window.innerWidth - 20;\r\n      } else if (windowState === WindowState.Minimized) {\r\n        // Use minimal size for minimized state\r\n        dialogHeight = 40; // Just show title bar\r\n        dialogWidth = 300;\r\n      }\r\n      return (\r\n        <ResizeableDraggablePaper\r\n          {...(paperProps ?? {})}\r\n          {...muiPaperProps}\r\n          height={dialogHeight}\r\n          width={dialogWidth}\r\n          // setRefineSizeProps={setRefineSizeProps}\r\n          dialogId={dialogDraggableHandleId}\r\n          minConstraints={minConstraints}\r\n          maxConstraints={[\r\n            window.innerWidth - 20, // Leave some margin\r\n            window.innerHeight - 20,\r\n          ]}\r\n          onResize={onResize}\r\n        />\r\n      );\r\n    },\r\n    [\r\n      height,\r\n      width,\r\n      windowState,\r\n      paperProps,\r\n      dialogDraggableHandleId,\r\n      minConstraints,\r\n      onResize,\r\n    ],\r\n  );\r\n\r\n  /**\r\n   * Validate initial dimensions against constraints.\r\n   * Logs a warning if initialHeight or initialWidth are outside the defined constraints.\r\n   */\r\n  React.useEffect(() => {\r\n    let newHeight = height;\r\n    let newWidth = width;\r\n    if (height < minConstraints[1]) {\r\n      console.warn(`initialHeight ${height} is outside constraints`);\r\n      newHeight = minConstraints[1];\r\n    }\r\n    if (height > window.innerHeight - 20) {\r\n      console.warn(`initialHeight ${height} is outside constraints`);\r\n      newHeight = window.innerHeight - 20;\r\n    }\r\n    if (width < minConstraints[0]) {\r\n      console.warn(`initialWidth ${width} is outside constraints`);\r\n      newWidth = minConstraints[0];\r\n    }\r\n    if (width > window.innerWidth - 20) {\r\n      console.warn(`initialWidth ${width} is outside constraints`);\r\n      newWidth = window.innerWidth - 20;\r\n    }\r\n    if (!onResize) {\r\n      log((l) =>\r\n        l.warn(\r\n          'onResize callback is not provided, dynamic resizing will not work.',\r\n        ),\r\n      );\r\n    }\r\n    onResize?.(newWidth, newHeight);\r\n  }, [height, width, minConstraints, onResize]);\r\n\r\n  /**\r\n   * Memoized slotProps for Dialog component to prevent unnecessary re-renders.\r\n   * Only updates when modal prop changes.\r\n   */\r\n  const dialogSlotProps = useMemo(\r\n    () => ({\r\n      root: {\r\n        style: {\r\n          // Allow pointer events to pass through when non-modal\r\n          pointerEvents:\r\n            modal === false ? ('none' as const) : ('auto' as const),\r\n        },\r\n      },\r\n    }),\r\n    [modal],\r\n  );\r\n\r\n  /**\r\n   * Memoized sx styles for Dialog component to prevent unnecessary re-renders.\r\n   * Only updates when modal prop changes.\r\n   */\r\n  const dialogSx = useMemo(\r\n    () => ({\r\n      // Additional styling if needed\r\n      ...(modal === false && {\r\n        '& .MuiDialog-container': {\r\n          pointerEvents: 'none',\r\n        },\r\n        '& .MuiDialog-paper': {\r\n          // Ensure the dialog paper itself still receives pointer events\r\n          pointerEvents: 'auto !important',\r\n        },\r\n      }),\r\n    }),\r\n    [modal],\r\n  );\r\n\r\n  return (\r\n    <React.Fragment>\r\n      <Dialog\r\n        open={open}\r\n        onClose={handleClose}\r\n        PaperComponent={RenderResizeableDraggablePaper}\r\n        hideBackdrop={modal === false} // Hide backdrop for non-modal, show for modal\r\n        disableEnforceFocus={modal === false} // Allow focus outside for non-modal\r\n        aria-labelledby={dialogTitleId}\r\n        slotProps={dialogSlotProps}\r\n        sx={dialogSx}\r\n      >\r\n        <DraggableHandle\r\n          ref={dragHandleRef}\r\n          id={dialogDraggableHandleId}\r\n          role=\"button\"\r\n          tabIndex={0}\r\n          aria-label=\"Drag to move dialog. Use arrow keys to move, hold Shift for larger steps.\"\r\n        >\r\n          <Typography component=\"h3\" sx={stableStyles.dialogTitle}>\r\n            {title}\r\n          </Typography>\r\n          <div style={{ flex: 1 }}>&nbsp;</div>\r\n          <WindowControls>\r\n            <IconButton\r\n              size=\"small\"\r\n              onClick={handleMinimize}\r\n              aria-label=\"Minimize dialog\"\r\n              sx={{ padding: '2px' }}\r\n              data-id=\"button-window-minimize\"\r\n            >\r\n              <MinimizeIcon fontSize=\"small\" />\r\n            </IconButton>\r\n            <IconButton\r\n              size=\"small\"\r\n              onClick={handleMaximize}\r\n              data-id=\"button-window-maximize\"\r\n              aria-label={\r\n                windowState === WindowState.Maximized\r\n                  ? 'Restore dialog'\r\n                  : 'Maximize dialog'\r\n              }\r\n              sx={{ padding: '2px' }}\r\n            >\r\n              {windowState === WindowState.Maximized ? (\r\n                <RestoreIcon fontSize=\"small\" />\r\n              ) : (\r\n                <MaximizeIcon fontSize=\"small\" />\r\n              )}\r\n            </IconButton>\r\n            <IconButton\r\n              size=\"small\"\r\n              data-id=\"button-window-inline\"\r\n              onClick={handleCloseClick}\r\n              aria-label=\"Close dialog\"\r\n              sx={{ padding: '2px' }}\r\n            >\r\n              <CloseIcon fontSize=\"small\" />\r\n            </IconButton>\r\n          </WindowControls>\r\n        </DraggableHandle>\r\n        {windowState !== WindowState.Minimized && (\r\n          <>\r\n            <DialogContent>{children}</DialogContent>\r\n            {dialogActions && dialogActions({})}\r\n          </>\r\n        )}\r\n      </Dialog>\r\n    </React.Fragment>\r\n  );\r\n};\r\n\r\nexport default ResizableDraggableDialog;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\resizeable-draggable-dialog\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":37,"column":1,"nodeType":"Program","endLine":65,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Entry point for the resizable draggable dialog component library.\r\n * This module provides the main export for the ResizableDraggableDialog component\r\n * and serves as the public API for the dialog system.\r\n *\r\n * The component library provides a complete solution for creating interactive dialogs\r\n * with resize and drag capabilities built on top of Material-UI components.\r\n *\r\n * @author NoEducation Team\r\n * @version 1.0.0\r\n * @since 2025-07-07\r\n *\r\n * @example\r\n * ```tsx\r\n * import ResizableDraggableDialog from '@/components/mui/resizeable-draggable-dialog';\r\n *\r\n * function MyComponent() {\r\n *   const [isOpen, setIsOpen] = useState(false);\r\n *\r\n *   return (\r\n *     <ResizableDraggableDialog\r\n *       isOpenState={[isOpen, setIsOpen]}\r\n *       title=\"Interactive Dialog\"\r\n *       modal={false}\r\n *       initialWidth={600}\r\n *       initialHeight={400}\r\n *     >\r\n *       <p>This dialog can be resized and dragged!</p>\r\n *     </ResizableDraggableDialog>\r\n *   );\r\n * }\r\n * ```\r\n *\r\n * @module ResizableDraggableDialog\r\n */\r\n\r\nimport ResizableDraggableDialog from './dialog';\r\n\r\n/**\r\n * The main resizable draggable dialog component.\r\n *\r\n * This is the primary export that combines all the functionality of the dialog system\r\n * into a single, easy-to-use component. It includes:\r\n * - Drag functionality with customizable handle\r\n * - Resize capabilities with configurable constraints\r\n * - Modal and non-modal modes\r\n * - Material-UI theming integration\r\n * - Accessibility features\r\n *\r\n * @component\r\n * @default\r\n */\r\nexport default ResizableDraggableDialog;\r\n\r\n// Re-export types for convenience\r\nexport type {\r\n  Size,\r\n  RefineSizeFunction,\r\n  SetRefineSizeFunction,\r\n  ResizeableDraggablePaperProps,\r\n  ResizeableDraggableDialogProps,\r\n} from './types';\r\n\r\nexport { isValidSize } from './types';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\resizeable-draggable-dialog\\resizeable-draggable-paper.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":27,"column":1,"nodeType":"Program","endLine":189,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Resizable and draggable paper component that wraps Material-UI Paper with interactive capabilities.\r\n * This module integrates react-draggable and react-resizable to provide a fully interactive p          <Paper\r\n            {...props}\r\n            style={{\r\n              height: `${height}px`,\r\n              width: `${width}px`,\r\n              maxHeight: '100%',\r\n              margin: 0,\r\n            }}\r\n          >\r\n            {props.children}\r\n          </Paper>onent\r\n * that can be used as a custom PaperComponent in Material-UI Dialogs.\r\n *\r\n * The component manages its own size state and provides callbacks for external size control,\r\n * making it suitable for complex dialog implementations that need programmatic size management.\r\n *\r\n * @author NoEducation Team\r\n * @version 1.0.0\r\n * @since 2025-07-07\r\n * @requires react-draggable\r\n * @requires react-resizable\r\n * @requires @mui/material/Paper\r\n */\r\n\r\n'use client';\r\n\r\nimport * as React from 'react';\r\nimport Paper from '@mui/material/Paper';\r\nimport Draggable from 'react-draggable';\r\nimport { ResizableBox, ResizeHandle } from 'react-resizable';\r\nimport { useCallback } from 'react';\r\nimport type {\r\n  ResizeableDraggablePaperProps,\r\n} from './types';\r\nimport 'react-resizable/css/styles.css';\r\n\r\n/**\r\n * Default resize handles configuration for the resizable component.\r\n * Includes all 8 directional handles: corners and edges.\r\n * @constant {string[]}\r\n */\r\nconst stableResizeHandles: ResizeHandle[] = ['sw', 'se', 'nw', 'ne', 'w', 'e', 'n', 's'] as const;\r\n\r\n/**\r\n * Default minimum size constraints [width, height] in pixels.\r\n * Ensures the dialog remains usable at small sizes.\r\n * @constant {[number, number]}\r\n */\r\nconst defaultMinConstraints: [number, number] | undefined = [200, 200] as const;\r\n\r\n/**\r\n * Default maximum size constraints [width, height] in pixels.\r\n * Prevents the dialog from becoming too large on small screens.\r\n * @constant {[number, number]}\r\n */\r\nconst defaultMaxConstraints: [number, number] | undefined = undefined;\r\n\r\n/**\r\n * A resizable and draggable paper component that extends Material-UI Paper functionality.\r\n *\r\n * This component combines:\r\n * - Material-UI Paper for consistent styling and theming\r\n * - react-draggable for drag functionality\r\n * - react-resizable for resize capabilities\r\n * - Internal size state management\r\n * - External size control through callbacks\r\n *\r\n * The component is designed to be used as a PaperComponent in Material-UI Dialogs,\r\n * providing a seamless way to make dialogs interactive.\r\n *\r\n * @component\r\n * @example\r\n * ```tsx\r\n * // Basic usage\r\n * <ResizeableDraggablePaper\r\n *   height={400}\r\n *   width={600}\r\n *   dialogId=\"my-dialog\"\r\n * />\r\n *\r\n * // With size control callback\r\n * const [height, setHeight] = useState(400);\r\n * const [width, setWidth] = useState(600);\r\n * const onResize = useCallback((height: number, width: number) => {\r\n *   setHeight(height);\r\n *   setWidth(width);\r\n * });\r\n *\r\n * <ResizeableDraggablePaper\r\n *   height={400}\r\n *   width={600}\r\n *   onResize={onResize}\r\n *   minConstraints={[200, 150]}\r\n * />\r\n * ```\r\n *\r\n * @param {ResizeableDraggablePaperProps} props - The component props\r\n * @param {number} [props.height] - Initial height in pixels\r\n * @param {number} [props.width] - Initial width in pixels\r\n * @param {SetRefineSizeFunction} [props.setRefineSizeProps] - Callback to expose size control function\r\n * @param {[number, number]} [props.minConstraints] - Minimum [width, height] constraints\r\n * @param {[number, number]} [props.maxConstraints] - Maximum [width, height] constraints\r\n * @param {string} [props.dialogId] - ID of the drag handle element\r\n * @param {...PaperProps} props.props - Additional props passed to Material-UI Paper\r\n *\r\n * @returns {JSX.Element} The rendered resizable draggable paper component\r\n */\r\nconst ResizeableDraggablePaper = ({\r\n  height,\r\n  width,\r\n  /*\r\n  height: initialHeight,\r\n  width: initialWidth,\r\n  setRefineSizeProps,\r\n  */\r\n  minConstraints,\r\n  maxConstraints,\r\n  dialogId,\r\n  children,\r\n  onResize,\r\n  ...props\r\n}: ResizeableDraggablePaperProps) => {\r\n  const nodeRef = React.useRef<HTMLDivElement>(null);\r\n  /**\r\n   * Handles resize events from the ResizableBox component.\r\n   *\r\n   * Updates the internal size state when the user resizes the dialog.\r\n   * Only updates state if the new dimensions are different from current ones\r\n   * to prevent unnecessary re-renders.\r\n   *\r\n   * @function onDialogResize\r\n   * @param {unknown} event - The resize event (unused)\r\n   * @param {object} data - Resize event data\r\n   * @param {object} data.size - New size information\r\n   * @param {number} data.size.width - New width in pixels\r\n   * @param {number} data.size.height - New height in pixels\r\n   */\r\n  const onDialogResize = useCallback(\r\n    (\r\n      event: unknown,\r\n      {\r\n        size: { width: newWidth, height: newHeight },\r\n      }: { size: { width: number; height: number } },\r\n    ) => {\r\n      // Trigger the onResize callback to notify parent\r\n      // of resize request; note parent maintains state through\r\n      // this callback, we may want to consider making it non-optional\r\n      onResize?.(newWidth, newHeight);\r\n    },\r\n    [onResize],\r\n  );\r\n  \r\n  return (\r\n    <Draggable\r\n      nodeRef={nodeRef as React.RefObject<HTMLDivElement>}\r\n      handle={`#${dialogId ?? 'draggable-dialog'}`}\r\n    >\r\n      <div ref={nodeRef}>\r\n        <ResizableBox\r\n          className=\"box\"\r\n          width={width}\r\n          height={height}\r\n          minConstraints={minConstraints ?? defaultMinConstraints}\r\n          maxConstraints={maxConstraints ?? defaultMaxConstraints}\r\n          resizeHandles={stableResizeHandles}\r\n          onResize={onDialogResize}\r\n        >\r\n          <Paper\r\n            {...props}\r\n            style={{\r\n              height: `${height}px`,\r\n              width: `${width}px`,\r\n              maxHeight: '100%',\r\n              maxWidth: '100%',\r\n              margin: 0,\r\n            }}\r\n          >\r\n            {children}\r\n          </Paper>\r\n        </ResizableBox>\r\n      </div>\r\n    </Draggable>\r\n  );\r\n};\r\n\r\nexport default ResizeableDraggablePaper;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\mui\\resizeable-draggable-dialog\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":17,"column":1,"nodeType":"Program","endLine":222,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Type definitions for the resizable draggable dialog component system.\r\n * This module contains all TypeScript interfaces, types, and type utilities used\r\n * throughout the resizable draggable dialog components.\r\n *\r\n * The type system is designed to provide strong typing for:\r\n * - Size management and constraints\r\n * - Component props with proper Material-UI integration\r\n * - Callback functions for external size control\r\n * - Dialog configuration options\r\n *\r\n * @author NoEducation Team\r\n * @version 1.0.0\r\n * @since 2025-07-07\r\n */\r\n\r\nimport { DialogProps } from '@mui/material/Dialog';\r\nimport { PaperProps } from '@mui/material/Paper';\r\nimport React, { JSX, PropsWithChildren } from 'react';\r\nimport DialogAction from '@mui/material/DialogActions';\r\nimport { FirstParameter } from '@/lib/typescript';\r\ntype DialogActionProps = FirstParameter<typeof DialogAction>;\r\n/**\r\n * Represents the dimensions of a dialog or component.\r\n *\r\n * @interface Size\r\n * @property {number} height - Height in pixels\r\n * @property {number} width - Width in pixels\r\n *\r\n * @example\r\n * ```tsx\r\n * const dialogSize: Size = { height: 400, width: 600 };\r\n * ```\r\n */\r\nexport type Pixels = number & { __brand: 'pixels' };\r\nexport type Size = { height: Pixels; width: Pixels };\r\n\r\n/**\r\n * Function type for reading or setting component size.\r\n *\r\n * This type supports two modes of operation:\r\n * 1. Getter mode: Called without parameters, returns current size\r\n * 2. Setter mode: Called with Size parameter, updates the size\r\n *\r\n * @typedef {Function} RefineSizeFunction\r\n * @param {Size} [size] - Optional size to set\r\n * @returns {Size|void} Current size when called as getter, void when called as setter\r\n *\r\n * @example\r\n * ```tsx\r\n * // As getter\r\n * const currentSize = refineSizeFunction();\r\n *\r\n * // As setter\r\n * refineSizeFunction({ width: 500, height: 300 });\r\n * ```\r\n */\r\nexport type RefineSizeFunction = (() => Size) | ((size: Size) => void);\r\n\r\n/**\r\n * React state setter type for the RefineSizeFunction.\r\n *\r\n * This type is used to pass the ability to set the refine size function\r\n * from child components back to parent components, enabling external\r\n * control of dialog sizing.\r\n *\r\n * @typedef {React.Dispatch<React.SetStateAction<RefineSizeFunction>>} SetRefineSizeFunction\r\n *\r\n * @example\r\n * ```tsx\r\n * const [refineSizeFunction, setRefineSizeFunction] = useState<RefineSizeFunction>();\r\n *\r\n * // Pass to child component\r\n * <ResizeableDraggablePaper setRefineSizeProps={setRefineSizeFunction} />\r\n * ```\r\n */\r\nexport type SetRefineSizeFunction = React.Dispatch<\r\n  React.SetStateAction<RefineSizeFunction>\r\n>;\r\n\r\n/**\r\n * Props interface for the ResizeableDraggablePaper component.\r\n *\r\n * Extends Material-UI PaperProps while adding resize and drag-specific properties.\r\n * This interface ensures type safety when configuring the interactive paper component.\r\n *\r\n * @interface ResizeableDraggablePaperProps\r\n * @extends {PaperProps}\r\n * @property {number} [height] - Initial height in pixels\r\n * @property {number} [width] - Initial width in pixels\r\n * @property {[number, number]} [minConstraints] - Minimum [width, height] constraints\r\n * @property {[number, number]} [maxConstraints] - Maximum [width, height] constraints\r\n * @property {SetRefineSizeFunction} [setRefineSizeProps] - Callback for external size control\r\n * @property {string} [dialogId] - ID of the drag handle element\r\n *\r\n * @example\r\n * ```tsx\r\n * const paperProps: ResizeableDraggablePaperProps = {\r\n *   height: 400,\r\n *   width: 600,\r\n *   minConstraints: [200, 150],\r\n *   maxConstraints: [1000, 800],\r\n *   elevation: 3\r\n * };\r\n * ```\r\n */\r\nexport type ResizeableDraggablePaperProps = PaperProps & {\r\n  height: number;\r\n  width: number;\r\n  minConstraints?: [number, number];\r\n  maxConstraints?: [number, number];\r\n  dialogId?: string;\r\n  onResize?: (width: number, height: number) => void;\r\n};\r\n\r\n/**\r\n * Props interface for the ResizeableDraggableDialog component.\r\n *\r\n * Extends Material-UI DialogProps while providing additional configuration\r\n * for resize/drag behavior, modal settings, and size management.\r\n *\r\n * @interface ResizeableDraggableDialogProps\r\n * @extends {PropsWithChildren<Omit<DialogProps, 'hideBackdrop' | 'disableEnforceFocus'>>}\r\n * @property {[boolean, React.Dispatch<React.SetStateAction<boolean>>]} isOpenState - Dialog open state tuple\r\n * @property {Omit<ResizeableDraggablePaperProps, 'setRefineSizeProps' | 'width' | 'height' | 'minConstraints' | 'maxConstraints' | 'dialogId'>} [paperProps] - Props for underlying paper component\r\n * @property {boolean} [modal] - Whether dialog should be modal (blocking background interaction)\r\n * @property {() => typeof DialogActions} [dialogActions] - Function returning dialog actions component\r\n * @property {SetRefineSizeFunction} [setRefineSizeProps] - Callback for external size control\r\n * @property {number} [initialHeight] - Initial height in pixels\r\n * @property {number} [initialWidth] - Initial width in pixels\r\n * @property {[number, number]} [minConstraints] - Minimum size constraints\r\n * @property {[number, number]} [maxConstraints] - Maximum size constraints\r\n *\r\n * @example\r\n * ```tsx\r\n * const dialogProps: ResizeableDraggableDialogProps = {\r\n *   isOpenState: [isOpen, setIsOpen],\r\n *   title: \"My Dialog\",\r\n *   modal: false,\r\n *   initialWidth: 500,\r\n *   initialHeight: 400,\r\n *   minConstraints: [300, 200],\r\n *   children: <div>Dialog content</div>\r\n * };\r\n * ```\r\n */\r\nexport type ResizeableDraggableDialogProps = PropsWithChildren<\r\n  Omit<\r\n    DialogProps,\r\n    'open' | 'hideBackdrop' | 'disableEnforceFocus' | 'onClose'\r\n  > & {\r\n    isOpenState: boolean;\r\n    paperProps?: Omit<\r\n      ResizeableDraggablePaperProps,\r\n      | 'setRefineSizeProps'\r\n      | 'width'\r\n      | 'height'\r\n      | 'minConstraints'\r\n      | 'maxConstraints'\r\n      | 'dialogId'\r\n    >;\r\n    modal?: boolean;\r\n    dialogActions?: (props: DialogActionProps) => JSX.Element;\r\n    /**\r\n     * @deprecated I dont know if we want to set this from here?\r\n     */\r\n    initialHeight?: number;\r\n    /**\r\n     * @deprecated I dont know if we want to set this from here?\r\n     */\r\n    initialWidth?: number;\r\n    height?: number;\r\n    width?: number;\r\n    minConstraints?: [number, number];\r\n    maxConstraints?: [number, number];\r\n    /**\r\n     * Called to notify parent of new height/width\r\n     * @param width {number} The new width.\r\n     * @param height {number} The new height.\r\n     */\r\n    onResize?: (width: number, height: number) => void;\r\n    /**\r\n     * Called to notify parent of a dialog close event\r\n     * @param evt {Event} The event that triggered the close.\r\n     * @param reason {string} The reason for the close, such as 'backdropClick' or 'escapeKeyDown'.\r\n     */\r\n    onClose: (\r\n      evt: React.MouseEvent<HTMLAnchorElement | HTMLButtonElement>,\r\n      reason: 'backdropClick' | 'escapeKeyDown' | '',\r\n    ) => void;\r\n  }\r\n>;\r\n\r\n/**\r\n * Runtime validation function for Size type.\r\n *\r\n * This function checks if the given size object conforms to the Size interface,\r\n * ensuring that height and width are positive numbers.\r\n *\r\n * @function isValidSize\r\n * @param {unknown} size - The size object to validate\r\n * @returns {boolean} True if size is valid, false otherwise\r\n *\r\n * @example\r\n * ```tsx\r\n * const sizeToTest = { height: 400, width: 600 };\r\n * const isValid = isValidSize(sizeToTest); // true\r\n * ```\r\n */\r\nexport const isValidSize = (size: unknown): size is Size => {\r\n  return (\r\n    typeof size === 'object' &&\r\n    size !== null &&\r\n    'height' in size &&\r\n    'width' in size &&\r\n    typeof size.height === 'number' &&\r\n    typeof size.width === 'number' &&\r\n    size.height > 0 &&\r\n    size.width > 0\r\n  );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\statistics\\model-statistics.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\statistics\\queue-statistics.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\statistics\\statistics-overview.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\components\\theme\\theme-selector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\data-models\\_types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\data-models\\_utilities.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":7,"column":1,"nodeType":"Program","endLine":143,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module _utilities\r\n *\r\n * This module provides utility functions for data normalization.\r\n */\r\n\r\nimport type { PaginationStats } from './_types';\r\nimport type {\r\n  EmailPropertyCategoryType,\r\n  EmailPropertyCategoryTypeId,\r\n  EmailPropertyTypeType,\r\n  EmailPropertyTypeTypeId,\r\n} from './api/email-properties/property-type';\r\nimport {\r\n  EmailPropertyCategoryTypeIdValues,\r\n  EmailPropertyCategoryTypeValues,\r\n  EmailPropertyTypeTypeIdValues,\r\n  EmailPropertyTypeTypeValues,\r\n} from './api/email-properties/property-type';\r\n\r\n\r\n/**\r\n * Normalizes a nullable numeric value.\r\n *\r\n * If the provided value is null or less than or equal to zero, it returns null.\r\n * Otherwise, it returns the original value.\r\n *\r\n * @param value - The numeric value to normalize, which can be null.\r\n * @returns The normalized numeric value or null.\r\n */\r\nexport const normalizeNullableNumeric = (\r\n  value: number | null | undefined,\r\n  defaultValue: number | null = null,\r\n  minValue: number = 1,\r\n): number | null => ((value ?? 0) > minValue - 1 ? value ?? null : defaultValue);\r\n\r\n\r\n\r\n/**\r\n * Checks if the given value is of type `PaginationStats`.\r\n *\r\n * @param check - The value to check.\r\n * @returns `true` if the value is a `PaginationStats` object, otherwise `false`.\r\n */\r\nexport const isPaginationStats = (check: unknown): check is PaginationStats => {\r\n  if (check && typeof check === 'object') {\r\n    const { page, num } = check as PaginationStats;\r\n    return (\r\n      typeof page === 'number' && typeof num === 'number' && page > 0 && num > 0\r\n    );\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Normalizes a date and time input to an ISO string format.\r\n *\r\n * If the input is invalid, it returns the default value or the current date and time.\r\n *\r\n * @param {string | Date} input - The date and time input to normalize.\r\n * @param {Date} [defaultValue] - The default value to return if the input is invalid.\r\n * @returns {string} The normalized date and time in ISO string format.\r\n */\r\nexport const normalizeDateAndTime = (\r\n  input: string | Date,\r\n  defaultValue?: Date,\r\n) => {\r\n  let date: Date;\r\n  try {\r\n    date = new Date(input);\r\n    if (isNaN(date.valueOf())) {\r\n      date = defaultValue ?? new Date();\r\n    }\r\n  } catch {\r\n    date = defaultValue ?? new Date();\r\n  }\r\n  return date.toISOString().slice(0, 16);\r\n};\r\n\r\n/**\r\n * Looks up the email property type ID within known {@link EmailPropertyTypeTypeId} values\r\n * based on the provided property type string.  Note that this is only looking at well-known\r\n * values and does not account for custom property types.\r\n *\r\n * @param {string} propertyType - The property type string to look up.\r\n * @returns {EmailPropertyTypeTypeId | -1} The email property type ID or -1 if not found.\r\n */\r\nexport const lookupEmailPropertyType = (\r\n  propertyType: string | number,\r\n): EmailPropertyTypeTypeId | -1 => {\r\n  const index =\r\n    typeof propertyType === 'number'\r\n      ? propertyType\r\n      : EmailPropertyTypeTypeValues.indexOf(\r\n          propertyType as EmailPropertyTypeType,\r\n        );\r\n  return index === -1 ? -1 : EmailPropertyTypeTypeIdValues[index];\r\n};\r\n\r\n/**\r\n * Checks if the provided value is a valid {@link EmailPropertyTypeType} value.\r\n *\r\n * @param {unknown} check - The value to check.\r\n * @returns {check is EmailPropertyTypeType} True if the value is a valid email property type, false otherwise.\r\n */\r\nexport const isEmailPropertyType = (\r\n  check: unknown,\r\n): check is EmailPropertyTypeType =>\r\n  typeof check === 'string' && lookupEmailPropertyType(check) !== -1;\r\n\r\n/**\r\n * Looks up the {@link EmailPropertyCategoryTypeId} value based on the provided input.\r\n * Note that this only handles well-known categories and does not account for custom property categories.\r\n *\r\n * @param {string} propertyCategory - The property category string to look up.\r\n * @returns {EmailPropertyCategoryTypeId | -1} The email property category ID or -1 if not found.\r\n */\r\nexport const lookupEmailPropertyCategory = (\r\n  propertyCategory: string | number,\r\n): EmailPropertyCategoryTypeId | -1 => {\r\n  const index =\r\n    typeof propertyCategory === 'number'\r\n      ? propertyCategory\r\n      : EmailPropertyCategoryTypeValues.indexOf(\r\n          propertyCategory as EmailPropertyCategoryType,\r\n        );\r\n  return index === -1 ? -1 : EmailPropertyCategoryTypeIdValues[index];\r\n};\r\n\r\n/**\r\n * Checks if the provided value is a valid {@link EmailPropertyCategoryType} value.\r\n *\r\n * @param {unknown} check - The value to check.\r\n * @returns {check is EmailPropertyCategoryType} True if the value is a valid email property category type, false otherwise.\r\n */\r\nexport const isEmailPropertyCategory = (\r\n  check: unknown,\r\n): check is EmailPropertyCategoryType => {\r\n  const isValidCategory =\r\n    typeof check === 'string' && lookupEmailPropertyCategory(check) !== -1;\r\n  return isValidCategory;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\data-models\\api\\attachment\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":28,"column":1,"nodeType":"Program","endLine":122,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview\r\n * This module defines TypeScript types for representing email attachments and their summaries.\r\n *\r\n * The `EmailAttachmentSummary` type provides a concise representation of an email attachment,\r\n * including essential metadata such as the attachment's unique identifier, file name, file path,\r\n * associated policy, email ID, MIME type, and size.\r\n *\r\n * The `EmailAttachment` type extends `EmailAttachmentSummary` to include additional details\r\n * extracted from the attachment, such as the extracted text, TSV (tab-separated values) representation,\r\n * and a brief summary of the content.\r\n *\r\n * These types are designed to facilitate the handling and processing of email attachments\r\n * in applications that require metadata and content extraction.\r\n */\r\n\r\n/**\r\n * Represents a summary of an email attachment.\r\n *\r\n * @property attachmentId - The unique identifier for the attachment.\r\n * @property fileName - The name of the file attached to the email.\r\n * @property filePath - The file path where the attachment is stored.\r\n * @property policyId - The identifier of the policy associated with the attachment, or `null` if no policy is associated.\r\n * @property emailId - The unique identifier of the email to which the attachment belongs.\r\n * @property mimeType - The MIME type of the attachment, indicating the file format.\r\n * @property size - The size of the attachment in bytes.\r\n */\r\nexport type EmailAttachmentSummary = {\r\n  /**\r\n   * Unique identifier for the attachment.\r\n   * @type {number}\r\n   * @memberof EmailAttachmentSummary\r\n   * @description The unique identifier for the attachment.\r\n   * @example 12345\r\n   */\r\n  attachmentId: number;\r\n  /**\r\n   * Name of the file attached to the email.\r\n   * @type {string}\r\n   * @memberof EmailAttachmentSummary\r\n   * @description The name of the file attached to the email.\r\n   * @example \"document.pdf\"\r\n   */\r\n  fileName: string;\r\n  /**\r\n   * File path where the attachment is stored.\r\n   * @type {string}\r\n   * @memberof EmailAttachmentSummary\r\n   * @description The file path where the attachment is stored.\r\n   * @example \"/attachments/document.pdf\"\r\n   */\r\n  filePath: string;\r\n  /**\r\n   * Identifier of the policy associated with the attachment.\r\n   * @type {number | null}\r\n   * @memberof EmailAttachmentSummary\r\n   * @description The identifier of the policy associated with the attachment, or `null` if no policy is associated.\r\n   * @example 67890\r\n   */\r\n  policyId: number | null;\r\n  /**\r\n   * Unique identifier of the email to which the attachment belongs.\r\n   * @type {string}\r\n   * @memberof EmailAttachmentSummary\r\n   * @description The unique identifier of the email to which the attachment belongs.\r\n   * @example \"abc123\"\r\n   */\r\n  emailId: string;\r\n  /**\r\n   * MIME type of the attachment, indicating the file format.\r\n   * @type {string}\r\n   * @memberof EmailAttachmentSummary\r\n   * @description The MIME type of the attachment, indicating the file format.\r\n   * @example \"application/pdf\"\r\n   */\r\n  mimeType: string;\r\n  /**\r\n   * Size of the attachment in bytes.\r\n   * @type {number}\r\n   * @memberof EmailAttachmentSummary\r\n   * @description The size of the attachment in bytes.\r\n   * @example 2048\r\n   */\r\n  size: number;\r\n};\r\n\r\n/**\r\n * Represents an email attachment with additional extracted data.\r\n * Extends the `EmailAttachmentSummary` type to include detailed information\r\n * such as extracted text, TSV (tab-separated values) representation, and a summary.\r\n *\r\n * @property extractedText - The text content extracted from the attachment, or `null` if unavailable.\r\n * @property extractedTextTsv - The TSV (tab-separated values) representation of the extracted text, or `null` if unavailable.\r\n * @property summary - A brief summary of the attachment's content, or `null` if unavailable.\r\n */\r\nexport type EmailAttachment = EmailAttachmentSummary & {\r\n  /**\r\n   * Text content extracted from the attachment.\r\n   * @type {string | null}\r\n   * @memberof EmailAttachment\r\n   * @description The text content extracted from the attachment, or `null` if unavailable.\r\n   * @example \"This is the extracted text.\"\r\n   */\r\n  extractedText: string | null;\r\n  /**\r\n   * TSV (tab-separated values) representation of the extracted text.\r\n   * @type {string | null}\r\n   * @memberof EmailAttachment\r\n   * @description The TSV (tab-separated values) representation of the extracted text, or `null` if unavailable.\r\n   * @example \"column1\\tcolumn2\\tcolumn3\"\r\n   */\r\n  extractedTextTsv: string | null;\r\n  /**\r\n   * A brief summary of the attachment's content.\r\n   * @type {string | null}\r\n   * @memberof EmailAttachment\r\n   * @description A brief summary of the attachment's content, or `null` if unavailable.\r\n   * @example \"This attachment contains important information.\"\r\n   */\r\n  summary: string | null;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\data-models\\api\\contact-cache.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":127,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { forOneOrMany, OneOrMany } from '@/lib/typescript';\r\nimport { ContactSummary, Contact } from './contact';\r\nimport { isContact } from './guards';\r\n\r\ntype CachedContact = ContactSummary & Partial<Contact>;\r\nexport type ContactCache = {\r\n  add: OneOrMany<CachedContact, boolean>;\r\n  get: OneOrMany<number, CachedContact | undefined>;\r\n  getByEmail: OneOrMany<string, CachedContact | undefined>;\r\n  remove: OneOrMany<number, boolean>;\r\n  getAll: () => CachedContact[];\r\n  clear: () => void;\r\n  has: OneOrMany<number, boolean>;\r\n  hasByEmail: OneOrMany<string, boolean>;\r\n};\r\n\r\nclass ContactCacheImpl implements ContactCache {\r\n  static #globalContactCache: ContactCache | null;\r\n  static ContactCacheImpl: ContactCacheImpl;\r\n  static get globalCache(): ContactCache {\r\n    if (!ContactCacheImpl.#globalContactCache) {\r\n      ContactCacheImpl.#globalContactCache = new ContactCacheImpl();\r\n    }\r\n    return ContactCacheImpl.#globalContactCache;\r\n  }\r\n  static resetGlobalCache(): void {\r\n    if (ContactCacheImpl.#globalContactCache) {\r\n      ContactCacheImpl.#globalContactCache.clear();\r\n      ContactCacheImpl.#globalContactCache = null;\r\n    }\r\n  }\r\n\r\n  private cache: Map<number, CachedContact> = new Map();\r\n  private cacheByEmail: Map<string, CachedContact> = new Map();\r\n\r\n  add(contact: CachedContact): boolean;\r\n  add(contact: Array<CachedContact>): boolean[];\r\n  add(contact: CachedContact | CachedContact[]): boolean | boolean[] {\r\n    return forOneOrMany((x) => {\r\n      const existing = this.cache.get(x.contactId);\r\n      if (existing) {\r\n        existing.name = x.name;\r\n        if (\r\n          existing.email.toLocaleLowerCase() !== x.email.toLocaleLowerCase()\r\n        ) {\r\n          this.cacheByEmail.delete(existing.email.toLocaleLowerCase());\r\n          existing.email = x.email;\r\n          this.cacheByEmail.set(x.email.toLocaleLowerCase(), existing);\r\n        }\r\n        if (isContact(x)) {\r\n          existing.jobDescription = x.jobDescription;\r\n          existing.isDistrictStaff = x.isDistrictStaff;\r\n          existing.phoneNumber = x.phoneNumber;\r\n        }\r\n        this.cache.set(x.contactId, x);\r\n        return true;\r\n      }\r\n      const cacheEntry = { ...x };\r\n      this.cache.set(x.contactId, cacheEntry);\r\n      this.cacheByEmail.set(x.email.toLocaleLowerCase(), cacheEntry);\r\n      return true;\r\n    }, contact);\r\n  }\r\n\r\n  get(id: number): CachedContact | undefined;\r\n  get(id: Array<number>): Array<CachedContact | undefined>;\r\n  get(\r\n    id: number | Array<number>,\r\n  ): CachedContact | undefined | Array<CachedContact | undefined> {\r\n    return forOneOrMany((x) => {\r\n      const ret = this.cache.get(x);\r\n      return ret ? { ...ret } : undefined;\r\n    }, id);\r\n  }\r\n\r\n  getByEmail(email: string): CachedContact | undefined;\r\n  getByEmail(email: Array<string>): Array<CachedContact | undefined>;\r\n  getByEmail(\r\n    email: string | Array<string>,\r\n  ): CachedContact | undefined | Array<CachedContact | undefined> {\r\n    return forOneOrMany((x) => {\r\n      const ret = this.cacheByEmail.get(x.toLocaleLowerCase());\r\n      return ret ? { ...ret } : undefined;\r\n    }, email);\r\n  }\r\n\r\n  remove(contact: Array<number>): Array<boolean>;\r\n  remove(contact: number): boolean;\r\n  remove(contact: number | Array<number>): boolean | boolean[] {\r\n    return forOneOrMany((x) => this.cache.delete(x), contact);\r\n  }\r\n\r\n  public getAll(): CachedContact[] {\r\n    return Array.from(this.cache.values()).map((x) => ({ ...x }));\r\n  }\r\n\r\n  public clear(): void {\r\n    this.cache.clear();\r\n  }\r\n\r\n  public has(id: number): boolean;\r\n  public has(id: Array<number>): boolean[];\r\n  public has(id: number | Array<number>): boolean | boolean[] {\r\n    return forOneOrMany((x) => this.cache.has(x), id);\r\n  }\r\n  public hasByEmail(email: string): boolean;\r\n  public hasByEmail(email: Array<string>): boolean[];\r\n  public hasByEmail(email: string | Array<string>): boolean | boolean[] {\r\n    return forOneOrMany(\r\n      (x) => this.cacheByEmail.has(x.toLocaleLowerCase()),\r\n      email,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Executes a callback function with the global contact cache.\r\n *\r\n * @template TRet - The return type of the callback function.\r\n * @param cb - The callback function to execute with the global contact cache.\r\n * @returns The result of the callback function.\r\n */\r\nexport const globalContactCache = <TRet>(\r\n  cb: (cache: ContactCache) => TRet,\r\n): TRet => cb(ContactCacheImpl.globalCache);\r\nexport const resetGlobalCache = () => ContactCacheImpl.resetGlobalCache();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\data-models\\api\\contact.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\data-models\\api\\document-unit\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":131,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export const DocumentUnitTypeValues = [\r\n  'email',\r\n  'attachment',\r\n  'note',\r\n  'key_point',\r\n  'cta',\r\n  'cta_response',\r\n  'sentiment',\r\n  'compliance',\r\n] as const;\r\nexport type DocumentUnitType = (typeof DocumentUnitTypeValues)[number];\r\n\r\n/**\r\n * Determines if the given value is a valid `DocumentUnitType`.\r\n *\r\n * @param check - The value to check.\r\n * @returns A boolean indicating whether the value is a valid `DocumentUnitType`.\r\n */\r\nexport const isDocumentUnitType = (check: unknown): check is DocumentUnitType =>\r\n  DocumentUnitTypeValues.includes(check as DocumentUnitType);\r\n\r\n/**\r\n * Represents a summary of a document unit, which can be an email, an attachment, or a property.\r\n */\r\nexport type DocumentUnitSummary = {\r\n  /**\r\n   * The unique identifier for the document unit.\r\n   */\r\n  unitId: number;\r\n\r\n  /**\r\n   * The identifier of the associated email, if applicable. Null if not associated with an email.\r\n   * This is important for understanding the context of the document unit.\r\n   * For emails, identifies the email to which the document unit belongs.\r\n   */\r\n  emailId: string | null;\r\n\r\n  /**\r\n   * The identifier of the associated attachment, if applicable. Null if not associated with an attachment.\r\n   * This is important for understanding the context of the document unit.\r\n   * For attachments, identifies the attachment to which the document unit belongs.\r\n   */\r\n  attachmentId: number | null;\r\n\r\n  /**\r\n   * The identifier of the associated email property, if applicable. Null if not associated with an email property.\r\n   * This is important for understanding the context of the document unit.\r\n   * For email properties, identifies the property to which the document unit belongs.\r\n   */\r\n  emailPropertyId: string | null;\r\n\r\n  /**\r\n   * The type of document represented by this unit. Can be 'email', 'attachment', or 'property'.\r\n   * This is important for understanding the context of the document unit.\r\n   * Valid Values: 'email', 'attachment', ''note' | 'key_point' | 'cta' | 'sentiment' | 'compliance';\r\n   *\r\n   * @example \"email\"\r\n   */\r\n  documentType: DocumentUnitType;\r\n  /**\r\n   * The date and time when the document unit was created.\r\n   * This is important for tracking the freshness of the document unit and its relevance.\r\n   */\r\n  createdOn: Date;\r\n\r\n  /**\r\n   * The URL or link to the document unit, if applicable. This can be used to access the document directly.\r\n   * This is important for providing easy access to the document unit.\r\n   */\r\n  hrefDocument?: string;\r\n\r\n  /**\r\n   * The URL or link to the API endpoint for the document unit, if applicable. This can be used to access the document's metadata or perform operations on it.\r\n   * This is important for providing easy access to the document unit's API.\r\n   */\r\n  hrefApi?: string;\r\n\r\n  /**\r\n   * The identifier of the thread to which the document unit belongs, if applicable. This can be used to group related emails together.\r\n   * This is important for understanding the context of the document unit.\r\n   */\r\n  threadId: number;\r\n\r\n  /**\r\n   * The identifier of the parent email - eg the email the current email was a reply to - if applicable. This can be used to identify the email to which this document unit belongs.\r\n   * This is important for understanding the context of the document unit.\r\n   */\r\n  parentEmailId: string | null;\r\n\r\n  /**\r\n   * An array containing the identifiers of related emails, if applicable. This can be used to identify other emails that are related to this document unit.\r\n   * This is important for understanding the context of the document unit.\r\n   */\r\n  relatedEmailIds: string[];\r\n  /**\r\n   * The name of the model used for embedding the document.\r\n   * This is important for understanding how the document is represented in vector space.\r\n   *\r\n   * @example \"text-embedding-ada-002\"\r\n   */\r\n  embeddingModel: string | null;\r\n  /**\r\n   * The date and time when the document was embedded.\r\n   * This can be useful for tracking the freshness of the embedding and its relevance.\r\n   *\r\n   * @example \"2023-10-01T12:00:00Z\"\r\n   */\r\n  embeddedOn: Date | null;\r\n};\r\n\r\n/**\r\n * Represents a detailed document unit that extends the summary information\r\n * with additional content and metadata.\r\n *\r\n * @extends DocumentUnitSummary\r\n *\r\n * @property {string} content - The full content of the document unit.\r\n * @property {string} embeddingModel - The name of the model used for embedding the document.\r\n * @property {Date} embeddedOn - The date and time when the document was embedded.\r\n */\r\nexport type DocumentUnit = DocumentUnitSummary & {\r\n  /**\r\n   * The full content of the document unit.\r\n   * This can include text, metadata, and other relevant information.\r\n   * It is used for processing and analysis of the document's content.\r\n   *\r\n   * @example \"This is an example of document content.\"\r\n   */\r\n  content: string;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\data-models\\api\\email-message.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":101,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ContactSummary } from './contact';\r\n\r\n/**\r\n * Represents a summary of an email message.\r\n *\r\n * @export\r\n * @type {EmailMessageSummary}\r\n * @public\r\n *\r\n * @property {string} emailId - The unique identifier of the email.\r\n * @property {ContactSummary} sender - The contact information of the sender.\r\n * @property {string} subject - The subject of the email.\r\n * @property {Date | string} sentOn - The date and time when the email was sent.\r\n * @property {number | null} [threadId] - The identifier of the email thread, if applicable.\r\n * @property {string | null} [parentEmailId] - The identifier of the parent email, if applicable.\r\n * @property {string | null} [importedFromId] - The identifier from which the email was imported, if applicable.\r\n * @property {string | null} [globalMessageId] - The global identifier of the email message, if applicable.\r\n * @property {ContactSummary[]} recipients - The list of recipients of the email.\r\n */\r\nexport type EmailMessageSummary = {\r\n  emailId: string;\r\n  sender: ContactSummary;\r\n  subject: string;\r\n  sentOn: Date | string;\r\n  threadId?: number | null;\r\n  parentEmailId?: string | null;\r\n  importedFromId?: string | null;\r\n  globalMessageId?: string | null;\r\n  recipients: ContactSummary[];\r\n  count_attachments?: number;\r\n  count_kpi?: number;\r\n  count_notes?: number;\r\n  count_cta?: number;\r\n  count_responsive_actions?: number;\r\n};\r\n\r\n/**\r\n * Represents an email message.\r\n *\r\n * @export\r\n * @type {EmailMessage}\r\n * @public\r\n *\r\n * @extends {EmailMessageSummary}\r\n *\r\n * @property {string} body - The body content of the email message.\r\n */\r\nexport type EmailMessage = EmailMessageSummary & {\r\n  body: string;\r\n};\r\n\r\n/**\r\n * Represents the statistics of email messages.\r\n *\r\n * @type {EmailMessageStats}\r\n * @property {number} total - The total number of email messages.\r\n * @property {Date} lastUpdated - The date when the statistics were last updated.\r\n */\r\nexport type EmailMessageStats = {\r\n  total: number;\r\n  lastUpdated: Date;\r\n};\r\n\r\n/**\r\n * Represents a summary of an email message attachment.\r\n *\r\n * @type {EmailMessageAttachmentSummary}\r\n *\r\n * @property {number} attachmentId - The unique identifier for the attachment.\r\n * @property {string} emailId - The unique identifier for the email to which the attachment belongs.\r\n * @property {string} fileName - The name of the attachment file.\r\n * @property {string} filePath - The path to the attachment file.\r\n * @property {number} size - The size of the attachment file in bytes.\r\n * @property {string} mimeType - The MIME type of the attachment file.\r\n */\r\nexport type EmailMessageAttachmentSummary = {\r\n  attachmentId: number;\r\n  emailId: string;\r\n  fileName: string;\r\n  filePath: string;\r\n  size: number;\r\n  mimeType: string;\r\n};\r\n\r\n/**\r\n * Represents an email message attachment with additional details.\r\n *\r\n * @type {EmailMessageAttachment}\r\n *\r\n * @property {string | null} extractedText - The text extracted from the attachment, if any.\r\n * @property {string | null} extractedTextVector - The vector representation of the extracted text, if any.\r\n * @property {number | null} policyId - The policy identifier associated with the attachment, if any.\r\n * @property {string | null} summary - A summary of the attachment content, if any.\r\n */\r\nexport type EmailMessageAttachment = EmailMessageAttachmentSummary & {\r\n  extractedText: string | null;\r\n  extractedTextVector: string | null;\r\n  policyId: number | null;\r\n  summary: string | null;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\data-models\\api\\email-properties\\extended-properties.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":470,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { EmailPropertySummary } from './property-type';\r\n\r\n/**\r\n * An array of all field names available in CallToActionDetails.\r\n */\r\nexport const CallToActionDetailKeyValues = [\r\n  'opened_date',\r\n  'closed_date',\r\n  'compliancy_close_date',\r\n  'completion_percentage',\r\n  'compliance_rating',\r\n  'inferred',\r\n  'compliance_date_enforceable',\r\n  'reasonable_request',\r\n  'reasonable_reasons',\r\n  'sentiment',\r\n  'sentiment_reasons',\r\n  'compliance_rating_reasons',\r\n  'severity',\r\n  'severity_reason',\r\n  'title_ix_applicable',\r\n  'title_ix_applicable_reasons',\r\n  'closure_actions',\r\n  'value',\r\n] as const;\r\n\r\n/**\r\n * Represents the valid key types for call-to-action details.\r\n *\r\n * This type is derived from the values of the `CallToActionDetailKeyValues` array,\r\n * ensuring that only predefined string values are allowed.\r\n *\r\n * @see CallToActionDetailKeyValues\r\n */\r\nexport type CallToActionDetailKeyType =\r\n  (typeof CallToActionDetailKeyValues)[number];\r\n\r\n/**\r\n * Details for a Call To Action property on an email.\r\n * Extends EmailPropertySummary (except typeId) with CTA-specific fields.\r\n */\r\n/**\r\n * Represents the extended properties for a call to action (CTA) within an email property summary,\r\n * excluding the 'typeId' field. This type includes detailed tracking of CTA lifecycle events,\r\n * compliance information, sentiment analysis, and additional metadata.\r\n *\r\n * @remarks\r\n * - Tracks when the CTA was opened, closed, and closed for compliance.\r\n * - Includes completion percentage and compliance-related ratings and reasons.\r\n * - Supports sentiment and severity analysis with optional explanations.\r\n * - Provides fields for Title IX applicability and closure actions.\r\n * - Contains a description of the call to action.\r\n *\r\n * @property {Date | null} opened_date - When the CTA was opened.\r\n * @property {Date | null} closed_date - When the CTA was closed.\r\n * @property {Date | null} compliancy_close_date - When the CTA was closed for compliance.\r\n * @property {number} completion_percentage - Completion percentage for the CTA.\r\n * @property {number | null} [compliance_rating] - Optional compliance rating.\r\n * @property {boolean} inferred - Indicates if the CTA was inferred.\r\n * @property {boolean} compliance_date_enforceable - Whether the compliance date is enforceable.\r\n * @property {number | null} [reasonable_request] - Optional reasonable request indicator.\r\n * @property {string[] | null} [reasonable_reasons] - Optional reasons for reasonable request.\r\n * @property {number | null} [sentiment] - Optional sentiment score.\r\n * @property {string[] | null} [sentiment_reasons] - Optional reasons for sentiment score.\r\n * @property {string[] | null} [compliance_rating_reasons] - Optional reasons for compliance rating.\r\n * @property {number | null} [severity] - Optional severity score.\r\n * @property {string[] | null} [severity_reason] - Optional reasons for severity score.\r\n * @property {number | null} [title_ix_applicable] - Optional Title IX applicability indicator.\r\n * @property {string[] | null} [title_ix_applicable_reasons] - Optional reasons for Title IX applicability.\r\n * @property {string[] | null} [closure_actions] - Optional closure actions taken.\r\n * @property {string} value - A description of the call to action.\r\n */\r\nexport type CallToActionDetails = Omit<EmailPropertySummary, 'typeId'> & {\r\n  /**\r\n   * @property {Date | null} openedDate - When the CTA was opened.\r\n   */\r\n  opened_date: Date | null;\r\n  /**\r\n   * @property {Date | null} closedDate - When the CTA was closed.\r\n   */\r\n  closed_date: Date | null;\r\n  /**\r\n   * @property {Date | null} compliancyCloseDate - When the CTA was closed for compliance.\r\n   */\r\n  compliancy_close_date: Date | null;\r\n  /**\r\n   * @property {number} completionPercentage - Completion percentage for the\r\n   */\r\n  completion_percentage: number;\r\n\r\n  /**\r\n   * Optional compliance rating.\r\n   * @type {number | null}\r\n   */\r\n  compliance_rating?: number | null;\r\n  /**\r\n   * Indicates if the CTA was inferred.\r\n   * @type {boolean}\r\n   */\r\n  inferred: boolean;\r\n  /**\r\n   * Whether the compliance date is enforceable.\r\n   * @type {boolean}\r\n   */\r\n  compliance_date_enforceable: boolean;\r\n  /**\r\n   * Optional reasonable request indicator.\r\n   * @type {number | null}\r\n   */\r\n  reasonable_request?: number | null;\r\n  /**\r\n   * Optional reasons for reasonable request.\r\n   * @type {string[] | null}\r\n   */\r\n  reasonable_reasons?: string[] | null;\r\n  /**\r\n   * Optional sentiment score.\r\n   * @type {number | null}\r\n   */\r\n  sentiment?: number | null;\r\n  /**\r\n   * Optional reasons for sentiment score.\r\n   * @type {string[] | null}\r\n   */\r\n  sentiment_reasons?: string[] | null;\r\n  /**\r\n   * Optional reasons for compliance rating.\r\n   * @type {string[] | null}\r\n   */\r\n  compliance_rating_reasons?: string[] | null;\r\n  /**\r\n   * Optional severity score.\r\n   * @type {number | null}\r\n   */\r\n  severity?: number | null;\r\n  /**\r\n   * Optional reasons for severity score.\r\n   * @type {string[] | null}\r\n   */\r\n  severity_reason?: string[] | null;\r\n  /**\r\n   * Optional Title IX applicability indicator.\r\n   * @type {number | null}\r\n   */\r\n  title_ix_applicable?: number | null;\r\n  /**\r\n   * Optional reasons for Title IX applicability.\r\n   * @type {string[] | null}\r\n   */\r\n  title_ix_applicable_reasons?: string[] | null;\r\n  /**\r\n   * Optional closure actions taken.\r\n   * @type {string[] | null}\r\n   */\r\n  closure_actions?: string[] | null;\r\n  /**\r\n   * @property {string} value - A description of the call to action.\r\n   */\r\n  value: string;\r\n  /**\r\n   * Average compliance rating for Chapter 13 assigned to all actions identified as responsive to this cta.\r\n   * @type {number | null}\r\n   */\r\n  compliance_average_chapter_13?: number | null;\r\n  /**\r\n   * Reasons identified for the {@link compliance_average_chapter_13} rating.\r\n   * @type {string[] | null}\r\n   */\r\n  compliance_chapter_13_reasons?: string[] | null;\r\n};\r\n\r\n/**\r\n * An array of all field names available in KeyPointsDetails.\r\n */\r\nexport const KeyPointsDetailsKeyValues = [\r\n  'relevance',\r\n  'compliance',\r\n  'severityRanking',\r\n  'inferred',\r\n  'value',\r\n] as const;\r\n\r\n/**\r\n * Represents the valid key types for KeyPointsDetails.\r\n *\r\n * This type is derived from the values of the `KeyPointsDetailsKeyValues` array,\r\n * ensuring that only predefined string values are allowed.\r\n *\r\n * @see KeyPointsDetailsKeyValues\r\n */\r\nexport type KeyPointsDetailsKeyType =\r\n  (typeof KeyPointsDetailsKeyValues)[number];\r\n\r\n/**\r\n * Details for a Key Point property on an email.\r\n * Extends EmailPropertySummary (except typeId) with key point-specific fields.\r\n */\r\nexport type KeyPointsDetails = Omit<EmailPropertySummary, 'typeId'> & {\r\n  /**\r\n   * @property {number | null} relevance - Relevance score for the key point.\r\n   */\r\n  relevance: number | null;\r\n  /**\r\n   * @property {number | null} compliance - Compliance score for the key point.\r\n   */\r\n  compliance: number | null;\r\n  /**\r\n   * @property {number | null} severityRanking - Severity ranking for the key point.\r\n   */\r\n  severity: number | null;\r\n  /**\r\n   * @property {boolean} inferred - Whether the key point was inferred.\r\n   */\r\n  inferred: boolean;\r\n  /**\r\n   * @property {string} value - The value/content of the key point.\r\n   */\r\n  value: string;\r\n};\r\n\r\n/**\r\n * An array of all field names available in CallToActionResponseDetails.\r\n */\r\nexport const CallToActionResponseDetailsKeyValues = [\r\n  'actionPropertyId',\r\n  'completionPercentage',\r\n  'responseTimestamp',\r\n  'value',\r\n] as const;\r\n\r\n/**\r\n * Represents the valid key types for CallToActionResponseDetails.\r\n *\r\n * This type is derived from the values of the `CallToActionResponseDetailsKeyValues` array,\r\n * ensuring that only predefined string values are allowed.\r\n *\r\n * @see CallToActionResponseDetailsKeyValues\r\n */\r\nexport type CallToActionResponseDetailsKeyType =\r\n  (typeof CallToActionResponseDetailsKeyValues)[number];\r\n\r\n/**\r\n * Details for a Call To Action Response property on an email.\r\n * Extends EmailPropertySummary (except typeId) with response-specific fields.\r\n */\r\nexport type CallToActionResponseDetails = Omit<\r\n  EmailPropertySummary,\r\n  'typeId'\r\n> & {\r\n  /**\r\n   * @property {string} actionPropertyId - The property ID of the related action.\r\n   */\r\n  actionPropertyId: string;\r\n  /**\r\n   * @property {number} completionPercentage - Completion percentage for the response.\r\n   */\r\n  completionPercentage: number;\r\n  /**\r\n   * @property {Date} responseTimestamp - When the response was recorded.\r\n   */\r\n  responseTimestamp: Date;\r\n  /**\r\n   * @property {string} value - The value/content of the response.\r\n   */\r\n  value: string;\r\n  /**\r\n   * @property {number} severity - Severity level of the response.\r\n   */\r\n  severity?: number;\r\n  /**\r\n   * @property {string[]} severity_reasons - Reasons for the severity level.\r\n   */\r\n  severity_reasons?: string[];\r\n  /**\r\n   * @property {boolean} inferred - Whether the response was inferred.\r\n   */\r\n  inferred?: boolean;\r\n  /**\r\n   * @property {number} sentiment - Sentiment score of the response.\r\n   */\r\n  sentiment?: number;\r\n  /**\r\n   * @property {string[]} sentiment_reasons - Reasons for the sentiment score.\r\n   */\r\n  sentiment_reasons?: string[];\r\n  /**\r\n   * @property {number} compliance_average_chapter_13 - Average compliance rating for Chapter 13.\r\n   */\r\n  compliance_average_chapter_13?: number;\r\n  /**\r\n   * @property {string[]} compliance_chapter_13_reasons - Reasons for the Chapter 13 compliance rating.\r\n   */\r\n  compliance_chapter_13_reasons?: string[];\r\n};\r\n\r\n/**\r\n * An array of all field names available in ComplianceScoresDetails.\r\n */\r\nexport const ComplianceScoresDetailsKeyValues = [\r\n  'actionPropertyId',\r\n  'complianceScore',\r\n  'violationsFound',\r\n  'responseDelayDays',\r\n  'overallGrade',\r\n  'evaluatedOn',\r\n  'value',\r\n] as const;\r\n\r\n/**\r\n * Represents the valid key types for ComplianceScoresDetails.\r\n *\r\n * This type is derived from the values of the `ComplianceScoresDetailsKeyValues` array,\r\n * ensuring that only predefined string values are allowed.\r\n *\r\n * @see ComplianceScoresDetailsKeyValues\r\n */\r\nexport type ComplianceScoresDetailsKeyType =\r\n  (typeof ComplianceScoresDetailsKeyValues)[number];\r\n\r\n/**\r\n * Details for a Compliance Scores property on an email.\r\n * Extends EmailPropertySummary (except typeId) with compliance scoring fields.\r\n */\r\nexport type ComplianceScoresDetails = Omit<EmailPropertySummary, 'typeId'> & {\r\n  /**\r\n   * @property {string | null} actionPropertyId - The property ID of the related action, if any.\r\n   */\r\n  actionPropertyId: string | null;\r\n  /**\r\n   * @property {number | null} complianceScore - The compliance score.\r\n   */\r\n  complianceScore: number | null;\r\n  /**\r\n   * @property {number} violationsFound - Number of violations found.\r\n   */\r\n  violationsFound: number;\r\n  /**\r\n   * @property {number} responseDelayDays - Delay in response, in days.\r\n   */\r\n  responseDelayDays: number;\r\n  /**\r\n   * @property {string | null} overallGrade - Overall grade assigned.\r\n   */\r\n  overallGrade: string | null;\r\n  /**\r\n   * @property {Date} evaluatedOn - When the compliance was evaluated.\r\n   */\r\n  evaluatedOn: Date;\r\n  /**\r\n   * @property {string} value - The value/content of the compliance score.\r\n   */\r\n  value: string;\r\n};\r\n\r\n/**\r\n * An array of all field names available in ViolationDetails.\r\n */\r\nexport const ViolationDetailsKeyValues = [\r\n  'attachmentId',\r\n  'keyPointPropertyId',\r\n  'actionPropertyId',\r\n  'violationType',\r\n  'severityLevel',\r\n  'detectedBy',\r\n  'detectedOn',\r\n  'value',\r\n] as const;\r\n\r\n/**\r\n * Represents the valid key types for ViolationDetails.\r\n *\r\n * This type is derived from the values of the `ViolationDetailsKeyValues` array,\r\n * ensuring that only predefined string values are allowed.\r\n *\r\n * @see ViolationDetailsKeyValues\r\n */\r\nexport type ViolationDetailsKeyType =\r\n  (typeof ViolationDetailsKeyValues)[number];\r\n\r\n/**\r\n * Details for a Violation property on an email.\r\n * Extends EmailPropertySummary (except typeId) with violation-specific fields.\r\n */\r\nexport type ViolationDetails = Omit<EmailPropertySummary, 'typeId'> & {\r\n  /**\r\n   * @property {number | null} attachmentId - Related attachment ID, if any.\r\n   */\r\n  attachmentId: number | null;\r\n  /**\r\n   * @property {string | null} keyPointPropertyId - Related key point property ID, if any.\r\n   */\r\n  keyPointPropertyId: string | null;\r\n  /**\r\n   * @property {string | null} actionPropertyId - Related action property ID, if any.\r\n   */\r\n  actionPropertyId: string | null;\r\n  /**\r\n   * @property {string} violationType - Type of violation.\r\n   */\r\n  violationType: string;\r\n  /**\r\n   * @property {number | null} severityLevel - Severity level of the violation.\r\n   */\r\n  severityLevel: number | null;\r\n  /**\r\n   * @property {string} detectedBy - Who detected the violation.\r\n   */\r\n  detectedBy: string;\r\n  /**\r\n   * @property {Date} detectedOn - When the violation was detected.\r\n   */\r\n  detectedOn: Date;\r\n  /**\r\n   * @property {string} value - The value/content of the violation.\r\n   */\r\n  value: string;\r\n};\r\n\r\n/**\r\n * An array of all field names available in EmailSentimentAnalysisDetails.\r\n */\r\nexport const EmailSentimentAnalysisDetailsKeyValues = [\r\n  'sentimentScore',\r\n  'detectedHostility',\r\n  'flaggedPhrases',\r\n  'detectedOn',\r\n  'value',\r\n] as const;\r\n\r\n/**\r\n * Represents the valid key types for EmailSentimentAnalysisDetails.\r\n *\r\n * This type is derived from the values of the `EmailSentimentAnalysisDetailsKeyValues` array,\r\n * ensuring that only predefined string values are allowed.\r\n *\r\n * @see EmailSentimentAnalysisDetailsKeyValues\r\n */\r\nexport type EmailSentimentAnalysisDetailsKeyType =\r\n  (typeof EmailSentimentAnalysisDetailsKeyValues)[number];\r\n\r\n/**\r\n * Details for an Email Sentiment Analysis property.\r\n * Extends EmailPropertySummary (except typeId) with sentiment analysis fields.\r\n */\r\nexport type EmailSentimentAnalysisDetails = Omit<\r\n  EmailPropertySummary,\r\n  'typeId'\r\n> & {\r\n  /**\r\n   * @property {number | null} sentimentScore - The sentiment score.\r\n   */\r\n  sentimentScore: number | null;\r\n  /**\r\n   * @property {boolean} detectedHostility - Whether hostility was detected.\r\n   */\r\n  detectedHostility: boolean;\r\n  /**\r\n   * @property {string} flaggedPhrases - Phrases that were flagged.\r\n   */\r\n  flaggedPhrases: string;\r\n  /**\r\n   * @property {Date} detectedOn - When the sentiment was detected.\r\n   */\r\n  detectedOn: Date;\r\n  /**\r\n   * @property {string} value - The value/content of the sentiment analysis.\r\n   */\r\n  value: string;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\data-models\\api\\email-properties\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\data-models\\api\\email-properties\\property-type.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":114,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export type EmailPropertyCategory = {\r\n  categoryId: number | EmailPropertyCategoryType | EmailPropertyCategoryTypeId;\r\n  description: string;\r\n  createdOn: Date;\r\n}; /**\r\n * Represents a summary of email properties.\r\n *\r\n * @property {string} typeId - The type identifier of the email property.\r\n * @property {string} propertyId - The unique identifier of the property.\r\n * @property {string} emailId - The unique identifier of the email.\r\n * @property {Date} createdOn - The date when the email property was created.\r\n *\r\n * Addtionally, the following properties are loaded from related tables\r\n *\r\n * @property {string} typeName - The name of the property type\r\n * @property {number} categoryId  - The related property category identifier\r\n * @property {number} categoryName = The nameof the assocaited property caterogy.\r\n */\r\n\r\nexport type EmailPropertySummary = {\r\n  typeId: number | EmailPropertyTypeType | EmailPropertyTypeTypeId;\r\n  propertyId: string;\r\n  propertyUnitId?: number;\r\n  documentId: number;\r\n  createdOn: Date;\r\n  categoryId?: number;\r\n  typeName?: string;\r\n  categoryName?: string;\r\n  tags?: string[];\r\n  policy_basis?: string[];\r\n};\r\n/**\r\n * Represents an email property which extends the summary of an email property\r\n * with an additional value field.\r\n *\r\n * @typedef {EmailPropertySummary} EmailPropertySummary - The summary of the email property.\r\n * @property {string} value - The actual value of the email property.\r\n */\r\n\r\nexport type EmailProperty = EmailPropertySummary & {\r\n  value: string;\r\n};\r\nexport const EmailPropertyCategoryTypeValues = [\r\n  'Email Header',\r\n  'Key Point',\r\n  'Note',\r\n  'Call to Action',\r\n  'Compliance Scores',\r\n  'Sentiment Analysis',\r\n] as const;\r\nexport type EmailPropertyCategoryType =\r\n  (typeof EmailPropertyCategoryTypeValues)[number];\r\nexport enum EmailPropertyCategoryTypeId {\r\n  EmailHeader = 1,\r\n  KeyPoint = 2,\r\n  Note = 3,\r\n  CallToAction = 4,\r\n  ComplianceScores = 5,\r\n  SentimentAnalysis = 6,\r\n}\r\nexport const EmailPropertyCategoryTypeIdValues = [\r\n  EmailPropertyCategoryTypeId.EmailHeader,\r\n  EmailPropertyCategoryTypeId.KeyPoint,\r\n  EmailPropertyCategoryTypeId.Note,\r\n  EmailPropertyCategoryTypeId.CallToAction,\r\n  EmailPropertyCategoryTypeId.ComplianceScores,\r\n  EmailPropertyCategoryTypeId.SentimentAnalysis,\r\n] as const;\r\n\r\nexport const EmailPropertyTypeTypeValues = [\r\n  'From',\r\n  'To',\r\n  'Cc',\r\n  'Call to Action',\r\n  'Call to Action Response',\r\n  'Compliance Score',\r\n  'Violation Details',\r\n  'Sentiment Analysis',\r\n  'Key Points',\r\n] as const;\r\nexport type EmailPropertyTypeType =\r\n  (typeof EmailPropertyTypeTypeValues)[number];\r\nexport enum EmailPropertyTypeTypeId {\r\n  From = 1,\r\n  To = 2,\r\n  Cc = 3,\r\n  CallToAction = 4,\r\n  CallToActionResponse = 5,\r\n  ComplianceScore = 6,\r\n  ViolationDetails = 7,\r\n  SentimentAnalysis = 8,\r\n  KeyPoints = 9,\r\n  Note = 102,\r\n  ManualReview = 1000,\r\n}\r\nexport const EmailPropertyTypeTypeIdValues = [\r\n  EmailPropertyTypeTypeId.From,\r\n  EmailPropertyTypeTypeId.To,\r\n  EmailPropertyTypeTypeId.Cc,\r\n  EmailPropertyTypeTypeId.CallToAction,\r\n  EmailPropertyTypeTypeId.CallToActionResponse,\r\n  EmailPropertyTypeTypeId.ComplianceScore,\r\n  EmailPropertyTypeTypeId.ViolationDetails,\r\n  EmailPropertyTypeTypeId.SentimentAnalysis,\r\n  EmailPropertyTypeTypeId.KeyPoints,\r\n] as const;\r\n\r\nexport type EmailPropertyType = {\r\n  typeId: number | EmailPropertyTypeType | EmailPropertyTypeTypeId;\r\n  categoryId: number | EmailPropertyCategoryType | EmailPropertyCategoryTypeId;\r\n  name: string;\r\n  createdOn: Date;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\data-models\\api\\factories.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":9,"column":1,"nodeType":"Program","endLine":59,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module Factories\r\n *\r\n * This module provides factory functions to create instances of data models\r\n * with default values. These functions can be used to generate mock data\r\n * for testing or to create new instances with optional overrides.\r\n */\r\n\r\nimport type { Contact, ContactSummary } from './contact';\r\nimport type { EmailMessage } from './email-message';\r\n\r\ntype Factory<T> = (overrides?: Partial<T>) => T;\r\n\r\n/**\r\n * Factory function to create a `ContactSummary` object.\r\n *\r\n * @param overrides - Optional properties to override the default values.\r\n * @returns A `ContactSummary` object with default values, overridden by any provided properties.\r\n */\r\nexport const createContactSummary: Factory<ContactSummary> = (overrides) => ({\r\n  contactId: -1,\r\n  email: '',\r\n  name: '',\r\n  ...(overrides ?? {}),\r\n});\r\n\r\n/**\r\n * Factory function to create a Contact object with default values.\r\n *\r\n * @param overrides - Partial object to override default values.\r\n * @returns A Contact object with default and overridden values.\r\n */\r\nexport const createContact: Factory<Contact> = (overrides) => ({\r\n  ...createContactSummary(overrides),\r\n  jobDescription: '',\r\n  phoneNumber: '',\r\n  isDistrictStaff: false,\r\n  ...(overrides ?? {}),\r\n});\r\n\r\n/**\r\n * Factory function to create an EmailMessage object with default values.\r\n * Allows overriding of default values through the `overrides` parameter.\r\n *\r\n * @param {Partial<EmailMessage>} overrides - An object containing properties to override the default values.\r\n * @returns {EmailMessage} - A new EmailMessage object with the specified overrides.\r\n */\r\nexport const createEmailMessage: Factory<EmailMessage> = (overrides) => ({\r\n  emailId: '',\r\n  subject: '',\r\n  body: '',\r\n  sentOn: new Date().toISOString(),\r\n  threadId: null,\r\n  parentEmailId: null,\r\n  recipients: [],\r\n  ...overrides,\r\n  sender: createContact(overrides?.sender),\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\data-models\\api\\guards.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":79,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Contact, ContactSummary } from './contact';\r\nimport {\r\n  MessageImportStatus,\r\n  MessageImportStatusWithChildren,\r\n} from './import/email-message';\r\nimport { EmailPropertyType } from './email-properties/property-type';\r\n\r\nexport const isContactSummary = (check: unknown): check is ContactSummary => {\r\n  const candidate = check as ContactSummary;\r\n  return (\r\n    typeof candidate?.contactId === 'number' &&\r\n    typeof candidate?.name === 'string' &&\r\n    typeof candidate?.email === 'string'\r\n  );\r\n};\r\nexport const isContact = (check: unknown): check is Contact => {\r\n  const candidate = check as Contact;\r\n  return (\r\n    isContactSummary(check) &&\r\n    ((typeof candidate?.jobDescription === 'string' &&\r\n      candidate.jobDescription.length > 0) ||\r\n      typeof candidate?.isDistrictStaff === 'boolean')\r\n  );\r\n};\r\n\r\nexport const isEmailPropertyDataModel = (\r\n  check: unknown,\r\n): check is EmailPropertyType => {\r\n  if (!check || typeof check !== 'object') {\r\n    return false;\r\n  }\r\n  return (\r\n    'categoryId' in check &&\r\n    (typeof check.categoryId === 'number' ||\r\n      typeof check.categoryId === 'string') &&\r\n    'typeId' in check &&\r\n    (typeof check.typeId === 'number' || typeof check.typeId === 'string') &&\r\n    'name' in check &&\r\n    typeof check.name === 'string'\r\n  );\r\n};\r\n\r\n/**\r\n * Type guard function to check if a given value is of type `ImportMessageChildStatus`.\r\n *\r\n * @param check - The value to be checked.\r\n * @returns A boolean indicating whether the value is an `ImportMessageChildStatus`.\r\n *\r\n * The function checks if the value is an object and contains the following properties:\r\n * - `emailId`: a string or null\r\n * - `providerId`: a string\r\n * - `status`: a string\r\n */\r\nexport const isMessageImportStatus = (\r\n  check: unknown,\r\n): check is MessageImportStatus =>\r\n  typeof check === 'object' &&\r\n  !!check &&\r\n  'emailId' in check &&\r\n  (typeof check.emailId === 'string' || check.emailId === null) &&\r\n  'providerId' in check &&\r\n  typeof check.providerId === 'string' &&\r\n  'status' in check &&\r\n  typeof check.status === 'string';\r\n\r\n/**\r\n * Type guard function to check if the given object is of type `ImportMessageStatus`.\r\n *\r\n * This function checks if the provided object is an `ImportMessageChildStatus` and\r\n * if it contains a `ref` property.\r\n *\r\n * @param check - The object to check.\r\n * @returns `true` if the object is an `ImportMessageStatus`, otherwise `false`.\r\n */\r\nexport const isMessageImportWithChildrenStatus = (\r\n  check: unknown,\r\n): check is MessageImportStatusWithChildren =>\r\n  isMessageImportStatus(check) && 'references' in check && 'subject' in check;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\data-models\\api\\import\\email-message.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":208,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ContactSummary } from '../contact';\r\nimport type { GmailEmailImportSource } from './provider-google';\r\n\r\nexport type { GmailEmailImportSource };\r\n\r\nexport const ImportStageValues = [\r\n  'new',\r\n  'staged',\r\n  'contacts',\r\n  'body',\r\n  'headers',\r\n  'attachments',\r\n  'completed',\r\n] as const;\r\nexport type ImportStage = (typeof ImportStageValues)[number];\r\n\r\n/**\r\n * Represents an email message to be imported from a source.\r\n *\r\n * @property {string} [id] - Once availalble, this contains the id of the matching email_staging record.\r\n * @property {string} [targetId] - Once available this contains the id of the emails record.\r\n * @property {GmailEmailImportSource} raw - The raw email data from the Gmail import source.\r\n * @property {ImportStage} stage - The current stage of the import process.\r\n */\r\nexport type ImportSourceMessage = {\r\n  /**\r\n   * The unique identifier of the staged_message record.\r\n   */\r\n  id?: string;\r\n  /**\r\n   * The unique identifier of the target emails table record.\r\n   */\r\n  targetId?: string;\r\n  /**\r\n   * The unique identifier used by the provider to identify the email.\r\n   */\r\n  providerId: string;\r\n  /**\r\n   * The raw email data from the Gmail import source.\r\n   */\r\n  raw: GmailEmailImportSource;\r\n  /**\r\n   * The current stage of the import process.\r\n   */\r\n  stage: ImportStage;\r\n  /**\r\n   * The user id of the user who owns the email.\r\n   */\r\n  userId: number;\r\n  /**\r\n   * The unique identified of the associated document record\r\n   */\r\n  documentId?: number;\r\n};\r\n\r\n/**\r\n * Represents a summary of a staged email message in the import process.\r\n *\r\n * @type {Object} StagedMessageSummary\r\n *\r\n * @property {string} id - The unique identifier of the staged_message record.\r\n * @property {ImportStage} stage - The current stage of the import process for the message.\r\n * @property {string} [targetId] - Once available, the unique id of the target emails table record.\r\n * @property {Date} timestamp - The timestamp when the message was staged.\r\n * @property {string} sender - The email address of the sender of the message.\r\n * @property {Array<string> | string | null} recipients - The recipients of the message, which can be an array of email addresses, a single email address, or null.\r\n */\r\nexport type StagedMessageSummary = {\r\n  id: string;\r\n  stage: ImportStage;\r\n  targetId?: string;\r\n  timestamp: Date;\r\n  sender: string;\r\n  userId: number;\r\n  recipients: Array<string> | string | null;\r\n};\r\n\r\nexport type EmailSearchResult = {\r\n  id: string;\r\n  threadId?: string;\r\n};\r\n\r\n/**\r\n * An array of possible import status types for email messages.\r\n *\r\n * The possible values are:\r\n * - 'imported': The email message has been successfully imported.\r\n * - 'pending': The email message is pending import.\r\n * - 'not-found': The email message could not be found.\r\n * - 'in-progress': The email message import is currently in progress.\r\n *\r\n * This array is defined as a constant tuple to ensure type safety.\r\n */\r\nexport const ImportStatusTypeValues = [\r\n  'imported',\r\n  'pending',\r\n  'not-found',\r\n  'in-progress',\r\n  'error',\r\n] as const;\r\n\r\n/**\r\n * Represents the import status type of an email message.  Possible values are:\r\n * - 'imported': The email message has been successfully imported.\r\n * - 'pending': The email message is pending import.\r\n * - 'not-found': The email message could not be found.\r\n * - 'in-progress': The email message import is currently in progress.\r\n *\r\n * This type is defined as a union of the possible values to ensure type safety.\r\n */\r\nexport type ImportStatusType = (typeof ImportStatusTypeValues)[number];\r\n\r\n/**\r\n * Represents the import status of a child email message.\r\n *\r\n * @property {string | null} emailId - The unique identifier for the email.\r\n * @property {string} providerId - The unique identifier for the email provider.\r\n * @property {ImportStatusType} status - The current import status of the email.\r\n */\r\nexport type MessageImportStatus = {\r\n  /**\r\n   * The unique identifier for the email.\r\n   */\r\n  emailId: string | null;\r\n  /**\r\n   * The unique identifier for the email provider.\r\n   */\r\n  providerId: string;\r\n  /**\r\n   * The current import status of the email.\r\n   */\r\n  status: ImportStatusType;\r\n  /**\r\n   * Name of the email provider.\r\n   */\r\n  provider: string;\r\n};\r\n\r\n/**\r\n * Describes the import status of an email message, including its provider ID, email ID,\r\n * and the status of the import process. Additionally, it contains reference information\r\n * for all emails that this email references.\r\n *\r\n * @property {string} providerId - The unique identifier for the email provider.  Note this\r\n *  may be a provider-specific identifier or a Message-ID header value.\r\n * @property {string} emailId - The unique identifier for the email.\r\n * @property {ImportStatusType} status - The current import status of the email.\r\n * @property {Array<ImportMessageStatus>} ref - An array of import statuses for all referenced emails.\r\n */\r\n/**\r\n * Represents the status of an email message import along with its related data.\r\n *\r\n * @extends MessageImportStatus\r\n *\r\n * @property {Array<MessageImportStatus>} references - An array of import statuses for all referenced emails.\r\n * @property {Omit<ContactSummary, 'contactId' | 'name'> & { name?: string }} sender - The sender's contact summary with an optional name.\r\n * @property {Array<Omit<ContactSummary, 'contactId' | 'name'> & { name?: string }} recipients - An array of recipient contact summaries with optional names.\r\n * @property {string} subject - The subject of the email message.\r\n * @property {Date} receivedDate - The date the email message was received.\r\n */\r\nexport type MessageImportStatusWithChildren = MessageImportStatus & {\r\n  /**\r\n   * An array of import statuses for all referenced emails.\r\n   */\r\n  references: Array<MessageImportStatus>;\r\n  /**\r\n   * The sender's contact summary with an optional name.\r\n   */\r\n  sender: Omit<ContactSummary, 'contactId' | 'name'> & { name?: string };\r\n  /**\r\n   * An array of recipient contact summaries with optional names.\r\n   */\r\n  recipients: Array<\r\n    Omit<ContactSummary, 'contactId' | 'name'> & { name?: string }\r\n  >;\r\n  /**\r\n   * The subject of the email message.\r\n   */\r\n  subject: string;\r\n  /**\r\n   * The date the email message was received.\r\n   */\r\n  receivedDate: Date;\r\n};\r\n\r\n/**\r\n * Represents the response from an import operation.\r\n *\r\n * This type is a discriminated union that can represent either a successful or\r\n * unsuccessful import operation.\r\n *\r\n * @property success - Indicates whether the import operation was successful.\r\n * @property message - A message providing additional information about the import operation.\r\n * @property error - (Optional) An error message or object, present if the import operation failed.\r\n * @property data - (Optional) The imported data, present if the import operation was successful.\r\n */\r\nexport type ImportResponse =\r\n  | {\r\n      success: false;\r\n      message: string;\r\n      error: string | Error;\r\n    }\r\n  | {\r\n      success: true;\r\n      message: string;\r\n      data: ImportSourceMessage;\r\n    };\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\data-models\\api\\import\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\data-models\\api\\import\\provider-google.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\data-models\\api\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\data-models\\api\\object-repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\data-models\\api\\thread.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":29,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { EmailMessageSummary } from './email-message';\r\n\r\n/**\r\n * Represents a summary of a thread.\r\n *\r\n * @property {number} threadId - The unique identifier of the thread.\r\n * @property {string} subject - The subject or title of the thread.\r\n * @property {Date} created - The date and time when the thread was created.\r\n */\r\nexport type ThreadSummary = {\r\n  threadId: number;\r\n  subject: string;\r\n  createdOn: Date;\r\n  externalId: string;\r\n};\r\n\r\n/**\r\n * Represents a detailed thread which includes a summary, total count, and a list of email message summaries.\r\n *\r\n * @extends ThreadSummary\r\n *\r\n * @property {number} total - The total count of items in the thread.\r\n * @property {EmailMessageSummary[]} emails - An array of email message summaries associated with the thread.\r\n */\r\nexport type Thread = ThreadSummary & {\r\n  total: number;\r\n  emails: EmailMessageSummary[];\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\data-models\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\drizzle.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\drizzle\\custom-relations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\drizzle\\relations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\drizzle\\schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\eslint-rules\\index.js","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":17,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":54,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\eslint-rules\\index.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\eslint.config-with-no-jsdoc.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\instrument\\browser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\instrument\\chunking\\ChunkingLogExporter.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":9,"column":1,"nodeType":"Program","endLine":146,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ChunkingLogExporter\r\n *\r\n * A LogRecordExporter decorator that inspects log bodies and attributes, splitting\r\n * oversized string values into multiple synthetic log records to avoid exceeding\r\n * downstream property limits. Each chunk carries a chunkContextId and ordering\r\n * information to allow reassembly on the consumer side.\r\n */\r\nimport type {\r\n  ReadableLogRecord,\r\n  LogRecordExporter,\r\n} from '@opentelemetry/sdk-logs';\r\nimport type { AnyValueMap } from '@opentelemetry/api-logs';\r\nimport type { ExportResult } from '@opentelemetry/core';\r\n\r\nexport type LogChunkingOptions = {\r\n  /** Maximum characters allowed in any single property or body before chunking */\r\n  maxChunkChars?: number;\r\n  /** If true, keep a truncated preview of original value */\r\n  keepOriginalKey?: boolean;\r\n};\r\n\r\nfunction makeChunkContextId(\r\n  traceId: string | undefined,\r\n  spanId: string | undefined,\r\n  key: string,\r\n): string {\r\n  const seed = `${traceId ?? 'no-trace'}:${spanId ?? 'no-span'}:${key}`;\r\n  let hash = 2166136261;\r\n  for (let i = 0; i < seed.length; i++) {\r\n    hash ^= seed.charCodeAt(i);\r\n    hash +=\r\n      (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\r\n  }\r\n  return (hash >>> 0).toString(36);\r\n}\r\n\r\nexport class ChunkingLogExporter implements LogRecordExporter {\r\n  private readonly inner: LogRecordExporter;\r\n  private readonly maxChunkChars: number;\r\n  private readonly keepOriginalKey: boolean;\r\n\r\n  constructor(inner: LogRecordExporter, opts: LogChunkingOptions = {}) {\r\n    this.inner = inner;\r\n    this.maxChunkChars = opts.maxChunkChars ?? 8000;\r\n    this.keepOriginalKey = opts.keepOriginalKey ?? false;\r\n  }\r\n\r\n  export(\r\n    records: ReadableLogRecord[],\r\n    resultCallback: (result: ExportResult) => void,\r\n  ): void {\r\n    for (const rec of records) {\r\n      const base = rec as unknown as {\r\n        attributes: AnyValueMap;\r\n        body?: unknown;\r\n      };\r\n      const attrs = (base.attributes ?? {}) as Record<string, unknown>;\r\n      const traceId = attrs['trace_id'] as string | undefined;\r\n      const spanId = attrs['span_id'] as string | undefined;\r\n\r\n      // Body chunking (add chunk_* properties on attributes)\r\n      if (\r\n        typeof base.body === 'string' &&\r\n        base.body.length > this.maxChunkChars\r\n      ) {\r\n        const s = base.body;\r\n        const totalChunks = Math.ceil(s.length / this.maxChunkChars);\r\n        const ctxId = makeChunkContextId(traceId, spanId, 'body');\r\n        attrs['body_chunked'] = 'true';\r\n        attrs['body_totalChunks'] = String(totalChunks);\r\n        attrs['body_chunkContextId'] = ctxId;\r\n        for (let i = 0; i < totalChunks; i++) {\r\n          const chunk = s.slice(\r\n            i * this.maxChunkChars,\r\n            (i + 1) * this.maxChunkChars,\r\n          );\r\n          attrs[`body_chunk_${i + 1}`] = chunk;\r\n        }\r\n        base.body = this.keepOriginalKey\r\n          ? s.slice(0, this.maxChunkChars)\r\n          : '[chunked]';\r\n      }\r\n\r\n      // Prepare a snapshot of original entries to avoid iterating over keys we add below\r\n      const originalEntries = Object.entries(attrs);\r\n      const isChunkMetaKey = (k: string) =>\r\n        k === 'body_chunked' ||\r\n        k === 'body_totalChunks' ||\r\n        k === 'body_chunkContextId' ||\r\n        k.startsWith('body_chunk_') ||\r\n        k.endsWith('_chunked') ||\r\n        k.endsWith('_totalChunks') ||\r\n        k.endsWith('_chunkContextId') ||\r\n        /_chunk_\\d+$/.test(k);\r\n\r\n      // Attribute chunking (split into key_chunk_* properties and add metadata)\r\n      for (const [key, rawVal] of originalEntries) {\r\n        if (isChunkMetaKey(key)) continue; // don't process metadata keys we add\r\n        if (rawVal == null) continue;\r\n        if (typeof key !== 'string') continue;\r\n        let s: string;\r\n        if (typeof rawVal === 'string') s = rawVal;\r\n        else {\r\n          try {\r\n            s = JSON.stringify(rawVal);\r\n          } catch {\r\n            s = String(rawVal);\r\n          }\r\n        }\r\n        if (s.length > this.maxChunkChars) {\r\n          const totalChunks = Math.ceil(s.length / this.maxChunkChars);\r\n          const ctxId = makeChunkContextId(traceId, spanId, key);\r\n          attrs[`${key}_chunked`] = 'true';\r\n          attrs[`${key}_totalChunks`] = String(totalChunks);\r\n          attrs[`${key}_chunkContextId`] = ctxId;\r\n          for (let i = 0; i < totalChunks; i++) {\r\n            const chunk = s.slice(\r\n              i * this.maxChunkChars,\r\n              (i + 1) * this.maxChunkChars,\r\n            );\r\n            attrs[`${key}_chunk_${i + 1}`] = chunk;\r\n          }\r\n          if (!this.keepOriginalKey) {\r\n            delete (attrs as Record<string, unknown>)[key];\r\n          } else {\r\n            (attrs as Record<string, unknown>)[key] = s.slice(\r\n              0,\r\n              this.maxChunkChars,\r\n            );\r\n          }\r\n        }\r\n      }\r\n      // write back mutated attributes\r\n      (base.attributes as unknown as Record<string, unknown>) = attrs;\r\n    }\r\n    this.inner.export(records, resultCallback);\r\n  }\r\n\r\n  async shutdown(): Promise<void> {\r\n    await this.inner.shutdown?.();\r\n  }\r\n}\r\n\r\nexport default ChunkingLogExporter;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\instrument\\chunking\\ChunkingTraceExporter.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":23,"column":1,"nodeType":"Program","endLine":216,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ChunkingTraceExporter\r\n *\r\n * A SpanExporter decorator that inspects all span attributes and event attributes\r\n * and splits any oversized string values into multiple chunk events so they can\r\n * be safely ingested by downstream exporters (e.g., Azure Monitor / App Insights)\r\n * that enforce strict per-property size limits.\r\n *\r\n * The exporter augments the original span/event attributes with metadata:\r\n * - `${key}_chunked` = 'true' when chunking occurs\r\n * - `${key}_totalChunks` = total number of chunks\r\n *\r\n * For each chunk, an event is appended to the span with attributes:\r\n * - chunkContextId: stable identifier tying all chunks from the same source together\r\n * - chunkKey: the original attribute key\r\n * - chunkIndex: 1-based index of the chunk\r\n * - totalChunks: total number of chunks\r\n * - chunk: the chunk text\r\n *\r\n * Chunk context id is derived from traceId/spanId/source/key to enable reassembly\r\n * on the downstream side.\r\n */\r\nimport type {\r\n  ReadableSpan,\r\n  SpanExporter,\r\n  TimedEvent,\r\n} from '@opentelemetry/sdk-trace-base';\r\nimport type { ExportResult } from '@opentelemetry/core';\r\nimport { hrTime } from '@opentelemetry/core';\r\nimport type { Attributes } from '@opentelemetry/api';\r\n\r\nexport type ChunkingTraceOptions = {\r\n  /** Maximum characters allowed in any single attribute value before chunking */\r\n  maxChunkChars?: number;\r\n  /** Name suffix for generated chunk events */\r\n  eventName?: string;\r\n  /** If true, keep a truncated preview of original value under the same key */\r\n  keepOriginalKey?: boolean;\r\n};\r\n\r\n/**\r\n * Compute a compact, stable chunkContextId from span context and source/key.\r\n * Uses a small, non-cryptographic hash to avoid heavy dependencies.\r\n */\r\nfunction makeChunkContextId(\r\n  traceId: string,\r\n  spanId: string,\r\n  source: string,\r\n  key: string,\r\n): string {\r\n  const seed = `${traceId}:${spanId}:${source}:${key}`;\r\n  let hash = 5381;\r\n  for (let i = 0; i < seed.length; i++) {\r\n    hash = ((hash << 5) + hash) ^ seed.charCodeAt(i);\r\n  }\r\n  return Math.abs(hash).toString(36);\r\n}\r\n\r\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] };\r\n\r\nexport class ChunkingTraceExporter implements SpanExporter {\r\n  private readonly inner: SpanExporter;\r\n  private readonly maxChunkChars: number;\r\n  private readonly eventName: string;\r\n  private readonly keepOriginalKey: boolean;\r\n\r\n  constructor(inner: SpanExporter, opts: ChunkingTraceOptions = {}) {\r\n    this.inner = inner;\r\n    this.maxChunkChars = opts.maxChunkChars ?? 8000;\r\n    this.eventName = opts.eventName ?? 'chunk';\r\n    this.keepOriginalKey = opts.keepOriginalKey ?? false;\r\n  }\r\n\r\n  export(\r\n    spans: ReadableSpan[],\r\n    resultCallback: (result: ExportResult) => void,\r\n  ): void {\r\n    const out: ReadableSpan[] = [];\r\n    for (const span of spans) {\r\n      const mSpan = span as unknown as Mutable<ReadableSpan> & {\r\n        events?: TimedEvent[];\r\n      };\r\n      const sc = span.spanContext();\r\n      const traceId: string = sc?.traceId ?? 'unknown-trace';\r\n      const spanId: string = sc?.spanId ?? 'unknown-span';\r\n\r\n      // Snapshot original events and collect chunk events separately to avoid mutation during iteration\r\n      const originalEvents: TimedEvent[] = Array.isArray(mSpan.events)\r\n        ? [...mSpan.events]\r\n        : [];\r\n      const chunkEvents: TimedEvent[] = [];\r\n\r\n      // Clone attributes and events to avoid mutating original references\r\n      const newAttrs = this.chunkAttributes(\r\n        (mSpan.attributes ?? {}) as Attributes,\r\n        chunkEvents,\r\n        traceId,\r\n        spanId,\r\n        'attributes',\r\n      );\r\n\r\n      const newEvents: TimedEvent[] = [];\r\n      for (const ev of originalEvents) {\r\n        const evCopy: Mutable<TimedEvent> = { ...ev } as Mutable<TimedEvent>;\r\n        evCopy.attributes = this.chunkAttributes(\r\n          (ev.attributes ?? {}) as Attributes,\r\n          chunkEvents,\r\n          traceId,\r\n          spanId,\r\n          ev.name ?? 'event',\r\n        ) as Attributes;\r\n        newEvents.push(evCopy);\r\n      }\r\n\r\n      if (chunkEvents.length) {\r\n        newEvents.push(...chunkEvents);\r\n      }\r\n\r\n      // Preserve instance methods and internals by using the original span as prototype\r\n      const spanCopy: Mutable<ReadableSpan> = Object.create(\r\n        span,\r\n      ) as Mutable<ReadableSpan>;\r\n      Object.defineProperty(spanCopy, 'attributes', {\r\n        value: newAttrs as Attributes,\r\n        enumerable: true,\r\n        configurable: true,\r\n        writable: true,\r\n      });\r\n      Object.defineProperty(spanCopy, 'events', {\r\n        value: newEvents,\r\n        enumerable: true,\r\n        configurable: true,\r\n        writable: true,\r\n      });\r\n      out.push(spanCopy as ReadableSpan);\r\n    }\r\n    this.inner.export(out, resultCallback);\r\n  }\r\n\r\n  private chunkAttributes(\r\n    attrs: Attributes,\r\n    chunkEventsOut: TimedEvent[],\r\n    traceId: string,\r\n    spanId: string,\r\n    sourceName: string,\r\n  ): Attributes {\r\n    const result: Record<string, unknown> = {\r\n      ...(attrs as Record<string, unknown>),\r\n    };\r\n    for (const [key, rawVal] of Object.entries(attrs)) {\r\n      if (rawVal == null) continue;\r\n      let str: string;\r\n      if (typeof rawVal === 'string') {\r\n        str = rawVal;\r\n      } else {\r\n        try {\r\n          str = JSON.stringify(rawVal);\r\n        } catch {\r\n          str = String(rawVal);\r\n        }\r\n      }\r\n      if (str.length > this.maxChunkChars) {\r\n        const totalChunks = Math.ceil(str.length / this.maxChunkChars);\r\n        const chunkContextId = makeChunkContextId(\r\n          traceId,\r\n          spanId,\r\n          sourceName,\r\n          key,\r\n        );\r\n        result[`${key}_chunked`] = 'true';\r\n        result[`${key}_totalChunks`] = String(totalChunks);\r\n        if (!this.keepOriginalKey) {\r\n          delete result[key];\r\n        } else {\r\n          result[key] = str.slice(0, this.maxChunkChars);\r\n        }\r\n        for (let i = 0; i < totalChunks; i++) {\r\n          const chunk = str.slice(\r\n            i * this.maxChunkChars,\r\n            (i + 1) * this.maxChunkChars,\r\n          );\r\n          chunkEventsOut.push({\r\n            name: `${sourceName}/${this.eventName}`,\r\n            time: hrTime(),\r\n            attributes: {\r\n              chunkContextId,\r\n              chunkKey: key,\r\n              chunkIndex: String(i + 1),\r\n              totalChunks: String(totalChunks),\r\n              chunk,\r\n            },\r\n          });\r\n        }\r\n      }\r\n    }\r\n    return result as Attributes;\r\n  }\r\n\r\n  async shutdown(): Promise<void> {\r\n    await this.inner.shutdown();\r\n  }\r\n\r\n  async forceFlush(): Promise<void> {\r\n    if (\r\n      typeof (this.inner as unknown as { forceFlush?: () => Promise<void> })\r\n        .forceFlush === 'function'\r\n    ) {\r\n      await (\r\n        this.inner as unknown as { forceFlush: () => Promise<void> }\r\n      ).forceFlush();\r\n    }\r\n  }\r\n}\r\n\r\nexport default ChunkingTraceExporter;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\instrument\\click-callback-processor.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":2,"column":1,"nodeType":"Program","endLine":41,"endColumn":2}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":17,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[527,530],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[527,530],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nexport default class ClickCallbackProcessor {\r\n  /**\r\n   * Function to override the default pageName capturing behavior.\r\n   */\r\n  pageName(): string {\r\n    return window.document.title;\r\n  }\r\n  /**\r\n   * A callback function to augument the default pageTags collected during pageAction event.\r\n  pageActionPageTags?: (element?: Element) => IPageTags;\r\n   */\r\n  /**\r\n   * A callback function to populate customized contentName.\r\n   */\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  contentName(element?: any, useDefaultContentName?: boolean) \r\n  {\r\n    if (!element) {\r\n      return '';\r\n    }\r\n    let check = element.getAttribute('data-id') ?? element.getAttribute('id') ?? element.getAttribute('name')\r\n      ?? element.getAttribute('aria-label') ?? element.getAttribute('title');\r\n    if (check) {\r\n      return check;\r\n    }\r\n    const labelledBy = element.getAttribute('aria-labelledby');\r\n    if (labelledBy) {\r\n      const labelledElement = document.getElementById(labelledBy);\r\n      if (labelledElement) {\r\n        check = this.contentName(labelledElement, useDefaultContentName);\r\n        if (check) {\r\n          return check;\r\n        } \r\n      }\r\n    } \r\n    check = element.getAttribute('data-testid');\r\n    const result = check || element.textContent?.trim() || '';\r\n    return result;\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\instrument\\common.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\instrument\\edge.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\instrument\\node.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\instrumentation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\jest.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\agents\\agent-base.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\agents\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\agents\\timeline\\agent-server.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":606,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { aiModelFactory } from '@/lib/ai/aiModelFactory';\r\nimport { getCaseFileDocument } from '@/lib/ai/tools';\r\nimport { ClientTimelineAgent } from './agent';\r\nimport {\r\n  TimelineAgentProps,\r\n  DocumentMetadata,\r\n  TimelineSummary,\r\n  ProcessingResult,\r\n  ComplianceRating,\r\n  GlobalMetadata,\r\n  SerializedTimelineAgent,\r\n} from './types';\r\nimport { type AiLanguageModelType, generateChatId } from '@/lib/ai/core';\r\nimport { drizDb } from '@/lib/drizzle-db';\r\nimport { setupDefaultTools } from '@/lib/ai/mcp/providers';\r\nimport { NextRequest } from 'next/server';\r\nimport {\r\n  type ChatHistoryContext,\r\n  createAgentHistoryContext,\r\n  wrapChatHistoryMiddleware,\r\n} from '@/lib/ai/middleware/chat-history';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport type { ToolProviderSet } from '@/lib/ai/mcp/types';\r\nimport { log } from '@/lib/logger';\r\nimport { auth } from '@/auth';\r\nimport { generateTextWithRetry } from '@/lib/ai/core/generate-text-with-retry';\r\n\r\ntype InitializeProps = { req: NextRequest };\r\n\r\n/**\r\n * Represents an agent responsible for building a timeline summary for a given case record.\r\n *\r\n * The `TimelineAgent` is responsible for building a timeline summary for data request cases\r\n * (e.g., FERPA/MNGDPA). It tracks pending and processed documents, loads and analyzes each\r\n * document in chronological order, records verbatim statements, compliance metadata, and\r\n * actions/inactions, then outputs a structured summary with global metadata, sequential\r\n * actions, and compliance ratings.\r\n *\r\n * Key features:\r\n * - Processes documents in chronological order based on send/receive dates\r\n * - Maintains detailed compliance tracking and metadata\r\n * - Preserves verbatim statements and critical information\r\n * - Supports resuming processing with new documents\r\n * - Generates structured summaries with compliance ratings\r\n *\r\n * @extends TimelineAgent\r\n *\r\n * @example\r\n * ```typescript\r\n * const agent = new TimelineAgent({ initialDocumentId: 'doc-123' });\r\n * await agent.initialize();\r\n * await agent.processNextDocument();\r\n * const summary = agent.generateSummary();\r\n * ```\r\n */\r\nclass ServerTimelineAgent extends ClientTimelineAgent {\r\n  readonly #pendingDocuments = new Set<string>();\r\n  readonly #processedDocuments = new Set<string>();\r\n  readonly #documentMetadata = new Map<string, DocumentMetadata>();\r\n  readonly #documentContent = new Map<string, string>();\r\n  #userId: string | undefined;\r\n  #timelineState: TimelineSummary = {\r\n    globalMetadata: {\r\n      caseId: '',\r\n      propertyId: '',\r\n      caseType: 'FERPA',\r\n      requestType: 'Data Request',\r\n      requestDate: '',\r\n      requesterName: '',\r\n      institutionName: '',\r\n      complianceDeadline: '',\r\n      currentStatus: 'In Progress',\r\n      totalDocuments: 0,\r\n      processedDocuments: 0,\r\n    },\r\n    sequentialActions: [],\r\n    complianceRatings: {\r\n      timeliness: ComplianceRating.Unknown,\r\n      completeness: ComplianceRating.Unknown,\r\n      accuracy: ComplianceRating.Unknown,\r\n      transparency: ComplianceRating.Unknown,\r\n      overall: ComplianceRating.Unknown,\r\n    },\r\n    criticalIssues: [],\r\n    recommendations: [],\r\n    lastUpdated: new Date().toISOString(),\r\n  };\r\n  #isInitialized = false;\r\n  #chatHistoryContext: ChatHistoryContext | undefined;\r\n\r\n  constructor(props: TimelineAgentProps | SerializedTimelineAgent) {\r\n    super(props);\r\n    if ('initialDocumentId' in props) {\r\n      if (props.initialDocumentId) {\r\n        this.#pendingDocuments.add(props.initialDocumentId);\r\n      }\r\n    } else if ('state' in props) {\r\n      this.attach(props);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize the agent by loading the initial document and extracting case metadata\r\n   */\r\n  async initialize(\r\n    { req }: InitializeProps | undefined = {} as InitializeProps,\r\n  ): Promise<void> {\r\n    if (this.#isInitialized) return;\r\n    const session = await auth();\r\n    this.#userId = session?.user?.id;\r\n    const initialDocId = Array.from(this.#pendingDocuments)[0];\r\n    if (!(this.propertyId ?? initialDocId)) {\r\n      throw new Error('No initial document provided');\r\n    }\r\n\r\n    try {\r\n      // Load initial document and extract case metadata\r\n      const initialDocument = await this.#loadDocument(\r\n        this.propertyId ?? initialDocId,\r\n      );\r\n      const caseMetadata = await this.#extractCaseMetadata(initialDocument);\r\n      if (\r\n        !caseMetadata ||\r\n        !caseMetadata.caseId ||\r\n        !caseMetadata.communicationId\r\n      ) {\r\n        throw new Error('Failed to extract case metadata');\r\n      }\r\n      // Update global metadata\r\n      this.#timelineState.globalMetadata = {\r\n        ...this.#timelineState.globalMetadata,\r\n        ...caseMetadata,\r\n      };\r\n      // Set propertyId for future reference\r\n      this.assertPropertyId(caseMetadata.caseId);\r\n      // Identify related documents\r\n      const relatedDocuments = await this.#identifyRelatedDocuments({\r\n        req,\r\n        document: initialDocument,\r\n      });\r\n      relatedDocuments.forEach((docId) => this.#pendingDocuments.add(docId));\r\n\r\n      this.#timelineState.globalMetadata.totalDocuments =\r\n        this.#pendingDocuments.size;\r\n      this.#isInitialized = true;\r\n    } catch (error) {\r\n      throw new Error(`Failed to initialize TimelineAgent: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process the next document in chronological order\r\n   */\r\n  async processNextDocument(\r\n    nextDocId?: string,\r\n  ): Promise<ProcessingResult | null> {\r\n    if (!this.#isInitialized) {\r\n      throw new Error('Agent must be initialized before processing documents');\r\n    }\r\n\r\n    if (!nextDocId) {\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const document = await this.#loadDocument(nextDocId);\r\n      const result = await this.#processDocument(nextDocId, document);\r\n\r\n      // Update timeline state\r\n      this.#updateTimelineState(result);\r\n\r\n      // Move document from pending to processed\r\n      this.#pendingDocuments.delete(nextDocId);\r\n      this.#processedDocuments.add(nextDocId);\r\n\r\n      // Add any additional documents identified during processing\r\n      if (result.additionalDocuments) {\r\n        result.additionalDocuments.forEach((docId) => {\r\n          if (\r\n            !this.#processedDocuments.has(docId) &&\r\n            !this.#pendingDocuments.has(docId)\r\n          ) {\r\n            this.#pendingDocuments.add(docId);\r\n          }\r\n        });\r\n      }\r\n\r\n      // Update counters\r\n      this.#timelineState.globalMetadata.processedDocuments =\r\n        this.#processedDocuments.size;\r\n      this.#timelineState.globalMetadata.totalDocuments =\r\n        this.#processedDocuments.size + this.#pendingDocuments.size;\r\n\r\n      this.#timelineState.lastUpdated = new Date().toISOString();\r\n\r\n      return result;\r\n    } catch (error) {\r\n      throw new Error(`Failed to process document ${nextDocId}: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate the current timeline summary\r\n   */\r\n  generateSummary(): TimelineSummary {\r\n    // Update compliance ratings based on current state\r\n    this.#updateComplianceRatings();\r\n\r\n    return {\r\n      ...this.#timelineState,\r\n      lastUpdated: new Date().toISOString(),\r\n    };\r\n  }\r\n\r\n  // Private helper methods\r\n\r\n  async #loadDocument(documentId: string): Promise<string> {\r\n    // Check cache first\r\n    if (this.#documentContent.has(documentId)) {\r\n      return this.#documentContent.get(documentId)!;\r\n    }\r\n    /*\r\n    - caseId: string\r\n    - caseType: \"FERPA\" | \"MNGDPA\" | \"Other\"\r\n    - requestType: string\r\n    - requestDate: ISO date string\r\n    - requesterName: string\r\n    - institutionName: string\r\n    - complianceDeadline: ISO date string\r\n    - currentStatus: string\r\n*/\r\n\r\n    const docRequest = await getCaseFileDocument({\r\n      caseFileId: documentId,\r\n      goals: [\r\n        `Create detailed timeline for call to action ${documentId}`,\r\n        `Locate related case file documents and attachments for ${documentId}`,\r\n        `Identify metadata such as Request Date, Requester Name, Requested Item, and Compliance Deadline for ${documentId}`,\r\n        `Include verbatim statements regarding specific item(s) requested in ${documentId}`,\r\n      ],\r\n    });\r\n    const result = docRequest?.structuredContent?.result;\r\n    if (!result) {\r\n      throw new Error(\r\n        `Failed to load document ${documentId}: No content found`,\r\n      );\r\n    }\r\n    if (result.isError === true) {\r\n      throw new Error(\r\n        `Failed to load document ${documentId}: ${result.message}`,\r\n      );\r\n    }\r\n    const content =\r\n      typeof result.value === 'string'\r\n        ? result.value\r\n        : JSON.stringify(result.value, null, 2);\r\n    this.#documentContent.set(documentId, content);\r\n    return content;\r\n  }\r\n\r\n  async #extractCaseMetadata(\r\n    document: string,\r\n  ): Promise<Partial<GlobalMetadata>> {\r\n    const prompt = `\r\n    Analyze the following document and extract case metadata. Return a JSON object with the following fields:\r\n    - caseId: string - The documentPropertyId of the target call-to-action case file; usually formatted as a uuid.\r\n    - communicationId: string - The ID of the email or attachment the target call-to-action originates from; usually formatted as an integer.\r\n    - caseType: \"FERPA\" | \"MNGDPA\" | \"Other\"\r\n    - requestType: string - The type of request being made (eg \"Data Request from Subject\", \"Public Data Request\", \"Educational Records Request\", \"Title IX Request\", \"Other\", etc.)\r\n    - requestDate: ISO date string - The date the request was made\r\n    - requesterName: string - The name of the requester\r\n    - institutionName: string - The name of the institution handling the request\r\n    - complianceDeadline: ISO date string - The nearest enforceable compliance deadline based on requestType and requestDate, considering any applicable laws or regulations and the request complexity.\r\n    - currentStatus: string - The current status of the request\r\n\r\n    Document:\r\n    ${document}\r\n    `;\r\n\r\n    const response = await this.generateResponse<GlobalMetadata>(prompt);\r\n    return response;\r\n  }\r\n  async #identifyRelatedDocuments({\r\n    req,\r\n    document,\r\n  }: {\r\n    req: NextRequest;\r\n    document: string;\r\n  }): Promise<string[]> {\r\n    const callToActionRecord = await drizDb().query.documentProperty.findFirst({\r\n      where: (property, { eq }) =>\r\n        eq(property.propertyId, this.propertyId ?? ''),\r\n    });\r\n    if (!callToActionRecord) {\r\n      throw new Error(\r\n        `Failed to find call to action record for document ${this.propertyId ?? 'null'}`,\r\n      );\r\n    }\r\n    const ctaText = callToActionRecord.propertyValue || '';\r\n    const prompt = `\r\n    You are the document retrieval pipeline that supports an AI compliance review system.  You will be provided with -\r\n    1) A specific call to action made by a citizen to a responsible authority.\r\n    2) The contents and metadata of the communication in when the citizen made the request.\r\n    Your goal is to identify all email or attachment case files that reference this call to action specifically, or speak \r\n    to a similar or related request.  To do that, you will -\r\n    ☐ Analyze the call to action, document content, and metadata.\r\n    ☐ Use tool-based sequential thinking to formulate a comprehensive plan of action.\r\n    ☐ Identify search terms and keywords that would retrieve relevant documents.  It is critical that we identify all related\r\n        case files, so a comprehensive set of queries should be identified - including synonyms, related terms, related concepts, and rephrased queries.\r\n    ☐ Use the case file search tool to retrieve all emails and attachment records that reference this call to action or related requests.\r\n    ☐ Retrieve a summarized version of retrieved case files confirming their relevance.\r\n        - The summarized document should also include the date it was sent as well as any document or attachment case file ID's that are associated.\r\n    ☐ For any related case files not already identified, pull summarized content to confirm relevance and identify any additional documents, etc.\r\n\r\n    Results should be returned in JSON format, and include both the document ID and the Date Sent for each identified value,\r\n    It should also return the total number of eligible documents, the number of documents that have been identified, and the\r\n    number of documents still pending analysis.\r\n    \r\n    Target Call to Action:\r\n    Case File Id: ${this.propertyId}\r\n    Text: ${ctaText}\r\n    Source Document and Metadata:\r\n    ${document}\r\n    `;\r\n\r\n    const response = await this.generateResponse(prompt, { req });\r\n    try {\r\n      const documentIds =\r\n        typeof response === 'object' ? response : JSON.parse(response);\r\n      return Array.isArray(documentIds) ? documentIds : [];\r\n    } catch {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async #processDocument(\r\n    documentId: string,\r\n    document: string,\r\n  ): Promise<ProcessingResult> {\r\n    // First, extract document metadata\r\n    const metadata = await this.#extractDocumentMetadata(documentId, document);\r\n    this.#documentMetadata.set(documentId, metadata);\r\n\r\n    // Process the document with current timeline context\r\n    const prompt = `\r\n    You are processing a document as part of a compliance timeline analysis for a data request case.\r\n    \r\n    Current Timeline State:\r\n    ${JSON.stringify(this.#timelineState, null, 2)}\r\n    \r\n    Document to Process:\r\n    ID: ${documentId}\r\n    Metadata: ${JSON.stringify(metadata, null, 2)}\r\n    Content: ${document}\r\n    \r\n    Please analyze this document and return a JSON object with:\r\n    - timelineEntry: Object describing this document's place in the timeline\r\n    - additionalDocuments: Array of additional document IDs discovered (if any)\r\n    - notes: Array of string notes about issues, concerns, or questions\r\n    - complianceImpact: Object describing how this document affects compliance ratings\r\n    - verbatimStatements: Array of critical verbatim quotes from the document\r\n    \r\n    Focus on compliance aspects, timeline accuracy, and any actions or inactions that affect the case.\r\n    `;\r\n\r\n    const response = await this.generateResponse<ProcessingResult>(prompt);\r\n    if (!response || typeof response !== 'object') {\r\n      throw new Error(\r\n        `Failed to process document ${documentId}: Invalid response format`,\r\n      );\r\n    }\r\n    try {\r\n      return {\r\n        documentId,\r\n        timelineEntry: response.timelineEntry,\r\n        additionalDocuments: response.additionalDocuments || [],\r\n        notes: response.notes || [],\r\n        complianceImpact: response.complianceImpact || {},\r\n        verbatimStatements: response.verbatimStatements || [],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        documentId,\r\n        timelineEntry: {\r\n          documentId,\r\n          date:\r\n            metadata.dateReceived ||\r\n            metadata.dateSent ||\r\n            new Date().toISOString(),\r\n          summary: `Failed to process document: ${error}`,\r\n        },\r\n        additionalDocuments: [],\r\n        notes: [`Error processing document: ${error}`],\r\n        complianceImpact: {},\r\n        verbatimStatements: [],\r\n      };\r\n    }\r\n  }\r\n\r\n  async #extractDocumentMetadata(\r\n    documentId: string,\r\n    document: string,\r\n  ): Promise<DocumentMetadata> {\r\n    const prompt = `\r\n    Extract metadata from the following document. Return a JSON object with:\r\n    - documentId: string\r\n    - documentType: string\r\n    - dateSent: ISO date string (if applicable)\r\n    - dateReceived: ISO date string (if applicable)\r\n    - sender: string\r\n    - recipient: string\r\n    - subject: string\r\n    - attachmentCount: number\r\n    - priority: \"Low\" | \"Medium\" | \"High\" | \"Critical\"\r\n    \r\n    Document:\r\n    ${document}\r\n    `;\r\n\r\n    const response = await this.generateResponse<DocumentMetadata>(prompt);\r\n    return (\r\n      response ?? {\r\n        documentId,\r\n        propertyId: this.propertyId || '',\r\n        documentType: 'Unknown',\r\n        sender: '',\r\n        recipient: '',\r\n        subject: '',\r\n        attachmentCount: 0,\r\n        priority: 'Medium',\r\n      }\r\n    );\r\n  }\r\n  #updateTimelineState(result: ProcessingResult): void {\r\n    // Add the timeline entry\r\n    if (result.timelineEntry) {\r\n      this.#timelineState.sequentialActions.push(result.timelineEntry);\r\n    }\r\n\r\n    // Add notes as critical issues if they indicate problems\r\n    if (result.notes && result.notes.length > 0) {\r\n      result.notes.forEach((note) => {\r\n        if (\r\n          note.toLowerCase().includes('concern') ||\r\n          note.toLowerCase().includes('issue') ||\r\n          note.toLowerCase().includes('problem')\r\n        ) {\r\n          this.#timelineState.criticalIssues.push(note);\r\n        }\r\n      });\r\n    }\r\n\r\n    // Sort sequential actions by date\r\n    this.#timelineState.sequentialActions.sort((a, b) => {\r\n      const dateA = new Date(a.date || '');\r\n      const dateB = new Date(b.date || '');\r\n      return dateA.getTime() - dateB.getTime();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Restore agent from a JSON snapshot string\r\n   */\r\n  static fromSnapshot(snapshot: string): ServerTimelineAgent {\r\n    try {\r\n      const serializedAgent = JSON.parse(snapshot) as SerializedTimelineAgent;\r\n      return new ServerTimelineAgent(serializedAgent);\r\n    } catch (error) {\r\n      throw new Error(`Failed to restore agent from snapshot: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update compliance ratings based on current timeline state\r\n   */\r\n  #updateComplianceRatings(): void {\r\n    // Calculate overall compliance rating based on document processing\r\n    const processedCount =\r\n      this.#timelineState.globalMetadata.processedDocuments;\r\n    const totalCount = this.#timelineState.globalMetadata.totalDocuments;\r\n\r\n    if (totalCount === 0) {\r\n      this.#timelineState.complianceRatings.overall = ComplianceRating.Unknown;\r\n      return;\r\n    }\r\n\r\n    const completionRate = processedCount / totalCount;\r\n\r\n    // Update overall compliance rating based on completion\r\n    if (completionRate >= 0.9) {\r\n      this.#timelineState.complianceRatings.overall =\r\n        ComplianceRating.Excellent;\r\n    } else if (completionRate >= 0.75) {\r\n      this.#timelineState.complianceRatings.overall = ComplianceRating.Good;\r\n    } else if (completionRate >= 0.5) {\r\n      this.#timelineState.complianceRatings.overall =\r\n        ComplianceRating.Satisfactory;\r\n    } else if (completionRate >= 0.25) {\r\n      this.#timelineState.complianceRatings.overall = ComplianceRating.Poor;\r\n    } else {\r\n      this.#timelineState.complianceRatings.overall = ComplianceRating.Unknown;\r\n    }\r\n\r\n    // Update document-specific ratings\r\n    this.#timelineState.complianceRatings.completeness =\r\n      completionRate >= 0.8\r\n        ? ComplianceRating.Good\r\n        : ComplianceRating.Satisfactory;\r\n\r\n    this.#timelineState.complianceRatings.timeliness =\r\n      ComplianceRating.Satisfactory;\r\n    this.#timelineState.complianceRatings.accuracy = ComplianceRating.Good;\r\n    this.#timelineState.complianceRatings.transparency = ComplianceRating.Good;\r\n  }\r\n  // Common methods and properties for all agents can be defined here\r\n  protected async generateResponse<TResultType extends string | object>(\r\n    input: string,\r\n    {\r\n      model = 'lofi',\r\n      req,\r\n      operation,\r\n      opProps,\r\n    }: {\r\n      model?: AiLanguageModelType;\r\n      req?: NextRequest;\r\n      operation?: string;\r\n      opProps?: Record<string, unknown>;\r\n    } = {},\r\n  ): Promise<TResultType> {\r\n    let tools: ToolProviderSet | undefined = undefined;\r\n    try {\r\n      this.#chatHistoryContext ??= createAgentHistoryContext({\r\n        model,\r\n        originatingUserId: this.#userId ?? '-1',\r\n        operation: operation ? `timeline:${operation}` : 'timeline:agent',\r\n        opTags: opProps,\r\n        chatId: generateChatId(Math.random() * 1000).id,\r\n      });\r\n      if (!this.#chatHistoryContext) {\r\n        throw new TypeError('Unknown failure creating chat history context.');\r\n      }\r\n      const hal = wrapChatHistoryMiddleware({\r\n        chatHistoryContext: this.#chatHistoryContext,\r\n        model: aiModelFactory(model ?? 'lofi'),\r\n      });\r\n      tools = await setupDefaultTools({ user: undefined, req });\r\n      const ret = await generateTextWithRetry({\r\n        model: hal,\r\n        prompt: input,\r\n        tools: tools.tools,\r\n        // maxSteps: 20,\r\n        experimental_telemetry: {\r\n          isEnabled: true,\r\n          functionId:\r\n            'agent-timeline-' + (operation ? operation : 'model-request'),\r\n        },\r\n        //experimental_continueSteps: true,\r\n      });\r\n      this.#chatHistoryContext.iteration++;\r\n      // If we have structured output available, use it.  Note our fancy middleware will automatically parse\r\n      // recognizable JSON content for us\r\n      if (\r\n        ret &&\r\n        ret.providerMetadata &&\r\n        'structuredOutputs' in ret.providerMetadata &&\r\n        !!ret.providerMetadata.structuredOutputs\r\n      ) {\r\n        // If we were able to parse structured output, return it directly\r\n        return ret.providerMetadata.structuredOutputs as TResultType;\r\n      }\r\n      // Otherwise, return the text response\r\n      return ret.text as TResultType;\r\n    } catch (error) {\r\n      throw LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'TimelineAgent',\r\n        message: 'Error generating response',\r\n        critical: true,\r\n        data: {\r\n          input,\r\n          model,\r\n          userId: this.#chatHistoryContext?.userId,\r\n          chatId: this.#chatHistoryContext?.chatId,\r\n        },\r\n      });\r\n    } finally {\r\n      if (tools) {\r\n        try {\r\n          tools.dispose();\r\n        } catch (e) {\r\n          log((l) => l.error('Error disposing tools', e));\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst TimelineAgentFactory = (\r\n  props: TimelineAgentProps,\r\n): ServerTimelineAgent => {\r\n  return new ServerTimelineAgent(props);\r\n};\r\n\r\nexport { TimelineAgentFactory };\r\nexport { ServerTimelineAgent };\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\agents\\timeline\\agent.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":434,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import AgentBase from '../agent-base';\r\nimport {\r\n  TimelineAgentProps,\r\n  DocumentMetadata,\r\n  TimelineSummary,\r\n  ProcessingResult,\r\n  ComplianceRating,\r\n  TimelineAgentState,\r\n  SerializedTimelineAgent,\r\n} from './types';\r\n\r\n/**\r\n * Represents an agent responsible for building a timeline summary for a given case record.\r\n *\r\n * The `ClientTimelineAgent` is responsible for building a timeline summary for data request cases\r\n * (e.g., FERPA/MNGDPA). It tracks pending and processed documents, loads and analyzes each\r\n * document in chronological order, records verbatim statements, compliance metadata, and\r\n * actions/inactions, then outputs a structured summary with global metadata, sequential\r\n * actions, and compliance ratings.\r\n *\r\n * Key features:\r\n * - Processes documents in chronological order based on send/receive dates\r\n * - Maintains detailed compliance tracking and metadata\r\n * - Preserves verbatim statements and critical information\r\n * - Supports resuming processing with new documents\r\n * - Generates structured summaries with compliance ratings\r\n *\r\n * @extends AgentBase\r\n *\r\n * @example\r\n * ```typescript\r\n * const agent = new ClientTimelineAgent({ initialDocumentId: 'doc-123' });\r\n * await agent.initialize();\r\n * await agent.processNextDocument();\r\n * const summary = agent.generateSummary();\r\n * ```\r\n */\r\nexport class ClientTimelineAgent extends AgentBase {\r\n  protected readonly pendingDocuments = new Set<string>();\r\n  protected readonly processedDocuments = new Set<string>();\r\n  protected readonly documentMetadata = new Map<string, DocumentMetadata>();\r\n  protected readonly documentContent = new Map<string, string>();\r\n  protected timelineState: TimelineSummary = {\r\n    globalMetadata: {\r\n      caseId: '',\r\n      caseType: 'FERPA',\r\n      requestType: 'Data Request',\r\n      requestDate: '',\r\n      requesterName: '',\r\n      institutionName: '',\r\n      complianceDeadline: '',\r\n      currentStatus: 'In Progress',\r\n      totalDocuments: 0,\r\n      processedDocuments: 0,\r\n    },\r\n    sequentialActions: [],\r\n    complianceRatings: {\r\n      timeliness: ComplianceRating.Unknown,\r\n      completeness: ComplianceRating.Unknown,\r\n      accuracy: ComplianceRating.Unknown,\r\n      transparency: ComplianceRating.Unknown,\r\n      overall: ComplianceRating.Unknown,\r\n    },\r\n    criticalIssues: [],\r\n    recommendations: [],\r\n    lastUpdated: new Date().toISOString(),\r\n  };\r\n  protected isInitialized = false;\r\n  #propertyId: string | null = null;\r\n\r\n  constructor(props: TimelineAgentProps | SerializedTimelineAgent) {\r\n    super();\r\n    if ('version' in props) {\r\n      this.attach(props);\r\n      this.#propertyId = props.state.propertyId || null;\r\n      props.state.pendingDocumentIds.forEach((id) =>\r\n        this.pendingDocuments.add(id),\r\n      );\r\n      props.state.processedDocumentIds.forEach((id) =>\r\n        this.processedDocuments.add(id),\r\n      );\r\n      if (props.state.metadata) {\r\n        Object.entries(props.state.metadata).forEach(([id, meta]) => {\r\n          this.documentMetadata.set(id, meta);\r\n        });\r\n      }\r\n    } else {\r\n      // Initialize with provided properties\r\n      this.#propertyId = props.propertyId || null;\r\n      if (props.initialDocumentId) {\r\n        this.pendingDocuments.add(props.initialDocumentId);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the current property ID\r\n   */\r\n  get propertyId(): string | null {\r\n    return this.#propertyId;\r\n  }\r\n\r\n  /**\r\n   * Get the currently active document ID being processed\r\n   */\r\n  getCurrentDocumentId(): string | null {\r\n    const pendingDocs = Array.from(this.pendingDocuments);\r\n    if (pendingDocs.length === 0) return null;\r\n\r\n    // Return the first document in chronological order\r\n    return this.getNextDocumentToProcess();\r\n  }\r\n\r\n  /**\r\n   * Initialize the agent by loading the initial document and extracting case metadata\r\n   */\r\n  async initialize(): Promise<void> {\r\n    if (this.isInitialized) return;\r\n\r\n    const initialDocId = Array.from(this.pendingDocuments)[0];\r\n    if (!initialDocId) {\r\n      throw new Error('No initial document provided');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process the next document in chronological order\r\n   */\r\n  async processNextDocument(): Promise<ProcessingResult | null> {\r\n    if (!this.isInitialized) {\r\n      throw new Error('Agent must be initialized before processing documents');\r\n    }\r\n\r\n    const nextDocId = this.getNextDocumentToProcess();\r\n    if (!nextDocId) {\r\n      return null; // No more documents to process\r\n    }\r\n\r\n    try {\r\n      // Update counters\r\n      this.timelineState.globalMetadata.processedDocuments =\r\n        this.processedDocuments.size;\r\n      this.timelineState.globalMetadata.totalDocuments =\r\n        this.processedDocuments.size + this.pendingDocuments.size;\r\n\r\n      this.timelineState.lastUpdated = new Date().toISOString();\r\n\r\n      return {} as ProcessingResult; // Placeholder for actual processing result\r\n    } catch (error) {\r\n      throw new Error(`Failed to process document ${nextDocId}: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add new documents to the processing queue\r\n   */\r\n  addDocuments(documentIds: string[]): void {\r\n    documentIds.forEach((docId) => {\r\n      if (\r\n        !this.processedDocuments.has(docId) &&\r\n        !this.pendingDocuments.has(docId)\r\n      ) {\r\n        this.pendingDocuments.add(docId);\r\n      }\r\n    });\r\n\r\n    this.timelineState.globalMetadata.totalDocuments =\r\n      this.processedDocuments.size + this.pendingDocuments.size;\r\n  }\r\n\r\n  /**\r\n   * Generate the current timeline summary\r\n   */\r\n  generateSummary(): TimelineSummary {\r\n    // Update compliance ratings based on current state\r\n    this.updateComplianceRatings();\r\n\r\n    return {\r\n      ...this.timelineState,\r\n      lastUpdated: new Date().toISOString(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if there are more documents to process\r\n   */\r\n  hasMoreDocuments(): boolean {\r\n    return this.pendingDocuments.size > 0;\r\n  }\r\n\r\n  /**\r\n   * Get the count of pending and processed documents\r\n   */\r\n  getDocumentCounts(): { pending: number; processed: number; total: number } {\r\n    return {\r\n      pending: this.pendingDocuments.size,\r\n      processed: this.processedDocuments.size,\r\n      total: this.pendingDocuments.size + this.processedDocuments.size,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset the agent to its initial state\r\n   */\r\n  reset(): void {\r\n    this.pendingDocuments.clear();\r\n    this.processedDocuments.clear();\r\n    this.documentMetadata.clear();\r\n    this.documentContent.clear();\r\n    this.isInitialized = false;\r\n\r\n    // Reset timeline state\r\n    this.timelineState = {\r\n      globalMetadata: {\r\n        caseId: '',\r\n        caseType: 'FERPA',\r\n        requestType: 'Data Request',\r\n        requestDate: '',\r\n        requesterName: '',\r\n        institutionName: '',\r\n        complianceDeadline: '',\r\n        currentStatus: 'In Progress',\r\n        totalDocuments: 0,\r\n        processedDocuments: 0,\r\n      },\r\n      sequentialActions: [],\r\n      complianceRatings: {\r\n        timeliness: ComplianceRating.Unknown,\r\n        completeness: ComplianceRating.Unknown,\r\n        accuracy: ComplianceRating.Unknown,\r\n        transparency: ComplianceRating.Unknown,\r\n        overall: ComplianceRating.Unknown,\r\n      },\r\n      criticalIssues: [],\r\n      recommendations: [],\r\n      lastUpdated: new Date().toISOString(),\r\n    };\r\n  }\r\n\r\n  // Private helper methods\r\n\r\n  getNextDocumentToProcess(): string | null {\r\n    if (this.pendingDocuments.size === 0) return null;\r\n\r\n    // Sort pending documents by chronological order based on metadata\r\n    const sortedDocs = Array.from(this.pendingDocuments).sort((a, b) => {\r\n      const metaA = this.documentMetadata.get(a);\r\n      const metaB = this.documentMetadata.get(b);\r\n\r\n      if (!metaA && !metaB) return 0;\r\n      if (!metaA) return 1;\r\n      if (!metaB) return -1;\r\n\r\n      const dateA = new Date(metaA.dateReceived || metaA.dateSent || '');\r\n      const dateB = new Date(metaB.dateReceived || metaB.dateSent || '');\r\n\r\n      return dateA.getTime() - dateB.getTime();\r\n    });\r\n\r\n    return sortedDocs[0];\r\n  }\r\n\r\n  protected updateComplianceRatings(): void {\r\n    // This would implement sophisticated compliance rating logic\r\n    // For now, provide a basic implementation\r\n    const totalDocs = this.timelineState.globalMetadata.totalDocuments;\r\n    const processedDocs = this.timelineState.globalMetadata.processedDocuments;\r\n    const issueCount = this.timelineState.criticalIssues.length;\r\n\r\n    // Completeness rating based on document processing\r\n    if (processedDocs === totalDocs && totalDocs > 0) {\r\n      this.timelineState.complianceRatings.completeness = ComplianceRating.Good;\r\n    } else if (processedDocs / totalDocs > 0.8) {\r\n      this.timelineState.complianceRatings.completeness =\r\n        ComplianceRating.Satisfactory;\r\n    } else {\r\n      this.timelineState.complianceRatings.completeness = ComplianceRating.Poor;\r\n    }\r\n\r\n    // Overall rating based on issues\r\n    if (issueCount === 0) {\r\n      this.timelineState.complianceRatings.overall = ComplianceRating.Good;\r\n    } else if (issueCount < 3) {\r\n      this.timelineState.complianceRatings.overall =\r\n        ComplianceRating.Satisfactory;\r\n    } else {\r\n      this.timelineState.complianceRatings.overall = ComplianceRating.Poor;\r\n    }\r\n\r\n    // Set other ratings to unknown for now - would be implemented based on specific analysis\r\n    this.timelineState.complianceRatings.timeliness = ComplianceRating.Unknown;\r\n    this.timelineState.complianceRatings.accuracy = ComplianceRating.Unknown;\r\n    this.timelineState.complianceRatings.transparency =\r\n      ComplianceRating.Unknown;\r\n  }\r\n\r\n  /**\r\n   * Serialize the current agent state to a JSON-compatible object\r\n   * This allows the agent's state to be saved and restored later\r\n   */\r\n  serialize(): SerializedTimelineAgent {\r\n    const state: TimelineAgentState = {\r\n      propertyId: this.propertyId || '',\r\n      pendingDocumentIds: Array.from(this.pendingDocuments),\r\n      processedDocumentIds: Array.from(this.processedDocuments),\r\n      currentDocumentId: this.getCurrentDocumentId(),\r\n      summary: this.timelineState,\r\n      metadata: Object.fromEntries(this.documentMetadata),\r\n      createdAt:\r\n        this.timelineState.globalMetadata.requestDate ||\r\n        new Date().toISOString(),\r\n      lastUpdated: this.timelineState.lastUpdated,\r\n    };\r\n\r\n    return {\r\n      version: '1.0.0',\r\n      timestamp: new Date().toISOString(),\r\n      state,\r\n    };\r\n  }\r\n\r\n  protected attach(agent: SerializedTimelineAgent): void {\r\n    const { state } = agent;\r\n    this.reset();\r\n    // Restore internal state\r\n    this.pendingDocuments.clear();\r\n    state.pendingDocumentIds.forEach((id: string) =>\r\n      this.pendingDocuments.add(id),\r\n    );\r\n\r\n    this.processedDocuments.clear();\r\n    state.processedDocumentIds.forEach((id: string) =>\r\n      this.processedDocuments.add(id),\r\n    );\r\n\r\n    this.documentMetadata.clear();\r\n    Object.entries(state.metadata).forEach(([id, metadata]) =>\r\n      this.documentMetadata.set(id, metadata as DocumentMetadata),\r\n    );\r\n\r\n    if (state.summary) {\r\n      this.timelineState = state.summary;\r\n    }\r\n\r\n    // Set propertyId if available\r\n    if (state.propertyId) {\r\n      this.#propertyId = state.propertyId;\r\n    }\r\n\r\n    // Mark as initialized if it has processed any documents or has summary data\r\n    this.isInitialized =\r\n      state.processedDocumentIds.length > 0 ||\r\n      (state.summary?.globalMetadata.caseId?.length ?? 0) > 0;\r\n  }\r\n\r\n  /**\r\n   * Restore agent state from a previously serialized state\r\n   * This allows resuming an agent session from a saved state\r\n   */\r\n  static deserialize(\r\n    serializedAgent: SerializedTimelineAgent,\r\n  ): ClientTimelineAgent {\r\n    const { state } = serializedAgent;\r\n\r\n    // Create a new agent instance\r\n    const agent = new ClientTimelineAgent({\r\n      initialDocumentId: state.pendingDocumentIds[0]!,\r\n      propertyId: state.propertyId!,\r\n    });\r\n\r\n    return agent;\r\n  }\r\n\r\n  /**\r\n   * Create a serialized snapshot of the current state\r\n   * Useful for checkpointing during long processing sessions\r\n   */\r\n  createSnapshot(): string {\r\n    return JSON.stringify(this.serialize(), null, 2);\r\n  }\r\n\r\n  /**\r\n   * Assert that the given property ID is valid\r\n   * @param value The property ID to validate\r\n   */\r\n  protected assertPropertyId(value: string) {\r\n    if (!value) {\r\n      throw new Error('Property ID is required');\r\n    }\r\n    if (!this.#propertyId) {\r\n      this.#propertyId = value;\r\n    } else if (this.#propertyId !== value) {\r\n      throw new Error(\r\n        `Property ID mismatch: expected ${this.#propertyId}, got ${value}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Restore agent from a JSON snapshot string\r\n   */\r\n  static fromSnapshot(snapshot: string): ClientTimelineAgent {\r\n    try {\r\n      const serializedAgent = JSON.parse(snapshot) as SerializedTimelineAgent;\r\n      return ClientTimelineAgent.deserialize(serializedAgent);\r\n    } catch (error) {\r\n      throw new Error(`Failed to restore agent from snapshot: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if the serialized state is compatible with the current version\r\n   */\r\n  static isCompatibleVersion(\r\n    serializedAgent: SerializedTimelineAgent,\r\n  ): boolean {\r\n    const currentVersion = '1.0.0';\r\n    const [currentMajor] = currentVersion.split('.').map(Number);\r\n    const [serializedMajor] = serializedAgent.version.split('.').map(Number);\r\n\r\n    // Compatible if major versions match\r\n    return currentMajor === serializedMajor;\r\n  }\r\n}\r\n\r\nconst TimelineAgentFactory = (\r\n  props: TimelineAgentProps,\r\n): ClientTimelineAgent => {\r\n  return new ClientTimelineAgent(props);\r\n};\r\n\r\nexport default TimelineAgentFactory;\r\nexport { ClientTimelineAgent as TimelineAgent };\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\agents\\timeline\\compliance-processor.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":343,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TimelineAgent } from './agent';\r\nimport { TimelineEntry, ComplianceRating, TimelineSummary } from './types';\r\nimport TimelineAgentFactory from './agent';\r\n\r\n/**\r\n * Specialized compliance processor for FERPA/MNGDPA data request cases.\r\n * This processor implements the specific requirements outlined in the compliance script.\r\n */\r\nexport class ComplianceTimelineProcessor {\r\n  private agent: TimelineAgent;\r\n  private currentSummary: string = '';\r\n\r\n  constructor(agent: TimelineAgent) {\r\n    this.agent = agent;\r\n  }\r\n\r\n  /**\r\n   * Process a single case document according to the compliance script requirements\r\n   * @param caseFileId The ID of the case file to process\r\n   * @returns The updated timeline summary\r\n   */\r\n  async processCaseDocument(caseFileId: string): Promise<string> {\r\n    // Add the document to the agent if not already present\r\n    this.agent.addDocuments([caseFileId]);\r\n\r\n    // Process the document\r\n    const result = await this.agent.processNextDocument();\r\n\r\n    if (!result) {\r\n      throw new Error(`Failed to process case file ${caseFileId}`);\r\n    }\r\n\r\n    // Generate the updated summary according to the script format\r\n    return this.generateComplianceSummary();\r\n  }\r\n\r\n  /**\r\n   * Generate a comprehensive compliance summary in the exact format specified by the script\r\n   */\r\n  private generateComplianceSummary(): string {\r\n    const summary = this.agent.generateSummary();\r\n    const actions = summary.sequentialActions;\r\n\r\n    // Build the compliance summary according to the script format\r\n    let output = '';\r\n\r\n    // Overview (Global Metadata)\r\n    output += 'Overview (Global Metadata):\\n\\n';\r\n    output += `Requested Record: ${this.extractRequestedRecord()}\\n`;\r\n    output += `Progress Status: ${this.calculateProgressStatus(summary)}\\n`;\r\n    output += `Overall Compliance: ${this.calculateOverallCompliance(summary)}\\n`;\r\n    output += `Executive Summary: ${this.generateExecutiveSummary(summary)}\\n`;\r\n    output += `Records Processed: ${this.getProcessedRecordsList(summary)}\\n`;\r\n    output += `Records Remaining: ${this.getRemainingRecordsList(summary)}\\n`;\r\n    output += `Next record to process: ${this.getNextRecordToProcess(summary)}\\n\\n`;\r\n\r\n    // Sequential Actions (Numbered Steps)\r\n    output += 'Sequential Actions (Numbered Steps):\\n\\n';\r\n\r\n    actions.forEach((action, index) => {\r\n      const stepNumber = index + 1;\r\n      output += `${stepNumber}. Case File ID: ${action.documentId}\\n`;\r\n      output += `Date of Communication: ${action.date}\\n`;\r\n      output += `Relevant Actor: ${this.extractRelevantActor(action)}\\n`;\r\n      output += `Identified Action/Inaction: ${this.extractIdentifiedAction(action)}\\n`;\r\n      output += `Relevant Action: ${this.extractRelevantAction(action)}\\n`;\r\n      output += `Embedded Metadata:\\n`;\r\n      output += `  Key Findings: ${this.extractKeyFindings(action)}\\n`;\r\n      output += `  Violations & Challenges: ${this.extractViolations(action)}\\n`;\r\n      output += `  Current Context: ${this.extractCurrentContext(action)}\\n\\n`;\r\n    });\r\n\r\n    this.currentSummary = output;\r\n    return output;\r\n  }\r\n\r\n  private extractRequestedRecord(): string {\r\n    // Extract the specific record or data that has been requested\r\n    // This would be determined from the initial document analysis\r\n    return 'Mandated reporting disclosure regarding incident involving student';\r\n  }\r\n\r\n  private calculateProgressStatus(summary: TimelineSummary): string {\r\n    const processed = summary.globalMetadata.processedDocuments;\r\n    const total = summary.globalMetadata.totalDocuments;\r\n    const percentage = total > 0 ? Math.round((processed / total) * 100) : 0;\r\n\r\n    return `${percentage}% complete. ${processed} of ${total} documents processed.`;\r\n  }\r\n\r\n  private calculateOverallCompliance(summary: TimelineSummary): string {\r\n    const rating = summary.complianceRatings.overall;\r\n    const issueCount = summary.criticalIssues.length;\r\n\r\n    // Convert rating to numeric score (-100 to 100)\r\n    let score = 0;\r\n    switch (rating) {\r\n      case ComplianceRating.Excellent:\r\n        score = 90;\r\n        break;\r\n      case ComplianceRating.Good:\r\n        score = 70;\r\n        break;\r\n      case ComplianceRating.Satisfactory:\r\n        score = 50;\r\n        break;\r\n      case ComplianceRating.Poor:\r\n        score = -20;\r\n        break;\r\n      default:\r\n        score = 0;\r\n    }\r\n\r\n    // Adjust score based on critical issues\r\n    score -= issueCount * 10;\r\n    score = Math.max(-100, Math.min(100, score));\r\n\r\n    let description = '';\r\n    if (score >= 80) {\r\n      description = 'Full compliance with all obligations';\r\n    } else if (score >= 50) {\r\n      description = 'Substantial compliance with minor issues';\r\n    } else if (score >= 0) {\r\n      description = 'Partial compliance with significant concerns';\r\n    } else {\r\n      description = 'Non-compliance with potential obstruction';\r\n    }\r\n\r\n    return `${score} (${description})`;\r\n  }\r\n\r\n  private generateExecutiveSummary(summary: TimelineSummary): string {\r\n    const criticalIssues = summary.criticalIssues;\r\n    const actionCount = summary.sequentialActions.length;\r\n\r\n    let execSummary = `Timeline analysis of ${actionCount} communications reveals `;\r\n\r\n    if (criticalIssues.length === 0) {\r\n      execSummary +=\r\n        'generally compliant response pattern with no critical violations identified.';\r\n    } else {\r\n      execSummary += `${criticalIssues.length} critical compliance issues including: `;\r\n      execSummary += criticalIssues.slice(0, 2).join('; ');\r\n      if (criticalIssues.length > 2) {\r\n        execSummary += '; and other concerns.';\r\n      }\r\n    }\r\n\r\n    return execSummary;\r\n  }\r\n\r\n  private getProcessedRecordsList(summary: TimelineSummary): string {\r\n    return summary.sequentialActions\r\n      .map((action: TimelineEntry) => action.documentId)\r\n      .join(', ');\r\n  }\r\n\r\n  private getRemainingRecordsList(summary: TimelineSummary): string {\r\n    // This would need to be tracked by the agent\r\n    const remainingCount =\r\n      summary.globalMetadata.totalDocuments -\r\n      summary.globalMetadata.processedDocuments;\r\n    if (remainingCount === 0) {\r\n      return 'None';\r\n    }\r\n    return `${remainingCount} documents remaining`;\r\n  }\r\n\r\n  private getNextRecordToProcess(summary: TimelineSummary): string {\r\n    const remaining = this.getRemainingRecordsList(summary);\r\n    return remaining === 'None' ? 'None' : 'Next available document';\r\n  }\r\n\r\n  private extractRelevantActor(action: TimelineEntry): string {\r\n    // Extract actor information from the timeline entry\r\n    return action.summary.includes('parent')\r\n      ? \"Sean O'Brien (citizen/parent)\"\r\n      : action.summary.includes('school') ||\r\n          action.summary.includes('authority')\r\n        ? 'School Authority'\r\n        : 'Unknown Actor';\r\n  }\r\n\r\n  private extractIdentifiedAction(action: TimelineEntry): string {\r\n    // Extract the specific action taken or not taken\r\n    if (action.actionTaken) {\r\n      return action.actionTaken;\r\n    }\r\n\r\n    // Infer from summary\r\n    if (action.summary.toLowerCase().includes('request')) {\r\n      return 'Submitted formal request for information';\r\n    } else if (action.summary.toLowerCase().includes('follow-up')) {\r\n      return 'Followed up on previous communication';\r\n    } else if (action.summary.toLowerCase().includes('response')) {\r\n      return 'Provided response to inquiry';\r\n    }\r\n\r\n    return action.summary;\r\n  }\r\n\r\n  private extractRelevantAction(action: TimelineEntry): string {\r\n    // Extract verbatim statements from the document\r\n    if (action.verbatimStatements && action.verbatimStatements.length > 0) {\r\n      return action.verbatimStatements\r\n        .slice(0, 2)\r\n        .map((stmt) => `\"${stmt}\"`)\r\n        .join(' ');\r\n    }\r\n\r\n    return 'No verbatim statements captured';\r\n  }\r\n\r\n  private extractKeyFindings(action: TimelineEntry): string {\r\n    // Extract key findings from the action\r\n    const findings = [];\r\n\r\n    if (action.complianceNotes && action.complianceNotes.length > 0) {\r\n      findings.push(...action.complianceNotes);\r\n    }\r\n\r\n    if (findings.length === 0) {\r\n      findings.push('Standard communication in sequence');\r\n    }\r\n\r\n    return findings.join('; ');\r\n  }\r\n\r\n  private extractViolations(action: TimelineEntry): string {\r\n    // Identify violations and challenges\r\n    const violations = [];\r\n\r\n    if (action.summary.toLowerCase().includes('delay')) {\r\n      violations.push('Potential timeline violation');\r\n    }\r\n\r\n    if (action.summary.toLowerCase().includes('incomplete')) {\r\n      violations.push('Incomplete response provided');\r\n    }\r\n\r\n    if (\r\n      action.summary.toLowerCase().includes('denial') ||\r\n      action.summary.toLowerCase().includes('refuse')\r\n    ) {\r\n      violations.push('Improper denial of request');\r\n    }\r\n\r\n    return violations.length > 0\r\n      ? violations.join('; ')\r\n      : 'No violations identified';\r\n  }\r\n\r\n  private extractCurrentContext(action: TimelineEntry): string {\r\n    // Describe the state after this action and what should happen next\r\n    let context = '';\r\n\r\n    if (action.actionRequired) {\r\n      context = `Action required: ${action.actionRequired}`;\r\n    } else {\r\n      context = 'Request remains pending full response';\r\n    }\r\n\r\n    // Add timeline expectations\r\n    const nextAction = this.determineNextExpectedAction(action);\r\n    if (nextAction) {\r\n      context += `. Next expected action: ${nextAction}`;\r\n    }\r\n\r\n    return context;\r\n  }\r\n\r\n  private determineNextExpectedAction(action: TimelineEntry): string {\r\n    // Determine what action should come next based on the current state\r\n    if (action.summary.toLowerCase().includes('request')) {\r\n      return 'Authority acknowledgment within 5 business days';\r\n    } else if (action.summary.toLowerCase().includes('follow-up')) {\r\n      return 'Substantive response addressing all concerns';\r\n    } else if (action.summary.toLowerCase().includes('partial')) {\r\n      return 'Complete response with remaining information';\r\n    }\r\n\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * Get the current summary text\r\n   */\r\n  getCurrentSummary(): string {\r\n    return this.currentSummary;\r\n  }\r\n\r\n  /**\r\n   * Process the next document in the timeline as demonstrated in the script\r\n   */\r\n  async processNextRecord(): Promise<string> {\r\n    const result = await this.agent.processNextDocument();\r\n\r\n    if (!result) {\r\n      return 'No more records to process';\r\n    }\r\n\r\n    return this.generateComplianceSummary();\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to create a compliance processor\r\n */\r\nexport function createComplianceProcessor(\r\n  propertyId: string,\r\n): ComplianceTimelineProcessor {\r\n  const agent = TimelineAgentFactory({ propertyId });\r\n  return new ComplianceTimelineProcessor(agent);\r\n}\r\n\r\n/**\r\n * Example usage demonstrating the script requirements\r\n */\r\nexport async function demonstrateComplianceProcessing() {\r\n  console.log('=== Compliance Timeline Processing Demonstration ===');\r\n\r\n  // Create a processor for the specific case mentioned in the script\r\n  const processor = createComplianceProcessor('initial-ferpa-request-325');\r\n\r\n  // Initialize the agent\r\n  await processor['agent'].initialize();\r\n\r\n  // Add the specific documents mentioned in the script\r\n  processor['agent'].addDocuments(['325', '308', '307']);\r\n\r\n  let summary = await processor.processCaseDocument('325');\r\n\r\n  summary = await processor.processCaseDocument('308');\r\n\r\n  console.log('\\nProcessing next record (307)...');\r\n  summary = await processor.processCaseDocument('307');\r\n\r\n  console.log('\\n=== Final Compliance Summary ===');\r\n  console.log(summary);\r\n\r\n  return summary;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\agents\\timeline\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":30,"column":1,"nodeType":"Program","endLine":113,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Timeline Agent - Comprehensive compliance timeline processing for data request cases\r\n *\r\n * This module provides functionality for processing sequences of case documents\r\n * to generate detailed, compliance-focused timeline summaries for data request cases\r\n * such as FERPA and MNGDPA requests.\r\n *\r\n * Key Components:\r\n * - TimelineAgent: Core agent for document processing and timeline management\r\n * - ComplianceTimelineProcessor: Specialized processor for compliance analysis\r\n * - Types: Comprehensive type definitions for timeline data structures\r\n *\r\n * @example\r\n * ```typescript\r\n * import { TimelineAgentFactory, createComplianceProcessor } from './timeline';\r\n *\r\n * // Basic usage\r\n * const agent = TimelineAgentFactory({ initialDocumentId: 'doc-001' });\r\n * await agent.initialize();\r\n * await agent.processNextDocument();\r\n * const summary = agent.generateSummary();\r\n *\r\n * // Compliance processing\r\n * const processor = createComplianceProcessor('ferpa-request-001');\r\n * const complianceSummary = await processor.processCaseDocument('doc-001');\r\n * ```\r\n */\r\n\r\n// Core agent exports\r\nexport { default as TimelineAgentFactory, TimelineAgent } from './agent';\r\n\r\n// Compliance processor exports\r\nexport {\r\n  ComplianceTimelineProcessor,\r\n  createComplianceProcessor,\r\n  demonstrateComplianceProcessing,\r\n} from './compliance-processor';\r\n\r\n// Type exports\r\nexport type {\r\n  TimelineAgentProps,\r\n  DocumentMetadata,\r\n  TimelineEntry,\r\n  GlobalMetadata,\r\n  ComplianceRatings,\r\n  TimelineSummary,\r\n  ProcessingResult,\r\n  TimelineAgentState,\r\n  SerializedTimelineAgent,\r\n} from './types';\r\n\r\nexport { ComplianceRating } from './types';\r\n\r\n// Import for internal use\r\nimport TimelineAgentFactory from './agent';\r\nimport { createComplianceProcessor } from './compliance-processor';\r\n\r\n/**\r\n * Quick start function for common use cases\r\n */\r\nexport async function quickStartTimelineAgent(options: {\r\n  callToActionId: string;\r\n  additionalDocuments?: string[];\r\n  processAllDocuments?: boolean;\r\n}) {\r\n  const agent = TimelineAgentFactory({\r\n    propertyId: options.callToActionId,\r\n  });\r\n\r\n  await agent.initialize();\r\n\r\n  if (options.additionalDocuments) {\r\n    agent.addDocuments(options.additionalDocuments);\r\n  }\r\n\r\n  if (options.processAllDocuments) {\r\n    while (agent.hasMoreDocuments()) {\r\n      await agent.processNextDocument();\r\n    }\r\n  }\r\n\r\n  return {\r\n    agent,\r\n    summary: agent.generateSummary(),\r\n    counts: agent.getDocumentCounts(),\r\n  };\r\n}\r\n\r\n/**\r\n * Quick start function for compliance processing\r\n */\r\nexport async function quickStartComplianceProcessing(options: {\r\n  initialDocumentId: string;\r\n  caseFileIds: string[];\r\n}) {\r\n  const processor = createComplianceProcessor(options.initialDocumentId);\r\n\r\n  // Initialize the underlying agent\r\n  await processor['agent'].initialize();\r\n\r\n  // Process each case file\r\n  let currentSummary = '';\r\n  for (const caseFileId of options.caseFileIds) {\r\n    currentSummary = await processor.processCaseDocument(caseFileId);\r\n  }\r\n\r\n  return {\r\n    processor,\r\n    finalSummary: currentSummary,\r\n    agent: processor['agent'],\r\n  };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\agents\\timeline\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":12,"column":1,"nodeType":"Program","endLine":346,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Configuration properties for initializing a Timeline Agent for a given call to action.\r\n *\r\n * @example\r\n * ```typescript\r\n * const agentProps: TimelineAgentProps = {\r\n *   propertyId: \"cta-uuid\",\r\n *   initialDocumentId: \"doc-456\"\r\n * };\r\n * ```\r\n */\r\nexport type TimelineAgentProps = {\r\n  /** Unique identifier for the call to action being analyzed */\r\n  propertyId: string;\r\n  /** Optional initial document ID to start the timeline analysis from */\r\n  initialDocumentId?: string;\r\n};\r\n\r\n/**\r\n * Enumeration of compliance rating levels used throughout the timeline analysis.\r\n * Ratings are used to assess various aspects of compliance such as timeliness,\r\n * completeness, accuracy, and transparency.\r\n *\r\n * @example\r\n * ```typescript\r\n * const rating: ComplianceRating = ComplianceRating.Good;\r\n * ```\r\n */\r\nexport enum ComplianceRating {\r\n  /** Rating could not be determined due to insufficient information */\r\n  Unknown = 'Unknown',\r\n  /** Compliance standards not met, significant issues identified */\r\n  Poor = 'Poor',\r\n  /** Minimum compliance standards met, some room for improvement */\r\n  Satisfactory = 'Satisfactory',\r\n  /** Good compliance with standards, minor issues if any */\r\n  Good = 'Good',\r\n  /** Exceptional compliance, exceeds all standards */\r\n  Excellent = 'Excellent',\r\n}\r\n\r\n/**\r\n * Metadata information for a document in the timeline analysis.\r\n * Contains essential document properties and communication details.\r\n *\r\n * @example\r\n * ```typescript\r\n * const metadata: DocumentMetadata = {\r\n *   documentId: \"email-123\",\r\n *   propertyId: \"prop-456\",\r\n *   documentType: \"email\",\r\n *   dateSent: \"2024-01-15\",\r\n *   sender: \"john@example.com\",\r\n *   recipient: \"jane@university.edu\",\r\n *   subject: \"FERPA Request Follow-up\",\r\n *   attachmentCount: 2,\r\n *   priority: \"High\"\r\n * };\r\n * ```\r\n */\r\nexport type DocumentMetadata = {\r\n  /** Unique identifier for the document */\r\n  documentId: string;\r\n  /** Identifier linking this document to a specific property/case */\r\n  propertyId: string;\r\n  /** Type of document (e.g., \"email\", \"letter\", \"form\") */\r\n  documentType: string;\r\n  /** ISO date string when the document was sent (optional) */\r\n  dateSent?: string;\r\n  /** ISO date string when the document was received (optional) */\r\n  dateReceived?: string;\r\n  /** Email address or name of the document sender */\r\n  sender: string;\r\n  /** Email address or name of the document recipient */\r\n  recipient: string;\r\n  /** Subject line or title of the document */\r\n  subject: string;\r\n  /** Number of attachments included with the document */\r\n  attachmentCount: number;\r\n  /** Priority level assigned to the document */\r\n  priority: 'Low' | 'Medium' | 'High' | 'Critical';\r\n};\r\n\r\n/**\r\n * Represents a single entry in the timeline analysis.\r\n * Each entry corresponds to a significant event or action in the compliance timeline.\r\n *\r\n * @example\r\n * ```typescript\r\n * const entry: TimelineEntry = {\r\n *   documentId: \"email-123\",\r\n *   date: \"2024-01-15T10:30:00Z\",\r\n *   summary: \"Initial FERPA request received from student\",\r\n *   verbatimStatements: [\"I request all my educational records\"],\r\n *   complianceNotes: [\"Request meets FERPA requirements\"],\r\n *   actionTaken: \"Forwarded to registrar's office\",\r\n *   actionRequired: \"Gather records within 45 days\"\r\n * };\r\n * ```\r\n */\r\nexport type TimelineEntry = {\r\n  /** Unique identifier of the document this entry relates to */\r\n  documentId: string;\r\n  /** ISO date string when this timeline event occurred */\r\n  date: string;\r\n  /** Brief summary of what happened in this timeline entry */\r\n  summary: string;\r\n  /** Direct quotes or verbatim text from the document (optional) */\r\n  verbatimStatements?: string[];\r\n  /** Compliance-related observations or notes (optional) */\r\n  complianceNotes?: string[];\r\n  /** Description of any action that was taken (optional) */\r\n  actionTaken?: string;\r\n  /** Description of any action that is required (optional) */\r\n  actionRequired?: string;\r\n  /** Additional flexible properties for extensibility */\r\n  [key: string]: unknown;\r\n};\r\n\r\n/**\r\n * Global metadata that applies to the entire case or timeline analysis.\r\n * Contains high-level information about the compliance request and its current status.\r\n *\r\n * @example\r\n * ```typescript\r\n * const globalMeta: GlobalMetadata = {\r\n *   caseId: \"case-2024-001\",\r\n *   propertyId: \"prop-123\",\r\n *   communicationId: \"comm-456\",\r\n *   caseType: \"FERPA\",\r\n *   requestType: \"Educational Records Request\",\r\n *   requestDate: \"2024-01-15\",\r\n *   requesterName: \"John Smith\",\r\n *   institutionName: \"State University\",\r\n *   complianceDeadline: \"2024-03-01\",\r\n *   currentStatus: \"In Progress\",\r\n *   totalDocuments: 15,\r\n *   processedDocuments: 8\r\n * };\r\n * ```\r\n */\r\nexport type GlobalMetadata = {\r\n  /** Unique identifier for the entire case */\r\n  caseId: string;\r\n  /** Optional property identifier (may be inherited from context) */\r\n  propertyId?: string;\r\n  /** Optional communication thread identifier */\r\n  communicationId?: string;\r\n  /** Type of compliance case being analyzed */\r\n  caseType: 'FERPA' | 'MNGDPA' | 'Other';\r\n  /** Description of the type of request (e.g., \"Records Request\", \"Directory Information\") */\r\n  requestType: string;\r\n  /** ISO date string when the request was initially made */\r\n  requestDate: string;\r\n  /** Name of the person making the compliance request */\r\n  requesterName: string;\r\n  /** Name of the institution handling the request */\r\n  institutionName: string;\r\n  /** ISO date string of the compliance deadline */\r\n  complianceDeadline: string;\r\n  /** Current status of the case (e.g., \"Open\", \"In Progress\", \"Completed\") */\r\n  currentStatus: string;\r\n  /** Total number of documents in this case */\r\n  totalDocuments: number;\r\n  /** Number of documents that have been processed so far */\r\n  processedDocuments: number;\r\n};\r\n\r\n/**\r\n * Collection of compliance ratings for different aspects of the timeline analysis.\r\n * Each rating assesses a specific dimension of compliance performance.\r\n *\r\n * @example\r\n * ```typescript\r\n * const ratings: ComplianceRatings = {\r\n *   timeliness: ComplianceRating.Good,\r\n *   completeness: ComplianceRating.Satisfactory,\r\n *   accuracy: ComplianceRating.Excellent,\r\n *   transparency: ComplianceRating.Good,\r\n *   overall: ComplianceRating.Good\r\n * };\r\n * ```\r\n */\r\nexport type ComplianceRatings = {\r\n  /** Rating for how well deadlines and time requirements were met */\r\n  timeliness: ComplianceRating;\r\n  /** Rating for how complete the response was to the original request */\r\n  completeness: ComplianceRating;\r\n  /** Rating for the accuracy of information provided */\r\n  accuracy: ComplianceRating;\r\n  /** Rating for transparency in communications and process */\r\n  transparency: ComplianceRating;\r\n  /** Overall composite rating across all dimensions */\r\n  overall: ComplianceRating;\r\n};\r\n\r\n/**\r\n * Complete summary of a timeline analysis, containing all processed information\r\n * and compliance assessments for a given case.\r\n *\r\n * This is the primary output type of the Timeline Agent analysis.\r\n *\r\n * @example\r\n * ```typescript\r\n * const summary: TimelineSummary = {\r\n *   globalMetadata: { caseId: \"case-001\", caseType: \"FERPA\", ... },\r\n *   sequentialActions: [\r\n *     { documentId: \"doc-1\", date: \"2024-01-15\", summary: \"Request received\" },\r\n *     { documentId: \"doc-2\", date: \"2024-01-20\", summary: \"Acknowledgment sent\" }\r\n *   ],\r\n *   complianceRatings: {\r\n *     timeliness: ComplianceRating.Good,\r\n *     overall: ComplianceRating.Satisfactory\r\n *   },\r\n *   criticalIssues: [\"Potential deadline concern\"],\r\n *   recommendations: [\"Follow up within 5 business days\"],\r\n *   lastUpdated: \"2024-01-25T14:30:00Z\"\r\n * };\r\n * ```\r\n */\r\nexport type TimelineSummary = {\r\n  /** High-level metadata about the entire case */\r\n  globalMetadata: GlobalMetadata;\r\n  /** Chronologically ordered list of timeline entries */\r\n  sequentialActions: TimelineEntry[];\r\n  /** Compliance ratings across different dimensions */\r\n  complianceRatings: ComplianceRatings;\r\n  /** List of critical issues identified during analysis */\r\n  criticalIssues: string[];\r\n  /** List of recommendations for improving compliance */\r\n  recommendations: string[];\r\n  /** ISO timestamp of when this summary was last updated */\r\n  lastUpdated: string;\r\n};\r\n\r\n/**\r\n * Result of processing a single document through the timeline analysis.\r\n * Contains the extracted timeline entry and any additional metadata or references.\r\n *\r\n * @example\r\n * ```typescript\r\n * const result: ProcessingResult = {\r\n *   documentId: \"email-123\",\r\n *   timelineEntry: {\r\n *     documentId: \"email-123\",\r\n *     date: \"2024-01-15\",\r\n *     summary: \"Initial request received\"\r\n *   },\r\n *   additionalDocuments: [\"attachment-1\", \"attachment-2\"],\r\n *   notes: [\"Contains sensitive student information\"],\r\n *   complianceImpact: { deadlineAffected: true },\r\n *   verbatimStatements: [\"I hereby request my educational records\"]\r\n * };\r\n * ```\r\n */\r\nexport type ProcessingResult = {\r\n  /** Unique identifier of the document that was processed */\r\n  documentId: string;\r\n  /** Timeline entry extracted from this document (optional if no timeline impact) */\r\n  timelineEntry?: TimelineEntry;\r\n  /** IDs of additional documents referenced or attached (optional) */\r\n  additionalDocuments?: string[];\r\n  /** Processing notes or observations (optional) */\r\n  notes?: string[];\r\n  /** Impact on compliance metrics or deadlines (optional) */\r\n  complianceImpact?: Record<string, unknown>;\r\n  /** Direct quotes extracted from the document (optional) */\r\n  verbatimStatements?: string[];\r\n};\r\n\r\n/**\r\n * Internal state representation of a Timeline Agent instance.\r\n * Contains all the data needed to resume or serialize the agent's current state.\r\n *\r\n * This type is used internally for state management and persistence.\r\n *\r\n * @example\r\n * ```typescript\r\n * const state: TimelineAgentState = {\r\n *   propertyId: \"prop-123\",\r\n *   pendingDocumentIds: [\"doc-4\", \"doc-5\"],\r\n *   processedDocumentIds: [\"doc-1\", \"doc-2\", \"doc-3\"],\r\n *   currentDocumentId: \"doc-4\",\r\n *   summary: { globalMetadata: {...}, sequentialActions: [...] },\r\n *   metadata: {\r\n *     \"doc-1\": { documentId: \"doc-1\", documentType: \"email\", ... }\r\n *   },\r\n *   createdAt: \"2024-01-15T10:00:00Z\",\r\n *   lastUpdated: \"2024-01-15T14:30:00Z\"\r\n * };\r\n * ```\r\n */\r\nexport type TimelineAgentState = {\r\n  /** Property identifier this agent is analyzing */\r\n  propertyId: string;\r\n  /** List of document IDs that still need to be processed */\r\n  pendingDocumentIds: string[];\r\n  /** List of document IDs that have been successfully processed */\r\n  processedDocumentIds: string[];\r\n  /** ID of the document currently being processed (null if none) */\r\n  currentDocumentId: string | null;\r\n  /** Current timeline summary (null if not yet generated) */\r\n  summary: TimelineSummary | null;\r\n  /** Cached metadata for all known documents, keyed by document ID */\r\n  metadata: Record<string, DocumentMetadata>;\r\n  /** ISO timestamp when this agent state was created */\r\n  createdAt: string;\r\n  /** ISO timestamp when this agent state was last modified */\r\n  lastUpdated: string;\r\n};\r\n\r\n/**\r\n * Serializable representation of a Timeline Agent for persistence or transfer.\r\n * Includes versioning information for backward compatibility.\r\n *\r\n * This type is used when saving/loading agent state to/from storage.\r\n *\r\n * @example\r\n * ```typescript\r\n * const serialized: SerializedTimelineAgent = {\r\n *   version: \"1.0.0\",\r\n *   timestamp: \"2024-01-15T14:30:00Z\",\r\n *   state: {\r\n *     propertyId: \"prop-123\",\r\n *     pendingDocumentIds: [...],\r\n *     processedDocumentIds: [...],\r\n *     // ... other state properties\r\n *   }\r\n * };\r\n *\r\n * // Save to storage\r\n * localStorage.setItem('timeline-agent', JSON.stringify(serialized));\r\n *\r\n * // Load from storage\r\n * const loaded = JSON.parse(localStorage.getItem('timeline-agent'));\r\n * ```\r\n */\r\nexport type SerializedTimelineAgent = {\r\n  /** Version string for backward compatibility when deserializing */\r\n  version: string;\r\n  /** ISO timestamp when this serialization was created */\r\n  timestamp: string;\r\n  /** The complete agent state to be serialized/deserialized */\r\n  state: TimelineAgentState;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\aiModelFactory.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":694,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":389,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":389,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13039,13042],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13039,13042],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":392,"column":4,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":392,"endColumn":7,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13141,13144],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13141,13144],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":457,"column":4,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":457,"endColumn":7,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15649,15652],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15649,15652],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createAzure } from '@ai-sdk/azure';\r\nimport { createGoogleGenerativeAI } from '@ai-sdk/google';\r\nimport { createOpenAI } from '@ai-sdk/openai';\r\nimport { env } from '@/lib/site-util/env';\r\nimport { EmbeddingModelV2, LanguageModelV2 } from '@ai-sdk/provider';\r\nimport { AiModelType, isAiLanguageModelType } from '@/lib/ai/core';\r\nimport {\r\n  AiModelTypeValue_Embedding,\r\n  AiModelTypeValue_GoogleEmbedding,\r\n} from '@/lib/ai/core/unions';\r\nimport { log } from '@/lib/logger';\r\n\r\nimport { customProvider, createProviderRegistry, wrapLanguageModel } from 'ai';\r\nimport {\r\n  cacheWithRedis,\r\n  setNormalizedDefaultsMiddleware,\r\n  MiddlewareStateManager,\r\n  tokenStatsLoggingOnlyMiddleware,\r\n} from './middleware';\r\n\r\n/**\r\n * Model availability manager for programmatic control of model enabling/disabling\r\n */\r\nclass ModelAvailabilityManager {\r\n  private availabilityMap = new Map<string, boolean>();\r\n\r\n  private constructor() {\r\n    // Initialize all models as available by default\r\n    this.resetToDefaults();\r\n  }\r\n\r\n  static getInstance(): ModelAvailabilityManager {\r\n    const KEY = Symbol.for('@noeducation/aiModelFactory:availability');\r\n    type GlobalReg = { [k: symbol]: ModelAvailabilityManager | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    if (!g[KEY]) {\r\n      g[KEY] = new ModelAvailabilityManager();\r\n    }\r\n    return g[KEY]!;\r\n  }\r\n\r\n  /**\r\n   * Check if a specific model is available\r\n   */\r\n  isModelAvailable(modelKey: string): boolean {\r\n    return this.availabilityMap.get(modelKey) ?? true;\r\n  }\r\n\r\n  /**\r\n   * Check if a provider is available (checks if any model for that provider is available)\r\n   */\r\n  isProviderAvailable(provider: 'azure' | 'google' | 'openai'): boolean {\r\n    const providerModels = Array.from(this.availabilityMap.keys()).filter(\r\n      (key) => key.startsWith(`${provider}:`),\r\n    );\r\n\r\n    if (providerModels.length === 0) return true; // No explicit settings, assume available\r\n\r\n    return providerModels.some((key) => this.availabilityMap.get(key) === true);\r\n  }\r\n\r\n  /**\r\n   * Disable a specific model\r\n   */\r\n  disableModel(modelKey: string): void {\r\n    this.availabilityMap.set(modelKey, false);\r\n  }\r\n\r\n  /**\r\n   * Enable a specific model\r\n   */\r\n  enableModel(modelKey: string): void {\r\n    this.availabilityMap.set(modelKey, true);\r\n  }\r\n\r\n  /**\r\n   * Disable all models for a provider\r\n   */\r\n  disableProvider(provider: 'azure' | 'google' | 'openai'): void {\r\n    const modelTypes = ['hifi', 'lofi', 'completions', 'embedding'];\r\n    const googleSpecificModels = [\r\n      'gemini-pro',\r\n      'gemini-flash',\r\n      'google-embedding',\r\n    ];\r\n\r\n    if (provider === 'azure') {\r\n      modelTypes.forEach((model) => this.disableModel(`azure:${model}`));\r\n    } else if (provider === 'google') {\r\n      [...modelTypes, ...googleSpecificModels].forEach((model) =>\r\n        this.disableModel(`google:${model}`),\r\n      );\r\n    } else if (provider === 'openai') {\r\n      modelTypes.forEach((model) => this.disableModel(`openai:${model}`));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enable all models for a provider\r\n   */\r\n  enableProvider(provider: 'azure' | 'google' | 'openai'): void {\r\n    const modelTypes = ['hifi', 'lofi', 'completions', 'embedding'];\r\n    const googleSpecificModels = [\r\n      'gemini-pro',\r\n      'gemini-flash',\r\n      'google-embedding',\r\n    ];\r\n\r\n    if (provider === 'azure') {\r\n      modelTypes.forEach((model) => this.enableModel(`azure:${model}`));\r\n    } else if (provider === 'google') {\r\n      [...modelTypes, ...googleSpecificModels].forEach((model) =>\r\n        this.enableModel(`google:${model}`),\r\n      );\r\n    } else if (provider === 'openai') {\r\n      modelTypes.forEach((model) => this.enableModel(`openai:${model}`));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Temporarily disable a model for a specified duration (in milliseconds)\r\n   */\r\n  temporarilyDisableModel(modelKey: string, durationMs: number): void {\r\n    this.disableModel(modelKey);\r\n    setTimeout(() => {\r\n      this.enableModel(modelKey);\r\n    }, durationMs);\r\n  }\r\n\r\n  /**\r\n   * Reset all models to default available state\r\n   */\r\n  resetToDefaults(): void {\r\n    this.availabilityMap.clear();\r\n    // All models are available by default (no explicit entries needed)\r\n  }\r\n\r\n  /**\r\n   * Get current availability status for debugging\r\n   */\r\n  getAvailabilityStatus(): Record<string, boolean> {\r\n    const status: Record<string, boolean> = {};\r\n    for (const [key, value] of this.availabilityMap.entries()) {\r\n      status[key] = value;\r\n    }\r\n    return status;\r\n  }\r\n}\r\n\r\nconst getAvailability = () => ModelAvailabilityManager.getInstance();\r\n\r\n/**\r\n * Setup middleware for language models with caching and retry logic\r\n */\r\nconst setupMiddleware = (\r\n  provider: string,\r\n  model: LanguageModelV2,\r\n): LanguageModelV2 => {\r\n  return wrapLanguageModel({\r\n    model: wrapLanguageModel({\r\n      model: wrapLanguageModel({\r\n        model,\r\n        middleware: cacheWithRedis,\r\n      }),\r\n      middleware: setNormalizedDefaultsMiddleware,\r\n    }),\r\n    middleware: [\r\n      tokenStatsLoggingOnlyMiddleware({ provider }),\r\n      /*\r\n      retryRateLimitMiddlewareFactory({\r\n        model,\r\n      }),\r\n      */\r\n    ],\r\n  });\r\n};\r\n\r\n/**\r\n * Azure custom provider with model aliases for our existing model names\r\n * Maps hifi, lofi, embedding to Azure-hosted models\r\n */\r\nconst getAzureProvider = () => {\r\n  const KEY = Symbol.for('@noeducation/aiModelFactory:azureProvider');\r\n  type GlobalReg = {\r\n    [k: symbol]: ReturnType<typeof customProvider> | undefined;\r\n  };\r\n  const g = globalThis as unknown as GlobalReg;\r\n  if (g[KEY]) return g[KEY]!;\r\n  g[KEY] = customProvider({\r\n    languageModels: {\r\n      // Custom aliases for Azure models\r\n      hifi: setupMiddleware(\r\n        'azure',\r\n        createAzure({\r\n          baseURL: env('AZURE_OPENAI_ENDPOINT'),\r\n          apiKey: env('AZURE_API_KEY'),\r\n          useDeploymentBasedUrls: true,\r\n          apiVersion: '2025-04-01-preview',\r\n        }).chat(env('AZURE_OPENAI_DEPLOYMENT_HIFI')),\r\n      ),\r\n      lofi: setupMiddleware(\r\n        'azure',\r\n        createAzure({\r\n          baseURL: env('AZURE_OPENAI_ENDPOINT'),\r\n          apiKey: env('AZURE_API_KEY'),\r\n          useDeploymentBasedUrls: true,\r\n          apiVersion: '2025-04-01-preview',\r\n        }).chat(env('AZURE_OPENAI_DEPLOYMENT_LOFI')),\r\n      ),\r\n      completions: setupMiddleware(\r\n        'azure',\r\n        createAzure({\r\n          baseURL: env('AZURE_OPENAI_ENDPOINT'),\r\n          apiKey: env('AZURE_API_KEY'),\r\n          useDeploymentBasedUrls: true,\r\n          apiVersion: '2025-04-01-preview',\r\n        }).completion(env('AZURE_OPENAI_DEPLOYMENT_COMPLETIONS')),\r\n      ),\r\n    },\r\n    textEmbeddingModels: {\r\n      embedding: createAzure({\r\n        baseURL: env('AZURE_OPENAI_ENDPOINT_EMBEDDING'),\r\n        apiKey: env('AZURE_OPENAI_KEY_EMBEDDING'),\r\n        useDeploymentBasedUrls: true,\r\n        apiVersion: '2025-04-01-preview',\r\n      }).textEmbeddingModel(env('AZURE_OPENAI_DEPLOYMENT_EMBEDDING')),\r\n    },\r\n    // Fallback to the raw Azure provider for any models not explicitly defined\r\n    fallbackProvider: createAzure({\r\n      baseURL: env('AZURE_OPENAI_ENDPOINT'),\r\n      apiKey: env('AZURE_API_KEY'),\r\n      apiVersion: '2025-04-01-preview',\r\n      useDeploymentBasedUrls: true,\r\n    }),\r\n  });\r\n  return g[KEY]!;\r\n};\r\n\r\n/**\r\n * Google custom provider with model aliases matching Azure as much as possible\r\n * Maps hifi, lofi, embedding to Google-hosted models\r\n */\r\nconst getGoogleProvider = () => {\r\n  const KEY = Symbol.for('@noeducation/aiModelFactory:googleProvider');\r\n  type GlobalReg = {\r\n    [k: symbol]: ReturnType<typeof customProvider> | undefined;\r\n  };\r\n  const g = globalThis as unknown as GlobalReg;\r\n  if (g[KEY]) return g[KEY]!;\r\n  g[KEY] = customProvider({\r\n    languageModels: {\r\n      // Match Azure aliases with equivalent Google models\r\n      hifi: setupMiddleware(\r\n        'google',\r\n        createGoogleGenerativeAI({\r\n          apiKey: env('GOOGLE_GENERATIVE_AI_API_KEY'),\r\n        }).chat('gemini-2.5-pro'), // High-quality model equivalent to Azure hifi\r\n      ),\r\n      lofi: setupMiddleware(\r\n        'google',\r\n        createGoogleGenerativeAI({\r\n          apiKey: env('GOOGLE_GENERATIVE_AI_API_KEY'),\r\n        }).chat('gemini-2.5-flash'), // Fast model equivalent to Azure lofi\r\n      ),\r\n      'gemini-2.0-flash': setupMiddleware(\r\n        'google',\r\n        createGoogleGenerativeAI({\r\n          apiKey: env('GOOGLE_GENERATIVE_AI_API_KEY'),\r\n        }).chat('gemini-2.0-flash'), // Fast model equivalent to Azure lofi\r\n      ),\r\n      // Google-specific model aliases\r\n      'gemini-pro': setupMiddleware(\r\n        'google',\r\n        createGoogleGenerativeAI({\r\n          apiKey: env('GOOGLE_GENERATIVE_AI_API_KEY'),\r\n        }).chat('gemini-2.5-pro'),\r\n      ),\r\n    },\r\n    textEmbeddingModels: {\r\n      embedding: createGoogleGenerativeAI({\r\n        apiKey: env('GOOGLE_GENERATIVE_AI_API_KEY'),\r\n      }).textEmbeddingModel('text-embedding-004'), // Google embedding equivalent to Azure embedding\r\n    },\r\n    // Fallback to the raw Google provider for any models not explicitly defined\r\n    fallbackProvider: createGoogleGenerativeAI({\r\n      apiKey: env('GOOGLE_GENERATIVE_AI_API_KEY'),\r\n    }),\r\n  });\r\n  return g[KEY]!;\r\n};\r\n\r\n/**\r\n * OpenAI custom provider with model aliases matching Azure and Google\r\n * Maps hifi, lofi, embedding to OpenAI-hosted models\r\n */\r\nconst getOpenAIProvider = () => {\r\n  const KEY = Symbol.for('@noeducation/aiModelFactory:openaiProvider');\r\n  type GlobalReg = {\r\n    [k: symbol]: ReturnType<typeof customProvider> | undefined;\r\n  };\r\n  const g = globalThis as unknown as GlobalReg;\r\n  if (g[KEY]) return g[KEY]!;\r\n  g[KEY] = customProvider({\r\n    languageModels: {\r\n      // Match Azure aliases with equivalent OpenAI models\r\n      hifi: setupMiddleware(\r\n        'openai',\r\n        createOpenAI({\r\n          apiKey: env('OPENAI_API_KEY'),\r\n        }).chat(env('OPENAI_HIFI')), // High-quality model equivalent to Azure hifi\r\n      ),\r\n      lofi: setupMiddleware(\r\n        'openai',\r\n        createOpenAI({\r\n          apiKey: env('OPENAI_API_KEY'),\r\n        }).chat(env('OPENAI_LOFI')), // Fast model equivalent to Azure lofi\r\n      ),\r\n      completions: setupMiddleware(\r\n        'openai',\r\n        createOpenAI({\r\n          apiKey: env('OPENAI_API_KEY'),\r\n        }).completion(env('OPENAI_LOFI')), // Use lofi for completions\r\n      ),\r\n    },\r\n    textEmbeddingModels: {\r\n      embedding: createOpenAI({\r\n        apiKey: env('OPENAI_API_KEY'),\r\n      }).textEmbeddingModel(env('OPENAI_EMBEDDING')), // OpenAI embedding model\r\n    },\r\n    // Fallback to the raw OpenAI provider for any models not explicitly defined\r\n    fallbackProvider: createOpenAI({\r\n      apiKey: env('OPENAI_API_KEY'),\r\n    }),\r\n  });\r\n  return g[KEY]!;\r\n};\r\n\r\n/**\r\n * Provider registry with Azure as default, Google and OpenAI as fallbacks\r\n * Supports creating models by alias with Azure as primary, falling back to Google and OpenAI\r\n */\r\nexport const getProviderRegistry = () => {\r\n  const KEY = Symbol.for('@noeducation/aiModelFactory:providerRegistry');\r\n  type GlobalReg = {\r\n    [k: symbol]: ReturnType<typeof createProviderRegistry> | undefined;\r\n  };\r\n  const g = globalThis as unknown as GlobalReg;\r\n  if (g[KEY]) return g[KEY]!;\r\n  g[KEY] = createProviderRegistry(\r\n    {\r\n      azure: getAzureProvider(),\r\n      google: getGoogleProvider(),\r\n      openai: getOpenAIProvider(),\r\n    },\r\n    {\r\n      languageModelMiddleware:\r\n        MiddlewareStateManager.Instance.getMiddlewareInstance(),\r\n    },\r\n  );\r\n  return g[KEY]!;\r\n};\r\n\r\n/**\r\n * Overloaded function signature for normalizing model keys based on the provider and model type.\r\n *\r\n * @param provider - The AI service provider, either `'azure'` or `'google'`.\r\n * @param modelType - The type of AI model to normalize the key for.\r\n * @returns A normalized model key string prefixed with the provider name (e.g., `azure:modelName` or `google:modelName`).\r\n */\r\ninterface NormalizeModelKeyForProviderOverloads {\r\n  (provider: 'azure', modelType: AiModelType): `azure:${string}`;\r\n  (provider: 'google', modelType: AiModelType): `google:${string}`;\r\n  (provider: 'openai', modelType: AiModelType): `openai:${string}`;\r\n}\r\n\r\n/**\r\n * Normalizes the model key for a given provider by ensuring it is prefixed with the provider name.\r\n *\r\n * If the `modelType` already starts with the provider prefix (e.g., \"provider:model\"), it is returned as-is.\r\n * If `modelType` contains a colon, the substring after the colon is used and prefixed with the provider.\r\n * Otherwise, the entire `modelType` is prefixed with the provider.\r\n *\r\n * @param provider - The name of the AI model provider.\r\n * @param modelType - The model type string, which may or may not be prefixed with a provider.\r\n * @returns The normalized model key in the format \"provider:model\".\r\n */\r\nconst normalizeModelKeyForProvider: NormalizeModelKeyForProviderOverloads = (\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  provider: any,\r\n  modelType: AiModelType,\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n): any => {\r\n  if (modelType.startsWith(provider + ':')) {\r\n    return modelType;\r\n  }\r\n  const idx = modelType.indexOf(':');\r\n  if (idx > -1) {\r\n    return `${provider}:${modelType.substring(idx + 1)}`;\r\n  }\r\n  return `${provider}:${modelType}`;\r\n};\r\n\r\n/**\r\n * Overloads for the AI model provider factory function.\r\n *\r\n * @remarks\r\n * This interface defines the various call signatures for obtaining different types of AI model providers.\r\n *\r\n * @overload\r\n * Returns the default Azure provider when called with no arguments.\r\n *\r\n * @overload\r\n * Returns an embedding model when called with a deployment ID of `'embedding'` or `'google-embedding'` and optional embedding options.\r\n * @param deploymentId - The deployment identifier for the embedding model.\r\n * @param options - Optional configuration for the embedding model.\r\n * @returns An instance of `EmbeddingModelV2<string>`.\r\n *\r\n * @overload\r\n * Returns a language model when called with any other deployment ID and optional chat options.\r\n * @param deploymentId - The deployment identifier for the language model, excluding embedding types.\r\n * @param options - Optional configuration for the language model.\r\n * @returns An instance of `LanguageModel`.\r\n */\r\ninterface GetAiModelProviderOverloads {\r\n  (): ReturnType<typeof getAzureProvider>;\r\n  (deploymentId: 'embedding' | 'google-embedding'): EmbeddingModelV2<string>;\r\n  (\r\n    deploymentId: Exclude<AiModelType, 'embedding' | 'google-embedding'>,\r\n  ): LanguageModelV2;\r\n  (deploymentId: AiModelType): LanguageModelV2 | EmbeddingModelV2<string>;\r\n}\r\n\r\n/**\r\n * Checks if the model type starts with the given prefix.  This is used to short-circuit\r\n * model case statements by matching on the provider prefix only.\r\n * @param prefix The prefix to check\r\n * @param modelType The model type to check against the prefix\r\n * @returns The model type if it starts with the prefix, otherwise 'not-a-match' - which, obviosly, won't match :)\r\n */\r\nconst caseProviderMatch = (\r\n  prefix: string,\r\n  modelType: AiModelType,\r\n): AiModelType => {\r\n  if (modelType.startsWith(prefix)) {\r\n    return modelType as AiModelType;\r\n  }\r\n  return 'not-a-match' as AiModelType;\r\n};\r\n\r\n/**\r\n * Main factory function that provides backward compatibility with existing usage\r\n * while using the new provider registry internally with availability control\r\n */\r\nexport const aiModelFactory: GetAiModelProviderOverloads = (\r\n  modelType?: AiModelType,\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n): any => {\r\n  if (typeof modelType === 'undefined') {\r\n    return getAzureProvider();\r\n  }\r\n  const azureModelKey = normalizeModelKeyForProvider('azure', modelType);\r\n  const googleModelKey = normalizeModelKeyForProvider('google', modelType);\r\n  const openaiModelKey = normalizeModelKeyForProvider('openai', modelType);\r\n\r\n  if (isAiLanguageModelType(modelType)) {\r\n    switch (modelType) {\r\n      case 'completions':\r\n      case 'lofi':\r\n      case 'hifi':\r\n      case caseProviderMatch('azure:', modelType): {\r\n        // Matches any string starting with 'azure:'\r\n        // Check availability and try Azure first if available, fallback to Google\r\n        if (getAvailability().isModelAvailable(azureModelKey)) {\r\n          try {\r\n            return getProviderRegistry().languageModel(azureModelKey);\r\n          } catch (error) {\r\n            // If Azure fails, temporarily disable it and try Google\r\n            getAvailability().temporarilyDisableModel(azureModelKey, 60000); // 1 minute\r\n            log((l) =>\r\n              l.warn(\r\n                `Azure model ${modelType} failed, temporarily disabled:`,\r\n                error,\r\n              ),\r\n            );\r\n          }\r\n        }\r\n\r\n        if (getAvailability().isModelAvailable(googleModelKey)) {\r\n          return getProviderRegistry().languageModel(googleModelKey);\r\n        }\r\n\r\n        throw new Error(`No available providers for model type: ${modelType}`);\r\n      }\r\n\r\n      case 'gemini-pro':\r\n      case 'gemini-flash':\r\n      case caseProviderMatch('google:', modelType): {\r\n        // Matches any string starting with 'google:'\r\n        // Google-specific models\r\n        if (!getAvailability().isModelAvailable(googleModelKey)) {\r\n          throw new Error(`Google model ${modelType} is currently disabled`);\r\n        }\r\n        return getProviderRegistry().languageModel(googleModelKey);\r\n      }\r\n\r\n      case caseProviderMatch('openai:', modelType): {\r\n        // Matches any string starting with 'openai:'\r\n        // OpenAI-specific models\r\n        if (!getAvailability().isModelAvailable(openaiModelKey)) {\r\n          throw new Error(`OpenAI model ${modelType} is currently disabled`);\r\n        }\r\n        return getProviderRegistry().languageModel(openaiModelKey);\r\n      }\r\n\r\n      default:\r\n        if (getAvailability().isModelAvailable(modelType)) {\r\n          const chat = getProviderRegistry().languageModel(modelType);\r\n          if (chat == null) {\r\n            throw new Error('Invalid AiModelType provided: ' + modelType);\r\n          }\r\n          return chat;\r\n        }\r\n    }\r\n  } else {\r\n    switch (modelType) {\r\n      case 'embedding':\r\n      case caseProviderMatch('azure:', modelType): // Matches any string starting with 'azure\r\n        const embed = getProviderRegistry().textEmbeddingModel(azureModelKey);\r\n        if (embed != null) {\r\n          return embed;\r\n        }\r\n        break;\r\n      case 'google-embedding':\r\n      case caseProviderMatch('google:', modelType): // Matches any string starting with 'google:'\r\n        const googleEmbed =\r\n          getProviderRegistry().textEmbeddingModel(googleModelKey);\r\n        if (googleEmbed != null) {\r\n          return googleEmbed;\r\n        }\r\n        break; // Continue to handle embedding models below\r\n      case caseProviderMatch('openai:', modelType): // Matches any string starting with 'openai:'\r\n        const openaiEmbed =\r\n          getProviderRegistry().textEmbeddingModel(openaiModelKey);\r\n        if (openaiEmbed != null) {\r\n          return openaiEmbed;\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n  // If we make it all the way here we were given a bad model string\r\n  throw new TypeError(\r\n    `Invalid AiModelType provided (${modelType}).  Expected one of the aliased names: $'hifi', 'lofi', \\\r\n      'completions']} or a provider-prefixed model name like 'azure:chatgtp-4o-minni', 'google:gemini-flash-2.0', or 'openai:gpt-4'.`,\r\n    {\r\n      cause: modelType,\r\n    },\r\n  );\r\n};\r\n\r\n/**\r\n * Convenience function to create Azure embedding model\r\n */\r\nexport const createEmbeddingModel = (): EmbeddingModelV2<string> =>\r\n  aiModelFactory(AiModelTypeValue_Embedding);\r\n\r\n/**\r\n * Convenience function to create Google embedding model\r\n */\r\nexport const createGoogleEmbeddingModel = (): EmbeddingModelV2<string> =>\r\n  aiModelFactory(AiModelTypeValue_GoogleEmbedding);\r\n\r\n/**\r\n * Model availability control functions\r\n */\r\n\r\n/**\r\n * Disable a specific model (e.g., 'azure:hifi', 'google:embedding')\r\n * @param modelKey - The model key in format 'provider:model' (e.g., 'azure:hifi')\r\n */\r\nexport const disableModel = (modelKey: string): void =>\r\n  getAvailability().disableModel(modelKey);\r\n\r\n/**\r\n * Enable a specific model (e.g., 'azure:hifi', 'google:embedding')\r\n * @param modelKey - The model key in format 'provider:model' (e.g., 'azure:hifi')\r\n */\r\nexport const enableModel = (modelKey: string): void =>\r\n  getAvailability().enableModel(modelKey);\r\n\r\n/**\r\n * Disable all models for a provider\r\n * @param provider - Either 'azure', 'google', or 'openai'\r\n */\r\nexport const disableProvider = (\r\n  provider: 'azure' | 'google' | 'openai',\r\n): void => getAvailability().disableProvider(provider);\r\n/**\r\n * Enable all models for a provider\r\n * @param provider - Either 'azure', 'google', or 'openai'\r\n */\r\nexport const enableProvider = (provider: 'azure' | 'google' | 'openai'): void =>\r\n  getAvailability().enableProvider(provider);\r\n\r\n/**\r\n * Temporarily disable a model for a specified duration\r\n * @param modelKey - The model key in format 'provider:model' (e.g., 'azure:hifi')\r\n * @param durationMs - Duration in milliseconds to disable the model\r\n */\r\nexport const temporarilyDisableModel = (\r\n  modelKey: string,\r\n  durationMs: number,\r\n): void => getAvailability().temporarilyDisableModel(modelKey, durationMs);\r\n/**\r\n * Check if a model is currently available\r\n * @param modelKey - The model key in format 'provider:model' (e.g., 'azure:hifi')\r\n * @returns True if the model is available, false otherwise\r\n */\r\nexport const isModelAvailable = (modelKey: string): boolean =>\r\n  getAvailability().isModelAvailable(modelKey);\r\n\r\n/**\r\n * Check if a provider is available\r\n * @param provider - Either 'azure', 'google', or 'openai'\r\n * @returns True if the provider has any available models, false otherwise\r\n */\r\nexport const isProviderAvailable = (\r\n  provider: 'azure' | 'google' | 'openai',\r\n): boolean => getAvailability().isProviderAvailable(provider);\r\n/**\r\n * Get the current availability status of all models (for debugging)\r\n * @returns Object mapping model keys to their availability status\r\n */\r\nexport const getModelAvailabilityStatus = (): Record<string, boolean> =>\r\n  getAvailability().getAvailabilityStatus();\r\n\r\n/**\r\n * Reset all models to their default available state\r\n */\r\nexport const resetModelAvailability = (): void =>\r\n  getAvailability().resetToDefaults();\r\n\r\n/**\r\n * Convenience functions for common scenarios\r\n */\r\n\r\n/**\r\n * Handle Azure rate limiting by temporarily disabling Azure models\r\n * @param durationMs - Duration in milliseconds to disable Azure (default: 5 minutes)\r\n */\r\nexport const handleAzureRateLimit = (durationMs: number = 300000): void => {\r\n  log((l) =>\r\n    l.warn('Azure rate limit detected, temporarily disabling Azure models'),\r\n  );\r\n  getAvailability().temporarilyDisableModel('azure:hifi', durationMs);\r\n  getAvailability().temporarilyDisableModel('azure:lofi', durationMs);\r\n  getAvailability().temporarilyDisableModel('azure:completions', durationMs);\r\n  getAvailability().temporarilyDisableModel('azure:embedding', durationMs);\r\n};\r\n\r\n/**\r\n * Handle Google rate limiting by temporarily disabling Google models\r\n * @param durationMs - Duration in milliseconds to disable Google (default: 5 minutes)\r\n */\r\nexport const handleGoogleRateLimit = (durationMs: number = 300000): void => {\r\n  log((l) =>\r\n    l.warn('Google rate limit detected, temporarily disabling Google models'),\r\n  );\r\n  getAvailability().temporarilyDisableModel('google:hifi', durationMs);\r\n  getAvailability().temporarilyDisableModel('google:lofi', durationMs);\r\n  getAvailability().temporarilyDisableModel('google:embedding', durationMs);\r\n  getAvailability().temporarilyDisableModel('google:gemini-pro', durationMs);\r\n  getAvailability().temporarilyDisableModel('google:gemini-flash', durationMs);\r\n  getAvailability().temporarilyDisableModel(\r\n    'google:google-embedding',\r\n    durationMs,\r\n  );\r\n};\r\n\r\n/**\r\n * Handle OpenAI rate limiting by temporarily disabling OpenAI models\r\n * @param durationMs - Duration in milliseconds to disable OpenAI (default: 5 minutes)\r\n */\r\nexport const handleOpenAIRateLimit = (durationMs: number = 300000): void => {\r\n  log((l) =>\r\n    l.warn('OpenAI rate limit detected, temporarily disabling OpenAI models'),\r\n  );\r\n  getAvailability().temporarilyDisableModel('openai:hifi', durationMs);\r\n  getAvailability().temporarilyDisableModel('openai:lofi', durationMs);\r\n  getAvailability().temporarilyDisableModel('openai:completions', durationMs);\r\n  getAvailability().temporarilyDisableModel('openai:embedding', durationMs);\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\chat\\error-helpers.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":77,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { APICallError } from 'ai';\r\nimport { isError } from '@/lib/react-util/utility-methods';\r\nimport type { RetryErrorInfo } from './types';\r\n\r\n/**\r\n * Extracts retry-related error information from a given error object.\r\n *\r\n * This function inspects the provided error and attempts to determine if it is a retryable API call error,\r\n * specifically checking for HTTP 429 (Too Many Requests) errors and extracting the `Retry-After` header if present.\r\n * It recursively traverses nested error properties (`cause`, `lastError`, `error`) to find retryable errors.\r\n *\r\n * @param error - The error object to inspect. Can be of any type.\r\n * @returns A `RetryErrorInfo` object containing details about whether the error is retryable,\r\n *          the retry delay (if applicable), and the original error. If the input is not an error,\r\n *          returns an object indicating no error information is available.\r\n */\r\nexport const getRetryErrorInfo = (\r\n  error: unknown,\r\n): RetryErrorInfo | undefined => {\r\n  // Absolutely must be an error to have retry error info\r\n  if (isError(error)) {\r\n    // Also really need to be an APICallError\r\n    if (APICallError.isInstance(error)) {\r\n      if (error.statusCode === 429) {\r\n        if (error.responseHeaders) {\r\n          const retryAfterHeader = parseInt(\r\n            error.responseHeaders['retry-after'] ?? '60',\r\n          );\r\n          const retryAfter = isNaN(retryAfterHeader) ? 60 : retryAfterHeader;\r\n          return {\r\n            isError: true,\r\n            isRetry: true,\r\n            error,\r\n            retryAfter,\r\n          };\r\n        }\r\n      }\r\n    }\r\n    // If not, there's a chance we have an error nested inside us\r\n    if (error.cause) {\r\n      const cause = getRetryErrorInfo(error.cause);\r\n      if (cause?.isRetry) {\r\n        return cause;\r\n      }\r\n    }\r\n    if ('lastError' in error) {\r\n      const lastError = getRetryErrorInfo(error.lastError);\r\n      if (lastError?.isRetry) {\r\n        return lastError;\r\n      }\r\n    }\r\n    if ('error' in error) {\r\n      const errorInfo = getRetryErrorInfo(error.error);\r\n      if (errorInfo?.isRetry) {\r\n        return errorInfo;\r\n      }\r\n    }\r\n    // Otherwise, we're just a boring old error\r\n    return {\r\n      isError: true,\r\n      isRetry: false,\r\n      error,\r\n    };\r\n  }\r\n  // The only way we could possibly be a retry from here is if we are a non-null / undefined value with a child property named 'error'.\r\n  if (error && typeof error === 'object' && 'error' in error) {\r\n    const errorInfo = getRetryErrorInfo(error.error);\r\n    if (errorInfo?.isError || errorInfo?.isRetry) {\r\n      return errorInfo;\r\n    }\r\n  }\r\n  // If we get here, we have no retry error info or error info at all\r\n  return {\r\n    isError: false,\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\chat\\export.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":9,"column":1,"nodeType":"Program","endLine":247,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Chat Export Utilities\r\n *\r\n * Provides functions to export selected chat messages to various formats:\r\n * - CSV: Tabular format with columns for timestamp, role, content, etc.\r\n * - Markdown: Structured text format with headers and timestamps\r\n */\r\n\r\nimport type { ChatMessage, ChatTurn } from '@/lib/ai/chat/types';\r\n\r\nexport interface SelectedChatItem {\r\n  type: 'turn' | 'message';\r\n  turnId: number;\r\n  messageId?: number; // Only set when type is 'message'\r\n}\r\n\r\n/**\r\n * Export selected chat items to CSV format\r\n */\r\nexport function exportToCsv(\r\n  turns: ChatTurn[],\r\n  selectedItems: SelectedChatItem[],\r\n  chatTitle?: string,\r\n): void {\r\n  const messages = getSelectedMessages(turns, selectedItems);\r\n\r\n  if (messages.length === 0) {\r\n    throw new Error('No messages selected for export');\r\n  }\r\n\r\n  const csvContent = generateCsvContent(messages);\r\n  const filename = `chat-export-${chatTitle ? sanitizeFilename(chatTitle) : 'untitled'}-${new Date().toISOString().slice(0, 10)}.csv`;\r\n\r\n  downloadFile(csvContent, filename, 'text/csv');\r\n}\r\n\r\n/**\r\n * Export selected chat items to Markdown format\r\n */\r\nexport function exportToMarkdown(\r\n  turns: ChatTurn[],\r\n  selectedItems: SelectedChatItem[],\r\n  chatTitle?: string,\r\n  chatCreatedAt?: string,\r\n): void {\r\n  const messages = getSelectedMessages(turns, selectedItems);\r\n\r\n  if (messages.length === 0) {\r\n    throw new Error('No messages selected for export');\r\n  }\r\n\r\n  const markdownContent = generateMarkdownContent(\r\n    messages,\r\n    chatTitle,\r\n    chatCreatedAt,\r\n  );\r\n  const filename = `chat-export-${chatTitle ? sanitizeFilename(chatTitle) : 'untitled'}-${new Date().toISOString().slice(0, 10)}.md`;\r\n\r\n  downloadFile(markdownContent, filename, 'text/markdown');\r\n}\r\n\r\n/**\r\n * Get all messages that match the selected items\r\n */\r\nconst getSelectedMessages = (\r\n  turns: ChatTurn[],\r\n  selectedItems: SelectedChatItem[],\r\n): ChatMessage[] => {\r\n  const messages: ChatMessage[] = [];\r\n\r\n  for (const item of selectedItems) {\r\n    const turn = turns.find((t) => t.turnId === item.turnId);\r\n    if (!turn) continue;\r\n\r\n    if (item.type === 'turn') {\r\n      // Add all messages from the turn\r\n      messages.push(...turn.messages);\r\n    } else if (item.type === 'message' && item.messageId !== undefined) {\r\n      // Add specific message\r\n      const message = turn.messages.find((m) => m.messageId === item.messageId);\r\n      if (message) {\r\n        messages.push(message);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Sort by turn ID and message order for consistent output\r\n  return messages.sort((a, b) => {\r\n    if (a.turnId !== b.turnId) {\r\n      return a.turnId - b.turnId;\r\n    }\r\n    return a.messageOrder - b.messageOrder;\r\n  });\r\n};\r\n\r\n/**\r\n * Generate CSV content from messages\r\n */\r\nconst generateCsvContent = (messages: ChatMessage[]): string => {\r\n  const headers = [\r\n    'Turn ID',\r\n    'Message ID',\r\n    'Role',\r\n    'Content',\r\n    'Tool Name',\r\n    'Message Order',\r\n    'Provider ID',\r\n  ];\r\n\r\n  const rows = messages.map((message) => [\r\n    message.turnId.toString(),\r\n    message.messageId.toString(),\r\n    message.role,\r\n    escapeCsvField(message.content || ''),\r\n    message.toolName || '',\r\n    message.messageOrder.toString(),\r\n    message.providerId || '',\r\n  ]);\r\n\r\n  const csvLines = [headers.join(','), ...rows.map((row) => row.join(','))];\r\n\r\n  return csvLines.join('\\n');\r\n};\r\n\r\n/**\r\n * Generate Markdown content from messages\r\n */\r\nconst generateMarkdownContent = (\r\n  messages: ChatMessage[],\r\n  chatTitle?: string,\r\n  chatCreatedAt?: string,\r\n): string => {\r\n  const lines: string[] = [];\r\n\r\n  // Header\r\n  lines.push(`# Chat Export: ${chatTitle || 'Untitled Chat'}`);\r\n  lines.push('');\r\n\r\n  if (chatCreatedAt) {\r\n    lines.push(`**Created:** ${new Date(chatCreatedAt).toLocaleString()}`);\r\n    lines.push('');\r\n  }\r\n\r\n  lines.push(`**Exported:** ${new Date().toLocaleString()}`);\r\n  lines.push(`**Total Messages:** ${messages.length}`);\r\n  lines.push('');\r\n  lines.push('---');\r\n  lines.push('');\r\n\r\n  // Group messages by turn for better structure\r\n  const turnGroups = new Map<number, ChatMessage[]>();\r\n  for (const message of messages) {\r\n    if (!turnGroups.has(message.turnId)) {\r\n      turnGroups.set(message.turnId, []);\r\n    }\r\n    turnGroups.get(message.turnId)!.push(message);\r\n  }\r\n\r\n  // Generate content for each turn\r\n  for (const [turnId, turnMessages] of Array.from(turnGroups.entries()).sort(\r\n    ([a], [b]) => a - b,\r\n  )) {\r\n    lines.push(`## Turn ${turnId}`);\r\n    lines.push('');\r\n\r\n    for (const message of turnMessages.sort(\r\n      (a, b) => a.messageOrder - b.messageOrder,\r\n    )) {\r\n      // Message header\r\n      let messageHeader = `**${capitalizeRole(message.role)}**`;\r\n      if (message.toolName) {\r\n        messageHeader += ` (Tool: ${message.toolName})`;\r\n      }\r\n      lines.push(messageHeader);\r\n      lines.push('');\r\n\r\n      // Message content\r\n      if (message.content) {\r\n        // Handle different content types\r\n        if (typeof message.content === 'string') {\r\n          lines.push(message.content);\r\n        } else {\r\n          lines.push('```json');\r\n          lines.push(JSON.stringify(message.content, null, 2));\r\n          lines.push('```');\r\n        }\r\n      } else {\r\n        lines.push('*No content*');\r\n      }\r\n\r\n      lines.push('');\r\n      lines.push('---');\r\n      lines.push('');\r\n    }\r\n  }\r\n\r\n  return lines.join('\\n');\r\n};\r\n\r\n/**\r\n * Escape a field for CSV format\r\n */\r\nconst escapeCsvField = (field: string): string => {\r\n  // If the field contains comma, newline, or quote, wrap in quotes and escape internal quotes\r\n  if (field.includes(',') || field.includes('\\n') || field.includes('\"')) {\r\n    return `\"${field.replace(/\"/g, '\"\"')}\"`;\r\n  }\r\n  return field;\r\n};\r\n\r\n/**\r\n * Capitalize the first letter of a role\r\n */\r\nconst capitalizeRole = (role: string): string => {\r\n  return role.charAt(0).toUpperCase() + role.slice(1);\r\n};\r\n\r\n/**\r\n * Sanitize filename by removing invalid characters\r\n */\r\nconst sanitizeFilename = (filename: string): string => {\r\n  return filename.replace(/[<>:\"/\\\\|?*]/g, '-').replace(/\\s+/g, '-');\r\n};\r\n\r\n/**\r\n * Download a file with the given content\r\n */\r\nconst downloadFile = (\r\n  content: string,\r\n  filename: string,\r\n  mimeType: string,\r\n): void => {\r\n  const blob = new Blob([content], { type: mimeType });\r\n  const url = URL.createObjectURL(blob);\r\n\r\n  const link = document.createElement('a');\r\n  link.href = url;\r\n  link.download = filename;\r\n  link.style.display = 'none';\r\n\r\n  document.body.appendChild(link);\r\n  link.click();\r\n  document.body.removeChild(link);\r\n\r\n  URL.revokeObjectURL(url);\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\chat\\history.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":32,"column":1,"nodeType":"Program","endLine":84,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Chat History Utilities\r\n * ------------------------------------------------------------------\r\n * Provides a helper for securely retrieving minimal chat metadata while\r\n * enforcing ownership authorization. The function performs a single\r\n * database lookup (lazy-initializing the Drizzle connection via\r\n * `drizDbWithInit`) and then validates that the requesting user is the\r\n * owner of the chat before returning any information.\r\n *\r\n * Returned data is intentionally minimal (currently only the title) to\r\n * avoid leaking potentially sensitive chat content or internal fields\r\n * through unauthorized access attempts.\r\n *\r\n * SECURITY MODEL\r\n *  - Authorization is owner-based: a chat is accessible only when\r\n *    `signedInUserId === ownerUserId` as evaluated by `isUserAuthorized`.\r\n *  - If the user is not authorized or the chat does not exist the function\r\n *    returns `{ ok: false }` without throwing, enabling simple branch\r\n *    handling in calling server components / route handlers.\r\n *\r\n * DESIGN NOTES\r\n *  - Returns a discriminated union-ish shape (`ok: true|false`) instead of\r\n *    throwing on not-found/unauthorized to keep UI logic straightforward.\r\n *  - Omits `title` when empty/null by converting to `undefined` so callers\r\n *    can rely on simple truthiness checks for display logic or fallbacks.\r\n *\r\n * EXTENSIBILITY\r\n *  To expose more public metadata, append fields inside the `columns`\r\n *  selection and the returned object under the authorized branch—preserving\r\n *  the guard so unauthorized requests still receive only `{ ok: false }`.\r\n */\r\nimport { drizDbWithInit } from '@/lib/drizzle-db';\r\nimport { isUserAuthorized } from '@/lib/site-util/auth';\r\n\r\n/**\r\n * Fetch chat metadata (currently title) if the requesting user owns the chat.\r\n *\r\n * @param params.chatId Unique identifier of the chat record.\r\n * @param params.userId Authenticated (signed-in) user ID performing the request.\r\n * @returns An object:\r\n *  - `{ ok: true, title?: string }` when the chat exists and user is authorized.\r\n *  - `{ ok: false }` when chat missing or unauthorized.\r\n *\r\n * @example\r\n * ```ts\r\n * const details = await getChatDetails({ chatId: 'abc123', userId: 42 });\r\n * if (details.ok) {\r\n *   console.log(details.title ?? '(untitled)');\r\n * } else {\r\n *   // handle not-found or unauthorized\r\n * }\r\n * ```\r\n */\r\nexport const getChatDetails = async ({\r\n  chatId,\r\n  userId,\r\n}: {\r\n  chatId: string;\r\n  userId: number;\r\n}) => {\r\n  const chat = await drizDbWithInit((db) =>\r\n    db.query.chats.findFirst({\r\n      columns: {\r\n        id: true,\r\n        userId: true,\r\n        title: true,\r\n      },\r\n      where: (chat, { eq }) => eq(chat.id, chatId),\r\n    }),\r\n  );\r\n  return chat &&\r\n    (await isUserAuthorized({\r\n      signedInUserId: userId,\r\n      ownerUserId: chat.userId,\r\n    }))\r\n    ? {\r\n        ok: true,\r\n        title: !chat.title ? undefined : chat.title,\r\n      }\r\n    : {\r\n        ok: false,\r\n      };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\chat\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\chat\\message-optimizer-tools.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":1479,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { generateObject, UIMessage } from 'ai';\r\nimport {\r\n  LanguageModelV2Prompt,\r\n  LanguageModelV2Message,\r\n} from '@ai-sdk/provider';\r\nimport { aiModelFactory } from '@/lib/ai/aiModelFactory';\r\nimport type { ChatHistoryContext } from '@/lib/ai/middleware/chat-history/types';\r\nimport { log } from '@/lib/logger';\r\nimport { createHash } from 'crypto';\r\n// import { v4 as uuidv4 } from 'uuid';\r\nimport { appMeters, hashUserId } from '@/lib/site-util/metrics';\r\n// import { ToolMap } from '../services/model-stats/tool-map';\r\nimport { createAgentHistoryContext } from '../middleware/chat-history/create-chat-history-context';\r\nimport { LoggedError } from '@/lib/react-util';\r\nimport z from 'zod';\r\nimport { DbTransactionType, drizDbWithInit, schema } from '@/lib/drizzle-db';\r\nimport { ThisDbQueryProvider } from '@/lib/drizzle-db/schema';\r\nimport { and, eq, not } from 'drizzle-orm';\r\nimport { AttributeValue } from '@opentelemetry/api';\r\nimport { isKeyOf } from '@/lib/typescript';\r\nimport { countTokens } from '../core/count-tokens';\r\nimport {\r\n  ChatToolCallsType,\r\n  ChatToolType,\r\n} from '@/lib/drizzle-db/drizzle-types';\r\nimport { ToolMap } from '../services/model-stats/tool-map';\r\n// import { sql } from 'drizzle-orm';\r\n\r\n/**\r\n * Create a chat_tool_calls record for a specific tool call\r\n * @param tx Database transaction context\r\n * @param chatToolId The chat tool ID from the tool map\r\n * @param chatMessageId The UUID of the chat message this tool call belongs to\r\n * @param providerId The provider-specific tool call ID\r\n * @param toolRequest Array of tool request messages\r\n * @param toolResult Array of tool result/response messages\r\n * @returns The generated chatToolCallId UUID\r\n */\r\n// Generic minimal part representation used internally (supports legacy UIMessage parts and V2 parts)\r\ntype GenericPart = {\r\n  type: string;\r\n  state?: string;\r\n  toolCallId?: string;\r\n  toolName?: string;\r\n  [k: string]: unknown;\r\n};\r\n// Legacy UIMessage shape compatibility minimal subset\r\ninterface LegacyMessageShape {\r\n  id?: string;\r\n  role: string;\r\n  parts?: GenericPart[];\r\n  content?: unknown;\r\n  toolInvocations?: unknown;\r\n  [k: string]: unknown;\r\n}\r\n// Include UIMessage explicitly so test helpers passing UIMessage instances type-check\r\ntype OptimizerMessage = LegacyMessageShape | LanguageModelV2Message | UIMessage;\r\n\r\n// Lightweight helpers (avoid pervasive any usage by local casting only)\r\nconst hasLegacyParts = (\r\n  m: OptimizerMessage,\r\n): m is LegacyMessageShape & { parts: GenericPart[] } =>\r\n  'parts' in m && Array.isArray((m as LegacyMessageShape).parts);\r\nconst readParts = (m: OptimizerMessage): GenericPart[] => {\r\n  if (hasLegacyParts(m)) return m.parts as GenericPart[];\r\n  const content = (m as unknown as { content?: unknown }).content;\r\n  return Array.isArray(content) ? (content as GenericPart[]) : [];\r\n};\r\nconst writeParts = <T extends OptimizerMessage>(\r\n  m: T,\r\n  parts: GenericPart[],\r\n): T => {\r\n  if (hasLegacyParts(m)) return { ...(m as object), parts } as T;\r\n  return { ...(m as object), content: parts } as T;\r\n};\r\n\r\nconst createChatToolCallRecord = async (\r\n  tx: DbTransactionType,\r\n  chatToolId: string,\r\n  chatMessageId: string,\r\n  providerId: string,\r\n  toolRequest: Array<GenericPart>,\r\n  toolResult: Array<GenericPart>,\r\n): Promise<string> => {\r\n  // Serialize input and output for storage\r\n  const input =\r\n    toolRequest.length > 0\r\n      ? JSON.stringify(\r\n          toolRequest.map((req) => ({\r\n            type: req.type,\r\n            state: 'state' in req ? req.state : undefined,\r\n            toolName: 'toolName' in req ? req.toolName : undefined,\r\n            args: 'args' in req ? req.args : undefined,\r\n            input: 'input' in req ? req.input : undefined,\r\n          })),\r\n        )\r\n      : null;\r\n\r\n  const output =\r\n    toolResult.length > 0\r\n      ? JSON.stringify(\r\n          toolResult.map((res) => ({\r\n            type: res.type,\r\n            state: 'state' in res ? res.state : undefined,\r\n            toolName: 'toolName' in res ? res.toolName : undefined,\r\n            result: 'result' in res ? res.result : undefined,\r\n            output: 'output' in res ? res.output : undefined,\r\n            errorText: 'errorText' in res ? res.errorText : undefined,\r\n          })),\r\n        )\r\n      : null;\r\n\r\n  const result = await tx\r\n    .insert(schema.chatToolCalls)\r\n    .values({\r\n      chatToolId,\r\n      chatMessageId,\r\n      providerId,\r\n      input,\r\n      output,\r\n      timestamp: new Date().toISOString(), // Current timestamp\r\n      providerOptions: null, // Can be extended later if needed\r\n    })\r\n    .returning({ chatToolCallId: schema.chatToolCalls.chatToolCallId })\r\n    .execute();\r\n\r\n  if (!result || result.length === 0) {\r\n    throw new Error('Failed to create chat tool call record');\r\n  }\r\n\r\n  return result[0].chatToolCallId;\r\n};\r\n\r\n// OpenTelemetry Metrics for Message Optimization\r\nconst optimizationCounter = appMeters.createCounter(\r\n  'ai_tool_message_optimization_total',\r\n  {\r\n    description: 'Total number of tool message optimization operations',\r\n    unit: '1',\r\n  },\r\n);\r\n\r\nconst messageReductionHistogram = appMeters.createHistogram(\r\n  'ai_tool_message_reduction_ratio',\r\n  {\r\n    description: 'Distribution of tool message reduction ratios (0-1)',\r\n    unit: '1',\r\n  },\r\n);\r\n\r\nconst characterReductionHistogram = appMeters.createHistogram(\r\n  'ai_tool_character_reduction_ratio',\r\n  {\r\n    description: 'Distribution of tool character reduction ratios (0-1)',\r\n    unit: '1',\r\n  },\r\n);\r\n\r\nconst optimizationDurationHistogram = appMeters.createHistogram(\r\n  'ai_tool_optimization_duration_ms',\r\n  {\r\n    description: 'Duration of tool message optimization operations',\r\n    unit: 'ms',\r\n  },\r\n);\r\n\r\nconst toolCallSummariesCounter = appMeters.createCounter(\r\n  'ai_tool_call_summaries_total',\r\n  {\r\n    description: 'Total number of tool call summaries generated',\r\n    unit: '1',\r\n  },\r\n);\r\n\r\nconst cacheHitsCounter = appMeters.createCounter(\r\n  'ai_tool_summary_cache_hits_total',\r\n  {\r\n    description: 'Total number of tool summary cache hits',\r\n    unit: '1',\r\n  },\r\n);\r\n\r\nconst cacheMissesCounter = appMeters.createCounter(\r\n  'ai_tool_summary_cache_misses_total',\r\n  {\r\n    description: 'Total number of tool summary cache misses',\r\n    unit: '1',\r\n  },\r\n);\r\n\r\nconst summaryGenerationDurationHistogram = appMeters.createHistogram(\r\n  'ai_tool_summary_generation_duration_ms',\r\n  {\r\n    description: 'Duration of individual tool summary generation operations',\r\n    unit: 'ms',\r\n  },\r\n);\r\n\r\nconst originalMessageCountHistogram = appMeters.createHistogram(\r\n  'ai_tool_original_message_count',\r\n  {\r\n    description: 'Distribution of original message counts in optimization',\r\n    unit: '1',\r\n  },\r\n);\r\n\r\nconst optimizedMessageCountHistogram = appMeters.createHistogram(\r\n  'ai_tool_optimized_message_count',\r\n  {\r\n    description: 'Distribution of optimized message counts after optimization',\r\n    unit: '1',\r\n  },\r\n);\r\n\r\nconst cacheHitRateHistogram = appMeters.createHistogram(\r\n  'ai_tool_summary_cache_hit_rate',\r\n  {\r\n    description: 'Distribution of cache hit rates for tool summary cache',\r\n    unit: '1',\r\n  },\r\n);\r\n\r\n/**\r\n * In-memory cache for tool call summaries\r\n * Key: hash of tool call sequence content\r\n * Value: cached summary content\r\n */\r\nconst toolSummaryCache = new Map<string, string>();\r\n\r\n/**\r\n * Cache statistics for hit rate tracking and OpenTelemetry metrics\r\n */\r\nconst cacheStats = {\r\n  hits: 0,\r\n  misses: 0,\r\n};\r\n\r\n/**\r\n * Cache management utilities for tool call summaries\r\n * These can be easily migrated to Redis in the future\r\n */\r\nexport const cacheManager = {\r\n  /**\r\n   * Get cache statistics for monitoring and debugging\r\n   */\r\n  getStats(): { size: number; keys: string[]; hitRate: number } {\r\n    return {\r\n      size: toolSummaryCache.size,\r\n      keys: Array.from(toolSummaryCache.keys()).map((k) => k.substring(0, 8)), // First 8 chars for privacy\r\n      hitRate: this.getHitRate(),\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Clear cache (useful for testing or memory management)\r\n   */\r\n  clear(): void {\r\n    toolSummaryCache.clear();\r\n    cacheStats.hits = 0;\r\n    cacheStats.misses = 0;\r\n    log((l) => l.info('Tool summary cache cleared'));\r\n  },\r\n\r\n  /**\r\n   * Get cache hit rate for the current session\r\n   */\r\n  getHitRate(): number {\r\n    const total = cacheStats.hits + cacheStats.misses;\r\n    return total > 0 ? cacheStats.hits / total : 0;\r\n  },\r\n\r\n  /**\r\n   * Update cache hit rate metrics for OpenTelemetry\r\n   */\r\n  updateMetrics(): void {\r\n    cacheHitRateHistogram.record(this.getHitRate(), {\r\n      cache_type: 'tool_summary',\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Export cache for migration to Redis or other storage\r\n   */\r\n  export(): Record<string, string> {\r\n    return Object.fromEntries(toolSummaryCache.entries());\r\n  },\r\n\r\n  /**\r\n   * Import cache from external storage\r\n   */\r\n  import(data: Record<string, string>): void {\r\n    toolSummaryCache.clear();\r\n    Object.entries(data).forEach(([key, value]) => {\r\n      toolSummaryCache.set(key, value);\r\n    });\r\n    log((l) =>\r\n      l.info('Tool summary cache imported', { size: toolSummaryCache.size }),\r\n    );\r\n  },\r\n};\r\n\r\n/**\r\n * Create tool records for a tool call - handles chat_tool and chat_tool_calls creation\r\n */\r\nconst createToolRecordsForToolCall = async (\r\n  record: ToolCallRecord,\r\n  toolCallId: string,\r\n): Promise<void> => {\r\n  if (record.chatToolCallId) {\r\n    // Already processed\r\n    return;\r\n  }\r\n\r\n  // Extract tool name from the tool request or result\r\n  const toolData = record.toolResult[0] || record.toolRequest[0];\r\n  if (!toolData || !('type' in toolData)) {\r\n    throw new Error(\r\n      `Unable to determine tool type for tool call ${toolCallId}`,\r\n    );\r\n  }\r\n\r\n  const toolName = toolData.type.startsWith('tool-')\r\n    ? toolData.type.substring(5) // Remove 'tool-' prefix\r\n    : toolData.type;\r\n\r\n  await drizDbWithInit((db) =>\r\n    db.transaction(async (tx) => {\r\n      try {\r\n        // Create or get chat_tool record\r\n        const chatToolId = await ToolMap.getInstance().then((x) =>\r\n          x.idOrThrow(toolName),\r\n        );\r\n        record.chatToolId = chatToolId;\r\n\r\n        // Get the message ID - we need to find the actual chat_message_id from the database\r\n        // For now, we'll use the messageId as the provider_id and assume we have the chat message ID\r\n        const chatMessageId = record.messageId; // This should be the actual chat_message_id UUID\r\n\r\n        // Create chat_tool_calls record\r\n        const chatToolCallId = await createChatToolCallRecord(\r\n          tx,\r\n          chatToolId,\r\n          chatMessageId,\r\n          toolCallId, // Use tool call ID as provider ID\r\n          record.toolRequest,\r\n          record.toolResult,\r\n        );\r\n\r\n        record.chatToolCallId = chatToolCallId;\r\n\r\n        log((l) =>\r\n          l.info('Created tool records for tool call', {\r\n            toolCallId,\r\n            chatToolId,\r\n            chatToolCallId,\r\n            toolName,\r\n            messageId: record.messageId,\r\n          }),\r\n        );\r\n      } catch (error) {\r\n        log((l) =>\r\n          l.error('Failed to create tool records', {\r\n            error,\r\n            toolCallId,\r\n            messageId: record.messageId,\r\n          }),\r\n        );\r\n        throw error;\r\n      }\r\n    }),\r\n  );\r\n};\r\n\r\n/**\r\n * Generate a deterministic hash for a tool call sequence\r\n */\r\nconst hashToolCallSequence = (toolMessages: GenericPart[]): string => {\r\n  // Create a stable representation of the tool call sequence\r\n  interface HashFriendly {\r\n    type: string;\r\n    state: string;\r\n    toolName?: string;\r\n    text?: string;\r\n    input?: unknown;\r\n    output?: unknown;\r\n    errorText?: string;\r\n  }\r\n  const toHashFriendly = (p: GenericPart): HashFriendly => {\r\n    const toolName =\r\n      p.toolName || (p.type.startsWith('tool-') ? p.type.substring(5) : p.type);\r\n    if (p.type === 'text') {\r\n      return {\r\n        type: p.type,\r\n        state: p.state ?? 'state',\r\n        text: (p as { text?: string }).text,\r\n      };\r\n    }\r\n    return {\r\n      type: p.type,\r\n      state: p.state ?? 'unknown',\r\n      toolName,\r\n      input: (p as { input?: unknown }).input,\r\n      output:\r\n        (p as { output?: unknown; result?: unknown }).output ??\r\n        (p as { result?: unknown }).result,\r\n      errorText: (p as { errorText?: string }).errorText,\r\n    };\r\n  };\r\n  const contentToHash = toolMessages.map(toHashFriendly).sort((a, b) => {\r\n    if (a.type !== b.type) return (a.type || '').localeCompare(b.type || '');\r\n    return String(a.text ?? a.input ?? '').localeCompare(\r\n      String(b.text ?? b.input ?? ''),\r\n    );\r\n  });\r\n\r\n  const hashInput = JSON.stringify(contentToHash);\r\n  return createHash('sha256').update(hashInput).digest('hex');\r\n};\r\n\r\nconst InputToolStateValues = ['input-streaming', 'input-available'] as const;\r\nconst OutputToolStateValues = ['output-error', 'output-available'] as const;\r\nconst ToolStateValues = [\r\n  ...InputToolStateValues,\r\n  ...OutputToolStateValues,\r\n] as const;\r\n\r\ntype InputToolState = (typeof InputToolStateValues)[number];\r\ntype OutputToolState = (typeof OutputToolStateValues)[number];\r\n\r\nconst isInputToolState = (state: unknown): state is InputToolState =>\r\n  !!state && InputToolStateValues.includes(state.toString() as InputToolState);\r\nconst isOutputToolState = (state: unknown): state is OutputToolState =>\r\n  !!state &&\r\n  OutputToolStateValues.includes(state.toString() as OutputToolState);\r\nconst isTool = (check: unknown): check is GenericPart => {\r\n  if (!check || typeof check !== 'object') return false;\r\n  const part = check as GenericPart;\r\n  if (!('type' in part)) return false;\r\n  if (!('state' in part)) return false;\r\n  return isKeyOf(part.state, ToolStateValues);\r\n};\r\n\r\ntype ToolResponseMesage = GenericPart & {\r\n  state: 'output-available' | 'output-error';\r\n};\r\ntype ToolRequestMessage = GenericPart & {\r\n  state: 'input-available' | 'input-streaming';\r\n};\r\n\r\ntype SummarizedToolRequest = ToolRequestMessage;\r\ntype SummarizedToolResponse = ToolResponseMesage & {\r\n  preliminary?: true;\r\n  input?: unknown;\r\n  output?: unknown;\r\n};\r\n\r\n/**\r\n * Interface for tracking tool call sequences\r\n */\r\ninterface ToolCallRecord {\r\n  /**\r\n   * The message this part was found in\r\n   */\r\n  messageId: string;\r\n  /**\r\n   * Tool response messages\r\n   */\r\n  toolResult: Array<ToolResponseMesage>;\r\n  /**\r\n   * Tool request messages\r\n   */\r\n  toolRequest: Array<ToolRequestMessage>;\r\n  /**\r\n   * Summary message text\r\n   * */\r\n  toolSummary: { type: 'text'; text: string };\r\n  /**\r\n   * Summarized tool request message\r\n   */\r\n  summarizedRequest?: SummarizedToolRequest;\r\n  /**\r\n   * Summarized tool response message\r\n   */\r\n  summarizedResult: SummarizedToolResponse;\r\n  /**\r\n   * Optional cached summary key for reference\r\n   */\r\n  tools: Array<ChatToolType>;\r\n  /**\r\n   * Stores the original tool call for search / retrieval\r\n   */\r\n  toolCalls: Array<ChatToolCallsType>;\r\n  /**\r\n   * The chat tool call ID from the database record\r\n   */\r\n  chatToolCallId?: string;\r\n  /**\r\n   * The chat tool ID from the tool map\r\n   */\r\n  chatToolId?: string;\r\n}\r\n\r\n/**\r\n * Enterprise-grade message optimization that preserves conversation integrity\r\n * while intelligently summarizing completed tool call sequences.\r\n *\r\n * Algorithm:\r\n * 1. Preserve the last two user interactions (loss-free current context)\r\n * 2. Work backwards through message history, grouping tool calls by ID\r\n * 3. Replace completed tool sequences with AI-generated summaries\r\n * 4. Maintain conversation flow and prevent recall loops\r\n */\r\n// Overloads preserve legacy inference when caller passes UIMessage[]\r\nexport async function optimizeMessagesWithToolSummarization(\r\n  messages: UIMessage[],\r\n  model: string,\r\n  userId?: string,\r\n  chatHistoryId?: string,\r\n): Promise<UIMessage[]>;\r\nexport async function optimizeMessagesWithToolSummarization(\r\n  messages: LanguageModelV2Message[],\r\n  model: string,\r\n  userId?: string,\r\n  chatHistoryId?: string,\r\n): Promise<LanguageModelV2Message[]>;\r\nexport async function optimizeMessagesWithToolSummarization(\r\n  messages: UIMessage[] | LanguageModelV2Message[],\r\n  model: string,\r\n  userId?: string,\r\n  chatHistoryId?: string,\r\n): Promise<UIMessage[] | LanguageModelV2Message[]> {\r\n  const msgs = messages as OptimizerMessage[];\r\n  const startTime = Date.now();\r\n\r\n  // Calculate original context size for meaningful metrics\r\n  const originalCharacterCount = calculateMessageCharacterCount(msgs);\r\n\r\n  // Record original message count for OpenTelemetry\r\n  originalMessageCountHistogram.record(messages.length, {\r\n    model,\r\n    user_id: userId ? hashUserId(userId) : 'anonymous',\r\n  });\r\n\r\n  log((l) =>\r\n    l.verbose('Starting enterprise tool message optimization', {\r\n      originalMessageCount: messages.length,\r\n      originalCharacterCount,\r\n      model,\r\n      userId,\r\n    }),\r\n  );\r\n\r\n  // Step 1: Find cutoff point - preserve last two user interactions\r\n  const { cutoffIndex, preservedToolIds } = findUserInteractionCutoff(msgs);\r\n  if (cutoffIndex === 0) {\r\n    // No optimization needed - all messages are recent\r\n    log((l) => l.verbose('No optimization needed - all messages are recent'));\r\n\r\n    // Record metrics for no-op optimization\r\n    optimizationCounter.add(1, {\r\n      model,\r\n      user_id: userId ? hashUserId(userId) : 'anonymous',\r\n      optimization_type: 'no_optimization_needed',\r\n    });\r\n\r\n    optimizationDurationHistogram.record(Date.now() - startTime, {\r\n      model,\r\n      user_id: userId ? hashUserId(userId) : 'anonymous',\r\n      optimization_type: 'no_optimization_needed',\r\n    });\r\n\r\n    return messages;\r\n  }\r\n\r\n  const chatHistoryContext = createAgentHistoryContext({\r\n    model,\r\n    originatingUserId: userId ?? '-1',\r\n    operation: 'context.summarize',\r\n    metadata: {\r\n      targetChatId: chatHistoryId,\r\n      cutoffIndex,\r\n      preservedToolIds: Array.from(preservedToolIds),\r\n    },\r\n  });\r\n\r\n  try {\r\n    // Step 2: Process older messages for tool summarization\r\n    const { optimizedMessages, toolCallDict } =\r\n      await processOlderMessagesForSummarization(\r\n        msgs,\r\n        cutoffIndex,\r\n        preservedToolIds,\r\n      );\r\n\r\n    // Step 3: Generate AI summaries for all collected tool calls\r\n    await generateToolCallSummaries(toolCallDict, chatHistoryContext, msgs);\r\n    const processingTime = Date.now() - startTime;\r\n\r\n    // Calculate optimized context size for meaningful metrics\r\n    const optimizedCharacterCount =\r\n      calculateMessageCharacterCount(optimizedMessages);\r\n    const characterReduction = Math.round(\r\n      ((originalCharacterCount - optimizedCharacterCount) /\r\n        originalCharacterCount) *\r\n        100,\r\n    );\r\n\r\n    const messageReduction = Math.round(\r\n      ((messages.length - optimizedMessages.length) / messages.length) * 100,\r\n    );\r\n\r\n    // Record comprehensive OpenTelemetry metrics\r\n    const attributes = {\r\n      model,\r\n      user_id: userId ? hashUserId(userId) : 'anonymous',\r\n      optimization_type: 'tool_summarization',\r\n    };\r\n\r\n    optimizationCounter.add(1, attributes);\r\n\r\n    optimizationDurationHistogram.record(processingTime, attributes);\r\n\r\n    optimizedMessageCountHistogram.record(optimizedMessages.length, attributes);\r\n\r\n    messageReductionHistogram.record(\r\n      (msgs.length - optimizedMessages.length) / msgs.length,\r\n      attributes,\r\n    );\r\n\r\n    characterReductionHistogram.record(\r\n      (originalCharacterCount - optimizedCharacterCount) /\r\n        originalCharacterCount,\r\n      attributes,\r\n    );\r\n\r\n    toolCallSummariesCounter.add(toolCallDict.size, attributes);\r\n\r\n    log((l) =>\r\n      l.info('Enterprise tool optimization completed', {\r\n        originalMessages: msgs.length,\r\n        optimizedMessages: optimizedMessages.length,\r\n        originalCharacterCount,\r\n        optimizedCharacterCount,\r\n        characterReduction: `${characterReduction}%`,\r\n        toolCallsProcessed: toolCallDict.size,\r\n        messageReduction: `${messageReduction}%`,\r\n        processingTimeMs: processingTime,\r\n        model,\r\n        userId,\r\n      }),\r\n    );\r\n    return optimizedMessages as unknown as\r\n      | UIMessage[]\r\n      | LanguageModelV2Message[];\r\n  } catch (error) {\r\n    chatHistoryContext.error = error;\r\n    throw LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: 'processOlderMessagesForSummarization',\r\n    });\r\n  } finally {\r\n    chatHistoryContext.dispose();\r\n  }\r\n}\r\n\r\n/**\r\n * Find the cutoff point by locating the last two user prompts\r\n * Returns the index where optimization should begin and IDs of tools to preserve\r\n */\r\nconst findUserInteractionCutoff = (\r\n  messages: OptimizerMessage[],\r\n): {\r\n  cutoffIndex: number;\r\n  preservedToolIds: Set<string>;\r\n} => {\r\n  const preservedToolIds = new Set<string>();\r\n  let userPromptCount = 0;\r\n  let cutoffIndex = messages.length;\r\n\r\n  // Work backwards from the end\r\n  for (let i = messages.length - 1; i >= 0; i--) {\r\n    const message = messages[i];\r\n\r\n    if (message.role === 'user') {\r\n      userPromptCount++;\r\n      if (userPromptCount >= 2) {\r\n        // Found our cutoff point - preserve everything from here forward\r\n        cutoffIndex = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Collect tool IDs in the preserved section\r\n    if (\r\n      message.role === 'assistant' &&\r\n      'toolInvocations' in message &&\r\n      Array.isArray(message.toolInvocations)\r\n    ) {\r\n      for (const invocation of message.toolInvocations) {\r\n        if (\r\n          'toolCallId' in invocation &&\r\n          typeof invocation.toolCallId === 'string'\r\n        ) {\r\n          preservedToolIds.add(invocation.toolCallId);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return { cutoffIndex, preservedToolIds };\r\n};\r\n\r\nexport const summarizeMessageRecord = async ({\r\n  tx,\r\n  chatId,\r\n  turnId,\r\n  messageId,\r\n  write = false,\r\n  deep = false,\r\n}: {\r\n  /**\r\n   * Dabase transactional context\r\n   */\r\n  tx?: DbTransactionType;\r\n  /**\r\n   * Chat ID to summarize\r\n   */\r\n  chatId: string;\r\n  /**\r\n   * Turn ID to summarize\r\n   */\r\n  turnId: number;\r\n  /**\r\n   * Message ID to summarize\r\n   */\r\n  messageId: number;\r\n  /**\r\n   * If true results are used to update the database record\r\n   */\r\n  write?: boolean;\r\n  /**\r\n   * If true, the full contents of historical messages will be considered for context;\r\n   * otherwise, the optimized output will be favored and used when present.\r\n   */\r\n  deep?: boolean;\r\n  /**\r\n   * Additional metadata to send to the model when summarizing.\r\n   */\r\n  metadata?: Record<string, AttributeValue>;\r\n}): Promise<{\r\n  /**\r\n   * An AI-optimized / summarized version of this message's content\r\n   */\r\n  optimizedContent: string;\r\n  /**\r\n   * The most appropriately descriptive title for the chat given current context\r\n   */\r\n  chatTitle: string;\r\n  /**\r\n   * When true it signals this is a different title than what was assigned before this message was processed\r\n   */\r\n  newTitle: boolean;\r\n}> => {\r\n  try {\r\n    const qp: ThisDbQueryProvider = (await (tx\r\n      ? Promise.resolve(tx)\r\n      : drizDbWithInit())) as unknown as ThisDbQueryProvider;\r\n\r\n    const isThisMessage = and(\r\n      eq(schema.chatMessages.chatId, chatId),\r\n      eq(schema.chatMessages.turnId, turnId),\r\n      eq(schema.chatMessages.messageId, messageId),\r\n    )!;\r\n    // First assemble previous message state\r\n    const prevMessages = await qp.query.chatMessages\r\n      .findMany({\r\n        where: and(eq(schema.chatMessages.chatId, chatId), not(isThisMessage)),\r\n        columns: {\r\n          content: deep === true,\r\n          optimizedContent: deep !== true,\r\n        },\r\n        orderBy: [schema.chatMessages.turnId, schema.chatMessages.messageId],\r\n      })\r\n      .execute()\r\n      .then((q) =>\r\n        q\r\n          .map(\r\n            deep\r\n              ? (m: object) => (m as { content: string }).content\r\n              : (m: object) =>\r\n                  (m as { optimizedContent: string }).optimizedContent,\r\n          )\r\n          .filter(\r\n            (content): content is string =>\r\n              typeof content === 'string' && content.trim().length > 0,\r\n          ),\r\n      );\r\n    // Then retrieve the target message\r\n    const thisMessage = await qp.query.chatMessages.findFirst({\r\n      where: isThisMessage,\r\n      columns: {\r\n        content: true,\r\n        optimizedContent: true,\r\n      },\r\n      with: {\r\n        chat: {\r\n          columns: {\r\n            title: true,\r\n          },\r\n        },\r\n      },\r\n    });\r\n    if (!thisMessage) {\r\n      throw new Error('Message not found');\r\n    }\r\n\r\n    // Validate that thisMessage.content is valid for prompt construction\r\n    if (!thisMessage.content || typeof thisMessage.content !== 'string') {\r\n      throw new Error('Message content is invalid or missing');\r\n    }\r\n\r\n    // Let the models work their magic...\r\n    const prompt = `You are an expert at summarizing message output for AI conversation context.\r\n\r\n  CONVERSATIONAL CONTEXT:\r\n  ${prevMessages.join('\\n----\\n')}\r\n\r\n  CURRENT MESSAGE:\r\n  ${JSON.stringify(thisMessage.content, null, 2)}\r\n\r\n  CURRENT CHAT TITLE:\r\n  ${thisMessage.chat.title || 'Untitled Chat'}\r\n\r\n  Create a short, concise summary that:\r\n  1. Maintains context for ongoing conversation flow\r\n  2. Extracts the key findings that might be relevant for future conversation\r\n  3. Notes any important patterns, insights, errors, or ommissions\r\n  4. Maintains high-fidelity context for ongoing conversation flow\r\n\r\n  Additionally,\r\n  5. Provide a short (4-5 word max) title that accurately describes the conversation as a whole - this will be used as the new Chat Title.\r\n\r\n  Keep the summary as short as possible while preserving essential meaning.`;\r\n\r\n    // Validate prompt is not empty and reasonable length\r\n    if (!prompt.trim() || prompt.length > 50000) {\r\n      throw new Error('Generated prompt is invalid (empty or too long)');\r\n    }\r\n\r\n    const model = aiModelFactory('lofi');\r\n    const summarized = (\r\n      await generateObject({\r\n        model,\r\n        prompt,\r\n        schema: z.object({\r\n          messageSummary: z.string(),\r\n          chatTitle: z.string(),\r\n        }),\r\n        temperature: 0.3,\r\n        experimental_telemetry: {\r\n          isEnabled: true,\r\n          functionId: 'completion-message-summarization',\r\n        },\r\n      })\r\n    ).object;\r\n    const ret = {\r\n      optimizedContent: summarized.messageSummary,\r\n      chatTitle: summarized.chatTitle,\r\n      newTitle: summarized.chatTitle !== thisMessage.chat.title,\r\n    };\r\n    if (write) {\r\n      (await drizDbWithInit())\r\n        // Update the specific chat message identified by (chatId, turnId, messageId)\r\n        .update(schema.chatMessages)\r\n        .set({ optimizedContent: ret.optimizedContent })\r\n        .where(isThisMessage)\r\n        .execute();\r\n\r\n      // Update chat title by chat id\r\n      await qp\r\n        .update(schema.chats)\r\n        .set({ title: ret.chatTitle })\r\n        .where(eq(schema.chats.id, chatId))\r\n        .execute();\r\n\r\n      /*\r\n    await qp\r\n      .update(schema.chatMessages)\r\n      .set({ optimizedContent: ret.optimizedContent })\r\n      .where(isThisMessage)\r\n      .execute();\r\n    */\r\n    }\r\n    return ret;\r\n  } catch (error) {\r\n    throw LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      source: 'tools-optimizer -  summarizeMessageRecord',\r\n      log: true,\r\n    });\r\n  }\r\n};\r\n\r\n// const requestSummaryFactory = ({\r\n//   responseSummary,\r\n//   toolRequest,\r\n// }: {\r\n//   responseSummary: SummarizedToolResponse;\r\n//   toolRequest: ToolRequestMessage;\r\n// }): SummarizedToolRequest => {\r\n//   const requestSummary = {\r\n//     state: toolRequest.state,\r\n//     type: toolRequest.type,\r\n//   } as Record<string, unknown>;\r\n//   const ignoreKeys = ['state', 'type', 'output', 'errorText'];\r\n//   for (const key of Object.keys(responseSummary).filter(\r\n//     (k) => !ignoreKeys.includes(k),\r\n//   )) {\r\n//     const value = responseSummary[key as keyof SummarizedToolResponse];\r\n//     if (value) {\r\n//       requestSummary[key] = value;\r\n//     }\r\n//   }\r\n//   return requestSummary as SummarizedToolRequest;\r\n// };\r\n\r\n/**\r\n * Process older messages (before cutoff) for tool summarization\r\n * Groups tool calls by ID and replaces them with summary placeholders\r\n */\r\nconst processOlderMessagesForSummarization = async (\r\n  messages: OptimizerMessage[],\r\n  cutoffIndex: number,\r\n  preservedToolIds: Set<string>,\r\n): Promise<{\r\n  optimizedMessages: OptimizerMessage[];\r\n  toolCallDict: Map<string, ToolCallRecord>;\r\n}> => {\r\n  const toolCallDict = new Map<string, ToolCallRecord>();\r\n  //const pendingToolIds = new Set<string>();\r\n  const optimizedMessages: OptimizerMessage[] = [\r\n    ...messages.slice(cutoffIndex),\r\n  ];\r\n  // Iterate through messages to build optimized output\r\n  for (let i = cutoffIndex - 1; i >= 0; i--) {\r\n    const message = messages[i];\r\n    const processedParts: GenericPart[] = [];\r\n\r\n    const getParts = readParts;\r\n    const setParts = writeParts;\r\n\r\n    let messageDirtyFlag = false;\r\n    // Ensure we only insert a single summary per toolCallId within this message\r\n    const summaryInsertedFor = new Set<string>();\r\n\r\n    // Process invocations backwards to maintain consistency with message processing\r\n    const messageParts = getParts(message);\r\n    for (let j = messageParts.length - 1; j >= 0; j--) {\r\n      const invocation = messageParts[j];\r\n      // If we are not a tool, or do not have an id, or have an id thats been bucketed as preserved\r\n      // then no additional processing is needed\r\n      if (\r\n        !isTool(invocation) ||\r\n        !invocation.toolCallId ||\r\n        preservedToolIds.has(invocation.toolCallId)\r\n      ) {\r\n        processedParts.unshift(invocation);\r\n        continue;\r\n      }\r\n      // First process records we've already seen a response for\r\n      if (toolCallDict.has(invocation.toolCallId)) {\r\n        const record = toolCallDict.get(invocation.toolCallId)!;\r\n        if (isInputToolState(invocation.state)) {\r\n          if (invocation.state === 'input-available') {\r\n            // Keep only a single summary in place of the request and capture request for summarization context\r\n            record.toolRequest.push({ ...invocation } as ToolRequestMessage);\r\n            if (!summaryInsertedFor.has(invocation.toolCallId)) {\r\n              processedParts.unshift(record.toolSummary);\r\n              summaryInsertedFor.add(invocation.toolCallId);\r\n              messageDirtyFlag = true;\r\n            }\r\n          } else {\r\n            // NO-OP: skip streaming message input when response present\r\n          }\r\n        } else if (isOutputToolState(invocation.state)) {\r\n          // Preserve the tool response (output-available/error) in the optimized message\r\n          processedParts.unshift(invocation);\r\n        } else {\r\n          log((l) =>\r\n            l.warn(\r\n              'Encountered existing tool invocation with unrecognized or missing state - preserving as-is',\r\n              { invocation },\r\n            ),\r\n          );\r\n          processedParts.unshift(invocation);\r\n        }\r\n      } else {\r\n        // Then process records we've never seen\r\n        if (isOutputToolState(invocation.state)) {\r\n          // If the first thing we see is a result then we want to create a new record\r\n          const record: ToolCallRecord = {\r\n            messageId: (message as LegacyMessageShape).id ?? `msg-${i}`,\r\n            toolResult: [{ ...invocation } as ToolResponseMesage],\r\n            toolRequest: [],\r\n            toolSummary: {\r\n              type: 'text',\r\n              text: '[TOOL SUMMARY LOADING...]',\r\n            },\r\n            summarizedResult: {\r\n              ...invocation,\r\n              preliminary: true,\r\n              input: '[SUMMARIZED - (input) See summary message]',\r\n              output: '[SUMMARIZED - (output) See summary message]',\r\n            } as SummarizedToolResponse,\r\n            tools: [],\r\n            toolCalls: [],\r\n          };\r\n          toolCallDict.set(invocation.toolCallId, record); // Replace this invocation with the summary message\r\n          // Preserve the actual output in the optimized message; we'll insert the summary in place of the request\r\n          processedParts.unshift(invocation);\r\n          messageDirtyFlag = true; // message changed because we'll later replace the request with summary and drop streaming\r\n        } else if (isInputToolState(invocation.state)) {\r\n          // If the first thing we see is a tool request, we want to preserve it\r\n          preservedToolIds.add(invocation.toolCallId);\r\n          processedParts.unshift(invocation);\r\n        } else {\r\n          log((l) =>\r\n            l.warn(\r\n              'Encountered new tool invocation with unrecognized or missing state - preserving as-is',\r\n              { invocation },\r\n            ),\r\n          );\r\n          processedParts.unshift(invocation);\r\n        }\r\n      }\r\n    }\r\n    if (messageDirtyFlag) {\r\n      optimizedMessages.unshift(setParts(message, processedParts));\r\n    } else {\r\n      optimizedMessages.unshift(message);\r\n    }\r\n  }\r\n  return { optimizedMessages, toolCallDict };\r\n};\r\n\r\n/**\r\n * Generate AI-powered summaries for all collected tool calls\r\n * Updates summary messages by reference\r\n */\r\nconst generateToolCallSummaries = async (\r\n  toolCallDict: Map<string, ToolCallRecord>,\r\n  chatHistoryContext: ChatHistoryContext,\r\n  allMessages?: OptimizerMessage[],\r\n): Promise<void> => {\r\n  if (toolCallDict.size === 0) {\r\n    return;\r\n  }\r\n\r\n  log((l) =>\r\n    l.debug(\r\n      `Generating AI summaries for ${toolCallDict.size} tool call sequences`,\r\n    ),\r\n  );\r\n\r\n  // Process all tool call summaries in parallel for efficiency\r\n  const summaryPromises = Array.from(toolCallDict.entries()).map(\r\n    async ([toolCallId, record]) => {\r\n      try {\r\n        // First, ensure tool records and chat_tool_calls are created\r\n        await createToolRecordsForToolCall(record, toolCallId);\r\n\r\n        const summary = await generateSingleToolCallSummary(\r\n          record,\r\n          chatHistoryContext,\r\n          allMessages,\r\n        );\r\n\r\n        // Update the summary message to include chat_tool_call_id\r\n        const summaryWithId = record.chatToolCallId\r\n          ? `${summary} [ID: ${record.chatToolCallId}]`\r\n          : summary;\r\n        record.toolSummary.text = summaryWithId;\r\n\r\n        log((l) =>\r\n          l.debug(`Generated summary for tool call ${toolCallId}`, {\r\n            originalLength: record.toolResult.reduce(\r\n              (acc, msg) => acc + JSON.stringify(msg).length,\r\n              0,\r\n            ),\r\n            summaryLength: summary.length,\r\n          }),\r\n        );\r\n      } catch (error) {\r\n        log((l) =>\r\n          l.error(`Failed to generate summary for tool call ${toolCallId}`, {\r\n            error,\r\n          }),\r\n        ); // Fallback to basic summary on error\r\n        const fallbackText = `[TOOL CALL COMPLETED] ID: ${toolCallId} - Summary generation failed, see logs for details.`;\r\n        const fallbackWithId = record.chatToolCallId\r\n          ? `${fallbackText} [ID: ${record.chatToolCallId}]`\r\n          : fallbackText;\r\n        record.toolSummary.text = fallbackWithId;\r\n      }\r\n    },\r\n  );\r\n\r\n  await Promise.all(summaryPromises);\r\n  log((l) =>\r\n    l.info(\r\n      `Completed AI summary generation for ${toolCallDict.size} tool sequences`,\r\n    ),\r\n  );\r\n};\r\n\r\n/**\r\n * Generate a single tool call summary using the lofi model (with caching)\r\n */\r\nconst generateSingleToolCallSummary = async (\r\n  record: ToolCallRecord,\r\n  chatHistoryContext: ChatHistoryContext,\r\n  allMessages?: OptimizerMessage[],\r\n): Promise<string> => {\r\n  // Generate cache key from the tool call sequence\r\n  const allToolMessages = [...record.toolRequest, ...record.toolResult];\r\n  const cacheKey = hashToolCallSequence(allToolMessages);\r\n  // Check cache first to avoid redundant LLM calls\r\n  const cachedSummary = toolSummaryCache.get(cacheKey);\r\n  if (cachedSummary) {\r\n    // Record cache hit metrics\r\n    cacheStats.hits++;\r\n    cacheHitsCounter.add(1, {\r\n      cache_type: 'tool_summary',\r\n    });\r\n\r\n    // Update gauge metrics\r\n    cacheManager.updateMetrics();\r\n\r\n    log((l) =>\r\n      l.debug('Using cached tool summary', {\r\n        cacheKey: cacheKey.substring(0, 8),\r\n      }),\r\n    );\r\n    return cachedSummary;\r\n  }\r\n\r\n  // Record cache miss metrics\r\n  cacheStats.misses++;\r\n  cacheMissesCounter.add(1, {\r\n    cache_type: 'tool_summary',\r\n  });\r\n\r\n  // Update gauge metrics\r\n  cacheManager.updateMetrics();\r\n\r\n  // Extract key information from tool requests and responses\r\n  const toolRequests = record.toolRequest.flatMap((msg) =>\r\n    'toolInvocations' in msg && Array.isArray(msg.toolInvocations)\r\n      ? msg.toolInvocations.map((inv) => ({\r\n          tool: 'toolName' in inv ? inv.toolName : 'unknown',\r\n          args: 'args' in inv ? inv.args : {},\r\n        }))\r\n      : [],\r\n  );\r\n\r\n  const toolResults = record.toolResult.flatMap((msg) =>\r\n    'toolInvocations' in msg && Array.isArray(msg.toolInvocations)\r\n      ? msg.toolInvocations.map((inv) => ({\r\n          result: 'result' in inv ? inv.result : 'No result',\r\n          tool: 'toolName' in inv ? inv.toolName : 'unknown',\r\n        }))\r\n      : [],\r\n  );\r\n\r\n  // Extract conversational context that explains WHY tools were called\r\n  const conversationalContext = extractConversationalContext(\r\n    record,\r\n    allMessages,\r\n  );\r\n\r\n  // Create summarization prompt with context\r\n  const prompt = `You are an expert at summarizing tool execution results for AI conversation context.\r\n\r\nCONVERSATIONAL CONTEXT:\r\n${conversationalContext}\r\n\r\nTOOL REQUESTS:\r\n${JSON.stringify(toolRequests, null, 2)}\r\n\r\nTOOL RESULTS:\r\n${JSON.stringify(\r\n  toolResults.map((r) => ({\r\n    tool: r.tool,\r\n    result:\r\n      typeof r.result === 'string' &&\r\n      /*r.result.length > 500\r\n         ? r.result.substring(0, 500) + '...[truncated]'\r\n        : */ r.result,\r\n  })),\r\n  null,\r\n  2,\r\n)}\r\n\r\nCreate a concise summary that:\r\n1. Identifies what tools were executed and why (based on the conversational context)\r\n2. Extracts the key findings that might be relevant for future conversation\r\n3. Notes any important patterns, insights, or errors\r\n4. Maintains context for ongoing conversation flow\r\n\r\nKeep the summary under 300 characters while preserving essential meaning.\r\nRespond with just the summary text, no additional formatting.`;\r\n\r\n  // Validate prompt is not empty and reasonable length\r\n  if (!prompt.trim() || prompt.length > 50000) {\r\n    throw new Error('Generated prompt is invalid (empty or too long)');\r\n  }\r\n\r\n  const startSummaryTime = Date.now();\r\n\r\n  try {\r\n    const lofiModel = aiModelFactory('lofi');\r\n    const result = await generateObject({\r\n      model: lofiModel,\r\n      prompt,\r\n      schema: z.object({\r\n        messageSummary: z.string(),\r\n        chatTitle: z.string(),\r\n      }),\r\n      temperature: 0.3,\r\n      experimental_telemetry: {\r\n        isEnabled: true,\r\n        functionId: 'completion-message-tool-summarization',\r\n      },\r\n    });\r\n    const summaryDuration = Date.now() - startSummaryTime;\r\n\r\n    // Record summary generation duration\r\n    summaryGenerationDurationHistogram.record(summaryDuration, {\r\n      model: 'lofi',\r\n      status: 'success',\r\n    });\r\n\r\n    const summary = result.object?.messageSummary;\r\n    if (summary) {\r\n      // Cache the result for future use\r\n      toolSummaryCache.set(cacheKey, summary);\r\n\r\n      log((l) =>\r\n        l.debug('Generated and cached new tool summary', {\r\n          cacheKey: cacheKey.substring(0, 8),\r\n          summaryLength: summary.length,\r\n          cacheSize: toolSummaryCache.size,\r\n          durationMs: summaryDuration,\r\n        }),\r\n      );\r\n    }\r\n    return summary;\r\n  } catch (error) {\r\n    const summaryDuration = Date.now() - startSummaryTime;\r\n\r\n    // Record error metrics\r\n    summaryGenerationDurationHistogram.record(summaryDuration, {\r\n      model: 'lofi',\r\n      status: 'error',\r\n    });\r\n\r\n    log((l) => l.error('Tool summarization failed', { error }));\r\n\r\n    // Fallback to basic summary\r\n    const toolNames = toolRequests.map((r) => r.tool).join(', ');\r\n    const fallbackSummary = `Tool execution completed: ${toolNames}. Data processed successfully.`;\r\n    // Cache fallback summary too to avoid retrying failures\r\n    toolSummaryCache.set(cacheKey, fallbackSummary);\r\n    return fallbackSummary;\r\n  }\r\n};\r\n\r\n/**\r\n * Extract relevant conversational context to explain why tools were called\r\n */\r\nconst extractConversationalContext = (\r\n  record: ToolCallRecord,\r\n  allMessages?: OptimizerMessage[],\r\n): string => {\r\n  if (!allMessages || allMessages.length === 0) {\r\n    return 'No conversational context available.';\r\n  }\r\n\r\n  const contextParts: string[] = [];\r\n\r\n  // Extract content from the assistant messages that contain tool requests\r\n  record.toolRequest.forEach((msg) => {\r\n    // Also check parts for AI SDK v5 structure\r\n    if ('parts' in msg && Array.isArray(msg.parts)) {\r\n      msg.parts.forEach((part) => {\r\n        if (\r\n          part.type === 'text' &&\r\n          typeof part.text === 'string' &&\r\n          part.text.trim()\r\n        ) {\r\n          contextParts.push(`Assistant reasoning: ${part.text.trim()}`);\r\n        }\r\n      });\r\n    }\r\n  });\r\n\r\n  // Look for the user message that likely prompted this tool sequence\r\n  // We'll search backwards from tool request messages to find recent user input\r\n  if (record.toolRequest.length > 0) {\r\n    const toolRequestIndex = allMessages.findIndex((msg) => {\r\n      const legacy = msg as LegacyMessageShape;\r\n      return legacy.id === record.messageId;\r\n    });\r\n\r\n    if (toolRequestIndex > 0) {\r\n      // Look for the most recent user message before this tool request\r\n      for (\r\n        let i = toolRequestIndex - 1;\r\n        i >= 0 && i >= toolRequestIndex - 5;\r\n        i--\r\n      ) {\r\n        const prevMessage = allMessages[i];\r\n        if (prevMessage.role === 'user') {\r\n          const prevContent = (\r\n            prevMessage as Partial<LegacyMessageShape> & { content?: unknown }\r\n          ).content;\r\n          const prevParts = hasLegacyParts(prevMessage)\r\n            ? prevMessage.parts\r\n            : Array.isArray(prevContent)\r\n              ? (prevContent as GenericPart[])\r\n              : [];\r\n          const userContent = prevParts\r\n            .filter((part: GenericPart) => part.type === 'text')\r\n            .map((part: GenericPart) => (part as { text?: string }).text ?? '')\r\n            .join(' ');\r\n          if (userContent.trim()) {\r\n            // Truncate user content to avoid bloating the prompt\r\n            const truncatedContent =\r\n              userContent.length > 200\r\n                ? userContent.substring(0, 200) + '...'\r\n                : userContent;\r\n            contextParts.unshift(`User request: ${truncatedContent.trim()}`);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return contextParts.length > 0\r\n    ? contextParts.join('\\n')\r\n    : 'No specific conversational context found.';\r\n};\r\n\r\n/**\r\n * Utility function to extract tool call IDs from a message\r\n */\r\n// Overloads for clearer typing in tests\r\nexport function extractToolCallIds(message: UIMessage): string[];\r\nexport function extractToolCallIds(message: OptimizerMessage): string[];\r\nexport function extractToolCallIds(message: unknown): string[] {\r\n  if (!message || typeof message !== 'object') return [];\r\n  const m = message as { role?: string; parts?: unknown };\r\n  if (m.role !== 'assistant' || !Array.isArray(m.parts)) return [];\r\n  return Array.from(\r\n    new Set<string>(\r\n      m.parts\r\n        .map((inv: unknown) =>\r\n          inv && typeof inv === 'object' && 'toolCallId' in inv\r\n            ? (inv as { toolCallId?: unknown }).toolCallId\r\n            : null,\r\n        )\r\n        .filter((id): id is string => typeof id === 'string' && id.length > 0),\r\n    ),\r\n  );\r\n}\r\n\r\n/**\r\n * Utility function to check if a message contains tool calls\r\n */\r\nexport function hasToolCalls(message: UIMessage): boolean;\r\nexport function hasToolCalls(message: OptimizerMessage): boolean;\r\nexport function hasToolCalls(message: unknown): boolean {\r\n  if (!message || typeof message !== 'object') return false;\r\n  const m = message as { role?: string; parts?: unknown };\r\n  if (m.role !== 'assistant' || !Array.isArray(m.parts)) return false;\r\n  return m.parts.some(\r\n    (p: unknown) =>\r\n      !!(\r\n        p &&\r\n        typeof p === 'object' &&\r\n        'toolCallId' in p &&\r\n        (p as { toolCallId?: unknown }).toolCallId\r\n      ),\r\n  );\r\n}\r\n\r\n/**\r\n * Calculate total character count for a message array\r\n * This gives a much better indication of actual context consumption than message count\r\n */\r\nconst calculateMessageCharacterCount = (\r\n  messages: OptimizerMessage[],\r\n): number => {\r\n  const promptMessages: LanguageModelV2Prompt = messages.map((msg) => {\r\n    if (msg.role === 'system') {\r\n      const systemContent = (\r\n        msg as Partial<LegacyMessageShape> & { content?: unknown }\r\n      ).content;\r\n      return {\r\n        role: 'system',\r\n        content: typeof systemContent === 'string' ? systemContent : '',\r\n      };\r\n    }\r\n    const parts = readParts(msg);\r\n    // Best-effort casting for token counting; SDK will only use structural fields for length calc\r\n    // Cast through unknown to satisfy prompt shape for token counting only.\r\n    return {\r\n      role: msg.role,\r\n      content: parts,\r\n    } as unknown as LanguageModelV2Message;\r\n  });\r\n  return countTokens({ prompt: promptMessages });\r\n};\r\n\r\n/**\r\n * Helper functions for OpenTelemetry integration and metrics export\r\n */\r\n\r\n/**\r\n * Export all message optimizer metrics for Prometheus or other observability backends\r\n * This can be called periodically or on-demand for metric collection\r\n */\r\nexport const exportMessageOptimizerMetrics = () => {\r\n  // Update gauge metrics to current values\r\n  cacheManager.updateMetrics();\r\n\r\n  return {\r\n    optimization_counters: {\r\n      total_optimizations: 'ai_message_optimization_total',\r\n      tool_summaries_generated: 'ai_tool_call_summaries_total',\r\n      cache_hits: 'ai_tool_summary_cache_hits_total',\r\n      cache_misses: 'ai_tool_summary_cache_misses_total',\r\n    },\r\n    histograms: {\r\n      message_reduction_ratio: 'ai_message_reduction_ratio',\r\n      character_reduction_ratio: 'ai_character_reduction_ratio',\r\n      optimization_duration: 'ai_optimization_duration_ms',\r\n      summary_generation_duration: 'ai_summary_generation_duration_ms',\r\n      original_message_count: 'ai_original_message_count',\r\n      optimized_message_count: 'ai_optimized_message_count',\r\n    },\r\n    gauges: {\r\n      cache_hit_rate: 'ai_tool_summary_cache_hit_rate',\r\n    },\r\n    cache_stats: cacheManager.getStats(),\r\n  };\r\n};\r\n\r\n/**\r\n * Start periodic metrics update for gauges that need regular updates\r\n * This ensures OpenTelemetry collectors get fresh gauge values\r\n */\r\nexport const startPeriodicMetricsUpdate = (intervalMs: number = 30000) => {\r\n  const updateInterval = setInterval(() => {\r\n    try {\r\n      cacheManager.updateMetrics();\r\n    } catch (error) {\r\n      log((l) => l.error('Failed to update periodic metrics', { error }));\r\n    }\r\n  }, intervalMs);\r\n\r\n  // Return cleanup function\r\n  return () => {\r\n    clearInterval(updateInterval);\r\n    log((l) =>\r\n      l.debug('Stopped periodic metrics updates for message optimizer'),\r\n    );\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\chat\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":33,"column":1,"nodeType":"Program","endLine":162,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Represents information about an error that may occur during a retryable operation.\r\n *\r\n * This type is a discriminated union that describes the state of an operation\r\n * with respect to errors and retry logic.\r\n *\r\n * - If `isError` is `false`, the input was not an error object and no retry or failure information is available.\r\n * - If `isError` is `true`, additional properties indicate whether a retry is possible,\r\n *   the error details, and the recommended retry delay.\r\n *\r\n * Variants:\r\n * - No error:\r\n *   - `isError: false`\r\n *   - `isRetry: never`\r\n *   - `error: never`\r\n *   - `retryAfter: never`\r\n * - Error with retry:\r\n *   - `isError: true`\r\n *   - `isRetry: true`\r\n *   - `error: APICallError`\r\n *   - `retryAfter: number` (milliseconds to wait before retrying)\r\n * - Error without retry:\r\n *   - `isError: true`\r\n *   - `isRetry: false`\r\n *   - `error: Error | APICallError`\r\n *   - `retryAfter: never`\r\n * - Generic error state (optional retry):\r\n *   - `isError: boolean`\r\n *   - `isRetry?: boolean`\r\n *   - `error?: APICallError | Error`\r\n *   - `retryAfter?: number`\r\n */\r\nimport { APICallError } from 'ai';\r\n\r\n/**\r\n * Chat Type System\r\n * -----------------\r\n * Central, reusable domain model for chat history (turns & messages) plus\r\n * a discriminated union helper for retry-capable error surfaces.\r\n *\r\n * Design Goals:\r\n * - Single source of truth for shape shared by server routes, client hooks, and tests.\r\n * - Narrow, explicit field types (no 'any').\r\n * - Preserve raw values delivered by persistence / providers (e.g. modelName, tool/function meta) to retain diagnostic fidelity.\r\n * - Be forward‑extensible: New optional fields should not break existing consumers.\r\n *\r\n * Conventions:\r\n * - Timestamps are ISO 8601 strings (UTC) to avoid Date serialization ambiguity over the wire.\r\n * - Nullable fields use `null` instead of `undefined` for easier JSON round‑trips and DB mapping symmetry.\r\n * - Arrays default to `null` (meaning \"not populated / unknown\") vs empty array (\"known empty\") unless we always materialize them.\r\n */\r\n\r\nexport type RetryErrorInfo =\r\n\t| {\r\n\t\t\t/** Operation produced no error. */\r\n\t\t\tisError: false;\r\n\t\t\tisRetry: never;\r\n\t\t\terror?: never;\r\n\t\t\tretryAfter?: never;\r\n\t\t}\r\n\t| {\r\n\t\t\t/** Generic branch (legacy / transitional) when caller pre-classifies. */\r\n\t\t\tisError: boolean;\r\n\t\t\tisRetry?: boolean;\r\n\t\t\terror?: APICallError | Error;\r\n\t\t\t/** Milliseconds until retry is recommended (if present). */\r\n\t\t\tretryAfter?: number;\r\n\t\t}\r\n\t| {\r\n\t\t\t/** Error and the platform indicates safe retry. */\r\n\t\t\tisError: true;\r\n\t\t\tisRetry: true;\r\n\t\t\terror: APICallError;\r\n\t\t\tretryAfter: number;\r\n\t\t}\r\n\t| {\r\n\t\t\t/** Error but retry is not advised (validation, fatal, etc.). */\r\n\t\t\tisError: true;\r\n\t\t\tisRetry: false;\r\n\t\t\terror?: Error | APICallError;\r\n\t\t\tretryAfter?: never;\r\n\t\t};\r\n\r\n\r\n    \r\n/**\r\n * A single atomic message within a chat turn. Represents user, assistant,\r\n * system, or tool/function output.\r\n */\r\nexport interface ChatMessage {\r\n\t/** Parent turn identifier (denormalized for convenience). */\r\n\tturnId: number;\r\n\t/** Stable primary id for the message (DB / persistence). */\r\n\tmessageId: number;\r\n\t/** Author role (e.g. 'user' | 'assistant' | 'system' | 'tool'). */\r\n\trole: string;\r\n\t/** Raw textual content (may be null for function/tool placeholder messages). */\r\n\tcontent: string | null;\r\n\t/** Position of the message within its turn (0-based or 1-based depending on ingest; treat as opaque ordering key). */\r\n\tmessageOrder: number;\r\n\t/** Tool name when role === 'tool' (nullable if not applicable). */\r\n\ttoolName?: string | null;\r\n\t/** Serialized function call payload (model dependent). */\r\n\tfunctionCall?: Record<string, unknown> | null;\r\n\t/** Tool execution result/return value. */\r\n\ttoolResult?: Record<string, unknown> | null;\r\n\t/** Status code id for message lifecycle (domain enum mapping). */\r\n\tstatusId: number;\r\n\t/** Upstream provider identifier (e.g. 'azure-openai', 'google'). */\r\n\tproviderId: string | null;\r\n\t/** Arbitrary structured metadata (token counts, annotations, etc.). */\r\n\tmetadata?: Record<string, unknown> | null;\r\n\t/** Tool instance correlation id linking to external invocation context. */\r\n\ttoolInstanceId: string | null;\r\n\t/** Optimized / condensed variant of content (summaries, embeddings pre-processed text). */\r\n\toptimizedContent: string | null;\r\n}\r\n\r\n\r\n/**\r\n * A logical unit of interaction consisting of one or more related messages\r\n * (e.g., user prompt + assistant response + tool calls). Turn boundaries often\r\n * align with a single full model invocation cycle.\r\n */\r\nexport interface ChatTurn {\r\n\t/** Sequential id within a chat (monotonic). */\r\n\tturnId: number;\r\n\t/** ISO timestamp when the turn started. */\r\n\tcreatedAt: string;\r\n\t/** ISO timestamp when the turn completed (null if in-progress). */\r\n\tcompletedAt: string | null;\r\n\t/** Model identifier (deployment or logical model). */\r\n\tmodelName: string | null;\r\n\t/** Messages exchanged within this turn (user prompt, assistant response, tool invocations). */\r\n\tmessages: ChatMessage[];\r\n\t/** Turn status enum id. */\r\n\tstatusId: number;\r\n\t/** Sampling temperature used (if applicable). */\r\n\ttemperature: number | null;\r\n\t/** Nucleus sampling top-p value (if applicable). */\r\n\ttopP: number | null;\r\n\t/** Full latency in milliseconds (request -> final token). */\r\n\tlatencyMs: number | null;\r\n\t/** Non-fatal issues surfaced during generation. */\r\n\twarnings: string[] | null;\r\n\t/** Fatal or blocking errors captured for diagnostics. */\r\n\terrors: string[] | null;\r\n\t/** Additional structured fields (token metrics, cost, provider raw). */\r\n\tmetadata: Record<string, unknown> | null;\r\n}\r\n\r\nexport interface ChatDetails {\r\n\t/** Unique chat identifier (UUID or ULID). */\r\n\tid: string;\r\n\t/** Human readable title (nullable until derived). */\r\n\ttitle: string | null;\r\n\t/** Chat creation timestamp (ISO). */\r\n\tcreatedAt: string;\r\n\t/** Ordered collection of turns. */\r\n\tturns: ChatTurn[];\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\client\\client-tools.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":91,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { UIDataTypes, UIMessage, UITools } from 'ai';\r\nimport { ValueOf } from 'next/dist/shared/lib/constants';\r\n\r\n/**\r\nTyped tool call that is returned by generateText and streamText.\r\nIt contains the tool call ID, the tool name, and the tool arguments.\r\n */\r\ninterface ToolCall<NAME extends string, INPUT> {\r\n  /**\r\n  ID of the tool call. This ID is used to match the tool call with the tool result.\r\n   */\r\n  toolCallId: string;\r\n  /**\r\n  Name of the tool that is being called.\r\n   */\r\n  toolName: NAME;\r\n  /**\r\n  Arguments of the tool call. This is a JSON-serializable object that matches the tool's input schema.\r\n     */\r\n  input: INPUT;\r\n  /**\r\n   * Whether the tool call will be executed by the provider.\r\n   * If this flag is not set or is false, the tool call will be executed by the client.\r\n   */\r\n  providerExecuted?: boolean;\r\n  /**\r\n   * Whether the tool is dynamic.\r\n   */\r\n  dynamic?: boolean;\r\n}\r\ntype InferUIMessageTools<T extends UIMessage> =\r\n  T extends UIMessage<unknown, UIDataTypes, infer TOOLS> ? TOOLS : UITools;\r\ntype InferUIMessageToolCall<UI_MESSAGE extends UIMessage> =\r\n  | ValueOf<{\r\n      [NAME in keyof InferUIMessageTools<UI_MESSAGE>]: ToolCall<\r\n        NAME & string,\r\n        InferUIMessageTools<UI_MESSAGE>[NAME] extends {\r\n          input: infer INPUT;\r\n        }\r\n          ? INPUT\r\n          : never\r\n      > & {\r\n        dynamic?: false;\r\n      };\r\n    }>\r\n  | (ToolCall<string, unknown> & {\r\n      dynamic: true;\r\n    });\r\n\r\nexport const openCaseFile = ({\r\n  caseId,\r\n  page,\r\n}: {\r\n  caseId: string;\r\n  page?: string;\r\n}) => {\r\n  const pagePart = page ? `/${page}` : '';\r\n  window.open(`/messages/email/${caseId}${pagePart}`, '_blank');\r\n};\r\n\r\nexport const onClientToolRequest = async ({\r\n  toolCall,\r\n  addToolResult,\r\n}: {\r\n  toolCall: InferUIMessageToolCall<UIMessage<unknown, UIDataTypes, UITools>>;\r\n  addToolResult: <TResult>(props: {\r\n    tool: string;\r\n    toolCallId: string;\r\n    output: TResult;\r\n  }) => void;\r\n}) => {\r\n  const { toolName } = toolCall;\r\n  switch (toolName) {\r\n    case 'askConfirmation':\r\n      // Handled by ConfirmationPrompt component\r\n      break;\r\n    case 'openCaseFile':\r\n      // TODO: Validate confirmation hash\r\n      openCaseFile(toolCall.input as { caseId: string; page?: string });\r\n      addToolResult({\r\n        tool: toolName,\r\n        toolCallId: toolCall.toolCallId,\r\n        output: { success: true, notes: 'Opened case file' },\r\n      });\r\n      break;\r\n    default:\r\n      // Not my tool\r\n      break;\r\n  }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\client\\confirmation.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":62,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { signData } from '@/lib/site-util/auth/user-keys';\r\n\r\n/**\r\n * Represents a user's response to a confirmation prompt.\r\n *\r\n * @property callId - The unique identifier for the call or confirmation session.\r\n * @property selectedOption - The option chosen by the user.\r\n * @property hash - A hash value for validation or integrity checking.\r\n */\r\nexport type UserResponse = {\r\n  /**\r\n   * Unique identifier for the call or confirmation session the option was selected in.\r\n   * This is used to track which confirmation prompt the response belongs to, and to\r\n   * ensure that the response is correctly associated with the right context.\r\n   * @type {string}\r\n   */\r\n  callId: string;\r\n  /**\r\n   * The option selected by the user in response to the confirmation prompt.\r\n   * This could be a string representing a choice like \"Yes\" or \"No\".\r\n   * @type {string}\r\n   */\r\n  choice: string;\r\n  /**\r\n   * A digital signature of the choice and call ID using the user's private key.\r\n   * This is used for validation purposes to ensure the integrity and authenticity of the response.\r\n   * @type {string}\r\n   */\r\n  hash: string;\r\n};\r\n\r\n/**\r\n * Generates a valid digital signature for a response made by the currently logged-in user.\r\n *\r\n * @param source - The source object containing the callId and selected choice to sign.\r\n * @returns A UserResponse object with a digital signature generated from the callId and selectedOption.\r\n */\r\nexport const signResponse = async (\r\n  source: Omit<UserResponse, 'hash'>,\r\n): Promise<UserResponse> => {\r\n  try {\r\n    // Create a message to sign that includes both callId and choice\r\n    const message = `${source.callId}:${source.choice}`;\r\n\r\n    // Sign the message using ECDSA\r\n    const hash = await signData(message);\r\n\r\n    return { ...source, hash };\r\n  } catch (error) {\r\n    LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: 'signResponse',\r\n    });\r\n    // Fallback to a basic hash if crypto fails (should not happen in secure contexts)\r\n    const fallbackHash = btoa(\r\n      `${source.callId}:${source.choice}:${Date.now()}`,\r\n    );\r\n    return { ...source, hash: fallbackHash };\r\n  }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\client\\hooks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\client\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\client\\initialization.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":56,"column":3,"nodeType":"Program","endLine":56,"endColumn":3}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/*\r\nimport { initializeUserKeys, getUserPublicKeyForServer } from './confirmation';\r\n*/\r\n/**\r\n * Initialize user cryptographic keys and register public key with server if needed\r\n * Call this on app startup or user login\r\n */\r\n/*\r\nexport const initializeUserSecurity = async (): Promise<void> => {\r\n  try {\r\n    // Ensure user has a key pair\r\n    await initializeUserKeys();\r\n    \r\n    // Get public key for server registration\r\n    const publicKey = await getUserPublicKeyForServer();\r\n    \r\n    if (publicKey) {\r\n      // TODO: Send public key to server to associate with user account\r\n      // This should be done via an API call to your backend\r\n      console.log('User public key ready for server registration:', publicKey.substring(0, 50) + '...');\r\n      \r\n      // Example API call (uncomment and modify for your backend):\r\n      /*\r\n      try {\r\n        await fetch('/api/user/register-public-key', {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n          },\r\n          body: JSON.stringify({ publicKey }),\r\n        });\r\n      } catch (error) {\r\n        console.error('Failed to register public key with server:', error);\r\n      }\r\n      * /\r\n    }\r\n  } catch (error) {\r\n    console.error('Failed to initialize user security:', error);\r\n  }\r\n};\r\n*/\r\n\r\n\r\n/**\r\n * Check if user's cryptographic setup is ready\r\n */\r\n/*\r\nexport const isUserSecurityInitialized = async (): Promise<boolean> => {\r\n  try {\r\n    const publicKey = await getUserPublicKeyForServer();\r\n    return publicKey !== null;\r\n  } catch {\r\n    return false;\r\n  }\r\n};\r\n*/","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\core\\chat-ids.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":149,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { log } from '@/lib/logger';\r\n\r\n/**\r\n * Creates a seeded pseudo-random number generator function using a linear congruential generator algorithm.\r\n *\r\n * @param seed - The initial seed value for the random number generator.\r\n * @returns A function that, when called, returns a pseudo-random number between 0 (inclusive) and 1 (exclusive).\r\n */\r\nconst seededRandom = (seed: number): (() => number) => {\r\n  return () => {\r\n    seed = (seed * 9301 + 49297) % 233280; // Linear congruential generator\r\n    return Math.abs(seed / 233280);\r\n  };\r\n};\r\n\r\n/**\r\n * This function generates a simple hash by iterating over each character in the string.\r\n * It uses a basic algorithm that shifts the hash value and adds the character's ASCII code.\r\n * This is not a cryptographic hash and should not be used for security purposes.\r\n * It is intended for generating a consistent hash value for a given string, such as for use in identifiers or keys.\r\n * @param str - The string to hash.\r\n * @returns The generated hash as a string.\r\n */\r\nexport const notCryptoSafeKeyHash = (str: string): string => {\r\n  let hash = 0;\r\n  for (let i = 0; i < str.length; i++) {\r\n    hash = (hash << 5) - hash + str.charCodeAt(i);\r\n    hash |= 0;\r\n  }\r\n  return hash.toString();\r\n};\r\n\r\n/**\r\n * Generates a chat ID using a simple seeded random function.\r\n * The generated ID is an 8-character string consisting of lowercase letters, digits, and special characters.\r\n * If a seed is provided, the same ID will be generated for the same seed.\r\n * This function is not cryptographically secure.\r\n *\r\n * @param seed - Optional. The seed value to initialize the random number generator. If not provided, a random seed is used.\r\n * @returns An object containing the seed used and the generated chat ID string.\r\n */\r\nexport const generateChatId = (\r\n  seed?: number | string,\r\n): { seed: number; id: string } => {\r\n  // Does not need to be cryptographically secure, so we can use a simple seeded random function\r\n  let actualSeed: number;\r\n  if (!seed) {\r\n    actualSeed = Math.floor(Math.random() * 1000000);\r\n  } else if (typeof seed === 'number') {\r\n    actualSeed = seed;\r\n  } else {\r\n    actualSeed = Number.parseInt(notCryptoSafeKeyHash(seed), 10);\r\n  }\r\n  const random = seededRandom(actualSeed);\r\n  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789!@$%~';\r\n  let id = '';\r\n  for (let i = 0; i < 8; i++) {\r\n    const cb = chars[Math.floor(random() * chars.length)];\r\n    if (cb === undefined) {\r\n      log((l) => l.error('Chat ID generation failed', { seed: actualSeed }));\r\n    }\r\n    id += cb ?? '';\r\n  }\r\n  return {\r\n    seed: actualSeed,\r\n    id,\r\n  };\r\n};\r\n\r\n/**\r\n * Splits a compound identifier into primary and secondary parts using the first colon (\":\") as a delimiter.\r\n *\r\n * The function is defensive and will never throw. It handles malformed inputs by returning empty or partial results,\r\n * and emits warnings for non-ideal cases. No trimming or normalization is performed on the input.\r\n *\r\n * Behavior summary:\r\n * - If `id` is falsy (e.g., empty string), returns [\"\", undefined].\r\n * - If no colon is found, returns [id, undefined].\r\n * - If the colon is the first or last character (e.g., \":foo\" or \"foo:\"), returns [\"\", undefined].\r\n * - Otherwise, returns [leftOfColon, rightOfColon].\r\n *\r\n * @param id - The identifier to split, typically in the form \"primary:secondary\".\r\n * @returns A tuple containing the primary segment and an optional secondary segment: [primary, secondary | undefined].\r\n *\r\n * @remarks\r\n * - Only the first colon is used as the split point; additional colons remain in the secondary segment.\r\n * - This function does not trim whitespace or validate segment content.\r\n * - Logs warnings for unexpected inputs and edge cases.\r\n *\r\n * @example\r\n * // Basic usage with both parts\r\n * const [chatId, messageId] = splitIds(\"chat123:msg456\");\r\n * // chatId === \"chat123\"\r\n * // messageId === \"msg456\"\r\n *\r\n * @example\r\n * // No secondary part present\r\n * const [chatId, messageId] = splitIds(\"chat123\");\r\n * // chatId === \"chat123\"\r\n * // messageId === undefined\r\n *\r\n * @example\r\n * // Empty or falsy input\r\n * const [chatId, messageId] = splitIds(\"\");\r\n * // chatId === \"\"\r\n * // messageId === undefined\r\n *\r\n * @example\r\n * // Invalid placement of delimiter\r\n * splitIds(\":msg\");   // [\"\", undefined]\r\n * splitIds(\"chat:\");  // [\"\", undefined]\r\n *\r\n * @example\r\n * // Only the first colon is used for splitting\r\n * const [primary, secondary] = splitIds(\"a:b:c:d\");\r\n * // primary === \"a\"\r\n * // secondary === \"b:c:d\"\r\n *\r\n * @example\r\n * // Safe destructuring with defaults and recomposition\r\n * const [primary, secondary] = splitIds(userInput ?? \"\");\r\n * const canonicalId = secondary ? `${primary}:${secondary}` : primary;\r\n *\r\n * @example\r\n * // Using with guards\r\n * const [entityId, subId] = splitIds(sourceId);\r\n * if (!subId) {\r\n *   // Handle entity-level operations\r\n * } else {\r\n *   // Handle sub-entity operations\r\n * }\r\n */\r\nexport const splitIds = (id: string): [string, string | undefined] => {\r\n  if (!id) {\r\n    log((l) => l.warn('No ID provided to splitIds, returning emtpy values.'));\r\n    return ['', undefined];\r\n  }\r\n  const splitIndex = id.indexOf(':');\r\n  if (splitIndex === -1) {\r\n    log((l) => l.warn('No \":\" found in ID, returning as is.'));\r\n    return [id, undefined];\r\n  }\r\n  if (splitIndex === 0 || splitIndex === id.length - 1) {\r\n    log((l) => l.warn('Invalid ID format, returning empty values.'));\r\n    return ['', undefined];\r\n  }\r\n  return [id.slice(0, splitIndex), id.slice(splitIndex + 1)];\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\core\\count-tokens.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":298,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { UIDataTypes, UIMessagePart, UITools } from 'ai';\r\nimport { promptTokensEstimate } from 'openai-chat-tokens';\r\nimport { LanguageModelV2Prompt } from '@ai-sdk/provider';\r\nimport {\r\n  ChatCompletionCreateParams,\r\n  ChatCompletionMessageParam,\r\n} from 'openai/resources/index.mjs';\r\n\r\n/**\r\n * Estimates the number of tokens in a given prompt for language model usage.\r\n *\r\n * This function processes the provided prompt, which can be either a `LanguageModelPrompt`\r\n * or an array of `CoreMessage` objects, and extracts relevant message content, tool calls,\r\n * and function information. It then constructs an input object suitable for token estimation\r\n * and returns the estimated token count using `promptTokensEstimate`.\r\n *\r\n * If an error occurs during token estimation, a fallback estimate is returned based on the\r\n * prompt's string length.\r\n *\r\n * @param params - An object containing:\r\n *   @param params.prompt - The prompt to estimate tokens for, either a `LanguageModelPrompt` or an array of `CoreMessage` objects.\r\n *   @param params.enableLogging - Optional. Whether to enable error logging. Defaults to `true`.\r\n * @returns The estimated number of tokens in the prompt.\r\n */\r\nexport const countTokens = ({\r\n  prompt,\r\n  enableLogging = true,\r\n}: {\r\n  prompt: LanguageModelV2Prompt | UIMessagePart<UIDataTypes, UITools>[];\r\n  enableLogging?: boolean;\r\n}): number => {\r\n  if (prompt.length === 0) {\r\n    return 0;\r\n  }\r\n  try {\r\n    // Normalize incoming prompt into OpenAI ChatCompletionMessageParam[]\r\n    const normalizeContentToParts = (\r\n      content: unknown,\r\n    ): {\r\n      [K in string]: K extends 'text' ? string : unknown;\r\n    }[] => {\r\n      if (!content) {\r\n        return [];\r\n      }\r\n      if (typeof content !== 'object') {\r\n        return [{ text: String(content) }];\r\n      }\r\n      if ('text' in content) {\r\n        return [\r\n          ...('content' in content\r\n            ? normalizeContentToParts(content.content)\r\n            : []),\r\n          {\r\n            ...content,\r\n            content: undefined,\r\n            text: String(content.text),\r\n          },\r\n        ];\r\n      }\r\n      if (Array.isArray(content)) {\r\n        return content.flatMap(normalizeContentToParts);\r\n      }\r\n      return [{ text: JSON.stringify(content) }];\r\n    };\r\n\r\n    const toChatCompletionMessages = (\r\n      src: unknown,\r\n    ): ChatCompletionMessageParam[] => {\r\n      const arr = Array.isArray(src)\r\n        ? (src as unknown[])\r\n        : src &&\r\n            typeof src === 'object' &&\r\n            'messages' in (src as Record<string, unknown>) &&\r\n            Array.isArray((src as Record<string, unknown>).messages)\r\n          ? ((src as Record<string, unknown>).messages as unknown[])\r\n          : [src];\r\n      return arr.map((msg) => {\r\n        // If message already has a role (LanguageModelV2Message-like)\r\n        if (\r\n          msg &&\r\n          typeof msg === 'object' &&\r\n          'role' in (msg as Record<string, unknown>)\r\n        ) {\r\n          const m = msg as Record<string, unknown>;\r\n          const rawRole = String(m['role'] ?? 'user');\r\n          const allowedRoles = [\r\n            'function',\r\n            'user',\r\n            'system',\r\n            'assistant',\r\n            'tool',\r\n            'developer',\r\n          ] as const;\r\n          const role = (\r\n            allowedRoles.some((r) => r === rawRole)\r\n              ? (rawRole as ChatCompletionMessageParam['role'])\r\n              : 'user'\r\n          ) as ChatCompletionMessageParam['role'];\r\n          const name = m['name'] ? String(m['name']) : '';\r\n          const rawContent =\r\n            'content' in m\r\n              ? m['content']\r\n              : 'text' in m\r\n                ? { text: m['text'] }\r\n                : undefined;\r\n          const parts = normalizeContentToParts(rawContent);\r\n          const contentText = parts.map((p) => p.text).join('\\n');\r\n          const outUnk: unknown = {\r\n            role,\r\n            content: contentText,\r\n            ...(name ? { name } : {}),\r\n          };\r\n          return outUnk as ChatCompletionMessageParam;\r\n        }\r\n\r\n        // Legacy/simple message with `.text`\r\n        if (\r\n          msg &&\r\n          typeof msg === 'object' &&\r\n          'text' in (msg as Record<string, unknown>)\r\n        ) {\r\n          const m = msg as Record<string, unknown>;\r\n          const parts = normalizeContentToParts(m['text']);\r\n          return {\r\n            role: 'user',\r\n            name: '',\r\n            content: parts.map((p) => p.text).join('\\n'),\r\n          } as ChatCompletionMessageParam;\r\n        }\r\n\r\n        // Fallback: treat item as a content blob\r\n        const parts = normalizeContentToParts(msg);\r\n        return {\r\n          role: 'user',\r\n          name: '',\r\n          content: parts.map((p) => p.text).join('\\n'),\r\n        } as ChatCompletionMessageParam;\r\n      });\r\n    };\r\n\r\n    // Normalize prompt source: it may be an array of messages or an object\r\n    // with { messages: [], functions: [] } (LanguageModelV2Prompt-like).\r\n    const isPromptObject = (p: unknown): p is Record<string, unknown> => {\r\n      return !!(\r\n        p &&\r\n        typeof p === 'object' &&\r\n        'messages' in (p as Record<string, unknown>)\r\n      );\r\n    };\r\n\r\n    const rawMessages =\r\n      isPromptObject(prompt) && Array.isArray(prompt.messages)\r\n        ? prompt.messages\r\n        : Array.isArray(prompt)\r\n          ? prompt\r\n          : [];\r\n    const rawFunctions =\r\n      isPromptObject(prompt) && Array.isArray(prompt.functions)\r\n        ? prompt.functions\r\n        : ([] as unknown[]);\r\n\r\n    const chatMessages = toChatCompletionMessages(rawMessages);\r\n\r\n    // Map raw function definitions (if any) into ChatCompletionCreateParams.Function[].\r\n    const functionsFromPrompt: ChatCompletionCreateParams.Function[] =\r\n      Array.isArray(rawFunctions)\r\n        ? rawFunctions.map((f) => {\r\n            const rec =\r\n              f && typeof f === 'object' ? (f as Record<string, unknown>) : {};\r\n            const name = rec['name'] ? String(rec['name']) : '';\r\n            const description = rec['description']\r\n              ? String(rec['description'])\r\n              : undefined;\r\n            // parameters may be a JSON schema object; keep as unknown and cast safely\r\n            const parameters =\r\n              'parameters' in rec ? (rec['parameters'] as unknown) : undefined;\r\n            const fnUnk: unknown = {\r\n              name,\r\n              ...(description ? { description } : {}),\r\n              ...(parameters ? { parameters } : {}),\r\n            };\r\n            return fnUnk as ChatCompletionCreateParams.Function;\r\n          })\r\n        : [];\r\n\r\n    // Helper: infer a minimal JSON-schema-like parameters object from runtime args\r\n    const inferParametersFromArgs = (args: unknown): unknown => {\r\n      if (args == null) return undefined;\r\n      if (Array.isArray(args)) {\r\n        return { type: 'array', items: {} };\r\n      }\r\n      if (typeof args === 'object') {\r\n        const obj = args as Record<string, unknown>;\r\n        const properties: Record<string, unknown> = {};\r\n        for (const [k, v] of Object.entries(obj)) {\r\n          const t = Array.isArray(v) ? 'array' : v === null ? 'null' : typeof v;\r\n          properties[k] = { type: t };\r\n        }\r\n        return { type: 'object', properties };\r\n      }\r\n      return { type: typeof args };\r\n    };\r\n\r\n    // Extract function definitions from any tool-call parts found in messages\r\n    const functionsFromToolCalls: ChatCompletionCreateParams.Function[] = [];\r\n    try {\r\n      const addIfUnique = (fn: ChatCompletionCreateParams.Function) => {\r\n        if (!fn || !fn.name) return;\r\n        const exists =\r\n          functionsFromPrompt.some((f) => f.name === fn.name) ||\r\n          functionsFromToolCalls.some((f) => f.name === fn.name);\r\n        if (!exists) functionsFromToolCalls.push(fn);\r\n      };\r\n\r\n      const scanForToolCalls = (msgs: unknown[]) => {\r\n        for (const m of msgs) {\r\n          if (!m || typeof m !== 'object') continue;\r\n          const rec = m as Record<string, unknown>;\r\n          const contents = rec['content'] ?? rec['text'] ?? undefined;\r\n          const parts = Array.isArray(contents) ? contents : [contents];\r\n          for (const p of parts) {\r\n            if (!p || typeof p !== 'object') continue;\r\n            const part = p as Record<string, unknown>;\r\n            if (part['type'] === 'tool-call') {\r\n              const toolName = part['toolName'] ?? part['tool'] ?? '';\r\n              const args = part['args'] ?? undefined;\r\n              const fn: unknown = {\r\n                name: String(toolName || part['toolCallId'] || ''),\r\n                description: `tool call: ${String(toolName ?? '')}`,\r\n                parameters: inferParametersFromArgs(args),\r\n              };\r\n              addIfUnique(fn as ChatCompletionCreateParams.Function);\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      if (Array.isArray(rawMessages)) {\r\n        scanForToolCalls(rawMessages as unknown[]);\r\n      }\r\n\r\n      // Also consider prompt-level tool_choice if present (OpenAI style)\r\n      if (\r\n        isPromptObject(prompt) &&\r\n        'tool_choice' in (prompt as Record<string, unknown>)\r\n      ) {\r\n        const tc = (prompt as Record<string, unknown>)['tool_choice'];\r\n        if (tc && typeof tc === 'object') {\r\n          const rec = tc as Record<string, unknown>;\r\n          // Named tool choice may have .function with name/description/parameters\r\n          if (\r\n            'function' in rec &&\r\n            rec['function'] &&\r\n            typeof rec['function'] === 'object'\r\n          ) {\r\n            const frec = rec['function'] as Record<string, unknown>;\r\n            const fn: unknown = {\r\n              name: frec['name'] ? String(frec['name']) : '',\r\n              description: frec['description']\r\n                ? String(frec['description'])\r\n                : undefined,\r\n              parameters: frec['parameters'] ?? undefined,\r\n            };\r\n            addIfUnique(fn as ChatCompletionCreateParams.Function);\r\n          }\r\n        }\r\n      }\r\n    } catch {\r\n      // best-effort; don't let extraction failures block token counting\r\n    }\r\n\r\n    const functions: ChatCompletionCreateParams.Function[] = [\r\n      // ...functionsFromPrompt,\r\n      // ...functionsFromToolCalls,\r\n    ];\r\n\r\n    // Determine function_call setting supported by the chat tokens estimator\r\n    const function_call: ChatCompletionCreateParams['function_call'] =\r\n      functions.length > 0 ? 'auto' : 'none';\r\n\r\n    return promptTokensEstimate({\r\n      messages: chatMessages,\r\n      functions,\r\n      function_call,\r\n    });\r\n  } catch (error) {\r\n    LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      source: 'tokenStatsMiddleware.transformParams',\r\n      log: enableLogging,\r\n    });\r\n    // Return a fallback estimate if token counting fails\r\n    const promptStr =\r\n      typeof prompt === 'string' ? prompt : JSON.stringify(prompt);\r\n    return Math.ceil(promptStr.length / 4);\r\n  }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\core\\extract-prompt.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":19,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[685,688],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[685,688],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\core\\generate-text-with-retry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\core\\guards.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":7,"column":1,"nodeType":"Program","endLine":109,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module ai/core/guards\r\n *\r\n * Provides type guard functions for validating annotated message types used in the AI core library.\r\n * Includes utilities to check if a value is an `AnnotatedMessageBase` or a specific `AnnotatedErrorMessage`.\r\n */\r\nimport { match, P } from 'ts-pattern';\r\nimport {\r\n  AnnotatedErrorMessage,\r\n  AnnotatedRetryMessage,\r\n  AnnotatedErrorMessageBase,\r\n} from './types';\r\nimport { AiModelType, AiModelTypeValues, AiLanguageModelType } from './unions';\r\n\r\n/**\r\n * Type guard to check if a given value is an `AnnotatedMessageBase`.\r\n *\r\n * @param message - The value to check.\r\n * @returns `true` if the value is an object with a string `type` property, otherwise `false`.\r\n */\r\nexport const isAnnotatedMessageBase = (\r\n  message: unknown,\r\n): message is AnnotatedErrorMessageBase => {\r\n  return (\r\n    typeof message === 'object' &&\r\n    message !== null &&\r\n    'type' in message &&\r\n    (message.type === 'data-error-notify-retry' ||\r\n      message.type === 'data-error-retry')\r\n  );\r\n};\r\n\r\n/**\r\n * Type guard to check if a given `AnnotatedMessageBase` is an `AnnotatedErrorMessage`.\r\n *\r\n * @param message - The `AnnotatedMessageBase` to check.\r\n * @returns `true` if the message's `type` is `'error'`, otherwise `false`.\r\n */\r\nexport const isAnnotatedErrorMessage = (\r\n  message: unknown,\r\n): message is AnnotatedErrorMessage => {\r\n  if (!isAnnotatedMessageBase(message)) {\r\n    return false;\r\n  }\r\n  return message.type === 'data-error-retry';\r\n};\r\n\r\n/**\r\n * Type guard that checks if the provided message is an `AnnotatedRetryMessage`.\r\n *\r\n * An `AnnotatedRetryMessage` is expected to have the following structure:\r\n * - `type`: must be the string `'error'`\r\n * - `hint`: must be the string `'notify:retry'`\r\n * - `message`: must be a string\r\n * - `data`: an object containing:\r\n *    - `model`: one of `'hifi'`, `'lofi'`, `'completions'`, or `'embedding'`\r\n *    - `retryAt`: a string matching the ISO 8601 date-time format\r\n *\r\n * @param message - The value to check.\r\n * @returns `true` if the message matches the `AnnotatedRetryMessage` structure, otherwise `false`.\r\n */\r\nexport const isAnnotatedRetryMessage = (\r\n  message: unknown,\r\n): message is AnnotatedRetryMessage =>\r\n  match(message)\r\n    .with(\r\n      {\r\n        type: 'data-error-notify-retry',\r\n        data: {\r\n          model: P.union(...AiModelTypeValues),\r\n          retryAt: P.string.regex(\r\n            /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})$/,\r\n          ),\r\n        },\r\n      },\r\n      () => true,\r\n    )\r\n    .otherwise(() => false);\r\n\r\n/**\r\n * Type guard to check if a given value is a valid `AiModelType`.\r\n *\r\n * @param value - The value to check.\r\n * @returns `true` if the value is a string and is included in `AiModelTypeValues`, otherwise `false`.\r\n */\r\nexport const isAiModelType = (value: unknown): value is AiModelType =>\r\n  typeof value === 'string' && AiModelTypeValues.includes(value as AiModelType);\r\n\r\n/**\r\n * Type guard that checks if a given value is an `AiModelType` excluding the embedding types.\r\n *\r\n * @param value - The value to check.\r\n * @returns `true` if the value is an `AiModelType` and not `'embedding'` or `'google-embedding'`; otherwise, `false`.\r\n *\r\n * @example\r\n * ```typescript\r\n * isAiLanguageModelType('hifi'); // true\r\n * isAiLanguageModelType('lofi'); // true\r\n * isAiLanguageModelType('gemini-pro'); // true\r\n * isAiLanguageModelType('embedding'); // false\r\n * isAiLanguageModelType('google-embedding'); // false\r\n * isAiLanguageModelType('other-model'); // false\r\n * ```\r\n */\r\nexport const isAiLanguageModelType = (\r\n  value: unknown,\r\n): value is AiLanguageModelType =>\r\n  isAiModelType(value) && value !== 'embedding' && value !== 'google-embedding';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\core\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\core\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":45,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AiModelType } from './unions';\r\n\r\nexport type { AiModelType, AiLanguageModelType } from './unions';\r\n\r\ntype ValueOf<\r\n  ObjectType,\r\n  ValueType extends keyof ObjectType = keyof ObjectType,\r\n> = ObjectType[ValueType];\r\ntype DataUIPart<\r\n  DATA_TYPES extends {\r\n    [x: string]: unknown;\r\n  },\r\n> = ValueOf<{\r\n  [NAME in keyof DATA_TYPES & string]: {\r\n    type: `data-${NAME}`;\r\n    id?: string;\r\n    data: DATA_TYPES[NAME];\r\n  };\r\n}>;\r\n\r\ntype AnnotatedErrorMessageType = {\r\n  'error-retry': { retryAfter: number; reason: string };\r\n  'error-notify-retry': { retryAt: string; model: AiModelType };\r\n};\r\n\r\nexport type AnnotatedErrorMessageBase = DataUIPart<AnnotatedErrorMessageType>;\r\nexport type AnnotatedErrorPart<TError extends keyof AnnotatedErrorMessageType> =\r\n  DataUIPart<Pick<AnnotatedErrorMessageType, TError>>;\r\n\r\n/**\r\n * Represents an annotated error message, extending the base annotated message.\r\n *\r\n * @property type - The fixed string literal 'error' indicating this is an error message.\r\n * @property data - An object containing details about the error.\r\n * @property data.reason - A string describing the reason for the error.\r\n * @property data.retryAfter - (Optional) The number of seconds to wait before retrying the operation.\r\n */\r\nexport type AnnotatedErrorMessage = AnnotatedErrorPart<'error-retry'>;\r\nexport type AnnotatedRetryMessage = AnnotatedErrorPart<'error-notify-retry'>;\r\n\r\nexport type AnnotatedMessage =\r\n  | AnnotatedErrorMessage\r\n  | AnnotatedRetryMessage\r\n  | AnnotatedErrorMessageBase;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\core\\unions.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":4,"column":1,"nodeType":"Program","endLine":61,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Array containing possible values for AiModelType.\r\n */\r\nexport const AiModelTypeValues = [\r\n  'lofi',\r\n  'hifi',\r\n  'google:lofi',\r\n  'google:hifi',\r\n  'completions',\r\n  'embedding',\r\n  'gemini-pro',\r\n  'gemini-flash',\r\n  'google-embedding',\r\n  'azure:lofi',\r\n  'azure:hifi',\r\n  'azure:completions',\r\n  'azure:embedding',\r\n  'google:completions',\r\n  'google:embedding',\r\n  'google:gemini-2.0-flash',\r\n] as const;\r\n\r\nexport const AiModelTypeValue_LoFi = AiModelTypeValues[0];\r\nexport const AiModelTypeValue_HiFi = AiModelTypeValues[1];\r\nexport const AiModelTypeValue_Google_LoFi = AiModelTypeValues[2];\r\nexport const AiModelTypeValue_Google_HiFi = AiModelTypeValues[3];\r\nexport const AiModelTypeValue_Completions = AiModelTypeValues[4];\r\nexport const AiModelTypeValue_Embedding = AiModelTypeValues[5];\r\nexport const AiModelTypeValue_GeminiPro = AiModelTypeValues[6];\r\nexport const AiModelTypeValue_GeminiFlash = AiModelTypeValues[7];\r\nexport const AiModelTypeValue_GoogleEmbedding = AiModelTypeValues[8];\r\nexport const AiModelTypeValue_Azure_LoFi = AiModelTypeValues[9];\r\nexport const AiModelTypeValue_Azure_HiFi = AiModelTypeValues[10];\r\nexport const AiModelTypeValue_Azure_Completions = AiModelTypeValues[11];\r\nexport const AiModelTypeValue_Azure_Embedding = AiModelTypeValues[12];\r\nexport const AiModelTypeValue_Google_Completions = AiModelTypeValues[13];\r\nexport const AiModelTypeValue_Google_Embedding = AiModelTypeValues[14];\r\nexport const AiModelTypeValue_Google_GeminiFlash_2dot0 = AiModelTypeValues[15];\r\n\r\n/**\r\n * Defines the type of AI model being used.\r\n * LoFi models are used for low-fidelity tasks, HiFi models for high-fidelity tasks,\r\n * Completions for generating text completions, and Embedding for generating embeddings.\r\n */\r\nexport type AiModelType = (typeof AiModelTypeValues)[number];\r\n\r\n/**\r\n * Represents all AI model types except for the embedding model types.\r\n *\r\n * This type is derived by excluding the embedding model types (`AiModelTypeValue_Embedding` and `AiModelTypeValue_GoogleEmbedding`)\r\n * from the set of all available AI model types (`AiModelType`).\r\n *\r\n * @see AiModelType\r\n * @see AiModelTypeValue_Embedding\r\n * @see AiModelTypeValue_GoogleEmbedding\r\n */\r\nexport type AiLanguageModelType = Exclude<\r\n  AiModelType,\r\n  typeof AiModelTypeValue_Embedding | typeof AiModelTypeValue_GoogleEmbedding\r\n>;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\guards.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\ai.sdk\\index.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\ai.sdk\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":15,"column":1,"nodeType":"Program","endLine":17,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module ai.sdk\r\n *\r\n * Re-exports core components of the AI SDK, including:\r\n * - JSON-RPC message utilities\r\n * - Tool result content types and helpers\r\n * - MCP Server-Sent Events (SSE) transport implementation\r\n *\r\n * TODO: Figure out how to set up local only exports\r\n *\r\n * @license Apache-2.0\r\n * @link {./LICENSE}\r\n *\r\n */\r\nexport * from './json-rpc-message';\r\nexport * from './mcp-sse-transport';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\ai.sdk\\json-rpc-message.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\ai.sdk\\mcp-sse-transport.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":3,"column":1,"nodeType":"Program","endLine":361,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Original source: https://github.com/vercel/ai/blob/ai%404.3.16/packages/ai/core/tool/mcp/mcp-sse-transport.ts\r\n\r\nimport {\r\n  EventSourceMessage,\r\n  EventSourceParserStream,\r\n} from '@ai-sdk/provider-utils';\r\nimport { MCPTransport, MCPClientError } from 'ai';\r\nimport { JSONRPCMessage, JSONRPCMessageSchema } from './json-rpc-message';\r\nimport { fetch } from '@/lib/nextjs-util/fetch';\r\nimport { log } from '@/lib/logger';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { isAbortError } from '@/lib/react-util/utility-methods';\r\n\r\nexport class SseMCPTransport implements MCPTransport {\r\n  /** The discovered endpoint URL for sending messages via POST */\r\n  protected endpoint?: URL;\r\n  /** AbortController for canceling ongoing requests */\r\n  protected abortController?: AbortController;\r\n  /** The initial SSE connection URL */\r\n  protected url: URL;\r\n  /** Current connection status */\r\n  protected connected = false;\r\n  /** SSE connection wrapper with close and optional destroy methods */\r\n  protected sseConnection?: {\r\n    close: () => Promise<void>;\r\n    /** Best-effort destroy: free underlying stream resources */\r\n    destroy?: () => Promise<void> | void;\r\n  };\r\n  /** HTTP headers to include in requests */\r\n  private headers?: Record<string, string>;\r\n  /**\r\n   * Callback invoked when the connection is closed.\r\n   * @event\r\n   */\r\n  private _onclose?: () => void;\r\n  get onclose(): (() => void) | undefined {\r\n    return this._onclose;\r\n  }\r\n  set onclose(handler: (() => void) | undefined) {\r\n    this._onclose = handler;\r\n  }\r\n\r\n  private _onerror?: (error: unknown) => void;\r\n  get onerror(): ((error: unknown) => void) | undefined {\r\n    return this._onerror;\r\n  }\r\n  set onerror(handler: ((error: unknown) => void) | undefined) {\r\n    this._onerror = handler;\r\n  }\r\n\r\n  private _onmessage?: (message: JSONRPCMessage) => void;\r\n  get onmessage(): ((message: JSONRPCMessage) => void) | undefined {\r\n    return this._onmessage;\r\n  }\r\n  set onmessage(handler: ((message: JSONRPCMessage) => void) | undefined) {\r\n    this._onmessage = handler;\r\n  }\r\n\r\n  constructor({\r\n    url,\r\n    headers,\r\n  }: {\r\n    url: string;\r\n    headers?: Record<string, string>;\r\n  }) {\r\n    this.url = new URL(url);\r\n    this.headers = headers;\r\n  }\r\n\r\n  async start(): Promise<void> {\r\n    return new Promise<void>((resolve, reject) => {\r\n      if (this.connected) {\r\n        return resolve();\r\n      }\r\n\r\n      this.abortController = new AbortController();\r\n\r\n      const establishConnection = async () => {\r\n        let reader: ReadableStream<EventSourceMessage> | undefined;\r\n        try {\r\n          const response = await fetch(this.url.href, {\r\n            headers: await this.resolveHeaders(),\r\n            signal: this.abortController?.signal,\r\n          });\r\n\r\n          if (!response.ok || !response.body) {\r\n            const error = new MCPClientError({\r\n              message: `MCP SSE Transport Error: ${response.status} ${response.statusText}`,\r\n            });\r\n            LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n              log: true,\r\n              source: 'MCP SSE Transport::establishConnection',\r\n            });\r\n            this.onerror?.(error);\r\n            return reject(error);\r\n          }\r\n          // Connection established, now wait for 'endpoint' event\r\n          const stream = response.body\r\n            .pipeThrough(new TextDecoderStream())\r\n            .pipeThrough(new EventSourceParserStream());\r\n          // grab our reader and a typed alias for the stream so we can\r\n          // safely call optional methods like cancel() or destroy().\r\n          const reader = stream.getReader();\r\n          const maybeStream = stream as unknown as {\r\n            cancel?: (reason?: unknown) => Promise<void> | void;\r\n            destroy?: () => void;\r\n          };\r\n\r\n          // Helper to read an error code safely without using `any`.\r\n          const getErrorCode = (err: unknown): string | undefined => {\r\n            if (err && typeof err === 'object') {\r\n              const c = (err as { code?: unknown }).code;\r\n              return typeof c === 'string' ? c : undefined;\r\n            }\r\n            return undefined;\r\n          };\r\n\r\n          // Serialized, idempotent destroy to avoid concurrent cancel() races\r\n          let destroyingPromise: Promise<void> | undefined;\r\n          const doDestroy = async (): Promise<void> => {\r\n            if (destroyingPromise) return destroyingPromise;\r\n            destroyingPromise = (async () => {\r\n              try {\r\n                // cancel the reader if present\r\n                try {\r\n                  await reader.cancel('Connection destroyed');\r\n                  log((l) => l.verbose('SSE reader cancelled by destroy'));\r\n                } catch (e) {\r\n                  // Ignore known race condition in Node's webstreams where cancel\r\n                  // may throw ERR_INVALID_STATE when the stream is locked.\r\n                  if (\r\n                    !isAbortError(e) &&\r\n                    getErrorCode(e) !== 'ERR_INVALID_STATE'\r\n                  ) {\r\n                    LoggedError.isTurtlesAllTheWayDownBaby(e, {\r\n                      message: 'Error cancelling SSE reader during destroy',\r\n                      log: true,\r\n                      source: 'MCP SSE Transport::doDestroy',\r\n                    });\r\n                  }\r\n                }\r\n\r\n                // Prefer node-style destroy when available, fallback to cancel()\r\n                try {\r\n                  if (typeof maybeStream.destroy === 'function') {\r\n                    maybeStream.destroy();\r\n                    log((l) =>\r\n                      l.verbose('Underlying SSE stream destroyed by destroy()'),\r\n                    );\r\n                  } else if (maybeStream.cancel) {\r\n                    await maybeStream.cancel('Connection destroyed');\r\n                    log((l) =>\r\n                      l.verbose('Underlying SSE stream cancelled by destroy()'),\r\n                    );\r\n                  }\r\n                } catch (e) {\r\n                  if (\r\n                    !isAbortError(e) &&\r\n                    getErrorCode(e) !== 'ERR_INVALID_STATE'\r\n                  ) {\r\n                    LoggedError.isTurtlesAllTheWayDownBaby(e, {\r\n                      message:\r\n                        'Error destroying/cancelling underlying stream during destroy',\r\n                      log: true,\r\n                      source: 'MCP SSE Transport::doDestroy',\r\n                    });\r\n                  }\r\n                }\r\n              } finally {\r\n                this.connected = false;\r\n              }\r\n            })();\r\n            return destroyingPromise;\r\n          };\r\n\r\n          this.sseConnection = {\r\n            close: async () => {\r\n              try {\r\n                await doDestroy();\r\n              } catch (e) {\r\n                LoggedError.isTurtlesAllTheWayDownBaby(e, {\r\n                  message: 'Error closing SSE connection',\r\n                  log: true,\r\n                  severity: 'warn',\r\n                  source: 'MCP SSE Transport::sseConnection.close',\r\n                });\r\n              }\r\n            },\r\n            destroy: doDestroy,\r\n          };\r\n          const processEvents = async () => {\r\n            try {\r\n              let lastMessage: EventSourceMessage | undefined;\r\n              while (true) {\r\n                const { done, value } = await reader.read();\r\n                lastMessage = value;\r\n                if (done) {\r\n                  if (this.connected) {\r\n                    this.connected = false;\r\n                    log((l) =>\r\n                      l.warn(\r\n                        'SSE connection closed unexpectedly; last message: ',\r\n                        JSON.stringify(lastMessage),\r\n                      ),\r\n                    );\r\n                  }\r\n                  return;\r\n                }\r\n\r\n                const { event, data } = value;\r\n\r\n                if (event === 'endpoint') {\r\n                  this.endpoint = new URL(data, this.url);\r\n\r\n                  if (this.endpoint.origin !== this.url.origin) {\r\n                    throw new MCPClientError({\r\n                      message: `MCP SSE Transport Error: Endpoint origin does not match connection origin: ${this.endpoint.origin}`,\r\n                    });\r\n                  }\r\n\r\n                  this.connected = true;\r\n                  resolve();\r\n                } else if (event === 'message') {\r\n                  try {\r\n                    const message = JSONRPCMessageSchema.parse(\r\n                      JSON.parse(data),\r\n                    );\r\n                    this.onmessage?.(message);\r\n                  } catch (error) {\r\n                    const e = new MCPClientError({\r\n                      message:\r\n                        'MCP SSE Transport Error: Failed to parse message',\r\n                      cause: error,\r\n                    });\r\n                    this.onerror?.(e);\r\n                    // We do not throw here so we continue processing events after reporting the error\r\n                    resolve();\r\n                  }\r\n                }\r\n              }\r\n            } catch (error) {\r\n              if (error instanceof Error && error.name === 'AbortError') {\r\n                resolve();\r\n                return;\r\n              }\r\n              LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n                message: `MCP SSE Transport: Connection error - ${LoggedError.buildMessage(error)}`,\r\n                log: true,\r\n                source: 'MCP SSE Transport::processEvents',\r\n              });\r\n              this.onerror?.(error);\r\n              reject(error);\r\n            }\r\n          };\r\n\r\n          await processEvents();\r\n        } catch (error) {\r\n          if (isAbortError(error)) {\r\n            // no-op\r\n            this.sseConnection?.close();\r\n            resolve();\r\n            return;\r\n          }\r\n          LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n            message: `MCP SSE Transport: Connection error - ${LoggedError.buildMessage(error)}`,\r\n            log: true,\r\n            source: 'MCP SSE Transport::establishConnection',\r\n          });\r\n          this.sseConnection?.close();\r\n          (reader?.cancel(error) ?? Promise.resolve()).catch((e) => {\r\n            log((l) =>\r\n              l.verbose('Error cancelling reader after connection failure', e),\r\n            );\r\n          });\r\n          this.onerror?.(error);\r\n          reject(error);\r\n        }\r\n      };\r\n\r\n      establishConnection();\r\n    });\r\n  }\r\n\r\n  protected async resolveHeaders(): Promise<Headers> {\r\n    const headers = new Headers(this.headers);\r\n    headers.set('Accept', 'text/event-stream');\r\n    return headers;\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    this.connected = false;\r\n    const connection = this.sseConnection\r\n      ?.close()\r\n      .catch((e) => {\r\n        LoggedError.isTurtlesAllTheWayDownBaby(e, {\r\n          message: 'Error closing SSE connection',\r\n          log: true,\r\n          severity: 'warn',\r\n          source: 'MCP SSE Transport::close',\r\n        });\r\n      })\r\n      .finally(() => {\r\n        this.sseConnection = undefined;\r\n      });\r\n    this.abortController?.abort();\r\n    await connection;\r\n    this.onclose?.();\r\n  }\r\n\r\n  async send(message: JSONRPCMessage): Promise<void> {\r\n    if (!this.endpoint || !this.connected) {\r\n      throw new MCPClientError({\r\n        message: 'MCP SSE Transport Error: Not connected',\r\n      });\r\n    }\r\n\r\n    try {\r\n      const headers = await this.resolveHeaders();\r\n      headers.set('Content-Type', 'application/json');\r\n      const init = {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify(message),\r\n        signal: this.abortController?.signal,\r\n      };\r\n\r\n      const response = await fetch(this.endpoint, init);\r\n\r\n      if (!response.ok) {\r\n        const text = await response.text().catch(() => null);\r\n        const error = new MCPClientError({\r\n          message: `MCP SSE Transport Error: POSTing to endpoint (HTTP ${response.status}): ${text}`,\r\n        });\r\n        LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n          log: true,\r\n          data: {\r\n            status: response.status,\r\n            statusText: response.statusText,\r\n            body: text,\r\n            url: this.endpoint?.href,\r\n          },\r\n          source: 'MCP SSE Transport::send',\r\n        });\r\n        this.onerror?.(error);\r\n        return;\r\n      }\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        message: `MCP SSE Transport: Send error - ${LoggedError.buildMessage(error)}`,\r\n        log: true,\r\n        source: 'MCP SSE Transport::send',\r\n      });\r\n      this.onerror?.(error);\r\n      return;\r\n    }\r\n  }\r\n}\r\n\r\nexport const deserializeMessage = (line: string): JSONRPCMessage =>\r\n  JSONRPCMessageSchema.parse(JSON.parse(line));\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\ai.sdk\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":153,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { z } from 'zod';\r\n\r\nexport const LATEST_PROTOCOL_VERSION = '2024-11-05';\r\nexport const SUPPORTED_PROTOCOL_VERSIONS = [\r\n  LATEST_PROTOCOL_VERSION,\r\n  '2024-10-07',\r\n];\r\n\r\nconst ClientOrServerImplementationSchema = z\r\n  .object({\r\n    name: z.string(),\r\n    version: z.string(),\r\n  })\r\n  .passthrough();\r\nexport type Configuration = z.infer<typeof ClientOrServerImplementationSchema>;\r\n\r\nexport const BaseParamsSchema = z\r\n  .object({\r\n    _meta: z.optional(z.object({}).passthrough()),\r\n  })\r\n  .passthrough();\r\ntype BaseParams = z.infer<typeof BaseParamsSchema>;\r\nexport const ResultSchema = BaseParamsSchema;\r\n\r\nexport const RequestSchema = z.object({\r\n  method: z.string(),\r\n  params: z.optional(BaseParamsSchema),\r\n});\r\nexport type Request = z.infer<typeof RequestSchema>;\r\nexport type RequestOptions = {\r\n  signal?: AbortSignal;\r\n  timeout?: number;\r\n  maxTotalTimeout?: number;\r\n};\r\n\r\nexport type Notification = z.infer<typeof RequestSchema>;\r\n\r\nconst ServerCapabilitiesSchema = z\r\n  .object({\r\n    experimental: z.optional(z.object({}).passthrough()),\r\n    logging: z.optional(z.object({}).passthrough()),\r\n    prompts: z.optional(\r\n      z\r\n        .object({\r\n          listChanged: z.optional(z.boolean()),\r\n        })\r\n        .passthrough(),\r\n    ),\r\n    resources: z.optional(\r\n      z\r\n        .object({\r\n          subscribe: z.optional(z.boolean()),\r\n          listChanged: z.optional(z.boolean()),\r\n        })\r\n        .passthrough(),\r\n    ),\r\n    tools: z.optional(\r\n      z\r\n        .object({\r\n          listChanged: z.optional(z.boolean()),\r\n        })\r\n        .passthrough(),\r\n    ),\r\n  })\r\n  .passthrough();\r\nexport type ServerCapabilities = z.infer<typeof ServerCapabilitiesSchema>;\r\n\r\nexport const InitializeResultSchema = ResultSchema.extend({\r\n  protocolVersion: z.string(),\r\n  capabilities: ServerCapabilitiesSchema,\r\n  serverInfo: ClientOrServerImplementationSchema,\r\n  instructions: z.optional(z.string()),\r\n});\r\nexport type InitializeResult = z.infer<typeof InitializeResultSchema>;\r\n\r\nexport type PaginatedRequest = Request & {\r\n  params?: BaseParams & {\r\n    cursor?: string;\r\n  };\r\n};\r\n\r\nconst PaginatedResultSchema = ResultSchema.extend({\r\n  nextCursor: z.optional(z.string()),\r\n});\r\n\r\nconst ToolSchema = z\r\n  .object({\r\n    name: z.string(),\r\n    description: z.optional(z.string()),\r\n    inputSchema: z\r\n      .object({\r\n        type: z.literal('object'),\r\n        properties: z.optional(z.object({}).passthrough()),\r\n      })\r\n      .passthrough(),\r\n  })\r\n  .passthrough();\r\nexport type MCPTool = z.infer<typeof ToolSchema>;\r\nexport const ListToolsResultSchema = PaginatedResultSchema.extend({\r\n  tools: z.array(ToolSchema),\r\n});\r\nexport type ListToolsResult = z.infer<typeof ListToolsResultSchema>;\r\n\r\nconst TextContentSchema = z\r\n  .object({\r\n    type: z.literal('text'),\r\n    text: z.string(),\r\n  })\r\n  .passthrough();\r\nconst ImageContentSchema = z\r\n  .object({\r\n    type: z.literal('image'),\r\n    data: z.string().base64(),\r\n    mimeType: z.string(),\r\n  })\r\n  .passthrough();\r\nconst ResourceContentsSchema = z\r\n  .object({\r\n    /**\r\n     * The URI of this resource.\r\n     */\r\n    uri: z.string(),\r\n    /**\r\n     * The MIME type of this resource, if known.\r\n     */\r\n    mimeType: z.optional(z.string()),\r\n  })\r\n  .passthrough();\r\nconst TextResourceContentsSchema = ResourceContentsSchema.extend({\r\n  text: z.string(),\r\n});\r\nconst BlobResourceContentsSchema = ResourceContentsSchema.extend({\r\n  blob: z.string().base64(),\r\n});\r\nconst EmbeddedResourceSchema = z\r\n  .object({\r\n    type: z.literal('resource'),\r\n    resource: z.union([TextResourceContentsSchema, BlobResourceContentsSchema]),\r\n  })\r\n  .passthrough();\r\n\r\nexport const CallToolResultSchema = ResultSchema.extend({\r\n  content: z.array(\r\n    z.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema]),\r\n  ),\r\n  isError: z.boolean().default(false).optional(),\r\n}).or(\r\n  ResultSchema.extend({\r\n    toolResult: z.unknown(),\r\n  }),\r\n);\r\nexport type CallToolResult = z.infer<typeof CallToolResultSchema>;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\cache\\index.d.ts","messages":[{"ruleId":"no-jsdoc-in-ts/prefer-function-declarations","severity":1,"message":"Prefer `export function name(...) : ...;` declarations in .d.ts files instead of `export const name: (...) => ...;`.","line":83,"column":22,"nodeType":"VariableDeclarator","endLine":88,"endColumn":2},{"ruleId":"no-jsdoc-in-ts/prefer-function-declarations","severity":1,"message":"Prefer `export function name(...) : ...;` declarations in .d.ts files instead of `export const name: (...) => ...;`.","line":90,"column":22,"nodeType":"VariableDeclarator","endLine":90,"endColumn":61}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Cache-related MCP utilities and implementations\r\n * @module cache\r\n */\r\n\r\nimport type { ToolSet } from 'ai';\r\nimport type {\r\n  ToolProviderFactoryOptions,\r\n  UserToolProviderCache,\r\n} from '../types';\r\n\r\n/**\r\n * Comprehensive MCP Tool Cache with Redis primary and memory fallback\r\n */\r\nexport declare class MCPToolCache {\r\n  constructor(\r\n    config?: Partial<{\r\n      defaultTtl: number;\r\n      maxMemoryEntries: number;\r\n      keyPrefix: string;\r\n    }>,\r\n  );\r\n  getCachedTools<TOOLS extends ToolSet = ToolSet>(\r\n    options: ToolProviderFactoryOptions,\r\n  ): Promise<TOOLS | null>;\r\n  setCachedTools(\r\n    options: ToolProviderFactoryOptions,\r\n    tools: ToolSet,\r\n    ttl?: number,\r\n  ): Promise<void>;\r\n  invalidateCache(options: ToolProviderFactoryOptions): Promise<void>;\r\n  clearAll(): Promise<void>;\r\n  getStats(): Promise<{\r\n    memorySize: number;\r\n    redisKeys: number;\r\n    hitRate?: number;\r\n  }>;\r\n  dispose(): Promise<void>;\r\n}\r\n\r\nexport declare function getToolCache(): MCPToolCache;\r\nexport declare function configureToolCache(\r\n  config: Partial<{\r\n    defaultTtl: number;\r\n    maxMemoryEntries: number;\r\n    keyPrefix: string;\r\n  }>,\r\n): MCPToolCache;\r\n\r\nexport declare function serializeWithSchema<T extends object>(data: T): string;\r\nexport declare function deserializeWithSchema<T extends object>(\r\n  json: string,\r\n): T;\r\nexport declare function serializeCacheEntry<TOOLS extends ToolSet>(entry: {\r\n  tools: TOOLS;\r\n  timestamp: number;\r\n  serverCapabilities?: string;\r\n}): string | undefined;\r\nexport declare function deserializedCacheEntry<TOOLS extends ToolSet = ToolSet>(\r\n  json: string,\r\n): (TOOLS & { timestamp?: number }) | undefined;\r\n\r\n/**\r\n * Cache administration utilities\r\n */\r\nexport declare class MCPToolCacheAdmin {\r\n  private static toolCache: MCPToolCache;\r\n  static showStats(): Promise<void>;\r\n  static clearCache(): Promise<void>;\r\n  static warmCache(\r\n    commonConfigs: Array<{ url: string; allowWrite?: boolean }>,\r\n  ): Promise<void>;\r\n  static healthCheck(): Promise<{\r\n    healthy: boolean;\r\n    details: {\r\n      memoryCache: boolean;\r\n      redisCache: boolean;\r\n      stats?: { memorySize: number; redisKeys: number; hitRate?: number };\r\n    };\r\n  }>;\r\n}\r\n\r\nexport declare const getCacheEnvConfig: () => {\r\n  MCP_CACHE_TTL: number;\r\n  MCP_CACHE_MAX_MEMORY: number;\r\n  MCP_CACHE_ENABLED: boolean;\r\n  MCP_CACHE_PREFIX: string;\r\n};\r\n\r\nexport declare const initializeMCPCache: () => Promise<void>;\r\nexport declare function getUserToolProviderCache(\r\n  config?: Partial<{\r\n    maxEntriesPerUser: number;\r\n    maxTotalEntries: number;\r\n    ttl: number;\r\n    cleanupInterval: number;\r\n  }>,\r\n): Promise<UserToolProviderCache>;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\cache\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":7,"column":1,"nodeType":"Program","endLine":26,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Cache-related MCP utilities and implementations\r\n * @module cache\r\n */\r\n\r\n// Re-export cache system\r\nexport {\r\n  MCPToolCache,\r\n  getToolCache,\r\n  configureToolCache,\r\n  serializeWithSchema,\r\n  deserializeWithSchema,\r\n  serializeCacheEntry,\r\n  deserializedCacheEntry,\r\n} from './tool-cache';\r\n\r\n// Re-export cache administration\r\nexport {\r\n  MCPToolCacheAdmin,\r\n  getCacheEnvConfig,\r\n  initializeMCPCache,\r\n} from './tool-cache-admin';\r\n\r\n// Re-export user tool provider cache\r\nexport { getUserToolProviderCache } from './user-tool-provider-cache';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\cache\\tool-cache-admin.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":9,"column":1,"nodeType":"Program","endLine":175,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview MCP Tool Cache Management Utilities\r\n * Provides administrative functions for monitoring and managing the MCP tool cache.\r\n *\r\n * @module tool-cache-admin\r\n * @version 1.0.0\r\n */\r\n\r\nimport { getToolCache } from './tool-cache';\r\nimport { log } from '@/lib/logger';\r\n\r\n/**\r\n * Cache administration utilities\r\n */\r\nexport class MCPToolCacheAdmin {\r\n  private static toolCache = getToolCache();\r\n\r\n  /**\r\n   * Displays comprehensive cache statistics\r\n   */\r\n  static async showStats(): Promise<void> {\r\n    try {\r\n      const stats = await this.toolCache.getStats();\r\n\r\n      log((l) =>\r\n        l.info('MCP Tool Cache Statistics:', {\r\n          memoryEntries: stats.memorySize,\r\n          redisKeys: stats.redisKeys,\r\n          hitRate: stats.hitRate\r\n            ? `${(stats.hitRate * 100).toFixed(1)}%`\r\n            : 'N/A',\r\n        }),\r\n      );\r\n    } catch (error) {\r\n      log((l) => l.error('Failed to retrieve cache statistics:', error));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clears all cached tools (use with caution)\r\n   */\r\n  static async clearCache(): Promise<void> {\r\n    try {\r\n      await this.toolCache.clearAll();\r\n      log((l) => l.info('All MCP tool caches cleared'));\r\n    } catch (error) {\r\n      log((l) => l.error('Failed to clear cache:', error));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Warm up cache by pre-loading tools for common configurations\r\n   * @param commonConfigs Array of frequently used MCP server configurations\r\n   */\r\n  static async warmCache(\r\n    commonConfigs: Array<{ url: string; allowWrite?: boolean }>,\r\n  ): Promise<void> {\r\n    log((l) =>\r\n      l.info(\r\n        `Warming MCP tool cache for ${commonConfigs.length} configurations...`,\r\n      ),\r\n    );\r\n\r\n    const { toolProviderFactory } = await import('../providers');\r\n\r\n    const warmupPromises = commonConfigs.map(async (config) => {\r\n      try {\r\n        const provider = await toolProviderFactory(config);\r\n        const tools = provider.tools;\r\n        await provider.dispose();\r\n\r\n        log((l) =>\r\n          l.debug(`Cache warmed for ${config.url}`, {\r\n            toolCount: Object.keys(tools).length,\r\n          }),\r\n        );\r\n      } catch (error) {\r\n        log((l) => l.warn(`Cache warmup failed for ${config.url}:`, error));\r\n      }\r\n    });\r\n\r\n    await Promise.allSettled(warmupPromises);\r\n    log((l) => l.info('MCP tool cache warmup completed'));\r\n  }\r\n\r\n  /**\r\n   * Health check for cache system\r\n   */\r\n  static async healthCheck(): Promise<{\r\n    healthy: boolean;\r\n    details: {\r\n      memoryCache: boolean;\r\n      redisCache: boolean;\r\n      stats?: {\r\n        memorySize: number;\r\n        redisKeys: number;\r\n        hitRate?: number;\r\n      };\r\n    };\r\n  }> {\r\n    const details = {\r\n      memoryCache: false,\r\n      redisCache: false,\r\n      stats: undefined as\r\n        | {\r\n            memorySize: number;\r\n            redisKeys: number;\r\n            hitRate?: number;\r\n          }\r\n        | undefined,\r\n    };\r\n\r\n    try {\r\n      // Test memory cache\r\n      details.memoryCache = true;\r\n\r\n      // Test Redis cache by getting stats\r\n      const stats = await this.toolCache.getStats();\r\n      details.redisCache = stats.redisKeys >= 0; // Redis accessible if we can get key count\r\n      details.stats = stats;\r\n\r\n      const healthy = details.memoryCache && details.redisCache;\r\n\r\n      return { healthy, details };\r\n    } catch (error) {\r\n      log((l) => l.error('Cache health check failed:', error));\r\n      return { healthy: false, details };\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Environment variable configuration for cache tuning\r\n */\r\nexport const getCacheEnvConfig = () => ({\r\n  MCP_CACHE_TTL: parseInt(process.env.MCP_CACHE_TTL || '86400'), // 24 hours default\r\n  MCP_CACHE_MAX_MEMORY: parseInt(process.env.MCP_CACHE_MAX_MEMORY || '100'), // 100 entries default\r\n  MCP_CACHE_ENABLED: process.env.MCP_CACHE_ENABLED !== 'false', // Enabled by default\r\n  MCP_CACHE_PREFIX: process.env.MCP_CACHE_PREFIX || 'mcp:tools',\r\n});\r\n\r\n/**\r\n * Middleware function to automatically warm cache on startup\r\n */\r\nexport const initializeMCPCache = async () => {\r\n  const config = getCacheEnvConfig();\r\n\r\n  if (!config.MCP_CACHE_ENABLED) {\r\n    log((l) => l.info('MCP tool caching disabled via environment variable'));\r\n    return;\r\n  }\r\n\r\n  try {\r\n    const healthCheck = await MCPToolCacheAdmin.healthCheck();\r\n\r\n    if (healthCheck.healthy) {\r\n      log((l) =>\r\n        l.info(\r\n          'MCP tool cache system initialized successfully',\r\n          healthCheck.details,\r\n        ),\r\n      );\r\n    } else {\r\n      log((l) =>\r\n        l.warn(\r\n          'MCP tool cache system partially unavailable',\r\n          healthCheck.details,\r\n        ),\r\n      );\r\n    }\r\n  } catch (error) {\r\n    log((l) => l.error('MCP tool cache initialization failed:', error));\r\n  }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\cache\\tool-cache.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":10,"column":1,"nodeType":"Program","endLine":661,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":493,"column":22,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":493,"endColumn":38,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":534,"column":24,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":534,"endColumn":40,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview MCP Tool Cache System\r\n * Provides efficient caching of MCP server tool definitions with Redis primary storage\r\n * and in-memory fallback for high-performance tool discovery.\r\n *\r\n * @module tool-cache\r\n * @version 1.0.0\r\n */\r\n\r\nimport { createHash } from 'crypto';\r\nimport { ToolSet } from 'ai';\r\nimport { getRedisClient } from '@/lib/ai/middleware/cacheWithRedis/redis-client';\r\nimport { log } from '@/lib/logger';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport type { ToolProviderFactoryOptions } from '../types';\r\nimport z from 'zod';\r\n\r\n/**\r\n * Cache entry structure for MCP tools\r\n */\r\ntype ToolCacheEntry = {\r\n  tools: ToolSet;\r\n  timestamp: number;\r\n  serverCapabilities?: string;\r\n};\r\n\r\ntype TypedToolCacheEntry<TOOLS extends ToolSet> = ToolCacheEntry & {\r\n  tools: TOOLS;\r\n};\r\n\r\ntype SchemaFieldEnvelope = {\r\n  __zerialize__schemaField: true;\r\n  serialized: string;\r\n};\r\n\r\n/**\r\n * Configuration for tool caching behavior\r\n */\r\ninterface ToolCacheConfig {\r\n  /** Default TTL in seconds (24 hours) */\r\n  defaultTtl: number;\r\n  /** Maximum in-memory cache size */\r\n  maxMemoryEntries: number;\r\n  /** Key prefix for Redis keys */\r\n  keyPrefix: string;\r\n}\r\n\r\nconst DEFAULT_CONFIG: ToolCacheConfig = {\r\n  defaultTtl: 24 * 60 * 60, // 24 hours\r\n  maxMemoryEntries: 100,\r\n  keyPrefix: 'mcp:tools',\r\n};\r\n\r\n/**\r\n * In-memory LRU cache for fastest access with TTL awareness\r\n */\r\nclass MemoryToolCache {\r\n  private cache = new Map<string, ToolCacheEntry>();\r\n  private accessOrder = new Map<string, number>();\r\n  private accessCounter = 0;\r\n  private ttlTimers = new Map<string, NodeJS.Timeout>();\r\n\r\n  constructor(\r\n    private maxSize: number,\r\n    private defaultTtl: number,\r\n  ) {}\r\n\r\n  get(key: string): ToolCacheEntry | null {\r\n    const entry = this.cache.get(key);\r\n    if (entry) {\r\n      this.accessOrder.set(key, ++this.accessCounter);\r\n      return entry;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  set(key: string, entry: ToolCacheEntry, ttl?: number): void {\r\n    // Evict oldest if at capacity\r\n    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {\r\n      const oldestKey = this.findOldestKey();\r\n      if (oldestKey) {\r\n        this.removeEntry(oldestKey);\r\n      }\r\n    }\r\n\r\n    // Clear existing timer if updating entry\r\n    this.clearTtlTimer(key);\r\n\r\n    this.cache.set(key, entry);\r\n    this.accessOrder.set(key, ++this.accessCounter);\r\n\r\n    // Set TTL timer for automatic expiration\r\n    const effectiveTtl = ttl || this.defaultTtl;\r\n    const timer = setTimeout(() => {\r\n      this.removeEntry(key);\r\n    }, effectiveTtl * 1000);\r\n\r\n    this.ttlTimers.set(key, timer);\r\n  }\r\n\r\n  private findOldestKey(): string | null {\r\n    let oldestKey: string | null = null;\r\n    let oldestAccess = Infinity;\r\n\r\n    for (const [key, access] of this.accessOrder) {\r\n      if (access < oldestAccess) {\r\n        oldestAccess = access;\r\n        oldestKey = key;\r\n      }\r\n    }\r\n\r\n    return oldestKey;\r\n  }\r\n\r\n  private removeEntry(key: string): void {\r\n    this.cache.delete(key);\r\n    this.accessOrder.delete(key);\r\n    this.clearTtlTimer(key);\r\n  }\r\n\r\n  private clearTtlTimer(key: string): void {\r\n    const timer = this.ttlTimers.get(key);\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n      this.ttlTimers.delete(key);\r\n    }\r\n  }\r\n\r\n  invalidateKey(key: string): void {\r\n    this.removeEntry(key);\r\n  }\r\n\r\n  clear(): void {\r\n    // Clear all timers first\r\n    for (const timer of this.ttlTimers.values()) {\r\n      clearTimeout(timer);\r\n    }\r\n\r\n    this.cache.clear();\r\n    this.accessOrder.clear();\r\n    this.ttlTimers.clear();\r\n    this.accessCounter = 0;\r\n  }\r\n\r\n  size(): number {\r\n    return this.cache.size;\r\n  }\r\n}\r\n\r\n/**\r\n * Comprehensive MCP Tool Cache with Redis primary and memory fallback\r\n */\r\nexport class MCPToolCache {\r\n  private memoryCache: MemoryToolCache;\r\n  private config: ToolCacheConfig;\r\n  private redisSubscriber?: Awaited<ReturnType<typeof getRedisClient>>;\r\n\r\n  constructor(config: Partial<ToolCacheConfig> = {}) {\r\n    this.config = { ...DEFAULT_CONFIG, ...config };\r\n    this.memoryCache = new MemoryToolCache(\r\n      this.config.maxMemoryEntries,\r\n      this.config.defaultTtl,\r\n    );\r\n    // Setup Redis subscription asynchronously (non-blocking)\r\n    this.setupRedisInvalidationSubscription().catch((error) => {\r\n      log((l) =>\r\n        l.warn('Failed to initialize Redis keyspace notifications:', error),\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a cache key from MCP server configuration\r\n   */\r\n  private createCacheKey(options: ToolProviderFactoryOptions): string {\r\n    // Sort headers for consistent hashing\r\n    const headersStr = options.headers\r\n      ? JSON.stringify(Object.entries(options.headers).sort())\r\n      : '';\r\n\r\n    const headersHash = createHash('sha256')\r\n      .update(headersStr)\r\n      .digest('hex')\r\n      .substring(0, 16);\r\n\r\n    // Create URL hash for shorter keys\r\n    const urlHash = createHash('sha256')\r\n      .update(options.url)\r\n      .digest('hex')\r\n      .substring(0, 16);\r\n\r\n    const accessLevel = options.allowWrite ? 'rw' : 'ro';\r\n\r\n    return `${this.config.keyPrefix}:${urlHash}:${headersHash}:${accessLevel}`;\r\n  }\r\n\r\n  /**\r\n   * Retrieves cached tools with multi-level fallback\r\n   */\r\n  async getCachedTools<TOOLS extends ToolSet = ToolSet>(\r\n    options: ToolProviderFactoryOptions,\r\n  ): Promise<TOOLS | null> {\r\n    const cacheKey = this.createCacheKey(options);\r\n\r\n    try {\r\n      // Level 1: Memory cache (fastest)\r\n      const memoryEntry = this.memoryCache.get(cacheKey);\r\n      if (memoryEntry && this.isEntryValid(memoryEntry)) {\r\n        log((l) => l.debug(`MCP tools cache hit (memory): ${cacheKey}`));\r\n        return memoryEntry.tools as TOOLS;\r\n      }\r\n\r\n      // Level 2: Redis cache\r\n      const redis = await getRedisClient();\r\n      const cachedData = await redis.get(cacheKey);\r\n\r\n      if (cachedData) {\r\n        try {\r\n          const entry = deserializedCacheEntry<TOOLS>(cachedData);\r\n          if (entry && this.isEntryValid(entry)) {\r\n            // Populate memory cache for next access with remaining TTL\r\n            const remainingTtl = Math.max(\r\n              0,\r\n              this.config.defaultTtl -\r\n                Math.floor((Date.now() - entry.timestamp) / 1000),\r\n            );\r\n            this.memoryCache.set(cacheKey, entry, remainingTtl);\r\n            log((l) => l.debug(`MCP tools cache hit (Redis): ${cacheKey}`));\r\n            return entry.tools;\r\n          }\r\n        } catch (parseError) {\r\n          log((l) =>\r\n            l.warn('Failed to parse cached MCP tools', {\r\n              cacheKey,\r\n              error: parseError,\r\n            }),\r\n          );\r\n        }\r\n      }\r\n\r\n      log((l) => l.debug(`MCP tools cache miss: ${cacheKey}`));\r\n      return null;\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'MCPToolCache.getCachedTools',\r\n        message: 'Failed to retrieve cached tools',\r\n        data: { cacheKey, options: { ...options, headers: '[REDACTED]' } },\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stores tools in cache with automatic expiration\r\n   */\r\n  async setCachedTools(\r\n    options: ToolProviderFactoryOptions,\r\n    tools: ToolSet,\r\n    ttl?: number,\r\n  ): Promise<void> {\r\n    const cacheKey = this.createCacheKey(options);\r\n    const entry: ToolCacheEntry = {\r\n      tools,\r\n      timestamp: Date.now(),\r\n      serverCapabilities: this.extractServerCapabilities(tools),\r\n    };\r\n\r\n    try {\r\n      const cacheTtl = ttl || this.config.defaultTtl;\r\n      // Store in memory cache with same TTL\r\n      this.memoryCache.set(cacheKey, entry, cacheTtl);\r\n      // Store in Redis with same TTL\r\n      const redis = await getRedisClient();\r\n      const serialized = serializeCacheEntry(entry);\r\n      if (!serialized) {\r\n        log((l) =>\r\n          l.warn(\r\n            `Failed to serialize MCP tools for storing in redis; will be available in memory cache only: ${cacheKey}`,\r\n          ),\r\n        );\r\n        return;\r\n      }\r\n      await redis.setEx(cacheKey, cacheTtl, serialized);\r\n      log((l) =>\r\n        l.debug(`MCP tools cached: ${cacheKey}`, {\r\n          toolCount: Object.keys(tools).length,\r\n          ttl: cacheTtl,\r\n        }),\r\n      );\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'MCPToolCache.setCachedTools',\r\n        message: 'Failed to cache tools',\r\n        data: { cacheKey, toolCount: Object.keys(tools).length },\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Invalidates cache for specific MCP server configuration\r\n   */\r\n  async invalidateCache(options: ToolProviderFactoryOptions): Promise<void> {\r\n    const cacheKey = this.createCacheKey(options);\r\n\r\n    try {\r\n      // Remove from memory\r\n      this.memoryCache.clear();\r\n\r\n      // Remove from Redis\r\n      const redis = await getRedisClient();\r\n      await redis.del(cacheKey);\r\n\r\n      log((l) => l.info(`MCP tools cache invalidated: ${cacheKey}`));\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'MCPToolCache.invalidateCache',\r\n        message: 'Failed to invalidate cache',\r\n        data: { cacheKey },\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clears all cached tools (useful for testing or memory management)\r\n   */\r\n  async clearAll(): Promise<void> {\r\n    try {\r\n      this.memoryCache.clear();\r\n\r\n      const redis = await getRedisClient();\r\n      const keys = await redis.keys(`${this.config.keyPrefix}:*`);\r\n\r\n      if (keys.length > 0) {\r\n        // Redis del command expects at least one key - batch delete for efficiency\r\n        await redis.del(keys);\r\n      }\r\n\r\n      log((l) =>\r\n        l.info('All MCP tools cache cleared', { clearedKeys: keys.length }),\r\n      );\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'MCPToolCache.clearAll',\r\n        message: 'Failed to clear all cache',\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets cache statistics for monitoring\r\n   */\r\n  async getStats(): Promise<{\r\n    memorySize: number;\r\n    redisKeys: number;\r\n    hitRate?: number;\r\n  }> {\r\n    try {\r\n      const redis = await getRedisClient();\r\n      const redisKeys = await redis.keys(`${this.config.keyPrefix}:*`);\r\n\r\n      return {\r\n        memorySize: this.memoryCache.size(),\r\n        redisKeys: redisKeys.length,\r\n      };\r\n    } catch {\r\n      return {\r\n        memorySize: this.memoryCache.size(),\r\n        redisKeys: 0,\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if cache entry is still valid\r\n   */\r\n  private isEntryValid(entry: ToolCacheEntry): boolean {\r\n    const age = Date.now() - entry.timestamp;\r\n    const maxAge = this.config.defaultTtl * 1000;\r\n    return age < maxAge;\r\n  }\r\n\r\n  /**\r\n   * Sets up Redis keyspace notification subscription for cache invalidation\r\n   */\r\n  private async setupRedisInvalidationSubscription(): Promise<void> {\r\n    try {\r\n      // Create separate Redis connection for pub/sub\r\n      this.redisSubscriber = await getRedisClient();\r\n\r\n      // Enable keyspace notifications for expired events\r\n      await this.redisSubscriber.configSet('notify-keyspace-events', 'Ex');\r\n\r\n      // Subscribe to expiration events for our cache keys\r\n      await this.redisSubscriber.pSubscribe(\r\n        `__keyevent@0__:expired`,\r\n        (message: string) => {\r\n          // Extract the expired key and check if it's one of ours\r\n          if (message && message.startsWith(this.config.keyPrefix)) {\r\n            log((l) =>\r\n              l.debug(\r\n                `Redis key expired, invalidating memory cache: ${message}`,\r\n              ),\r\n            );\r\n            this.memoryCache.invalidateKey(message);\r\n          }\r\n        },\r\n      );\r\n\r\n      log((l) =>\r\n        l.debug('Redis keyspace notifications enabled for MCP tool cache'),\r\n      );\r\n    } catch (error) {\r\n      // Non-critical failure - cache will still work without notifications\r\n      log((l) =>\r\n        l.warn(\r\n          'Failed to setup Redis keyspace notifications for cache invalidation',\r\n          error,\r\n        ),\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleanup method for proper resource disposal\r\n   */\r\n  async dispose(): Promise<void> {\r\n    try {\r\n      if (this.redisSubscriber) {\r\n        await this.redisSubscriber.pUnsubscribe();\r\n        await this.redisSubscriber.quit();\r\n      }\r\n      this.memoryCache.clear();\r\n    } catch (error) {\r\n      log((l) => l.warn('Error during cache disposal:', error));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extracts server capabilities fingerprint from tools\r\n   */\r\n  private extractServerCapabilities(tools: ToolSet): string {\r\n    const toolNames = Object.keys(tools).sort();\r\n    return createHash('md5')\r\n      .update(JSON.stringify(toolNames))\r\n      .digest('hex')\r\n      .substring(0, 8);\r\n  }\r\n}\r\n\r\n/**\r\n * Typeguard to check if a value is a Zod schema.\r\n * @param value The value to check\r\n * @return True if the value is a Zod schema, false otherwise\r\n * @example\r\n * ```typescript\r\n * if (isSchema(schema)) {\r\n *  // schema is typed as z.ZodTypeAny\r\n *  const shape = schema.shape; // Access object-specific properties\r\n * }\r\n */\r\nexport const isSchema = (value: unknown): value is z.ZodTypeAny =>\r\n  !!value && value instanceof z.ZodType;\r\n\r\nlet zodex:\r\n  | undefined\r\n  | {\r\n      zerialize: (schema: z.ZodTypeAny) => { type: unknown };\r\n      dezerialize: (data: unknown) => z.ZodTypeAny;\r\n    } = undefined;\r\n\r\n/**\r\n * Serializes an object, converting any Zod schemas to their serializable forms.\r\n * Adds metadata to indicate which fields were schemas for proper deserialization.\r\n * @example\r\n * ```typescript\r\n * const json = serializeWithSchema(data);\r\n * const original = deserializeWithSchema<typeof data>(json);\r\n * if (isSchema(original.schemaField)) {\r\n *   // original.schemaField is restored as a Zod schema\r\n * }\r\n * ```\r\n */\r\nexport const serializeWithSchema = <T extends object>(data: T): string => {\r\n  return JSON.stringify(data, (_key, value) => {\r\n    if (!isSchema(value)) {\r\n      return value;\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-require-imports\r\n    zodex = zodex ?? require('zodex').Zodex;\r\n    if (!zodex) {\r\n      throw new TypeError('Zodex module is required for schema serialization');\r\n    }\r\n    return {\r\n      __zerialize__schemaField: true,\r\n      serialized: zodex.zerialize(value),\r\n    };\r\n  });\r\n};\r\n\r\nconst isSerializedSchema = (value: unknown): value is SchemaFieldEnvelope =>\r\n  !!value &&\r\n  typeof value === 'object' &&\r\n  '__zerialize__schemaField' in value &&\r\n  value.__zerialize__schemaField === true &&\r\n  'serialized' in value &&\r\n  typeof value.serialized === 'string';\r\n\r\n/**\r\n * Deserializes a JSON string, restoring any Zod schemas to their original form.\r\n * @param json The JSON string to deserialize\r\n * @example\r\n * ```typescript\r\n * const json = serializeWithSchema(data);\r\n * const original = deserializeWithSchema<typeof data>(json);\r\n * if (isSchema(original.schemaField)) {\r\n *   // original.schemaField is restored as a Zod schema\r\n * }\r\n * ```\r\n * @returns The deserialized object with restored Zod schemas\r\n */\r\nexport const deserializeWithSchema = <T extends object>(json: string): T => {\r\n  return JSON.parse(json, (_key, value) => {\r\n    // If it's not a serialized schema handle normally\r\n    if (!isSerializedSchema(value)) {\r\n      return value;\r\n    }\r\n    // Otherwise parse and return the value of the serialized field\r\n    try {\r\n      // eslint-disable-next-line @typescript-eslint/no-require-imports\r\n      zodex = zodex ?? require('zodex').Zodex;\r\n      if (!zodex) {\r\n        throw new TypeError(\r\n          'Zodex module is required for schema serialization',\r\n        );\r\n      }\r\n      return zodex.dezerialize(value.serialized);\r\n    } catch (error) {\r\n      const le = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        critical: false,\r\n        source: 'MCPToolCache.deserializedCacheEntry',\r\n      });\r\n      log((l) =>\r\n        l.warn('Failed to parse cached MCP tools', {\r\n          error: le.toString(),\r\n          json,\r\n        }),\r\n      );\r\n      return value;\r\n    }\r\n  });\r\n};\r\n\r\nexport const serializeCacheEntry = <TOOLS extends ToolSet>(\r\n  entry: TypedToolCacheEntry<TOOLS>,\r\n): string | undefined => {\r\n  if (!entry || typeof entry !== 'object') {\r\n    return undefined;\r\n  }\r\n  return JSON.stringify(entry, (key, value) => {\r\n    // if this is not the tools property or if its an unexpected type, let default serialization handle it\r\n    // do its thing\r\n    if (key !== 'tools' || !value || typeof value !== 'object') {\r\n      return value;\r\n    }\r\n    // Serialize tools individually to handle inner schemas (and execute callback maybe?)\r\n    const serializedTools: Record<string, unknown> = {};\r\n    for (const [toolName, tool] of Object.entries(value as TOOLS)) {\r\n      serializedTools[toolName] = serializeWithSchema(tool);\r\n    }\r\n    return serializedTools;\r\n  });\r\n};\r\n\r\nexport const deserializedCacheEntry = <TOOLS extends ToolSet = ToolSet>(\r\n  json: string,\r\n): TypedToolCacheEntry<TOOLS> | undefined => {\r\n  // Handle unexpeced or explicit not values gracefully\r\n  if (\r\n    !json ||\r\n    typeof json !== 'string' ||\r\n    json === 'null' ||\r\n    json === 'undefined'\r\n  ) {\r\n    return undefined;\r\n  }\r\n  try {\r\n    return JSON.parse(json, (key, value) => {\r\n      // if this is not the tools property, let default deserialization handle it\r\n      if (key !== 'tools' || !value || typeof value !== 'object') {\r\n        return value;\r\n      }\r\n      // Deserialize tools individually to handle inner schemas\r\n      return Object.entries(value).reduce(\r\n        (\r\n          acc: Record<keyof TOOLS, TOOLS[keyof TOOLS]>,\r\n          [toolName, toolJson]: [string, unknown],\r\n        ) => {\r\n          if (!toolJson) {\r\n            return acc;\r\n          }\r\n          const tool: TOOLS[typeof toolName] = deserializeWithSchema<\r\n            TOOLS[typeof toolName]\r\n          >(typeof toolJson === 'string' ? toolJson : JSON.stringify(toolJson));\r\n          if (!tool) {\r\n            log((l) =>\r\n              l.warn('Unexpected null tool after deserialization', {\r\n                toolName,\r\n              }),\r\n            );\r\n          } else {\r\n            acc[toolName as keyof TOOLS] = tool;\r\n          }\r\n          return acc;\r\n        },\r\n        {} as TOOLS,\r\n      );\r\n    });\r\n  } catch (error) {\r\n    const le = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      critical: false,\r\n      source: 'MCPToolCache.deserializedCacheEntry',\r\n    });\r\n    log((l) =>\r\n      l.warn('Failed to parse cached MCP tools', {\r\n        error: le.toString(),\r\n        json,\r\n      }),\r\n    );\r\n    return undefined;\r\n  }\r\n};\r\n\r\n// Global singleton instance\r\nlet globalToolCache: MCPToolCache | null = null;\r\n\r\n/**\r\n * Gets the global MCP tool cache instance\r\n */\r\nexport const getToolCache = (): MCPToolCache => {\r\n  if (!globalToolCache) {\r\n    globalToolCache = new MCPToolCache();\r\n  }\r\n  return globalToolCache;\r\n};\r\n\r\n/**\r\n * Configures the global tool cache\r\n */\r\nexport const configureToolCache = (\r\n  config: Partial<ToolCacheConfig>,\r\n): MCPToolCache => {\r\n  globalToolCache = new MCPToolCache(config);\r\n  return globalToolCache;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\cache\\user-tool-provider-cache.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":10,"column":1,"nodeType":"Program","endLine":406,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview User-scoped tool provider cache for maintaining persistent MCP connections\r\n *\r\n * This module provides a cache for maintaining ToolProviderSet instances across HTTP requests\r\n * while ensuring proper user isolation and cleanup. Each user gets their own tool provider\r\n * instance that persists for the configured TTL, reducing connection overhead and improving\r\n * performance.\r\n */\r\n\r\nimport type {\r\n  CachedToolProvider,\r\n  ToolProviderSet,\r\n  UserToolProviderCache,\r\n  UserToolProviderCacheConfig,\r\n} from '../types';\r\nimport { log } from '@/lib/logger';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { getFeatureFlag } from '@/lib/site-util/feature-flags/server';\r\nimport { globalSingleton } from '@/lib/typescript';\r\n\r\n/**\r\n * Cache for maintaining ToolProviderSet instances per user across HTTP requests.\r\n *\r\n * Features:\r\n * - Per-user isolation with session-based keys\r\n * - Automatic TTL-based cleanup\r\n * - LRU eviction when cache limits are exceeded\r\n * - Proper disposal of tool providers on cleanup\r\n * - Memory usage monitoring and limits\r\n *\r\n * @example\r\n * ```typescript\r\n * const cache = UserToolProviderCache.getInstance();\r\n *\r\n * // Get or create tool providers for a user\r\n * const toolProviders = await cache.getOrCreate(\r\n *   userId,\r\n *   sessionId,\r\n *   async () => toolProviderFactory({ ... })\r\n * );\r\n *\r\n * // Cleanup when done (optional - automatic cleanup also occurs)\r\n * cache.invalidateUser(userId);\r\n * ```\r\n */\r\nclass UserToolProviderCacheImpl implements UserToolProviderCache {\r\n  private cache = new Map<string, CachedToolProvider>();\r\n  private cleanupTimer: NodeJS.Timeout | null = null;\r\n  private readonly config: UserToolProviderCacheConfig;\r\n\r\n  public constructor(config: Partial<UserToolProviderCacheConfig> = {}) {\r\n    this.config = {\r\n      maxEntriesPerUser: 3, // Max 3 different tool provider configs per user\r\n      maxTotalEntries: 100, // Max 100 total entries across all users\r\n      ttl: 30 * 60 * 1000, // 30 minutes\r\n      cleanupInterval: 5 * 60 * 1000, // Cleanup every 5 minutes\r\n      ...config,\r\n    };\r\n\r\n    this.startCleanupTimer();\r\n  }\r\n\r\n  /**\r\n   * Generate a cache key for a user's tool provider configuration.\r\n   */\r\n  private generateCacheKey(\r\n    userId: string,\r\n    sessionId: string,\r\n    configHash: string,\r\n  ): string {\r\n    return `${userId}:${sessionId}:${configHash}`;\r\n  }\r\n\r\n  /**\r\n   * Generate a hash for the tool provider configuration to detect changes.\r\n   */\r\n  private generateConfigHash(config: {\r\n    writeEnabled: boolean;\r\n    memoryDisabled: boolean;\r\n    headers?: Record<string, string>;\r\n  }): string {\r\n    // Create a stable hash of the configuration\r\n    const configString = JSON.stringify({\r\n      writeEnabled: config.writeEnabled,\r\n      memoryDisabled: config.memoryDisabled,\r\n      // Only include non-auth headers in hash to avoid session token changes\r\n      headers: config.headers\r\n        ? Object.fromEntries(\r\n            Object.entries(config.headers).filter(\r\n              ([key]) =>\r\n                !key.toLowerCase().includes('auth') &&\r\n                !key.toLowerCase().includes('cookie') &&\r\n                key !== 'x-chat-history-id',\r\n            ),\r\n          )\r\n        : {},\r\n    });\r\n\r\n    // Simple hash function (in production, consider using a crypto hash)\r\n    let hash = 0;\r\n    for (let i = 0; i < configString.length; i++) {\r\n      const char = configString.charCodeAt(i);\r\n      hash = (hash << 5) - hash + char;\r\n      hash = hash & hash; // Convert to 32-bit integer\r\n    }\r\n    return hash.toString(36);\r\n  }\r\n\r\n  /**\r\n   * Get or create a tool provider set for a user.\r\n   */\r\n  public async getOrCreate(\r\n    userId: string,\r\n    sessionId: string,\r\n    config: {\r\n      writeEnabled: boolean;\r\n      memoryDisabled: boolean;\r\n      headers?: Record<string, string>;\r\n    },\r\n    factory: () => Promise<ToolProviderSet>,\r\n  ): Promise<ToolProviderSet> {\r\n    const configHash = this.generateConfigHash(config);\r\n    const cacheKey = this.generateCacheKey(userId, sessionId, configHash);\r\n\r\n    // Check if we have a valid cached entry\r\n    const cached = this.cache.get(cacheKey);\r\n    if (cached && !this.isExpired(cached)) {\r\n      // Update last accessed time\r\n      cached.lastAccessed = Date.now();\r\n      log((l) => l.debug('Tool provider cache hit', { userId, cacheKey }));\r\n      return cached.toolProviders;\r\n    }\r\n\r\n    // Clean up expired entry if it exists\r\n    if (cached && this.isExpired(cached)) {\r\n      this.removeEntry(cacheKey, cached);\r\n    }\r\n\r\n    // Create new tool provider set\r\n    log((l) => l.debug('Creating new tool provider set', { userId, cacheKey }));\r\n\r\n    try {\r\n      const toolProviders = await factory();\r\n\r\n      if (toolProviders.isHealthy) {\r\n        // Check cache size limits before adding\r\n        this.enforceEvictionLimits(userId);\r\n\r\n        // Cache the new tool provider\r\n        this.cache.set(cacheKey, {\r\n          toolProviders,\r\n          lastAccessed: Date.now(),\r\n          userId,\r\n          sessionId,\r\n        });\r\n\r\n        log((l) =>\r\n          l.debug('Tool provider cached successfully', {\r\n            userId,\r\n            cacheKey,\r\n            cacheSize: this.cache.size,\r\n          }),\r\n        );\r\n      }\r\n      return toolProviders;\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'UserToolProviderCache.getOrCreate',\r\n        message: 'Failed to create tool provider set',\r\n        data: { userId, cacheKey },\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a cached entry is expired.\r\n   */\r\n  private isExpired(entry: CachedToolProvider): boolean {\r\n    return Date.now() - entry.lastAccessed > this.config.ttl;\r\n  }\r\n\r\n  /**\r\n   * Remove and properly dispose of a cache entry.\r\n   */\r\n  private removeEntry(cacheKey: string, entry: CachedToolProvider): void {\r\n    try {\r\n      entry.toolProviders.dispose();\r\n      log((l) =>\r\n        l.debug('Tool provider disposed', {\r\n          userId: entry.userId,\r\n          cacheKey,\r\n        }),\r\n      );\r\n    } catch (error) {\r\n      log((l) =>\r\n        l.warn('Error disposing tool provider', {\r\n          userId: entry.userId,\r\n          cacheKey,\r\n          error,\r\n        }),\r\n      );\r\n    }\r\n    this.cache.delete(cacheKey);\r\n  }\r\n\r\n  /**\r\n   * Enforce cache size limits with LRU eviction.\r\n   */\r\n  private enforceEvictionLimits(currentUserId: string): void {\r\n    // Check per-user limit\r\n    const userEntries = Array.from(this.cache.entries()).filter(\r\n      ([, entry]) => entry.userId === currentUserId,\r\n    );\r\n\r\n    if (userEntries.length >= this.config.maxEntriesPerUser) {\r\n      // Remove oldest entry for this user\r\n      const oldestUserEntry = userEntries.sort(\r\n        ([, a], [, b]) => a.lastAccessed - b.lastAccessed,\r\n      )[0];\r\n\r\n      if (oldestUserEntry) {\r\n        this.removeEntry(oldestUserEntry[0], oldestUserEntry[1]);\r\n      }\r\n    }\r\n\r\n    // Check total cache limit\r\n    if (this.cache.size >= this.config.maxTotalEntries) {\r\n      // Remove oldest entry globally\r\n      const oldestEntry = Array.from(this.cache.entries()).sort(\r\n        ([, a], [, b]) => a.lastAccessed - b.lastAccessed,\r\n      )[0];\r\n\r\n      if (oldestEntry) {\r\n        this.removeEntry(oldestEntry[0], oldestEntry[1]);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Invalidate all cached tool providers for a specific user.\r\n   */\r\n  public invalidateUser(userId: string): void {\r\n    const userEntries = Array.from(this.cache.entries()).filter(\r\n      ([, entry]) => entry.userId === userId,\r\n    );\r\n\r\n    for (const [cacheKey, entry] of userEntries) {\r\n      this.removeEntry(cacheKey, entry);\r\n    }\r\n\r\n    log((l) =>\r\n      l.debug('Invalidated user tool providers', {\r\n        userId,\r\n        removedCount: userEntries.length,\r\n      }),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Invalidate all cached tool providers for a specific user session.\r\n   */\r\n  public invalidateSession(userId: string, sessionId: string): void {\r\n    const sessionEntries = Array.from(this.cache.entries()).filter(\r\n      ([, entry]) => entry.userId === userId && entry.sessionId === sessionId,\r\n    );\r\n\r\n    for (const [cacheKey, entry] of sessionEntries) {\r\n      this.removeEntry(cacheKey, entry);\r\n    }\r\n\r\n    log((l) =>\r\n      l.debug('Invalidated session tool providers', {\r\n        userId,\r\n        sessionId,\r\n        removedCount: sessionEntries.length,\r\n      }),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Clean up expired entries.\r\n   */\r\n  private cleanup(): void {\r\n    const expiredEntries: [string, CachedToolProvider][] = [];\r\n\r\n    for (const [cacheKey, entry] of this.cache.entries()) {\r\n      if (this.isExpired(entry)) {\r\n        expiredEntries.push([cacheKey, entry]);\r\n      }\r\n    }\r\n\r\n    for (const [cacheKey, entry] of expiredEntries) {\r\n      this.removeEntry(cacheKey, entry);\r\n    }\r\n\r\n    if (expiredEntries.length > 0) {\r\n      log((l) =>\r\n        l.debug('Cleaned up expired tool providers', {\r\n          removedCount: expiredEntries.length,\r\n          remainingCount: this.cache.size,\r\n        }),\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all cached tool providers and dispose them.\r\n   */\r\n  public clear(): void {\r\n    for (const entry of this.cache.values()) {\r\n      try {\r\n        entry.toolProviders.dispose();\r\n      } catch (error) {\r\n        log((l) =>\r\n          l.warn('Error disposing tool provider during clear', { error }),\r\n        );\r\n      }\r\n    }\r\n\r\n    this.cache.clear();\r\n    log((l) => l.debug('Cleared all cached tool providers'));\r\n  }\r\n\r\n  /**\r\n   * Start the periodic cleanup timer.\r\n   */\r\n  private startCleanupTimer(): void {\r\n    this.cleanupTimer = setInterval(() => {\r\n      this.cleanup();\r\n    }, this.config.cleanupInterval);\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics.\r\n   */\r\n  public getStats() {\r\n    const userCounts = new Map<string, number>();\r\n    for (const entry of this.cache.values()) {\r\n      userCounts.set(entry.userId, (userCounts.get(entry.userId) || 0) + 1);\r\n    }\r\n\r\n    return {\r\n      totalEntries: this.cache.size,\r\n      userCounts: Object.fromEntries(userCounts),\r\n      config: this.config,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Shutdown the cache and clean up all entries.\r\n   */\r\n  public shutdown(): void {\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer);\r\n      this.cleanupTimer = null;\r\n    }\r\n\r\n    // Dispose all cached tool providers\r\n    for (const [cacheKey, entry] of this.cache.entries()) {\r\n      this.removeEntry(cacheKey, entry);\r\n    }\r\n\r\n    log((l) => l.info('User tool provider cache shutdown complete'));\r\n  }\r\n}\r\n/**\r\n * Get the singleton instance of the cache.\r\n */\r\nconst getInstanceInternal = async (\r\n  config?: Partial<UserToolProviderCacheConfig>,\r\n): Promise<UserToolProviderCache> => {\r\n  const cachingEnabled = await getFeatureFlag('mcp_cache_tools');\r\n  if (!cachingEnabled) {\r\n    const fnNoOp = () => Promise.resolve();\r\n    return {\r\n      getOrCreate: (\r\n        _userId: string,\r\n        _sessionId: string,\r\n        _config: {\r\n          writeEnabled: boolean;\r\n          memoryDisabled: boolean;\r\n          headers?: Record<string, string>;\r\n        },\r\n        factory: () => Promise<ToolProviderSet>,\r\n      ) => factory(),\r\n      shutdown: fnNoOp,\r\n      clear: fnNoOp,\r\n      invalidateUser: fnNoOp,\r\n      invalidateSession: fnNoOp,\r\n      getStats: () => ({\r\n        totalEntries: 0,\r\n        userCounts: {},\r\n        config: {} as UserToolProviderCacheConfig,\r\n      }),\r\n    };\r\n  }\r\n  return globalSingleton(\r\n    '@seanm/wedontneednoeducation/lib/ai/mcp/user-tool-provider-cache',\r\n    () => new UserToolProviderCacheImpl(config),\r\n  );\r\n};\r\n\r\nexport const getUserToolProviderCache = getInstanceInternal;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\instrumented-sse-transport\\index.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\instrumented-sse-transport\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\instrumented-sse-transport\\instrumented-transport-refactored.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":9,"column":1,"nodeType":"Program","endLine":735,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Refactored Instrumented SSE MCP Transport Client\r\n *\r\n * This is a refactored version of the original InstrumentedSseTransport that\r\n * delegates specific concerns to dedicated modules while maintaining the\r\n * same external interface and functionality.\r\n */\r\n\r\nimport { Span, SpanStatusCode } from '@opentelemetry/api';\r\nimport { SseMCPTransport } from '../ai.sdk';\r\nimport type { JSONRPCMessage } from '../ai.sdk';\r\n\r\nimport { isAbortError, isError } from '@/lib/react-util/utility-methods';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { log } from '@/lib/logger';\r\n\r\n// Import refactored modules\r\nimport { tracer, MetricsRecorder, DEBUG_MODE } from './metrics/otel-metrics';\r\nimport { CounterManager } from './metrics/counter-manager';\r\nimport { SessionManager } from './session/session-manager';\r\nimport { TraceContextManager } from './tracing/trace-context';\r\nimport {\r\n  SafetyUtils,\r\n  CONNECTION_TIMEOUT_MS,\r\n  SEND_TIMEOUT_MS,\r\n} from './utils/safety-utils';\r\nimport { MessageProcessor } from './message/message-processor';\r\nimport { ImpersonationService } from '@/lib/auth/impersonation';\r\n\r\ntype InstrumentedSseTransportOptions = {\r\n  url: string;\r\n  headers?: () => Promise<Record<string, string>>;\r\n  // impersonation?: ImpersonationService;\r\n  onclose?: () => void;\r\n  onmessage?: (message: JSONRPCMessage) => void;\r\n  onerror: ((error: unknown) => void) | ((error: Error) => void);\r\n};\r\n\r\n/**\r\n * Instrumented SSE Transport with comprehensive OpenTelemetry support.\r\n *\r\n * This refactored version maintains the same external interface while delegating\r\n * specific concerns to specialized modules:\r\n * - MetricsRecorder: OpenTelemetry metrics recording\r\n * - CounterManager: Active session and tool call tracking\r\n * - SessionManager: Session lifecycle and timeout management\r\n * - TraceContextManager: Distributed tracing support\r\n * - SafetyUtils: Error handling and timeout utilities\r\n * - MessageProcessor: Message parsing and tool call detection\r\n *\r\n * All original functionality is preserved with improved maintainability.\r\n */\r\nexport class InstrumentedSseTransport extends SseMCPTransport {\r\n  // Module dependencies\r\n  #counterManager: CounterManager;\r\n  #sessionManager: SessionManager;\r\n  #safetyUtils: SafetyUtils;\r\n  #messageProcessor: MessageProcessor;\r\n  #impersonation?: ImpersonationService;\r\n  // Core transport state\r\n  #onmessage?: (message: JSONRPCMessage) => void;\r\n  #onerror: (error: unknown) => void;\r\n  #onclose?: () => void;\r\n  #transportSpan?: Span;\r\n  #connectionStartTime: number = 0;\r\n  #isClosing = false;\r\n  #heartbeatTimer?: ReturnType<typeof setInterval>;\r\n  #inactivityTimer?: ReturnType<typeof setTimeout>;\r\n  #lastActivity: number = Date.now();\r\n  #closed = false;\r\n  #getHeaders: () => Promise<Record<string, string>>;\r\n\r\n  // Heartbeat / inactivity constants (tunable)\r\n  static readonly HEARTBEAT_INTERVAL_MS = 15_000; // send watchdog ping / check every 15s\r\n  static readonly INACTIVITY_TIMEOUT_MS = 60_000 * 60 * 2; // if no inbound activity for 2 hours -> close\r\n  static readonly POST_ERROR_AUTOCLOSE_DELAY_MS = 2_000; // grace period before forced close after fatal error\r\n\r\n  constructor({\r\n    // impersonation,\r\n    headers: getHeaders,\r\n    ...opts\r\n  }: InstrumentedSseTransportOptions) {\r\n    let constructorSpan: Span | undefined;\r\n    try {\r\n      // Start constructor instrumentation as child of current active span\r\n      constructorSpan = tracer.startSpan('mcp.transport.constructor', {\r\n        attributes: {\r\n          'mcp.transport.url': opts.url,\r\n          'mcp.transport.mode': DEBUG_MODE ? 'DEBUG' : 'WARNING',\r\n          'mcp.transport.has_headers': !!getHeaders,\r\n        },\r\n      });\r\n\r\n      if (DEBUG_MODE) {\r\n        log((l) =>\r\n          l.debug('Initializing InstrumentedSseTransport', {\r\n            data: {\r\n              url: opts.url,\r\n              mode: DEBUG_MODE ? 'DEBUG' : 'WARNING',\r\n            },\r\n          }),\r\n        );\r\n      }\r\n\r\n      // Inject trace context into headers for distributed tracing before calling super\r\n      const headers = TraceContextManager.injectTraceContext({});\r\n      super({ ...opts, headers }); // Call the base constructor with enhanced headers\r\n      // Capture impersonation service if provided\r\n      // this.#impersonation = impersonation;\r\n      this.#getHeaders = getHeaders || (() => Promise.resolve({}));\r\n      if (!opts.onerror) {\r\n        const error = new Error('onerror handler is required');\r\n        constructorSpan?.recordException(error);\r\n        constructorSpan?.setStatus({\r\n          code: SpanStatusCode.ERROR,\r\n          message: error.message,\r\n        });\r\n        throw error;\r\n      }\r\n\r\n      // Initialize module dependencies\r\n      this.#counterManager = new CounterManager();\r\n      this.#sessionManager = new SessionManager(opts.url, this.#counterManager);\r\n      this.#safetyUtils = new SafetyUtils(opts.url);\r\n      this.#messageProcessor = new MessageProcessor(\r\n        opts.url,\r\n        this.#sessionManager,\r\n        this.#counterManager,\r\n      );\r\n\r\n      // Set up event handlers\r\n      this.#onclose = opts.onclose;\r\n      this.#onmessage = opts.onmessage;\r\n      this.#onerror = this.#safetyUtils.createSafeErrorHandler((e: unknown) => {\r\n        opts.onerror(\r\n          LoggedError.isTurtlesAllTheWayDownBaby(e, {\r\n            log: true,\r\n            message: 'MCP SSE Transport: Error occurred',\r\n          }),\r\n        );\r\n      });\r\n\r\n      // Override base callbacks with instrumented versions\r\n      super.onclose = this.#safetyUtils.createSafeAsyncWrapper(\r\n        'handleClose',\r\n        this.handleClose.bind(this),\r\n        this.#onerror,\r\n      );\r\n      super.onerror = this.#safetyUtils.createSafeAsyncWrapper(\r\n        'handleError',\r\n        this.handleError.bind(this),\r\n        this.#onerror,\r\n      );\r\n      super.onmessage = this.#safetyUtils.createSafeAsyncWrapper(\r\n        'handleMessage',\r\n        this.handleMessage.bind(this),\r\n        this.#onerror,\r\n      );\r\n\r\n      // Record successful construction\r\n      MetricsRecorder.recordConnection(opts.url, 'constructor', 'success');\r\n\r\n      constructorSpan?.setStatus({ code: SpanStatusCode.OK });\r\n\r\n      if (DEBUG_MODE) {\r\n        log((l) =>\r\n          l.debug('InstrumentedSseTransport initialized successfully'),\r\n        );\r\n      }\r\n    } catch (error) {\r\n      // Record construction failure\r\n      MetricsRecorder.recordConnection(opts.url, 'constructor', 'error');\r\n      MetricsRecorder.recordError(\r\n        'constructor',\r\n        isError(error) ? error.name : 'unknown',\r\n      );\r\n\r\n      constructorSpan?.recordException(error as Error);\r\n      constructorSpan?.setStatus({\r\n        code: SpanStatusCode.ERROR,\r\n        message: isError(error) ? error.message : String(error),\r\n      });\r\n\r\n      log((l) =>\r\n        l.error('Failed to initialize InstrumentedSseTransport', {\r\n          data: { error: isError(error) ? error.message : String(error) },\r\n        }),\r\n      );\r\n\r\n      throw error;\r\n    } finally {\r\n      constructorSpan?.end();\r\n    }\r\n  }\r\n\r\n  // === Property Overrides ===\r\n\r\n  override get onmessage(): ((message: JSONRPCMessage) => void) | undefined {\r\n    return this.#onmessage;\r\n  }\r\n\r\n  override set onmessage(\r\n    handler: ((message: JSONRPCMessage) => void) | undefined,\r\n  ) {\r\n    this.#onmessage = handler;\r\n  }\r\n\r\n  override get onerror(): (error: unknown) => void {\r\n    return this.#onerror;\r\n  }\r\n\r\n  override set onerror(handler: (error: unknown) => void) {\r\n    if (!handler) {\r\n      throw new Error('onerror handler is required');\r\n    }\r\n    this.#onerror = this.#safetyUtils.createSafeErrorHandler(handler);\r\n  }\r\n\r\n  override get onclose(): (() => void) | undefined {\r\n    return this.#onclose;\r\n  }\r\n\r\n  override set onclose(handler: (() => void) | undefined) {\r\n    this.#onclose = handler;\r\n  }\r\n\r\n  toString(): string {\r\n    return `InstrumentedSseTransport(${this.url?.toString() || 'unknown'})`;\r\n  }\r\n\r\n  // === MCP Client Transport Methods ===\r\n\r\n  override async start(): Promise<void> {\r\n    let span: Span | undefined;\r\n    const operationId = this.#safetyUtils.recordOperation('start');\r\n\r\n    try {\r\n      this.#connectionStartTime = Date.now();\r\n\r\n      // Create span as child of active span if one exists\r\n      span = tracer.startSpan('mcp.transport.start', {\r\n        attributes: {\r\n          'mcp.transport.url': this.url?.toString(),\r\n          'mcp.transport.mode': DEBUG_MODE ? 'DEBUG' : 'WARNING',\r\n        },\r\n      });\r\n\r\n      this.#transportSpan = span;\r\n\r\n      if (DEBUG_MODE) {\r\n        log((l) =>\r\n          l.debug('Starting MCP Client Transport', {\r\n            data: {\r\n              url: this.url?.toString(),\r\n              mode: DEBUG_MODE ? 'DEBUG' : 'WARNING',\r\n            },\r\n          }),\r\n        );\r\n      }\r\n\r\n      // Record connection attempt\r\n      MetricsRecorder.recordConnection(\r\n        this.url?.toString() || 'unknown',\r\n        'start',\r\n        'attempt',\r\n      );\r\n\r\n      // Apply connection timeout\r\n      await this.#safetyUtils.withTimeout(\r\n        super.start(),\r\n        CONNECTION_TIMEOUT_MS,\r\n        'MCP connection',\r\n      );\r\n\r\n      // Record successful connection\r\n      MetricsRecorder.recordConnection(\r\n        this.url?.toString() || 'unknown',\r\n        'start',\r\n        'success',\r\n      );\r\n\r\n      // Initialize heartbeat & inactivity watchdog AFTER successful start\r\n      this.#initializeConnectionWatchdogs();\r\n\r\n      span.setStatus({ code: SpanStatusCode.OK });\r\n      this.#safetyUtils.completeOperation(operationId, 'success');\r\n\r\n      if (DEBUG_MODE) {\r\n        log((l) => l.debug('MCP Client Transport started successfully'));\r\n      }\r\n    } catch (error) {\r\n      if (isAbortError(error)) {\r\n        // Suppress abort errors; this is a disconnect not a construction failure.\r\n        const isClosing = this.#isClosing;\r\n        log((l) =>\r\n          l.verbose(\r\n            `InstrumentedTransport::MCP Client Transport start() aborted; isClosing=${isClosing}`,\r\n          ),\r\n        );\r\n        return;\r\n      }\r\n      // Record failed connection\r\n      MetricsRecorder.recordConnection(\r\n        this.url?.toString() || 'unknown',\r\n        'start',\r\n        'error',\r\n      );\r\n      MetricsRecorder.recordError(\r\n        'start',\r\n        isError(error) ? error.name : 'unknown',\r\n      );\r\n\r\n      span?.recordException(error as Error);\r\n      span?.setStatus({\r\n        code: SpanStatusCode.ERROR,\r\n        message: isError(error) ? error.message : String(error),\r\n      });\r\n\r\n      this.#safetyUtils.completeOperation(operationId, 'error');\r\n\r\n      log((l) =>\r\n        l.error('Failed to start MCP Client Transport', {\r\n          data: {\r\n            error: isError(error) ? error.message : String(error),\r\n            stack: isError(error) ? error.stack : undefined,\r\n          },\r\n        }),\r\n      );\r\n\r\n      throw error;\r\n    } finally {\r\n      // Don't end the transport span here - it should stay active for the connection duration\r\n    }\r\n  }\r\n\r\n  protected override async resolveHeaders(): Promise<Headers> {\r\n    const ret = await super.resolveHeaders();\r\n    const dynamicHeaders = await this.#getHeaders();\r\n    Object.entries(dynamicHeaders).forEach(([key, value]) => {\r\n      ret.set(key, value);\r\n    });\r\n    // If impersonation service is provided, add impersonation headers\r\n    if (this.#impersonation) {\r\n      const token = await this.#impersonation.getImpersonatedToken();\r\n      if (token) {\r\n        ret.set('Authorization', `Bearer ${token}`);\r\n      }\r\n    }\r\n    return ret;\r\n  }\r\n\r\n  override async close(): Promise<void> {\r\n    let span: Span | undefined;\r\n    const operationId = this.#safetyUtils.recordOperation('close');\r\n\r\n    try {\r\n      this.#isClosing = true;\r\n\r\n      span = tracer.startSpan('mcp.transport.close', {\r\n        attributes: {\r\n          'mcp.transport.url': this.url?.toString(),\r\n          'mcp.transport.session_count': this.#sessionManager.sessionCount,\r\n        },\r\n      });\r\n\r\n      if (DEBUG_MODE) {\r\n        log((l) =>\r\n          l.debug('Closing MCP Client Transport', {\r\n            data: {\r\n              url: this.url?.toString(),\r\n              sessionCount: this.#sessionManager.sessionCount,\r\n              connectionDuration: this.#connectionStartTime\r\n                ? Date.now() - this.#connectionStartTime\r\n                : 0,\r\n            },\r\n          }),\r\n        );\r\n      }\r\n\r\n      // Close all active sessions\r\n      this.#sessionManager.closeAllSessions();\r\n\r\n      // Stop timers early to avoid late firing while awaiting super.close()\r\n      this.#clearWatchdogs();\r\n\r\n      try {\r\n        await super.close();\r\n      } catch (e) {\r\n        // Swallow AbortError that can arise from closing streams mid-flight\r\n        if (isAbortError(e)) {\r\n          log((l) =>\r\n            l.verbose(\r\n              'InstrumentedSseTransport.close: Ignoring AbortError during close()',\r\n            ),\r\n          );\r\n        } else {\r\n          throw e;\r\n        }\r\n      }\r\n\r\n      // End the transport span\r\n      if (this.#transportSpan) {\r\n        try {\r\n          const connectionDuration = this.#connectionStartTime\r\n            ? Date.now() - this.#connectionStartTime\r\n            : 0;\r\n          this.#transportSpan.addEvent('transport.closed', {\r\n            'mcp.transport.duration_ms': connectionDuration,\r\n          });\r\n          this.#transportSpan.setStatus({ code: SpanStatusCode.OK });\r\n          this.#transportSpan.end();\r\n        } catch (e) {\r\n          LoggedError.isTurtlesAllTheWayDownBaby(e, {\r\n            log: true,\r\n          });\r\n        }\r\n      }\r\n\r\n      span.setStatus({ code: SpanStatusCode.OK });\r\n      this.#safetyUtils.completeOperation(operationId, 'success');\r\n\r\n      this.#closed = true;\r\n\r\n      if (DEBUG_MODE) {\r\n        log((l) => l.debug('MCP Client Transport closed successfully'));\r\n      }\r\n    } catch (error) {\r\n      MetricsRecorder.recordError(\r\n        'close',\r\n        isError(error) ? error.name : 'unknown',\r\n      );\r\n\r\n      span?.recordException(error as Error);\r\n      span?.setStatus({\r\n        code: SpanStatusCode.ERROR,\r\n        message: isError(error) ? error.message : String(error),\r\n      });\r\n\r\n      this.#safetyUtils.completeOperation(operationId, 'error');\r\n\r\n      log((l) =>\r\n        l.error('Failed to close MCP Client Transport', {\r\n          data: { error: isError(error) ? error.message : String(error) },\r\n        }),\r\n      );\r\n      // throw error;\r\n    } finally {\r\n      span?.end();\r\n    }\r\n  }\r\n\r\n  override async send(message: JSONRPCMessage): Promise<void> {\r\n    let span: Span | undefined;\r\n    const messageId = this.#sessionManager.getMessageId(message);\r\n    const messageMethod = this.#sessionManager.getMessageMethod(message);\r\n    const operationId = this.#safetyUtils.recordOperation('send', messageId);\r\n\r\n    try {\r\n      // Create span as child of active span if one exists\r\n      span = tracer.startSpan('mcp.transport.send', {\r\n        attributes: {\r\n          'mcp.transport.url': this.url?.toString(),\r\n          'mcp.message.id': String(messageId || 'unknown'),\r\n          'mcp.message.method': messageMethod || 'unknown',\r\n        },\r\n      });\r\n\r\n      // Process the outbound message\r\n      this.#messageProcessor.processOutboundMessage(message);\r\n\r\n      if (DEBUG_MODE) {\r\n        log((l) =>\r\n          l.debug('Sending MCP Client Message', {\r\n            data: {\r\n              messageId,\r\n              method: messageMethod,\r\n              url: this.url?.toString(),\r\n            },\r\n          }),\r\n        );\r\n      }\r\n\r\n      // Apply send timeout\r\n      await this.#safetyUtils.withTimeout(\r\n        super.send(message),\r\n        SEND_TIMEOUT_MS,\r\n        'MCP message send',\r\n      );\r\n\r\n      span.setStatus({ code: SpanStatusCode.OK });\r\n      this.#safetyUtils.completeOperation(operationId, 'success');\r\n\r\n      if (DEBUG_MODE) {\r\n        log((l) =>\r\n          l.debug('MCP Client Message sent successfully', {\r\n            data: { messageId, method: messageMethod },\r\n          }),\r\n        );\r\n      }\r\n    } catch (error) {\r\n      MetricsRecorder.recordError(\r\n        'send',\r\n        isError(error) ? error.name : 'unknown',\r\n      );\r\n\r\n      span?.recordException(error as Error);\r\n      span?.setStatus({\r\n        code: SpanStatusCode.ERROR,\r\n        message: isError(error) ? error.message : String(error),\r\n      });\r\n\r\n      this.#safetyUtils.completeOperation(operationId, 'error');\r\n\r\n      log((l) =>\r\n        l.error('Failed to send MCP Client Message', {\r\n          data: {\r\n            messageId,\r\n            method: messageMethod,\r\n            error: isError(error) ? error.message : String(error),\r\n          },\r\n        }),\r\n      );\r\n\r\n      throw error;\r\n    } finally {\r\n      span?.end();\r\n    }\r\n  }\r\n\r\n  // === Public API Methods (Delegated to modules) ===\r\n\r\n  /**\r\n   * Gets the current count of active sessions and tool calls\r\n   */\r\n  getActiveCounters(): { sessions: number; toolCalls: number } {\r\n    return this.#counterManager.getActiveCounters();\r\n  }\r\n\r\n  /**\r\n   * Manually resets all active counters to zero\r\n   */\r\n  resetActiveCounters(): void {\r\n    this.#counterManager.resetActiveCounters();\r\n  }\r\n\r\n  /**\r\n   * Gets current session information for debugging\r\n   */\r\n  getSessionDebugInfo(): Array<{\r\n    sessionId: string;\r\n    messageCount: number;\r\n    duration: number;\r\n    isToolCall: boolean;\r\n    toolCallMethod?: string;\r\n    lastActivity: number;\r\n  }> {\r\n    return this.#sessionManager.getSessionDebugInfo();\r\n  }\r\n\r\n  /**\r\n   * Manually completes a stuck tool call session\r\n   */\r\n  forceCompleteToolCall(\r\n    sessionId: string,\r\n    reason: string = 'manual_completion',\r\n  ): boolean {\r\n    return this.#sessionManager.forceCompleteToolCall(sessionId, reason);\r\n  }\r\n\r\n  /**\r\n   * Gets enhanced headers with trace context for HTTP requests\r\n   */\r\n  getEnhancedHeaders(\r\n    baseHeaders: Record<string, string> = {},\r\n  ): Record<string, string> {\r\n    return TraceContextManager.getEnhancedHeaders(baseHeaders);\r\n  }\r\n\r\n  /**\r\n   * Updates existing headers object with trace context in place\r\n   */\r\n  updateHeadersWithTraceContext(headers: Record<string, string>): boolean {\r\n    return TraceContextManager.updateHeadersWithTraceContext(headers);\r\n  }\r\n\r\n  /**\r\n   * Static method to inject trace context into HTTP headers for distributed tracing\r\n   */\r\n  static injectTraceContext(\r\n    headers: Record<string, string> = {},\r\n  ): Record<string, string> {\r\n    return TraceContextManager.injectTraceContext(headers);\r\n  }\r\n\r\n  // === Event Handlers ===\r\n\r\n  private handleClose() {\r\n    log((l) => l.verbose('MCP Client Transport Closed'));\r\n    try {\r\n      this.#onclose?.(); // pass through to client\r\n    } catch (e) {\r\n      log((l) => l.error('Error handling MCP Client Transport close:', e));\r\n    }\r\n  }\r\n\r\n  private handleMessage(message: JSONRPCMessage) {\r\n    log((l) => l.verbose('MCP Client Transport Message Received:', message));\r\n\r\n    try {\r\n      // Process the inbound message\r\n      this.#messageProcessor.processInboundMessage(message);\r\n\r\n      // Update activity time for watchdog\r\n      this.#lastActivity = Date.now();\r\n\r\n      this.#onmessage?.(message); // pass through to client\r\n    } catch (e) {\r\n      log((l) => l.error('Error handling MCP Client Transport message:', e));\r\n    }\r\n  }\r\n\r\n  private handleError(error: unknown) {\r\n    const le = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: 'MCP Client Transport',\r\n      data: {\r\n        details: 'Error occurred in MCP Client Transport',\r\n      },\r\n    });\r\n    try {\r\n      this.#onerror(le); // pass through to client\r\n    } catch (e) {\r\n      log((l) => l.error('Error handling MCP Client Transport error:', e));\r\n    }\r\n\r\n    // If we are not already closing, schedule an automatic close to prevent\r\n    // lingering hung transports after an unrecoverable error. Abort errors\r\n    // are treated as graceful shutdowns upstream, so only close on non-abort.\r\n    if (!this.#isClosing && !isAbortError(error)) {\r\n      this.#schedulePostErrorAutoclose();\r\n    }\r\n  }\r\n\r\n  // === Heartbeat & Watchdog Management ===\r\n\r\n  /**\r\n   * Initialize heartbeat interval and inactivity timeout watchdog.\r\n   * These guard against silent hung connections where the underlying SSE\r\n   * stream remains open but no messages are received (e.g., network middlebox\r\n   * buffering or server-side stall).\r\n   */\r\n  #initializeConnectionWatchdogs(): void {\r\n    this.#lastActivity = Date.now();\r\n    this.#clearWatchdogs();\r\n\r\n    // Heartbeat interval: record metric + (optionally) emit trace event.\r\n    this.#heartbeatTimer = setInterval(() => {\r\n      // Only act if not closing/closed\r\n      if (this.#isClosing || this.#closed) return;\r\n      const now = Date.now();\r\n      MetricsRecorder.recordConnection(\r\n        this.url?.toString() || 'unknown',\r\n        'heartbeat',\r\n        'success',\r\n      );\r\n      // Inactivity check piggybacked here (alternative to separate timeout reset)\r\n      if (\r\n        now - this.#lastActivity >\r\n        InstrumentedSseTransport.INACTIVITY_TIMEOUT_MS\r\n      ) {\r\n        log((l) =>\r\n          l.warn(\r\n            'MCP Client Transport inactivity threshold exceeded; initiating graceful close',\r\n            {\r\n              url: this.url?.toString(),\r\n              idleMs: now - this.#lastActivity,\r\n              threshold: InstrumentedSseTransport.INACTIVITY_TIMEOUT_MS,\r\n            },\r\n          ),\r\n        );\r\n        this.close().catch((err) =>\r\n          log((l) =>\r\n            l.error('Error while closing after inactivity watchdog', {\r\n              error: isError(err) ? err.message : String(err),\r\n            }),\r\n          ),\r\n        );\r\n      }\r\n    }, InstrumentedSseTransport.HEARTBEAT_INTERVAL_MS);\r\n  }\r\n\r\n  /** Clear heartbeat and inactivity timers. */\r\n  #clearWatchdogs(): void {\r\n    if (this.#heartbeatTimer) {\r\n      clearInterval(this.#heartbeatTimer);\r\n      this.#heartbeatTimer = undefined;\r\n    }\r\n    if (this.#inactivityTimer) {\r\n      clearTimeout(this.#inactivityTimer);\r\n      this.#inactivityTimer = undefined;\r\n    }\r\n  }\r\n\r\n  /** Schedule forced close after fatal error to prevent resource leaks. */\r\n  #schedulePostErrorAutoclose(): void {\r\n    // Avoid multiple schedules\r\n    if (this.#inactivityTimer || this.#isClosing || this.#closed) return;\r\n    this.#inactivityTimer = setTimeout(() => {\r\n      if (this.#isClosing || this.#closed) return;\r\n      log((l) =>\r\n        l.warn('Auto-closing MCP Client Transport after error grace period', {\r\n          url: this.url?.toString(),\r\n          delayMs: InstrumentedSseTransport.POST_ERROR_AUTOCLOSE_DELAY_MS,\r\n        }),\r\n      );\r\n      this.close().catch((err) =>\r\n        log((l) =>\r\n          l.error('Error during post-error autoclose', {\r\n            error: isError(err) ? err.message : String(err),\r\n          }),\r\n        ),\r\n      );\r\n    }, InstrumentedSseTransport.POST_ERROR_AUTOCLOSE_DELAY_MS);\r\n  }\r\n}\r\n\r\n/**\r\n * TransportPlugin interface for MCP Client Transport plugins\r\n */\r\nexport interface TransportPlugin {\r\n  onMessage?(message: JSONRPCMessage): void;\r\n  onError?(error: Error): void;\r\n  onClose?(): void;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\instrumented-sse-transport\\message\\message-processor.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":8,"column":1,"nodeType":"Program","endLine":171,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Message Processing Utilities for MCP Transport\r\n *\r\n * This module provides utilities for processing and handling MCP messages,\r\n * including message type detection and tool call identification.\r\n */\r\n\r\nimport type { JSONRPCMessage } from '../../ai.sdk';\r\nimport { SessionManager } from '../session/session-manager';\r\nimport { MetricsRecorder, DEBUG_MODE } from '../metrics/otel-metrics';\r\nimport { CounterManager } from '../metrics/counter-manager';\r\nimport { log } from '@/lib/logger';\r\nimport { LoggedError } from '@/lib/react-util';\r\n\r\n/**\r\n * Handles message processing and tool call lifecycle management\r\n */\r\nexport class MessageProcessor {\r\n  #sessionManager: SessionManager;\r\n  #counterManager: CounterManager;\r\n  #url: string;\r\n\r\n  constructor(\r\n    url: string,\r\n    sessionManager: SessionManager,\r\n    counterManager: CounterManager,\r\n  ) {\r\n    this.#url = url;\r\n    this.#sessionManager = sessionManager;\r\n    this.#counterManager = counterManager;\r\n  }\r\n\r\n  /**\r\n   * Processes an outbound message and handles session/tool call tracking\r\n   */\r\n  processOutboundMessage(message: JSONRPCMessage): void {\r\n    const messageId = this.#sessionManager.getMessageId(message);\r\n    const messageMethod = this.#sessionManager.getMessageMethod(message);\r\n\r\n    // Check if this is a tool call and track it\r\n    const isToolCall =\r\n      messageMethod && this.#sessionManager.isToolCallMethod(messageMethod);\r\n\r\n    // Create or update session for this message if it has an ID\r\n    let sessionState = undefined;\r\n    if (messageId) {\r\n      sessionState = this.#sessionManager.getOrCreateSession(message);\r\n\r\n      // If this is a new session, increment session counter\r\n      if (sessionState && sessionState.messageCount === 1) {\r\n        this.#counterManager.incrementCounter('sessions');\r\n      }\r\n\r\n      // If this is a tool call and session wasn't already marked as tool call\r\n      if (sessionState && isToolCall && !sessionState.isToolCall) {\r\n        sessionState.isToolCall = true;\r\n        sessionState.toolCallMethod = messageMethod;\r\n        this.#counterManager.incrementCounter('toolCalls');\r\n\r\n        MetricsRecorder.recordToolCall(this.#url, messageMethod || 'unknown');\r\n      }\r\n    }\r\n\r\n    // Record message metrics\r\n    MetricsRecorder.recordMessage(\r\n      this.#url,\r\n      'outbound',\r\n      messageMethod || 'unknown',\r\n    );\r\n\r\n    // Record message size\r\n    const messageStr = JSON.stringify(message);\r\n    const messageSize = new TextEncoder().encode(messageStr).length;\r\n    MetricsRecorder.recordMessageSize(\r\n      messageSize,\r\n      'outbound',\r\n      messageMethod || 'unknown',\r\n    );\r\n\r\n    if (DEBUG_MODE) {\r\n      log((l) =>\r\n        l.debug('Processing outbound MCP message', {\r\n          data: {\r\n            messageId,\r\n            method: messageMethod,\r\n            size: messageSize,\r\n            url: this.#url,\r\n            isToolCall,\r\n          },\r\n        }),\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Processes an inbound message and handles response completion\r\n   */\r\n  processInboundMessage(message: JSONRPCMessage): void {\r\n    let sessionId: string = '';\r\n    try {\r\n      const messageId = this.#sessionManager.getMessageId(message);\r\n      const messageMethod = this.#sessionManager.getMessageMethod(message);\r\n\r\n      // Record message metrics\r\n      MetricsRecorder.recordMessage(\r\n        this.#url,\r\n        'inbound',\r\n        messageMethod || 'response',\r\n      );\r\n\r\n      // Record message size\r\n      const messageStr = JSON.stringify(message);\r\n      const messageSize = new TextEncoder().encode(messageStr).length;\r\n      MetricsRecorder.recordMessageSize(\r\n        messageSize,\r\n        'inbound',\r\n        messageMethod || 'response',\r\n      );\r\n\r\n      // Check if this is a response to a tool call and handle completion\r\n      if (messageId) {\r\n        sessionId = String(messageId);\r\n        const sessionState = this.#sessionManager.getSession(sessionId);\r\n\r\n        // If this is a response (has result or error) and the session was a tool call\r\n        if (\r\n          sessionState &&\r\n          sessionState.isToolCall &&\r\n          ('result' in message || 'error' in message)\r\n        ) {\r\n          const reason = 'error' in message ? 'error' : 'success';\r\n          this.#sessionManager.completeSession(sessionId, reason);\r\n\r\n          if (DEBUG_MODE) {\r\n            log((l) =>\r\n              l.debug('Tool call completed via response', {\r\n                data: {\r\n                  sessionId,\r\n                  success: reason === 'success',\r\n                  method: sessionState.toolCallMethod,\r\n                },\r\n              }),\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      if (DEBUG_MODE) {\r\n        log((l) =>\r\n          l.debug('Processing inbound MCP message', {\r\n            data: {\r\n              messageId,\r\n              method: messageMethod,\r\n              size: messageSize,\r\n              isResponse: 'result' in message || 'error' in message,\r\n            },\r\n          }),\r\n        );\r\n      }\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'MessageProcessor',\r\n        message: 'Failed to process inbound message',\r\n        critical: true,\r\n      });\r\n      this.#sessionManager.completeSession(sessionId, 'error');\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\instrumented-sse-transport\\metrics\\counter-manager.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":8,"column":1,"nodeType":"Program","endLine":109,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Counter Management for MCP Transport\r\n *\r\n * This module handles tracking of active sessions and tool calls with\r\n * safe increment/decrement operations and debugging capabilities.\r\n */\r\n\r\nimport { activeSessionsGauge, activeToolCallsGauge } from './otel-metrics';\r\nimport { log } from '@/lib/logger';\r\nimport { DEBUG_MODE } from './otel-metrics';\r\n\r\nexport interface ActiveCounters {\r\n  sessions: number;\r\n  toolCalls: number;\r\n}\r\n\r\n/**\r\n * Manages active session and tool call counters with safe operations\r\n */\r\nexport class CounterManager {\r\n  #activeCounters: ActiveCounters = { sessions: 0, toolCalls: 0 };\r\n\r\n  /**\r\n   * Gets the current count of active sessions and tool calls\r\n   */\r\n  getActiveCounters(): ActiveCounters {\r\n    return { ...this.#activeCounters };\r\n  }\r\n\r\n  /**\r\n   * Manually resets all active counters to zero\r\n   * Use this when you suspect counters are out of sync due to errors\r\n   */\r\n  resetActiveCounters(): void {\r\n    if (DEBUG_MODE) {\r\n      log((l) =>\r\n        l.debug('Manually resetting active counters', {\r\n          data: {\r\n            previousSessions: this.#activeCounters.sessions,\r\n            previousToolCalls: this.#activeCounters.toolCalls,\r\n          },\r\n        }),\r\n      );\r\n    }\r\n\r\n    // Update metrics to reflect the reset\r\n    activeSessionsGauge.add(-this.#activeCounters.sessions);\r\n    activeToolCallsGauge.add(-this.#activeCounters.toolCalls);\r\n\r\n    this.#activeCounters = { sessions: 0, toolCalls: 0 };\r\n\r\n    log((l) => l.warn('Active counters have been manually reset to zero'));\r\n  }\r\n\r\n  /**\r\n   * Safely increments active counters\r\n   */\r\n  incrementCounter(type: 'sessions' | 'toolCalls', amount: number = 1): void {\r\n    this.#activeCounters[type] = Math.max(\r\n      0,\r\n      this.#activeCounters[type] + amount,\r\n    );\r\n\r\n    if (type === 'sessions') {\r\n      activeSessionsGauge.add(amount);\r\n    } else {\r\n      activeToolCallsGauge.add(amount);\r\n    }\r\n\r\n    if (DEBUG_MODE) {\r\n      log((l) =>\r\n        l.debug(`Incremented ${type} counter`, {\r\n          data: { amount, newValue: this.#activeCounters[type] },\r\n        }),\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Safely decrements active counters (never goes below 0)\r\n   */\r\n  decrementCounter(type: 'sessions' | 'toolCalls', amount: number = 1): void {\r\n    const oldValue = this.#activeCounters[type];\r\n    this.#activeCounters[type] = Math.max(\r\n      0,\r\n      this.#activeCounters[type] - amount,\r\n    );\r\n    const actualDecrement = oldValue - this.#activeCounters[type];\r\n\r\n    if (type === 'sessions') {\r\n      activeSessionsGauge.add(-actualDecrement);\r\n    } else {\r\n      activeToolCallsGauge.add(-actualDecrement);\r\n    }\r\n\r\n    if (DEBUG_MODE) {\r\n      log((l) =>\r\n        l.debug(`Decremented ${type} counter`, {\r\n          data: {\r\n            requestedAmount: amount,\r\n            actualAmount: actualDecrement,\r\n            newValue: this.#activeCounters[type],\r\n          },\r\n        }),\r\n      );\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\instrumented-sse-transport\\metrics\\otel-metrics.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":8,"column":1,"nodeType":"Program","endLine":139,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview OpenTelemetry Metrics Setup for MCP Transport\r\n * \r\n * This module centralizes all OpenTelemetry metric definitions and provides\r\n * utilities for recording transport-related metrics.\r\n */\r\n\r\nimport { trace, metrics } from '@opentelemetry/api';\r\n\r\n// OTEL Configuration\r\nexport const OTEL_MODE = process.env.MCP_OTEL_MODE?.toUpperCase() || 'WARNING';\r\nexport const DEBUG_MODE = OTEL_MODE === 'DEBUG';\r\n\r\n// OTEL Instrumentation\r\nexport const tracer = trace.getTracer('mcp-client-transport', '1.0.0');\r\nexport const meter = metrics.getMeter('mcp-client-transport', '1.0.0');\r\n\r\n// Connection Metrics\r\nexport const connectionCounter = meter.createCounter('mcp_connections_total', {\r\n  description: 'Total number of MCP connection attempts',\r\n});\r\n\r\n// Message Metrics\r\nexport const messageCounter = meter.createCounter('mcp_messages_total', {\r\n  description: 'Total number of MCP messages sent/received',\r\n});\r\n\r\nexport const messageSizeHistogram = meter.createHistogram('mcp_message_size_bytes', {\r\n  description: 'Size of MCP messages in bytes',\r\n});\r\n\r\n// Error Metrics\r\nexport const errorCounter = meter.createCounter('mcp_errors_total', {\r\n  description: 'Total number of MCP transport errors',\r\n});\r\n\r\n// Duration Metrics\r\nexport const sessionDurationHistogram = meter.createHistogram(\r\n  'mcp_session_duration_ms',\r\n  {\r\n    description: 'Duration of MCP sessions in milliseconds',\r\n  },\r\n);\r\n\r\nexport const operationDurationHistogram = meter.createHistogram(\r\n  'mcp_operation_duration_ms',\r\n  {\r\n    description: 'Duration of MCP operations in milliseconds',\r\n  },\r\n);\r\n\r\n// Active Counters\r\nexport const activeSessionsGauge = meter.createUpDownCounter('mcp_active_sessions', {\r\n  description: 'Number of currently active MCP sessions',\r\n});\r\n\r\nexport const activeToolCallsGauge = meter.createUpDownCounter(\r\n  'mcp_active_tool_calls',\r\n  {\r\n    description: 'Number of currently active MCP tool calls',\r\n  },\r\n);\r\n\r\n// Tool Call Metrics\r\nexport const toolCallCounter = meter.createCounter('mcp_tool_calls_total', {\r\n  description: 'Total number of MCP tool calls initiated',\r\n});\r\n\r\nexport const toolCallCompletionCounter = meter.createCounter(\r\n  'mcp_tool_call_completions_total',\r\n  {\r\n    description: 'Total number of MCP tool call completions',\r\n  },\r\n);\r\n\r\n/**\r\n * Utility class for recording common metric patterns\r\n */\r\nexport class MetricsRecorder {\r\n  static recordConnection(url: string, operation: string, status: string) {\r\n    connectionCounter.add(1, {\r\n      'mcp.transport.url': url,\r\n      'mcp.transport.operation': operation,\r\n      'mcp.transport.status': status,\r\n    });\r\n  }\r\n\r\n  static recordMessage(url: string, direction: 'inbound' | 'outbound', method: string) {\r\n    messageCounter.add(1, {\r\n      'mcp.transport.url': url,\r\n      'mcp.transport.direction': direction,\r\n      'mcp.message.method': method,\r\n    });\r\n  }\r\n\r\n  static recordMessageSize(size: number, direction: 'inbound' | 'outbound', method: string) {\r\n    messageSizeHistogram.record(size, {\r\n      'mcp.transport.direction': direction,\r\n      'mcp.message.method': method,\r\n    });\r\n  }\r\n\r\n  static recordError(operation: string, errorType: string) {\r\n    errorCounter.add(1, {\r\n      'mcp.transport.operation': operation,\r\n      'mcp.transport.error_type': errorType,\r\n    });\r\n  }\r\n\r\n  static recordOperationDuration(duration: number, operation: string, status: string) {\r\n    operationDurationHistogram.record(duration, {\r\n      'mcp.transport.operation': operation,\r\n      'mcp.transport.status': status,\r\n    });\r\n  }\r\n\r\n  static recordSessionDuration(duration: number, url: string, sessionType: string) {\r\n    sessionDurationHistogram.record(duration, {\r\n      'mcp.transport.url': url,\r\n      'mcp.transport.session_type': sessionType,\r\n    });\r\n  }\r\n\r\n  static recordToolCall(url: string, method: string) {\r\n    toolCallCounter.add(1, {\r\n      'mcp.transport.url': url,\r\n      'mcp.tool.method': method,\r\n    });\r\n  }\r\n\r\n  static recordToolCallCompletion(url: string, method: string, reason: string) {\r\n    toolCallCompletionCounter.add(1, {\r\n      'mcp.transport.url': url,\r\n      'mcp.tool.method': method,\r\n      'mcp.tool.completion_reason': reason,\r\n    });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\instrumented-sse-transport\\session\\session-manager.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":7,"column":1,"nodeType":"Program","endLine":363,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Session Management for MCP Transport\r\n *\r\n * This module handles session lifecycle, idle timeouts, and session state tracking.\r\n */\r\n\r\nimport { Span, SpanStatusCode } from '@opentelemetry/api';\r\nimport { tracer, MetricsRecorder, DEBUG_MODE } from '../metrics/otel-metrics';\r\nimport { CounterManager } from '../metrics/counter-manager';\r\nimport type { JSONRPCMessage } from '@/lib/ai/mcp/ai.sdk';\r\nimport { log } from '@/lib/logger';\r\nimport { isError } from '@/lib/react-util/utility-methods';\r\n\r\nexport interface SpanState {\r\n  span: Span;\r\n  idleTimer: ReturnType<typeof setTimeout>;\r\n  createdAt: number;\r\n  messageCount: number;\r\n  lastActivity: number;\r\n  isToolCall?: boolean;\r\n  toolCallMethod?: string;\r\n}\r\n\r\n// Constants\r\nconst IDLE_TIMEOUT_MS = 15 * 60 * 1000; // 15 minutes\r\n\r\n// Tool call methods that initiate sessions\r\nconst TOOL_CALL_METHODS = new Set([\r\n  'tools/call',\r\n  'tools/list',\r\n  'tools/get',\r\n  'prompts/list',\r\n  'prompts/get',\r\n  'resources/list',\r\n  'resources/read',\r\n  'resources/subscribe',\r\n]);\r\n\r\n/**\r\n * Manages MCP session lifecycle and tracking\r\n */\r\nexport class SessionManager {\r\n  #sessions = new Map<string, SpanState>();\r\n  #counterManager: CounterManager;\r\n  #url: string;\r\n  #isClosing = false;\r\n\r\n  constructor(url: string, counterManager: CounterManager) {\r\n    this.#url = url;\r\n    this.#counterManager = counterManager;\r\n  }\r\n\r\n  /**\r\n   * Creates or updates session state for message tracking\r\n   */\r\n  getOrCreateSession(message: JSONRPCMessage): SpanState | undefined {\r\n    const messageId = this.getMessageId(message);\r\n    if (!messageId) return undefined;\r\n\r\n    const sessionId = String(messageId);\r\n    let sessionState = this.#sessions.get(sessionId);\r\n\r\n    if (!sessionState) {\r\n      if (DEBUG_MODE) {\r\n        log((l) =>\r\n          l.debug('Creating new MCP session', {\r\n            data: { sessionId, method: this.getMessageMethod(message) },\r\n          }),\r\n        );\r\n      }\r\n\r\n      // Create session span as child of current active span\r\n      const span = tracer.startSpan('mcp.session', {\r\n        attributes: {\r\n          'mcp.session.id': sessionId,\r\n          'mcp.session.created_at': Date.now(),\r\n          'mcp.transport.url': this.#url,\r\n          'mcp.session.initiating_method':\r\n            this.getMessageMethod(message) || 'unknown',\r\n        },\r\n      });\r\n\r\n      sessionState = {\r\n        span,\r\n        idleTimer: this.setIdleTimer(sessionId),\r\n        createdAt: Date.now(),\r\n        messageCount: 0,\r\n        lastActivity: Date.now(),\r\n      };\r\n\r\n      this.#sessions.set(sessionId, sessionState);\r\n    }\r\n\r\n    // Update activity\r\n    sessionState.messageCount++;\r\n    sessionState.lastActivity = Date.now();\r\n    clearTimeout(sessionState.idleTimer);\r\n    sessionState.idleTimer = this.setIdleTimer(sessionId);\r\n\r\n    return sessionState;\r\n  }\r\n\r\n  /**\r\n   * Checks if a message method is a tool call\r\n   */\r\n  isToolCallMethod(method: string): boolean {\r\n    return TOOL_CALL_METHODS.has(method);\r\n  }\r\n\r\n  /**\r\n   * Sets up idle timer for session cleanup\r\n   */\r\n  setIdleTimer(sessionId: string): ReturnType<typeof setTimeout> {\r\n    return setTimeout(() => {\r\n      try {\r\n        const sessionState = this.#sessions.get(sessionId);\r\n        if (sessionState && !this.#isClosing) {\r\n          const sessionDuration = Date.now() - sessionState.createdAt;\r\n\r\n          MetricsRecorder.recordSessionDuration(\r\n            sessionDuration,\r\n            this.#url,\r\n            'idle_timeout',\r\n          );\r\n\r\n          sessionState.span.addEvent('session.idle_timeout', {\r\n            'mcp.session.duration_ms': sessionDuration,\r\n            'mcp.session.message_count': sessionState.messageCount,\r\n          });\r\n          sessionState.span.setStatus({ code: SpanStatusCode.OK });\r\n          sessionState.span.end();\r\n\r\n          // Decrement counters before removing session\r\n          this.#counterManager.decrementCounter('sessions');\r\n          if (sessionState.isToolCall) {\r\n            this.#counterManager.decrementCounter('toolCalls');\r\n\r\n            // Record tool call completion\r\n            MetricsRecorder.recordToolCallCompletion(\r\n              this.#url,\r\n              sessionState.toolCallMethod || 'unknown',\r\n              'idle_timeout',\r\n            );\r\n          }\r\n\r\n          this.#sessions.delete(sessionId);\r\n\r\n          if (DEBUG_MODE) {\r\n            log((l) =>\r\n              l.debug('Session idle timeout', {\r\n                data: {\r\n                  sessionId,\r\n                  duration: sessionDuration,\r\n                  messageCount: sessionState.messageCount,\r\n                },\r\n              }),\r\n            );\r\n          }\r\n        }\r\n      } catch (error) {\r\n        log((l) =>\r\n          l.error('Error in session idle timer', {\r\n            data: {\r\n              sessionId,\r\n              error: isError(error) ? error.message : String(error),\r\n            },\r\n          }),\r\n        );\r\n      }\r\n    }, IDLE_TIMEOUT_MS);\r\n  }\r\n\r\n  /**\r\n   * Gets session by ID\r\n   */\r\n  getSession(sessionId: string): SpanState | undefined {\r\n    return this.#sessions.get(sessionId);\r\n  }\r\n\r\n  /**\r\n   * Closes all active sessions\r\n   */\r\n  closeAllSessions(): void {\r\n    this.#isClosing = true;\r\n\r\n    for (const [, sessionState] of this.#sessions.entries()) {\r\n      const sessionDuration = Date.now() - sessionState.createdAt;\r\n\r\n      MetricsRecorder.recordSessionDuration(\r\n        sessionDuration,\r\n        this.#url,\r\n        'normal_close',\r\n      );\r\n\r\n      sessionState.span.addEvent('session.closing', {\r\n        'mcp.session.duration_ms': sessionDuration,\r\n        'mcp.session.message_count': sessionState.messageCount,\r\n      });\r\n      sessionState.span.setStatus({ code: SpanStatusCode.OK });\r\n      sessionState.span.end();\r\n      clearTimeout(sessionState.idleTimer);\r\n\r\n      // Decrement counters safely\r\n      this.#counterManager.decrementCounter('sessions');\r\n      if (sessionState.isToolCall) {\r\n        this.#counterManager.decrementCounter('toolCalls');\r\n\r\n        // Record tool call completion\r\n        MetricsRecorder.recordToolCallCompletion(\r\n          this.#url,\r\n          sessionState.toolCallMethod || 'unknown',\r\n          'transport_close',\r\n        );\r\n      }\r\n    }\r\n    this.#sessions.clear();\r\n  }\r\n\r\n  /**\r\n   * Completes a specific session\r\n   */\r\n  completeSession(sessionId: string, reason: string = 'completed'): boolean {\r\n    const sessionState = this.#sessions.get(sessionId);\r\n    if (!sessionState) return false;\r\n\r\n    const sessionDuration = Date.now() - sessionState.createdAt;\r\n\r\n    MetricsRecorder.recordSessionDuration(\r\n      sessionDuration,\r\n      this.#url,\r\n      reason === 'tool_call_response'\r\n        ? 'tool_call_response'\r\n        : 'normal_completion',\r\n    );\r\n\r\n    if (sessionState.isToolCall) {\r\n      sessionState.span.addEvent('tool.call.completed', {\r\n        'mcp.session.duration_ms': sessionDuration,\r\n        'mcp.session.message_count': sessionState.messageCount,\r\n        'mcp.tool.success': reason !== 'error',\r\n      });\r\n    }\r\n\r\n    sessionState.span.setStatus({ code: SpanStatusCode.OK });\r\n    sessionState.span.end();\r\n    clearTimeout(sessionState.idleTimer);\r\n\r\n    // Decrement counters\r\n    this.#counterManager.decrementCounter('sessions');\r\n    if (sessionState.isToolCall) {\r\n      this.#counterManager.decrementCounter('toolCalls');\r\n\r\n      // Record tool call completion\r\n      MetricsRecorder.recordToolCallCompletion(\r\n        this.#url,\r\n        sessionState.toolCallMethod || 'unknown',\r\n        reason,\r\n      );\r\n    }\r\n\r\n    this.#sessions.delete(sessionId);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Gets current session information for debugging\r\n   */\r\n  getSessionDebugInfo(): Array<{\r\n    sessionId: string;\r\n    messageCount: number;\r\n    duration: number;\r\n    isToolCall: boolean;\r\n    toolCallMethod?: string;\r\n    lastActivity: number;\r\n  }> {\r\n    const now = Date.now();\r\n    return Array.from(this.#sessions.entries()).map(([sessionId, state]) => ({\r\n      sessionId,\r\n      messageCount: state.messageCount,\r\n      duration: now - state.createdAt,\r\n      isToolCall: !!state.isToolCall,\r\n      toolCallMethod: state.toolCallMethod,\r\n      lastActivity: now - state.lastActivity,\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Manually completes a stuck tool call session\r\n   */\r\n  forceCompleteToolCall(\r\n    sessionId: string,\r\n    reason: string = 'manual_completion',\r\n  ): boolean {\r\n    const sessionState = this.#sessions.get(sessionId);\r\n    if (!sessionState || !sessionState.isToolCall) {\r\n      return false;\r\n    }\r\n\r\n    const sessionDuration = Date.now() - sessionState.createdAt;\r\n\r\n    sessionState.span.addEvent('tool.call.force_completed', {\r\n      'mcp.session.duration_ms': sessionDuration,\r\n      'mcp.session.message_count': sessionState.messageCount,\r\n      'mcp.tool.completion_reason': reason,\r\n    });\r\n\r\n    sessionState.span.setStatus({ code: SpanStatusCode.OK });\r\n    sessionState.span.end();\r\n    clearTimeout(sessionState.idleTimer);\r\n\r\n    // Decrement counters\r\n    this.#counterManager.decrementCounter('sessions');\r\n    this.#counterManager.decrementCounter('toolCalls');\r\n\r\n    // Record tool call completion\r\n    MetricsRecorder.recordToolCallCompletion(\r\n      this.#url,\r\n      sessionState.toolCallMethod || 'unknown',\r\n      reason,\r\n    );\r\n\r\n    this.#sessions.delete(sessionId);\r\n\r\n    log((l) =>\r\n      l.warn('Tool call manually completed', {\r\n        data: {\r\n          sessionId,\r\n          duration: sessionDuration,\r\n          reason,\r\n          method: sessionState.toolCallMethod,\r\n        },\r\n      }),\r\n    );\r\n\r\n    return true;\r\n  }\r\n\r\n  get sessionCount(): number {\r\n    return this.#sessions.size;\r\n  }\r\n\r\n  // Message utility methods\r\n  getMessageId(message: JSONRPCMessage): string | number | undefined {\r\n    return this.hasId(message) ? message.id : undefined;\r\n  }\r\n\r\n  getMessageMethod(message: JSONRPCMessage): string | undefined {\r\n    return this.hasMethod(message) ? message.method : undefined;\r\n  }\r\n\r\n  private hasId(\r\n    message: JSONRPCMessage,\r\n  ): message is JSONRPCMessage & { id: string | number } {\r\n    return 'id' in message && message.id !== undefined;\r\n  }\r\n\r\n  private hasMethod(\r\n    message: JSONRPCMessage,\r\n  ): message is JSONRPCMessage & { method: string } {\r\n    return 'method' in message && typeof message.method === 'string';\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\instrumented-sse-transport\\traceable-transport-client.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":59,"column":1,"nodeType":"Program","endLine":1366,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Instrumented SSE MCP Transport Client with OpenTelemetry Support\r\n *\r\n * This module provides a comprehensive OpenTelemetry-instrumented wrapper around the base\r\n * Server-Sent Events (SSE) transport for Model Context Protocol (MCP) client connections.\r\n *\r\n * Features:\r\n * - Comprehensive OTEL metrics (connections, messages, errors, durations, sizes)\r\n * - Detailed tracing for all transport operations with parent/child span relationships\r\n * - Two operational modes: WARNING (high-level) and DEBUG (detailed)\r\n * - Robust error handling with safe async wrappers\r\n * - Session management with idle timeout handling\r\n * - Active session and tool call tracking with UpDownCounters\r\n * - Distributed tracing support with trace context injection\r\n * - Tool call lifecycle tracking from initiation to completion\r\n * - Manual counter reset and debugging utilities\r\n * - Timeout handling for async operations (connect, send)\r\n * - Type-safe message property access\r\n *\r\n * Environment Variables:\r\n * - MCP_OTEL_MODE: 'WARNING' (default) or 'DEBUG'\r\n *\r\n * Counter Management:\r\n * - Active sessions are tracked and automatically managed\r\n * - Tool calls are detected and tracked separately\r\n * - Counters never go negative and can be manually reset\r\n * - Debugging methods provide insight into current state\r\n *\r\n * Distributed Tracing:\r\n * - All spans created as children of current active span\r\n * - Trace context injection available for HTTP headers\r\n * - Session spans track entire tool call lifecycle\r\n * - Transport span tracks connection lifetime\r\n *\r\n * @module InstrumentedSseTransport\r\n * @version 1.1.0\r\n * @author NoEducation Project\r\n *\r\n * @legal\r\n * SPDX-License-Identifier: Apache-2.0\r\n *\r\n * This file incorporates code derived from Vercel's AI SDK,\r\n * which is licensed under the Apache License, Version 2.0.\r\n * See: https://github.com/vercel/ai\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { trace, Span, SpanStatusCode, metrics } from '@opentelemetry/api';\r\nimport { SseMCPTransport } from '../ai.sdk';\r\nimport type { JSONRPCMessage } from '../ai.sdk';\r\n\r\nimport { isAbortError, isError } from '@/lib/react-util/utility-methods';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { log } from '@/lib/logger';\r\n\r\n// OTEL Configuration\r\nconst OTEL_MODE = process.env.MCP_OTEL_MODE?.toUpperCase() || 'WARNING'; // WARNING or DEBUG\r\nconst DEBUG_MODE = OTEL_MODE === 'DEBUG';\r\n\r\n// OTEL Instrumentation\r\nconst tracer = trace.getTracer('mcp-client-transport', '1.0.0');\r\nconst meter = metrics.getMeter('mcp-client-transport', '1.0.0');\r\n\r\n// Metrics\r\nconst connectionCounter = meter.createCounter('mcp_connections_total', {\r\n  description: 'Total number of MCP connection attempts',\r\n});\r\n\r\nconst messageCounter = meter.createCounter('mcp_messages_total', {\r\n  description: 'Total number of MCP messages sent/received',\r\n});\r\n\r\nconst errorCounter = meter.createCounter('mcp_errors_total', {\r\n  description: 'Total number of MCP transport errors',\r\n});\r\n\r\nconst sessionDurationHistogram = meter.createHistogram(\r\n  'mcp_session_duration_ms',\r\n  {\r\n    description: 'Duration of MCP sessions in milliseconds',\r\n  },\r\n);\r\n\r\nconst messageSizeHistogram = meter.createHistogram('mcp_message_size_bytes', {\r\n  description: 'Size of MCP messages in bytes',\r\n});\r\n\r\nconst operationDurationHistogram = meter.createHistogram(\r\n  'mcp_operation_duration_ms',\r\n  {\r\n    description: 'Duration of MCP operations in milliseconds',\r\n  },\r\n);\r\n\r\n// Active counters for monitoring\r\nconst activeSessionsGauge = meter.createUpDownCounter('mcp_active_sessions', {\r\n  description: 'Number of currently active MCP sessions',\r\n});\r\n\r\nconst activeToolCallsGauge = meter.createUpDownCounter(\r\n  'mcp_active_tool_calls',\r\n  {\r\n    description: 'Number of currently active MCP tool calls',\r\n  },\r\n);\r\n\r\nconst toolCallCounter = meter.createCounter('mcp_tool_calls_total', {\r\n  description: 'Total number of MCP tool calls initiated',\r\n});\r\n\r\nconst toolCallCompletionCounter = meter.createCounter(\r\n  'mcp_tool_call_completions_total',\r\n  {\r\n    description: 'Total number of MCP tool call completions',\r\n  },\r\n);\r\n\r\ninterface SpanState {\r\n  span: Span;\r\n  idleTimer: ReturnType<typeof setTimeout>;\r\n  createdAt: number;\r\n  messageCount: number;\r\n  lastActivity: number;\r\n  isToolCall?: boolean;\r\n  toolCallMethod?: string;\r\n}\r\n\r\ninterface OperationMetrics {\r\n  startTime: number;\r\n  operation: string;\r\n  messageId?: string | number;\r\n}\r\n\r\ninterface ActiveCounters {\r\n  sessions: number;\r\n  toolCalls: number;\r\n}\r\n\r\nconst IDLE_TIMEOUT_MS = 60 * 60 * 1000; // 60 minutes\r\nconst CONNECTION_TIMEOUT_MS = 30 * 1000; // 30 seconds for connection\r\nconst SEND_TIMEOUT_MS = 10 * 1000; // 10 seconds for sending messages\r\n\r\n// Tool call methods that initiate sessions\r\nconst TOOL_CALL_METHODS = new Set([\r\n  'tools/call',\r\n  'tools/list',\r\n  'tools/get',\r\n  'prompts/list',\r\n  'prompts/get',\r\n  'resources/list',\r\n  'resources/read',\r\n  'resources/subscribe',\r\n]);\r\n\r\ntype InstrumentedSseTransportOptions = {\r\n  url: string;\r\n  headers?: Record<string, string>;\r\n  onclose?: () => void;\r\n  onmessage?: (message: JSONRPCMessage) => void;\r\n  onerror: ((error: unknown) => void) | ((error: Error) => void);\r\n};\r\n\r\n/**\r\n * Instrumented SSE Transport with comprehensive OpenTelemetry support.\r\n *\r\n * Supports two operational modes:\r\n * - WARNING: High-level metrics and error reporting\r\n * - DEBUG: Detailed tracing of all operations and message flows\r\n *\r\n * Key Features:\r\n * - Active session and tool call tracking with UpDownCounters\r\n * - Distributed tracing with automatic parent/child span relationships\r\n * - Tool call lifecycle management (initiation to completion)\r\n * - Trace context injection for HTTP headers\r\n * - Manual debugging and counter reset capabilities\r\n * - Timeout handling for all async operations\r\n * - Safe error handling that never crashes the process\r\n *\r\n * Environment Variables:\r\n * - MCP_OTEL_MODE: 'WARNING' (default) or 'DEBUG'\r\n *\r\n * Public Methods:\r\n * - getActiveCounters(): Get current session and tool call counts\r\n * - resetActiveCounters(): Manually reset all counters to zero\r\n * - getSessionDebugInfo(): Get detailed session information\r\n * - forceCompleteToolCall(): Manually complete stuck tool calls\r\n * - getEnhancedHeaders(): Get headers with trace context\r\n * - updateHeadersWithTraceContext(): Update existing headers with trace context\r\n *\r\n * Static Methods:\r\n * - injectTraceContext(): Inject trace context into headers (can be used before construction)\r\n */\r\nexport class InstrumentedSseTransport extends SseMCPTransport {\r\n  #sessions = new Map<string, SpanState>();\r\n  #onmessage?: (message: JSONRPCMessage) => void;\r\n  #onerror: (error: unknown) => void;\r\n  #onclose?: () => void;\r\n  #transportSpan?: Span;\r\n  #connectionStartTime: number = 0;\r\n  #operationMetrics = new Map<string, OperationMetrics>();\r\n  #isClosing = false;\r\n  #activeCounters: ActiveCounters = { sessions: 0, toolCalls: 0 };\r\n\r\n  constructor(opts: InstrumentedSseTransportOptions) {\r\n    let constructorSpan: Span | undefined;\r\n\r\n    try {\r\n      // Start constructor instrumentation as child of current active span\r\n      constructorSpan = tracer.startSpan('mcp.transport.constructor', {\r\n        attributes: {\r\n          'mcp.transport.url': opts.url,\r\n          'mcp.transport.mode': OTEL_MODE,\r\n          'mcp.transport.has_headers': !!opts.headers,\r\n        },\r\n      });\r\n\r\n      if (DEBUG_MODE) {\r\n        log((l) =>\r\n          l.debug('Initializing InstrumentedSseTransport', {\r\n            data: {\r\n              url: opts.url,\r\n              mode: OTEL_MODE,\r\n              headers: opts.headers ? Object.keys(opts.headers) : [],\r\n            },\r\n          }),\r\n        );\r\n      }\r\n\r\n      // Inject trace context into headers for distributed tracing before calling super\r\n      const enhancedHeaders = InstrumentedSseTransport.injectTraceContext(\r\n        opts.headers || {},\r\n      );\r\n      super({ ...opts, headers: enhancedHeaders }); // Call the base constructor with enhanced headers\r\n\r\n      if (!opts.onerror) {\r\n        const error = new Error('onerror handler is required');\r\n        constructorSpan?.recordException(error);\r\n        constructorSpan?.setStatus({\r\n          code: SpanStatusCode.ERROR,\r\n          message: error.message,\r\n        });\r\n        throw error;\r\n      }\r\n\r\n      this.#onclose = opts.onclose;\r\n      this.#onmessage = opts.onmessage;\r\n      this.#onerror = this.#safeErrorHandler((e: unknown) => {\r\n        if (isError(e)) {\r\n          if (isAbortError(e)) {\r\n            log((l) =>\r\n              l.verbose(\r\n                `InstrumentedSseTransport (From error handler...) aborted; isClosing=${this.#isClosing}`,\r\n              ),\r\n            );\r\n          } else {\r\n            opts.onerror(e);\r\n          }\r\n        } else {\r\n          opts.onerror(new Error(String(e)));\r\n        }\r\n      });\r\n\r\n      // Override base callbacks with instrumented versions\r\n      super.onclose = this.#safeAsyncWrapper(\r\n        'handleClose',\r\n        this.handleClose.bind(this),\r\n      );\r\n      super.onerror = this.#safeAsyncWrapper(\r\n        'handleError',\r\n        this.handleError.bind(this),\r\n      );\r\n      super.onmessage = this.#safeAsyncWrapper(\r\n        'handleMessage',\r\n        this.handleMessage.bind(this),\r\n      );\r\n\r\n      // Record successful construction\r\n      connectionCounter.add(1, {\r\n        'mcp.transport.url': opts.url,\r\n        'mcp.transport.operation': 'constructor',\r\n        'mcp.transport.status': 'success',\r\n      });\r\n\r\n      constructorSpan?.setStatus({ code: SpanStatusCode.OK });\r\n\r\n      if (DEBUG_MODE) {\r\n        log((l) =>\r\n          l.debug('InstrumentedSseTransport initialized successfully'),\r\n        );\r\n      }\r\n    } catch (error) {\r\n      /*\r\n      if (isAbortError(error)) {\r\n        // Suppress abort errors; this is a disconnect not a construction failure.\r\n        const isClosing = this.#isClosing;\r\n        log((l) =>\r\n          l.verbose(\r\n            `InstrumentedSseTransport construction aborted; isClosing=${isClosing}`,\r\n          ),\r\n        );\r\n      }\r\n      */\r\n      error = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'MCP Transport Constructor',\r\n      });\r\n      // Record construction failure\r\n      connectionCounter.add(1, {\r\n        'mcp.transport.url': opts.url,\r\n        'mcp.transport.operation': 'constructor',\r\n        'mcp.transport.status': 'error',\r\n      });\r\n\r\n      errorCounter.add(1, {\r\n        'mcp.transport.operation': 'constructor',\r\n        'mcp.transport.error_type': isError(error) ? error.name : 'unknown',\r\n      });\r\n\r\n      constructorSpan?.recordException(error as Error);\r\n      constructorSpan?.setStatus({\r\n        code: SpanStatusCode.ERROR,\r\n        message: isError(error) ? error.message : String(error),\r\n      });\r\n      log((l) =>\r\n        l.error('Failed to initialize InstrumentedSseTransport', {\r\n          data: { error: isError(error) ? error.message : String(error) },\r\n        }),\r\n      );\r\n\r\n      throw error;\r\n    } finally {\r\n      constructorSpan?.end();\r\n    }\r\n  }\r\n\r\n  // === Safety Wrappers ===\r\n\r\n  /**\r\n   * Creates a safe wrapper for error handlers that never throws\r\n   */\r\n  #safeErrorHandler = (handler: (error: unknown) => void) => {\r\n    return (error: unknown) => {\r\n      try {\r\n        handler(error);\r\n      } catch (wrapperError) {\r\n        // Last resort logging - error handler itself failed\r\n        log((l) =>\r\n          l.error('Error handler failed', {\r\n            data: {\r\n              originalError: isError(error) ? error.message : String(error),\r\n              wrapperError: isError(wrapperError)\r\n                ? wrapperError.message\r\n                : String(wrapperError),\r\n            },\r\n          }),\r\n        );\r\n      }\r\n    };\r\n  };\r\n\r\n  /**\r\n   * Creates a safe async wrapper that catches all exceptions\r\n   */\r\n  #safeAsyncWrapper = <T extends unknown[], R>(\r\n    operationName: string,\r\n    fn: (...args: T) => R | Promise<R>,\r\n  ) => {\r\n    return async (...args: T): Promise<R | void> => {\r\n      const startTime = Date.now();\r\n      let span: Span | undefined;\r\n\r\n      try {\r\n        if (DEBUG_MODE) {\r\n          // Create span as child of current active span\r\n          span = tracer.startSpan(`mcp.transport.${operationName}`, {\r\n            attributes: {\r\n              'mcp.transport.operation': operationName,\r\n              'mcp.transport.url': this.url?.toString(),\r\n            },\r\n          });\r\n        }\r\n\r\n        const result = await fn(...args);\r\n\r\n        if (DEBUG_MODE) {\r\n          const duration = Date.now() - startTime;\r\n          operationDurationHistogram.record(duration, {\r\n            'mcp.transport.operation': operationName,\r\n            'mcp.transport.status': 'success',\r\n          });\r\n\r\n          span?.addEvent(`${operationName}.completed`, {\r\n            'mcp.transport.duration_ms': duration,\r\n          });\r\n          span?.setStatus({ code: SpanStatusCode.OK });\r\n        }\r\n\r\n        return result;\r\n      } catch (error) {\r\n        const duration = Date.now() - startTime;\r\n\r\n        // Record error metrics\r\n        errorCounter.add(1, {\r\n          'mcp.transport.operation': operationName,\r\n          'mcp.transport.error_type': isError(error) ? error.name : 'unknown',\r\n        });\r\n\r\n        operationDurationHistogram.record(duration, {\r\n          'mcp.transport.operation': operationName,\r\n          'mcp.transport.status': 'error',\r\n        });\r\n\r\n        span?.recordException(error as Error);\r\n        span?.setStatus({\r\n          code: SpanStatusCode.ERROR,\r\n          message: isError(error) ? error.message : String(error),\r\n        });\r\n\r\n        log((l) =>\r\n          l.error(`MCP Transport ${operationName} failed`, {\r\n            data: {\r\n              error: isError(error) ? error.message : String(error),\r\n              duration,\r\n              stack: isError(error) ? error.stack : undefined,\r\n            },\r\n          }),\r\n        );\r\n\r\n        // Convert to LoggedError and pass to error handler\r\n        const loggedError = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n          log: false, // Already logged above\r\n          source: `MCP Transport ${operationName}`,\r\n          data: { operationName, duration },\r\n        });\r\n\r\n        this.#onerror(loggedError);\r\n      } finally {\r\n        span?.end();\r\n      }\r\n    };\r\n  };\r\n\r\n  /**\r\n   * Records operation metrics for detailed tracking\r\n   */\r\n  #recordOperation = (\r\n    operation: string,\r\n    messageId?: string | number,\r\n  ): string => {\r\n    const operationId = `${operation}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n    this.#operationMetrics.set(operationId, {\r\n      startTime: Date.now(),\r\n      operation,\r\n      messageId,\r\n    });\r\n    return operationId;\r\n  };\r\n\r\n  /**\r\n   * Completes operation metrics tracking\r\n   */\r\n  #completeOperation = (\r\n    operationId: string,\r\n    status: 'success' | 'error' = 'success',\r\n  ) => {\r\n    const metrics = this.#operationMetrics.get(operationId);\r\n    if (metrics) {\r\n      const duration = Date.now() - metrics.startTime;\r\n      operationDurationHistogram.record(duration, {\r\n        'mcp.transport.operation': metrics.operation,\r\n        'mcp.transport.status': status,\r\n      });\r\n      this.#operationMetrics.delete(operationId);\r\n\r\n      if (DEBUG_MODE) {\r\n        log((l) =>\r\n          l.debug(`Operation ${metrics.operation} completed`, {\r\n            data: { duration, status, messageId: metrics.messageId },\r\n          }),\r\n        );\r\n      }\r\n    }\r\n  };\r\n\r\n  // === Property Overrides ===\r\n\r\n  override get onmessage(): ((message: JSONRPCMessage) => void) | undefined {\r\n    return this.#onmessage;\r\n  }\r\n\r\n  override set onmessage(\r\n    handler: ((message: JSONRPCMessage) => void) | undefined,\r\n  ) {\r\n    this.#onmessage = handler;\r\n  }\r\n\r\n  override get onerror(): (error: unknown) => void {\r\n    return this.#onerror;\r\n  }\r\n\r\n  override set onerror(handler: (error: unknown) => void) {\r\n    if (!handler) {\r\n      throw new Error('onerror handler is required');\r\n    }\r\n    this.#onerror = this.#safeErrorHandler(handler);\r\n  }\r\n\r\n  override get onclose(): (() => void) | undefined {\r\n    return this.#onclose;\r\n  }\r\n\r\n  override set onclose(handler: (() => void) | undefined) {\r\n    this.#onclose = handler;\r\n  }\r\n\r\n  toString(): string {\r\n    return `InstrumentedSseTransport(${this.url?.toString() || 'unknown'})`;\r\n  }\r\n  // === MCP Client Transport Methods ===\r\n\r\n  override async start(): Promise<void> {\r\n    let span: Span | undefined;\r\n    const operationId = this.#recordOperation('start');\r\n\r\n    try {\r\n      this.#connectionStartTime = Date.now();\r\n\r\n      // Create span as child of active span if one exists\r\n      span = tracer.startSpan('mcp.transport.start', {\r\n        attributes: {\r\n          'mcp.transport.url': this.url?.toString(),\r\n          'mcp.transport.mode': OTEL_MODE,\r\n        },\r\n      });\r\n\r\n      this.#transportSpan = span;\r\n\r\n      if (DEBUG_MODE) {\r\n        log((l) =>\r\n          l.debug('Starting MCP Client Transport', {\r\n            data: { url: this.url?.toString(), mode: OTEL_MODE },\r\n          }),\r\n        );\r\n      }\r\n\r\n      // Record connection attempt\r\n      connectionCounter.add(1, {\r\n        'mcp.transport.url': this.url?.toString() || 'unknown',\r\n        'mcp.transport.operation': 'start',\r\n        'mcp.transport.status': 'attempt',\r\n      });\r\n\r\n      // Apply connection timeout\r\n      await this.#withTimeout(\r\n        super.start(),\r\n        CONNECTION_TIMEOUT_MS,\r\n        'MCP connection',\r\n      );\r\n\r\n      // Record successful connection\r\n      connectionCounter.add(1, {\r\n        'mcp.transport.url': this.url?.toString() || 'unknown',\r\n        'mcp.transport.operation': 'start',\r\n        'mcp.transport.status': 'success',\r\n      });\r\n\r\n      span.setStatus({ code: SpanStatusCode.OK });\r\n      this.#completeOperation(operationId, 'success');\r\n\r\n      if (DEBUG_MODE) {\r\n        log((l) => l.debug('MCP Client Transport started successfully'));\r\n      }\r\n    } catch (error) {\r\n      if (isAbortError(error)) {\r\n        // Suppress abort errors; this is a disconnect not a construction failure.\r\n        const isClosing = this.#isClosing;\r\n        log((l) =>\r\n          l.verbose(\r\n            `InstrumentedSseTransport start() aborted; isClosing=${isClosing}`,\r\n          ),\r\n        );\r\n        return;\r\n      }\r\n      // Record failed connection\r\n      connectionCounter.add(1, {\r\n        'mcp.transport.url': this.url?.toString() || 'unknown',\r\n        'mcp.transport.operation': 'start',\r\n        'mcp.transport.status': 'error',\r\n      });\r\n\r\n      errorCounter.add(1, {\r\n        'mcp.transport.operation': 'start',\r\n        'mcp.transport.error_type': isError(error) ? error.name : 'unknown',\r\n      });\r\n\r\n      span?.recordException(error as Error);\r\n      span?.setStatus({\r\n        code: SpanStatusCode.ERROR,\r\n        message: isError(error) ? error.message : String(error),\r\n      });\r\n\r\n      this.#completeOperation(operationId, 'error');\r\n\r\n      log((l) =>\r\n        l.error('Failed to start MCP Client Transport', {\r\n          data: {\r\n            error: isError(error) ? error.message : String(error),\r\n            stack: isError(error) ? error.stack : undefined,\r\n          },\r\n        }),\r\n      );\r\n\r\n      throw error;\r\n    } finally {\r\n      // Don't end the transport span here - it should stay active for the connection duration\r\n    }\r\n  }\r\n\r\n  override async close(): Promise<void> {\r\n    let span: Span | undefined;\r\n    const operationId = this.#recordOperation('close');\r\n\r\n    try {\r\n      this.#isClosing = true;\r\n\r\n      span = tracer.startSpan('mcp.transport.close', {\r\n        attributes: {\r\n          'mcp.transport.url': this.url?.toString(),\r\n          'mcp.transport.session_count': this.#sessions.size,\r\n        },\r\n      });\r\n\r\n      if (DEBUG_MODE) {\r\n        log((l) =>\r\n          l.debug('Closing MCP Client Transport', {\r\n            data: {\r\n              url: this.url?.toString(),\r\n              sessionCount: this.#sessions.size,\r\n              connectionDuration: this.#connectionStartTime\r\n                ? Date.now() - this.#connectionStartTime\r\n                : 0,\r\n            },\r\n          }),\r\n        );\r\n      }\r\n\r\n      // Close all active sessions\r\n      for (const [, sessionState] of this.#sessions.entries()) {\r\n        const sessionDuration = Date.now() - sessionState.createdAt;\r\n        sessionDurationHistogram.record(sessionDuration, {\r\n          'mcp.transport.url': this.url?.toString() || 'unknown',\r\n          'mcp.transport.session_type': 'normal_close',\r\n        });\r\n\r\n        sessionState.span.addEvent('session.closing', {\r\n          'mcp.session.duration_ms': sessionDuration,\r\n          'mcp.session.message_count': sessionState.messageCount,\r\n        });\r\n        sessionState.span.setStatus({ code: SpanStatusCode.OK });\r\n        sessionState.span.end();\r\n        clearTimeout(sessionState.idleTimer);\r\n\r\n        // Decrement counters safely\r\n        this.#decrementCounter('sessions');\r\n        if (sessionState.isToolCall) {\r\n          this.#decrementCounter('toolCalls');\r\n\r\n          // Record tool call completion\r\n          toolCallCompletionCounter.add(1, {\r\n            'mcp.transport.url': this.url?.toString() || 'unknown',\r\n            'mcp.tool.method': sessionState.toolCallMethod || 'unknown',\r\n            'mcp.tool.completion_reason': 'transport_close',\r\n          });\r\n        }\r\n      }\r\n      this.#sessions.clear();\r\n\r\n      await super.close();\r\n\r\n      // End the transport span\r\n      if (this.#transportSpan) {\r\n        const connectionDuration = this.#connectionStartTime\r\n          ? Date.now() - this.#connectionStartTime\r\n          : 0;\r\n        this.#transportSpan.addEvent('transport.closed', {\r\n          'mcp.transport.duration_ms': connectionDuration,\r\n        });\r\n        this.#transportSpan.setStatus({ code: SpanStatusCode.OK });\r\n        this.#transportSpan.end();\r\n      }\r\n\r\n      span.setStatus({ code: SpanStatusCode.OK });\r\n      this.#completeOperation(operationId, 'success');\r\n\r\n      if (DEBUG_MODE) {\r\n        log((l) => l.debug('MCP Client Transport closed successfully'));\r\n      }\r\n    } catch (error) {\r\n      errorCounter.add(1, {\r\n        'mcp.transport.operation': 'close',\r\n        'mcp.transport.error_type': isError(error) ? error.name : 'unknown',\r\n      });\r\n\r\n      span?.recordException(error as Error);\r\n      span?.setStatus({\r\n        code: SpanStatusCode.ERROR,\r\n        message: isError(error) ? error.message : String(error),\r\n      });\r\n\r\n      this.#completeOperation(operationId, 'error');\r\n\r\n      log((l) =>\r\n        l.error('Failed to close MCP Client Transport', {\r\n          data: { error: isError(error) ? error.message : String(error) },\r\n        }),\r\n      );\r\n\r\n      throw error;\r\n    } finally {\r\n      span?.end();\r\n    }\r\n  }\r\n\r\n  override async send(message: JSONRPCMessage): Promise<void> {\r\n    let span: Span | undefined;\r\n    const messageId = this.#getMessageId(message);\r\n    const messageMethod = this.#getMessageMethod(message);\r\n    const operationId = this.#recordOperation('send', messageId);\r\n\r\n    try {\r\n      const messageStr = JSON.stringify(message);\r\n      const messageSize = new TextEncoder().encode(messageStr).length;\r\n\r\n      // Create span as child of active span if one exists\r\n      span = tracer.startSpan('mcp.transport.send', {\r\n        attributes: {\r\n          'mcp.transport.url': this.url?.toString(),\r\n          'mcp.message.id': String(messageId || 'unknown'),\r\n          'mcp.message.method': messageMethod || 'unknown',\r\n          'mcp.message.size_bytes': messageSize,\r\n        },\r\n      });\r\n\r\n      // Check if this is a tool call and track it\r\n      const isToolCall = messageMethod && TOOL_CALL_METHODS.has(messageMethod);\r\n\r\n      // Create or update session for this message if it has an ID\r\n      let sessionState: SpanState | undefined;\r\n      if (messageId) {\r\n        sessionState = this.#getOrCreateSession(message);\r\n\r\n        // If this is a new session, increment session counter\r\n        if (sessionState && sessionState.messageCount === 1) {\r\n          this.#incrementCounter('sessions');\r\n        }\r\n\r\n        // If this is a tool call and session wasn't already marked as tool call\r\n        if (sessionState && isToolCall && !sessionState.isToolCall) {\r\n          sessionState.isToolCall = true;\r\n          sessionState.toolCallMethod = messageMethod;\r\n          this.#incrementCounter('toolCalls');\r\n\r\n          toolCallCounter.add(1, {\r\n            'mcp.transport.url': this.url?.toString() || 'unknown',\r\n            'mcp.tool.method': messageMethod || 'unknown',\r\n          });\r\n        }\r\n      }\r\n\r\n      // Record message metrics\r\n      messageCounter.add(1, {\r\n        'mcp.transport.url': this.url?.toString() || 'unknown',\r\n        'mcp.transport.direction': 'outbound',\r\n        'mcp.message.method': messageMethod || 'unknown',\r\n      });\r\n\r\n      messageSizeHistogram.record(messageSize, {\r\n        'mcp.transport.direction': 'outbound',\r\n        'mcp.message.method': messageMethod || 'unknown',\r\n      });\r\n\r\n      if (DEBUG_MODE) {\r\n        log((l) =>\r\n          l.debug('Sending MCP Client Message', {\r\n            data: {\r\n              messageId,\r\n              method: messageMethod,\r\n              size: messageSize,\r\n              url: this.url?.toString(),\r\n              isToolCall,\r\n            },\r\n          }),\r\n        );\r\n      }\r\n\r\n      // Apply send timeout\r\n      await this.#withTimeout(\r\n        super.send(message),\r\n        SEND_TIMEOUT_MS,\r\n        'MCP message send',\r\n      );\r\n\r\n      span.setStatus({ code: SpanStatusCode.OK });\r\n      this.#completeOperation(operationId, 'success');\r\n\r\n      if (DEBUG_MODE) {\r\n        log((l) =>\r\n          l.debug('MCP Client Message sent successfully', {\r\n            data: { messageId, method: messageMethod },\r\n          }),\r\n        );\r\n      }\r\n    } catch (error) {\r\n      errorCounter.add(1, {\r\n        'mcp.transport.operation': 'send',\r\n        'mcp.transport.error_type': isError(error) ? error.name : 'unknown',\r\n        'mcp.message.method': messageMethod || 'unknown',\r\n      });\r\n\r\n      span?.recordException(error as Error);\r\n      span?.setStatus({\r\n        code: SpanStatusCode.ERROR,\r\n        message: isError(error) ? error.message : String(error),\r\n      });\r\n\r\n      this.#completeOperation(operationId, 'error');\r\n\r\n      log((l) =>\r\n        l.error('Failed to send MCP Client Message', {\r\n          data: {\r\n            messageId,\r\n            method: messageMethod,\r\n            error: isError(error) ? error.message : String(error),\r\n          },\r\n        }),\r\n      );\r\n\r\n      throw error;\r\n    } finally {\r\n      span?.end();\r\n    }\r\n  }\r\n\r\n  // === Helper Functions ===\r\n\r\n  /**\r\n   * Type guard to check if message has an id property\r\n   */\r\n  #hasId = (\r\n    message: JSONRPCMessage,\r\n  ): message is JSONRPCMessage & { id: string | number } => {\r\n    return 'id' in message && message.id !== undefined;\r\n  };\r\n\r\n  /**\r\n   * Type guard to check if message has a method property\r\n   */\r\n  #hasMethod = (\r\n    message: JSONRPCMessage,\r\n  ): message is JSONRPCMessage & { method: string } => {\r\n    return 'method' in message && typeof message.method === 'string';\r\n  };\r\n\r\n  /**\r\n   * Safely gets the message ID\r\n   */\r\n  #getMessageId = (message: JSONRPCMessage): string | number | undefined => {\r\n    return this.#hasId(message) ? message.id : undefined;\r\n  };\r\n\r\n  /**\r\n   * Safely gets the message method\r\n   */\r\n  #getMessageMethod = (message: JSONRPCMessage): string | undefined => {\r\n    return this.#hasMethod(message) ? message.method : undefined;\r\n  };\r\n\r\n  /**\r\n   * Creates or updates session state for message tracking\r\n   */\r\n  #getOrCreateSession = (message: JSONRPCMessage): SpanState | undefined => {\r\n    const messageId = this.#getMessageId(message);\r\n    if (!messageId) return undefined;\r\n\r\n    const sessionId = String(messageId);\r\n    let sessionState = this.#sessions.get(sessionId);\r\n\r\n    if (!sessionState) {\r\n      if (DEBUG_MODE) {\r\n        log((l) =>\r\n          l.debug('Creating new MCP session', {\r\n            data: { sessionId, method: this.#getMessageMethod(message) },\r\n          }),\r\n        );\r\n      }\r\n\r\n      // Create session span as child of current active span\r\n      const span = tracer.startSpan('mcp.session', {\r\n        attributes: {\r\n          'mcp.session.id': sessionId,\r\n          'mcp.session.created_at': Date.now(),\r\n          'mcp.transport.url': this.url?.toString(),\r\n          'mcp.session.initiating_method':\r\n            this.#getMessageMethod(message) || 'unknown',\r\n        },\r\n      });\r\n\r\n      sessionState = {\r\n        span,\r\n        idleTimer: this.#setIdleTimer(sessionId),\r\n        createdAt: Date.now(),\r\n        messageCount: 0,\r\n        lastActivity: Date.now(),\r\n      };\r\n\r\n      this.#sessions.set(sessionId, sessionState);\r\n    }\r\n\r\n    // Update activity\r\n    sessionState.messageCount++;\r\n    sessionState.lastActivity = Date.now();\r\n    clearTimeout(sessionState.idleTimer);\r\n    sessionState.idleTimer = this.#setIdleTimer(sessionId);\r\n\r\n    return sessionState;\r\n  };\r\n\r\n  /**\r\n   * Sets up idle timer for session cleanup\r\n   */\r\n  #setIdleTimer = (sessionId: string): ReturnType<typeof setTimeout> => {\r\n    return setTimeout(() => {\r\n      try {\r\n        const sessionState = this.#sessions.get(sessionId);\r\n        if (sessionState && !this.#isClosing) {\r\n          const sessionDuration = Date.now() - sessionState.createdAt;\r\n\r\n          sessionDurationHistogram.record(sessionDuration, {\r\n            'mcp.transport.url': this.url?.toString() || 'unknown',\r\n            'mcp.transport.session_type': 'idle_timeout',\r\n          });\r\n\r\n          sessionState.span.addEvent('session.idle_timeout', {\r\n            'mcp.session.duration_ms': sessionDuration,\r\n            'mcp.session.message_count': sessionState.messageCount,\r\n          });\r\n          sessionState.span.setStatus({ code: SpanStatusCode.OK });\r\n          sessionState.span.end();\r\n\r\n          // Decrement counters before removing session\r\n          this.#decrementCounter('sessions');\r\n          if (sessionState.isToolCall) {\r\n            this.#decrementCounter('toolCalls');\r\n\r\n            // Record tool call completion\r\n            toolCallCompletionCounter.add(1, {\r\n              'mcp.transport.url': this.url?.toString() || 'unknown',\r\n              'mcp.tool.method': sessionState.toolCallMethod || 'unknown',\r\n              'mcp.tool.completion_reason': 'idle_timeout',\r\n            });\r\n          }\r\n\r\n          this.#sessions.delete(sessionId);\r\n\r\n          if (DEBUG_MODE) {\r\n            log((l) =>\r\n              l.debug('Session idle timeout', {\r\n                data: {\r\n                  sessionId,\r\n                  duration: sessionDuration,\r\n                  messageCount: sessionState.messageCount,\r\n                },\r\n              }),\r\n            );\r\n          }\r\n        }\r\n      } catch (error) {\r\n        log((l) =>\r\n          l.error('Error in session idle timer', {\r\n            data: {\r\n              sessionId,\r\n              error: isError(error) ? error.message : String(error),\r\n            },\r\n          }),\r\n        );\r\n      }\r\n    }, IDLE_TIMEOUT_MS);\r\n  };\r\n\r\n  /**\r\n   * Gets the current count of active sessions and tool calls\r\n   */\r\n  getActiveCounters(): { sessions: number; toolCalls: number } {\r\n    return { ...this.#activeCounters };\r\n  }\r\n\r\n  /**\r\n   * Manually resets all active counters to zero\r\n   * Use this when you suspect counters are out of sync due to errors\r\n   */\r\n  resetActiveCounters(): void {\r\n    if (DEBUG_MODE) {\r\n      log((l) =>\r\n        l.debug('Manually resetting active counters', {\r\n          data: {\r\n            previousSessions: this.#activeCounters.sessions,\r\n            previousToolCalls: this.#activeCounters.toolCalls,\r\n          },\r\n        }),\r\n      );\r\n    }\r\n\r\n    // Update metrics to reflect the reset\r\n    activeSessionsGauge.add(-this.#activeCounters.sessions);\r\n    activeToolCallsGauge.add(-this.#activeCounters.toolCalls);\r\n\r\n    this.#activeCounters = { sessions: 0, toolCalls: 0 };\r\n\r\n    log((l) => l.warn('Active counters have been manually reset to zero'));\r\n  }\r\n\r\n  /**\r\n   * Gets current session information for debugging\r\n   */\r\n  getSessionDebugInfo(): Array<{\r\n    sessionId: string;\r\n    messageCount: number;\r\n    duration: number;\r\n    isToolCall: boolean;\r\n    toolCallMethod?: string;\r\n    lastActivity: number;\r\n  }> {\r\n    const now = Date.now();\r\n    return Array.from(this.#sessions.entries()).map(([sessionId, state]) => ({\r\n      sessionId,\r\n      messageCount: state.messageCount,\r\n      duration: now - state.createdAt,\r\n      isToolCall: !!state.isToolCall,\r\n      toolCallMethod: state.toolCallMethod,\r\n      lastActivity: now - state.lastActivity,\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Manually completes a stuck tool call session\r\n   * Use this when a tool call seems to be hanging\r\n   */\r\n  forceCompleteToolCall(\r\n    sessionId: string,\r\n    reason: string = 'manual_completion',\r\n  ): boolean {\r\n    const sessionState = this.#sessions.get(sessionId);\r\n    if (!sessionState || !sessionState.isToolCall) {\r\n      return false;\r\n    }\r\n\r\n    const sessionDuration = Date.now() - sessionState.createdAt;\r\n\r\n    sessionState.span.addEvent('tool.call.force_completed', {\r\n      'mcp.session.duration_ms': sessionDuration,\r\n      'mcp.session.message_count': sessionState.messageCount,\r\n      'mcp.tool.completion_reason': reason,\r\n    });\r\n\r\n    sessionState.span.setStatus({ code: SpanStatusCode.OK });\r\n    sessionState.span.end();\r\n    clearTimeout(sessionState.idleTimer);\r\n\r\n    // Decrement counters\r\n    this.#decrementCounter('sessions');\r\n    this.#decrementCounter('toolCalls');\r\n\r\n    // Record tool call completion\r\n    toolCallCompletionCounter.add(1, {\r\n      'mcp.transport.url': this.url?.toString() || 'unknown',\r\n      'mcp.tool.method': sessionState.toolCallMethod || 'unknown',\r\n      'mcp.tool.completion_reason': reason,\r\n    });\r\n\r\n    this.#sessions.delete(sessionId);\r\n\r\n    log((l) =>\r\n      l.warn('Tool call manually completed', {\r\n        data: {\r\n          sessionId,\r\n          duration: sessionDuration,\r\n          reason,\r\n          method: sessionState.toolCallMethod,\r\n        },\r\n      }),\r\n    );\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Gets enhanced headers with trace context for HTTP requests\r\n   * This method can be used by callers to get headers with trace context included\r\n   */\r\n  getEnhancedHeaders(\r\n    baseHeaders: Record<string, string> = {},\r\n  ): Record<string, string> {\r\n    return this.#injectTraceContext(baseHeaders);\r\n  }\r\n\r\n  /**\r\n   * Updates existing headers object with trace context in place\r\n   * Returns true if trace context was injected, false otherwise\r\n   */\r\n  updateHeadersWithTraceContext(headers: Record<string, string>): boolean {\r\n    const originalKeyCount = Object.keys(headers).length;\r\n    const enhancedHeaders = this.#injectTraceContext(headers);\r\n\r\n    // Copy new headers to the original object\r\n    Object.assign(headers, enhancedHeaders);\r\n\r\n    const wasInjected = Object.keys(headers).length > originalKeyCount;\r\n\r\n    if (wasInjected && DEBUG_MODE) {\r\n      log((l) =>\r\n        l.debug('Trace context updated in existing headers', {\r\n          data: {\r\n            originalKeys: originalKeyCount,\r\n            newKeys: Object.keys(headers).length,\r\n          },\r\n        }),\r\n      );\r\n    }\r\n\r\n    return wasInjected;\r\n  }\r\n\r\n  /**\r\n   * Static method to inject trace context into HTTP headers for distributed tracing\r\n   * This can be called before the instance is created\r\n   */\r\n  static injectTraceContext(\r\n    headers: Record<string, string> = {},\r\n  ): Record<string, string> {\r\n    const activeSpan = trace.getActiveSpan();\r\n    if (activeSpan) {\r\n      const spanContext = activeSpan.spanContext();\r\n      if (spanContext.traceId && spanContext.spanId) {\r\n        headers['traceparent'] =\r\n          `00-${spanContext.traceId}-${spanContext.spanId}-${spanContext.traceFlags?.toString(16).padStart(2, '0') || '01'}`;\r\n\r\n        if (DEBUG_MODE) {\r\n          log((l) =>\r\n            l.debug('Injected trace context into headers (static)', {\r\n              data: {\r\n                traceId: spanContext.traceId,\r\n                spanId: spanContext.spanId,\r\n                traceFlags: spanContext.traceFlags,\r\n              },\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n    return headers;\r\n  }\r\n\r\n  /**\r\n   * Instance method to inject trace context into HTTP headers for distributed tracing\r\n   */\r\n  #injectTraceContext = (\r\n    headers: Record<string, string> = {},\r\n  ): Record<string, string> => {\r\n    return InstrumentedSseTransport.injectTraceContext(headers);\r\n  };\r\n\r\n  /**\r\n   * Creates a timeout wrapper for async operations\r\n   */\r\n  #withTimeout = <T>(\r\n    promise: Promise<T>,\r\n    timeoutMs: number,\r\n    operation: string,\r\n  ): Promise<T> => {\r\n    return Promise.race([\r\n      promise,\r\n      new Promise<never>((_, reject) => {\r\n        setTimeout(() => {\r\n          const error = new Error(\r\n            `${operation} timed out after ${timeoutMs}ms`,\r\n          );\r\n          error.name = 'TimeoutError';\r\n          reject(error);\r\n        }, timeoutMs);\r\n      }),\r\n    ]);\r\n  };\r\n\r\n  /**\r\n   * Safely increments active counters\r\n   */\r\n  #incrementCounter = (\r\n    type: 'sessions' | 'toolCalls',\r\n    amount: number = 1,\r\n  ): void => {\r\n    this.#activeCounters[type] = Math.max(\r\n      0,\r\n      this.#activeCounters[type] + amount,\r\n    );\r\n\r\n    if (type === 'sessions') {\r\n      activeSessionsGauge.add(amount);\r\n    } else {\r\n      activeToolCallsGauge.add(amount);\r\n    }\r\n\r\n    if (DEBUG_MODE) {\r\n      log((l) =>\r\n        l.debug(`Incremented ${type} counter`, {\r\n          data: { amount, newValue: this.#activeCounters[type] },\r\n        }),\r\n      );\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Safely decrements active counters (never goes below 0)\r\n   */\r\n  #decrementCounter = (\r\n    type: 'sessions' | 'toolCalls',\r\n    amount: number = 1,\r\n  ): void => {\r\n    const oldValue = this.#activeCounters[type];\r\n    this.#activeCounters[type] = Math.max(\r\n      0,\r\n      this.#activeCounters[type] - amount,\r\n    );\r\n    const actualDecrement = oldValue - this.#activeCounters[type];\r\n\r\n    if (type === 'sessions') {\r\n      activeSessionsGauge.add(-actualDecrement);\r\n    } else {\r\n      activeToolCallsGauge.add(-actualDecrement);\r\n    }\r\n\r\n    if (DEBUG_MODE) {\r\n      log((l) =>\r\n        l.debug(`Decremented ${type} counter`, {\r\n          data: {\r\n            requestedAmount: amount,\r\n            actualAmount: actualDecrement,\r\n            newValue: this.#activeCounters[type],\r\n          },\r\n        }),\r\n      );\r\n    }\r\n  };\r\n\r\n  private handleClose() {\r\n    log((l) => l.verbose('MCP Client Transport Closed'));\r\n    try {\r\n      this.#onclose?.(); // pass through to client\r\n    } catch (e) {\r\n      log((l) => l.error('Error handling MCP Client Transport close:', e));\r\n    }\r\n  }\r\n\r\n  private handleMessage(message: JSONRPCMessage) {\r\n    log((l) => l.verbose('MCP Client Transport Message Received:', message));\r\n\r\n    try {\r\n      // Check if this is a response to a tool call and handle completion\r\n      const messageId = this.#getMessageId(message);\r\n      if (messageId) {\r\n        const sessionId = String(messageId);\r\n        const sessionState = this.#sessions.get(sessionId);\r\n\r\n        // If this is a response (has result or error) and the session was a tool call\r\n        if (\r\n          sessionState &&\r\n          sessionState.isToolCall &&\r\n          ('result' in message || 'error' in message)\r\n        ) {\r\n          const sessionDuration = Date.now() - sessionState.createdAt;\r\n\r\n          sessionDurationHistogram.record(sessionDuration, {\r\n            'mcp.transport.url': this.url?.toString() || 'unknown',\r\n            'mcp.transport.session_type': 'tool_call_response',\r\n          });\r\n\r\n          sessionState.span.addEvent('tool.call.completed', {\r\n            'mcp.session.duration_ms': sessionDuration,\r\n            'mcp.session.message_count': sessionState.messageCount,\r\n            'mcp.tool.success': !('error' in message),\r\n          });\r\n\r\n          sessionState.span.setStatus({ code: SpanStatusCode.OK });\r\n          sessionState.span.end();\r\n          clearTimeout(sessionState.idleTimer);\r\n\r\n          // Decrement counters\r\n          this.#decrementCounter('sessions');\r\n          this.#decrementCounter('toolCalls');\r\n\r\n          // Record tool call completion\r\n          toolCallCompletionCounter.add(1, {\r\n            'mcp.transport.url': this.url?.toString() || 'unknown',\r\n            'mcp.tool.method': sessionState.toolCallMethod || 'unknown',\r\n            'mcp.tool.completion_reason':\r\n              'error' in message ? 'error' : 'success',\r\n          });\r\n\r\n          this.#sessions.delete(sessionId);\r\n\r\n          if (DEBUG_MODE) {\r\n            log((l) =>\r\n              l.debug('Tool call completed', {\r\n                data: {\r\n                  sessionId,\r\n                  duration: sessionDuration,\r\n                  success: !('error' in message),\r\n                  method: sessionState.toolCallMethod,\r\n                },\r\n              }),\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      this.#onmessage?.(message); // pass through to client\r\n    } catch (e) {\r\n      log((l) => l.error('Error handling MCP Client Transport message:', e));\r\n    }\r\n  }\r\n\r\n  private handleError(error: unknown) {\r\n    const le = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: 'MCP Client Transport',\r\n      data: {\r\n        details: 'Error occurred in MCP Client Transport',\r\n      },\r\n    });\r\n    try {\r\n      this.#onerror(le); // pass through to client\r\n    } catch (e) {\r\n      log((l) => l.error('Error handling MCP Client Transport error:', e));\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * TransportPlugin interface for MCP Client Transport plugins\r\n */\r\nexport interface TransportPlugin {\r\n  onMessage?(message: JSONRPCMessage): void;\r\n  onError?(error: Error): void;\r\n  onClose?(): void;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\instrumented-sse-transport\\tracing\\trace-context.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":8,"column":1,"nodeType":"Program","endLine":85,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Trace Context Management for MCP Transport\r\n *\r\n * This module handles distributed tracing support with trace context injection\r\n * for HTTP headers.\r\n */\r\n\r\nimport { trace } from '@opentelemetry/api';\r\nimport { log } from '@/lib/logger';\r\nimport { DEBUG_MODE } from '../metrics/otel-metrics';\r\n\r\n/**\r\n * Manages trace context injection for distributed tracing\r\n */\r\nexport class TraceContextManager {\r\n  /**\r\n   * Static method to inject trace context into HTTP headers for distributed tracing\r\n   * This can be called before the instance is created\r\n   */\r\n  static injectTraceContext(\r\n    headers: Record<string, string> = {},\r\n  ): Record<string, string> {\r\n    const activeSpan = trace.getActiveSpan();\r\n    if (activeSpan) {\r\n      const spanContext = activeSpan.spanContext();\r\n      if (spanContext.traceId && spanContext.spanId) {\r\n        headers['traceparent'] =\r\n          `00-${spanContext.traceId}-${spanContext.spanId}-${spanContext.traceFlags?.toString(16).padStart(2, '0') || '01'}`;\r\n\r\n        if (DEBUG_MODE) {\r\n          log((l) =>\r\n            l.debug('Injected trace context into headers (static)', {\r\n              data: {\r\n                traceId: spanContext.traceId,\r\n                spanId: spanContext.spanId,\r\n                traceFlags: spanContext.traceFlags,\r\n              },\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n    return headers;\r\n  }\r\n\r\n  /**\r\n   * Gets enhanced headers with trace context for HTTP requests\r\n   * This method can be used by callers to get headers with trace context included\r\n   */\r\n  static getEnhancedHeaders(\r\n    baseHeaders: Record<string, string> = {},\r\n  ): Record<string, string> {\r\n    return TraceContextManager.injectTraceContext(baseHeaders);\r\n  }\r\n\r\n  /**\r\n   * Updates existing headers object with trace context in place\r\n   * Returns true if trace context was injected, false otherwise\r\n   */\r\n  static updateHeadersWithTraceContext(\r\n    headers: Record<string, string>,\r\n  ): boolean {\r\n    const originalKeyCount = Object.keys(headers).length;\r\n    const enhancedHeaders = TraceContextManager.injectTraceContext(headers);\r\n\r\n    // Copy new headers to the original object\r\n    Object.assign(headers, enhancedHeaders);\r\n\r\n    const wasInjected = Object.keys(headers).length > originalKeyCount;\r\n\r\n    if (wasInjected && DEBUG_MODE) {\r\n      log((l) =>\r\n        l.debug('Trace context updated in existing headers', {\r\n          data: {\r\n            originalKeys: originalKeyCount,\r\n            newKeys: Object.keys(headers).length,\r\n          },\r\n        }),\r\n      );\r\n    }\r\n\r\n    return wasInjected;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\instrumented-sse-transport\\utils\\safety-utils.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":8,"column":1,"nodeType":"Program","endLine":206,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Safety Utilities for MCP Transport\r\n *\r\n * This module provides error handling wrappers, timeout utilities, and\r\n * safe operation patterns.\r\n */\r\n\r\nimport { Span, SpanStatusCode } from '@opentelemetry/api';\r\nimport { tracer, MetricsRecorder, DEBUG_MODE } from '../metrics/otel-metrics';\r\nimport { isError } from '@/lib/react-util/utility-methods';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { log } from '@/lib/logger';\r\n\r\n// Timeout constants\r\nexport const CONNECTION_TIMEOUT_MS = 30 * 1000; // 30 seconds for connection\r\nexport const SEND_TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes for sending messages\r\n\r\nexport interface OperationMetrics {\r\n  startTime: number;\r\n  operation: string;\r\n  messageId?: string | number;\r\n}\r\n\r\n/**\r\n * Provides safety utilities for async operations and error handling\r\n */\r\nexport class SafetyUtils {\r\n  #operationMetrics = new Map<string, OperationMetrics>();\r\n  #url: string;\r\n\r\n  constructor(url: string) {\r\n    this.#url = url;\r\n  }\r\n\r\n  /**\r\n   * Creates a safe wrapper for error handlers that never throws\r\n   */\r\n  createSafeErrorHandler(\r\n    handler: (error: unknown) => void,\r\n  ): (error: unknown) => void {\r\n    return (error: unknown) => {\r\n      try {\r\n        handler(error);\r\n      } catch (wrapperError) {\r\n        // Last resort logging - error handler itself failed\r\n        log((l) =>\r\n          l.error('Error handler failed', {\r\n            data: {\r\n              originalError: isError(error) ? error.message : String(error),\r\n              wrapperError: isError(wrapperError)\r\n                ? wrapperError.message\r\n                : String(wrapperError),\r\n            },\r\n          }),\r\n        );\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Creates a safe async wrapper that catches all exceptions\r\n   */\r\n  createSafeAsyncWrapper<T extends unknown[], R>(\r\n    operationName: string,\r\n    fn: (...args: T) => R | Promise<R>,\r\n    errorHandler: (error: unknown) => void,\r\n  ): (...args: T) => Promise<R | void> {\r\n    return async (...args: T): Promise<R | void> => {\r\n      const startTime = Date.now();\r\n      let span: Span | undefined;\r\n\r\n      try {\r\n        if (DEBUG_MODE) {\r\n          // Create span as child of current active span\r\n          span = tracer.startSpan(`mcp.transport.${operationName}`, {\r\n            attributes: {\r\n              'mcp.transport.operation': operationName,\r\n              'mcp.transport.url': this.#url,\r\n            },\r\n          });\r\n        }\r\n\r\n        const result = await fn(...args);\r\n\r\n        if (DEBUG_MODE) {\r\n          const duration = Date.now() - startTime;\r\n          MetricsRecorder.recordOperationDuration(\r\n            duration,\r\n            operationName,\r\n            'success',\r\n          );\r\n\r\n          span?.addEvent(`${operationName}.completed`, {\r\n            'mcp.transport.duration_ms': duration,\r\n          });\r\n          span?.setStatus({ code: SpanStatusCode.OK });\r\n        }\r\n\r\n        return result;\r\n      } catch (error) {\r\n        const duration = Date.now() - startTime;\r\n\r\n        // Record error metrics\r\n        MetricsRecorder.recordError(\r\n          operationName,\r\n          isError(error) ? error.name : 'unknown',\r\n        );\r\n        MetricsRecorder.recordOperationDuration(\r\n          duration,\r\n          operationName,\r\n          'error',\r\n        );\r\n\r\n        span?.recordException(error as Error);\r\n        span?.setStatus({\r\n          code: SpanStatusCode.ERROR,\r\n          message: isError(error) ? error.message : String(error),\r\n        });\r\n\r\n        log((l) =>\r\n          l.error(`MCP Transport ${operationName} failed`, {\r\n            data: {\r\n              error: isError(error) ? error.message : String(error),\r\n              duration,\r\n              stack: isError(error) ? error.stack : undefined,\r\n            },\r\n          }),\r\n        );\r\n\r\n        // Convert to LoggedError and pass to error handler\r\n        const loggedError = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n          log: false, // Already logged above\r\n          source: `MCP Transport ${operationName}`,\r\n          data: { operationName, duration },\r\n        });\r\n\r\n        errorHandler(loggedError);\r\n      } finally {\r\n        span?.end();\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Records operation metrics for detailed tracking\r\n   */\r\n  recordOperation(operation: string, messageId?: string | number): string {\r\n    const operationId = `${operation}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n    this.#operationMetrics.set(operationId, {\r\n      startTime: Date.now(),\r\n      operation,\r\n      messageId,\r\n    });\r\n    return operationId;\r\n  }\r\n\r\n  /**\r\n   * Completes operation metrics tracking\r\n   */\r\n  completeOperation(\r\n    operationId: string,\r\n    status: 'success' | 'error' = 'success',\r\n  ) {\r\n    const metrics = this.#operationMetrics.get(operationId);\r\n    if (metrics) {\r\n      const duration = Date.now() - metrics.startTime;\r\n      MetricsRecorder.recordOperationDuration(\r\n        duration,\r\n        metrics.operation,\r\n        status,\r\n      );\r\n      this.#operationMetrics.delete(operationId);\r\n\r\n      if (DEBUG_MODE) {\r\n        log((l) =>\r\n          l.debug(`Operation ${metrics.operation} completed`, {\r\n            data: { duration, status, messageId: metrics.messageId },\r\n          }),\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a timeout wrapper for async operations\r\n   */\r\n  withTimeout<T>(\r\n    promise: Promise<T>,\r\n    timeoutMs: number,\r\n    operation: string,\r\n  ): Promise<T> {\r\n    return Promise.race([\r\n      promise,\r\n      new Promise<never>((_, reject) => {\r\n        setTimeout(() => {\r\n          const error = new Error(\r\n            `${operation} timed out after ${timeoutMs}ms`,\r\n          );\r\n          error.name = 'TimeoutError';\r\n          reject(error);\r\n        }, timeoutMs);\r\n      }),\r\n    ]);\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\providers\\client-tool-provider.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":67,"column":1,"nodeType":"Program","endLine":136,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Client-side MCP (Model Context Protocol) Tool Provider Factory\r\n * ------------------------------------------------------------------\r\n * Produces a lightweight {@link ConnectableToolProvider} implementation that\r\n * exposes a curated set of UI‑mediated tools to AI model runtimes on the\r\n * client. These tools let an agent request user interaction (confirmation)\r\n * or trigger UI navigation (open a case file) while keeping the transport\r\n * and connection lifecycle abstracted behind a stable interface.\r\n *\r\n * DESIGN GOALS\r\n * 1. Deterministic: No side effects at construction; the returned provider\r\n *    reports an already-connected state (`get_isConnected() === true`).\r\n * 2. Type Safety: Zod schemas define tool parameter contracts so both AI\r\n *    orchestration and UI layers can validate inputs at runtime and derive\r\n *    TypeScript types at compile time.\r\n * 3. Extensibility: Add additional tools by appending entries to the\r\n *    `clientSideTools` map—each key becomes a callable tool name.\r\n * 4. Separation of Concerns: The factory does not perform actual MCP socket\r\n *    or transport work—it returns a stubbed `MCPClient` object. Real\r\n *    connectivity can be injected later or swapped behind the same surface.\r\n *\r\n * TOOLS EXPOSED\r\n * - askConfirmation\r\n *   Purpose: Prompt the human user to approve or reject an agent action.\r\n *   Return Contract (expected by upstream code): A confirmation hash (string)\r\n *   when accepted, or empty string on denial. (Actual implementation supplied\r\n *   elsewhere—this factory only declares the shape.)\r\n *   Parameters:\r\n *     question (string, required) – The prompt presented to the user.\r\n *     options (string[]?, optional) – Discrete selection list; absent => simple yes/no.\r\n *\r\n * - openCaseFile\r\n *   Purpose: Instruct the UI to focus/open a particular investigative case\r\n *   and optionally deep‑link to a specific page/section.\r\n *   Parameters:\r\n *     caseId (string, required) – Case identifier.\r\n *     page (enum?, optional) – One of: 'email', 'call-to-action',\r\n *       'call-to-action-response', 'email-header', 'key-points', 'notes'.\r\n *       Defaults to 'email' if omitted.\r\n *     confirmation (string?, optional) – Hash from prior askConfirmation call;\r\n *       if absent, UI may re‑prompt for confirmation before navigation.\r\n *\r\n * USAGE EXAMPLE\r\n * ```ts\r\n * import { clientToolProviderFactory } from '@/lib/ai/mcp/client-tool-provider';\r\n *\r\n * const provider = clientToolProviderFactory();\r\n * const tools = provider.tools();\r\n * // tools.askConfirmation.parameters.parse({ question: 'Proceed?' });\r\n * ```\r\n *\r\n * EXTENDING\r\n * When adding a new tool entry:\r\n * 1. Pick a concise camelCase name (avoid collisions).\r\n * 2. Provide a clear natural language description (used in model prompting).\r\n * 3. Supply a Zod schema (parameters) with `.describe()` on each field.\r\n * 4. (Optional) Update higher level documentation / tool registry if needed.\r\n *\r\n * CAVEATS\r\n * - The returned `MCPClient` is currently a stub (empty object cast). If/when\r\n *   real client features (streaming events, connection teardown) are needed,\r\n *   augment `get_mcpClient` and `dispose` accordingly.\r\n * - `connect` returns the same provider immediately—this keeps the interface\r\n *   uniform with potential asynchronous providers while avoiding complexity.\r\n */\r\n\r\nimport { ToolSet } from 'ai';\r\nimport { ConnectableToolProvider, MCPClient } from '../types';\r\nimport z from 'zod';\r\n\r\n/**\r\n * Factory that creates a pre‑connected {@link ConnectableToolProvider} exposing\r\n * client‑side interactive tools defined via Zod schemas.\r\n *\r\n * @returns A connectable tool provider whose `tools` method returns the\r\n *          available tool definitions.\r\n */\r\nexport const clientToolProviderFactory = (): ConnectableToolProvider => {\r\n  const clientSideTools: ToolSet = {\r\n    askConfirmation: {\r\n      description:\r\n        'Ask the user for confirmation before proceeding.  Returns an empty string if the user rejects the request, otherwise a confirmation hash.',\r\n      inputSchema: z.object({\r\n        question: z\r\n          .string()\r\n          .describe('The question or activity for the user to confirm'),\r\n        options: z\r\n          .array(z.string())\r\n          .optional()\r\n          .describe(\r\n            'Optional list of options for the user to choose from.  If not set, the user will be asked to confirm or reject.',\r\n          ),\r\n      }),\r\n    },\r\n    openCaseFile: {\r\n      description:\r\n        \"Opens a case file on the user's desktop.  This tool is useful when a \",\r\n      inputSchema: z.object({\r\n        caseId: z.string().describe('The ID of the case to open.'),\r\n        page: z\r\n          .literal('email')\r\n          .or(\r\n            z\r\n              .literal('call-to-action')\r\n              .or(z.literal('call-to-action-response'))\r\n              .or(z.literal('email-header'))\r\n              .or(z.literal('key-points'))\r\n              .or(z.literal('notes')),\r\n          )\r\n          .optional()\r\n          .describe(\r\n            'Optional page of case file to open.  If not set, defaults to email.',\r\n          ),\r\n        confirmation: z\r\n          .string()\r\n          .optional()\r\n          .describe(\r\n            'Confirmation hash returned by the askConfirmation tool.  If not set, the tool will prompt the user for confirmation.',\r\n          ),\r\n      }),\r\n    },\r\n  };\r\n  const thisProvider: ConnectableToolProvider = {\r\n    get_mcpClient: () => {\r\n      return {} as MCPClient;\r\n    },\r\n    get_isConnected: () => true,\r\n    get tools() {\r\n      return clientSideTools;\r\n    },\r\n    dispose: () => Promise.resolve(),\r\n    connect: ({}) => Promise.resolve(thisProvider),\r\n  };\r\n  return thisProvider;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\providers\\index.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\providers\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\providers\\setup-default-tools.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":32,"column":1,"nodeType":"Program","endLine":143,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * MCP Default Tool Setup Utilities\r\n * ------------------------------------------------------------------\r\n * This module centralizes construction of a standard set of Model Context\r\n * Protocol (MCP) tool providers used by the AI orchestration layer. It\r\n * produces a composable tool provider collection based on runtime options\r\n * such as request context, write permissions, and optional memory tooling.\r\n *\r\n * EXPORTS\r\n *  - {@link getMcpClientHeaders}: Extracts / synthesizes HTTP headers (cookies,\r\n *    correlation IDs) required by remote MCP tool endpoints.\r\n *  - {@link setupDefaultTools}: High-level factory that assembles an array of\r\n *    provider configurations and delegates to `toolProviderSetFactory`.\r\n *\r\n * DESIGN PRINCIPLES\r\n *  1. Isolation: HTTP header extraction is separate from provider assembly.\r\n *  2. Extensibility: Add new provider sources by pushing onto the `options`\r\n *     array before invocation of `toolProviderSetFactory`.\r\n *  3. Safety: Only forwards the session cookie when present; omits entirely\r\n *     if absent to avoid sending empty tokens.\r\n *  4. Determinism: Absent `req` or when `memoryEnabled` is false, those\r\n *     providers are simply not included—no partial objects.\r\n *\r\n * ENVIRONMENT VARIABLES (via env())\r\n *  - NEXT_PUBLIC_HOSTNAME: Base host used to build first-party tool SSE URL.\r\n *  - MEM0_API_HOST, MEM0_USERNAME: Configure optional memory provider path.\r\n *\r\n * NOTE: The underlying `toolProviderSetFactory` is expected to merge/instantiate\r\n * the specified provider configurations and return an aggregated interface the\r\n * caller can hand to higher-level AI tooling.\r\n */\r\nimport { toolProviderSetFactory } from './toolProviderFactory';\r\nimport { env } from '@/lib/site-util/env';\r\nimport { ToolProviderFactoryOptions, ToolProviderSet } from '../types';\r\nimport { NextRequest } from 'next/server';\r\nimport { fromUserId as fromUser } from '@/lib/auth/impersonation/impersonation-factory';\r\nimport { User } from 'next-auth';\r\n\r\n/**\r\n * Builds a minimal header map for MCP client connections.\r\n *\r\n * Responsibilities:\r\n *  - Conditionally attaches a chat history correlation header.\r\n *  - Forwards a session cookie (Auth.js) when present so server-originating\r\n *    tool invocations can perform authenticated actions.\r\n *\r\n * Cookie Forwarding Logic:\r\n *  If `authjs.session-token` exists in the request cookies, sets a `Cookie`\r\n *  header with only that token (scope-limited forwarding instead of sending\r\n *  the entire cookie jar).\r\n *\r\n * @param params.req Incoming Next.js request object (server context).\r\n * @param params.chatHistoryId Optional chat history identifier for correlation.\r\n * @returns A record of header key/value pairs safe for upstream MCP requests.\r\n */\r\nexport const getMcpClientHeaders = ({\r\n  req,\r\n  chatHistoryId,\r\n}: {\r\n  req: NextRequest;\r\n  chatHistoryId?: string;\r\n}): Record<string, string> => {\r\n  const ret: { [key: string]: string } = {\r\n    ...(chatHistoryId ? { 'x-chat-history-id': chatHistoryId } : {}),\r\n  };\r\n  const sessionCookie = req.cookies?.get('authjs.session-token')?.value ?? '';\r\n  if (sessionCookie.length > 0) {\r\n    ret.Cookie = `authjs.session-token=${sessionCookie}`;\r\n  }\r\n  return ret;\r\n};\r\n\r\n/**\r\n * Constructs and returns the default set of MCP tool providers based on\r\n * runtime configuration flags.\r\n *\r\n * Provider Sources:\r\n *  1. First-party tools (if `req` is supplied) – Configured with SSE endpoint\r\n *     at `/api/ai/tools/sse` relative to the public hostname. Write capability\r\n *     is governed by `writeEnabled`.\r\n *  2. Memory provider (if `memoryEnabled` true) – An auxiliary tool namespace\r\n *     for persistent or contextual memory operations (OpenMemory / MEM0).\r\n *\r\n * Header Strategy:\r\n *  Uses {@link getMcpClientHeaders} for request-scoped headers, and attaches\r\n *  caching directives for the memory provider to avoid unintended intermediaries.\r\n *\r\n * @param params.writeEnabled Optional flag enabling write operations for the\r\n *        first-party tool provider. Undefined treated as falsey (read-only).\r\n * @param params.req Optional Next.js request; absence skips first-party tools.\r\n * @param params.chatHistoryId Optional identifier passed to headers for context.\r\n * @param params.memoryEnabled Defaults to true; toggles memory provider inclusion.\r\n * @returns A promise resolving to the aggregated provider set returned by\r\n *          `toolProviderSetFactory`.\r\n */\r\nexport const setupDefaultTools = async ({\r\n  writeEnabled,\r\n  req,\r\n  chatHistoryId,\r\n  user,\r\n  memoryEnabled = true,\r\n}: {\r\n  writeEnabled?: boolean;\r\n  req?: NextRequest;\r\n  chatHistoryId?: string;\r\n  memoryEnabled?: boolean;\r\n  user: User | undefined;\r\n}): Promise<ToolProviderSet> => {\r\n  const options: Array<ToolProviderFactoryOptions> = [];\r\n  const defaultHeaders = {\r\n    ...(chatHistoryId ? { 'x-chat-history-id': chatHistoryId } : {}),\r\n  };\r\n  if (req) {\r\n    const sessionToken = req.cookies?.get('authjs.session-token')?.value ?? '';\r\n    options.push({\r\n      allowWrite: writeEnabled,\r\n      url: new URL('/api/ai/tools/sse', env('NEXT_PUBLIC_HOSTNAME')).toString(),\r\n      headers: async () => ({\r\n        ...defaultHeaders,\r\n        ...(sessionToken\r\n          ? { Cookie: `authjs.session-token=${sessionToken}` }\r\n          : {}),\r\n      }),\r\n    });\r\n  }\r\n  if (memoryEnabled && !env('MEM0_DISABLED')) {\r\n    const impersonation = await fromUser({ user });\r\n    options.push({\r\n      allowWrite: true,\r\n      headers: async () => ({\r\n        ...defaultHeaders,\r\n        'cache-control': 'no-cache, no-transform',\r\n        'content-encoding': 'none',\r\n        Authorization: impersonation\r\n          ? `Bearer ${impersonation ? await impersonation.getImpersonatedToken() : ''}`\r\n          : `APIKey ${env('MEM0_API_KEY')}`,\r\n      }),\r\n      url: `${env('MEM0_API_HOST')}/mcp/${env('MEM0_PROJECT_ID')}/sse`,\r\n    });\r\n  }\r\n  return await toolProviderSetFactory(options);\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\providers\\toolProviderFactory.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":10,"column":1,"nodeType":"Program","endLine":595,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Tool Provider Factory for Model Context Protocol (MCP) client connections.\r\n * Handles connection timeouts, error recovery, and resource cleanup for MCP servers.\r\n *\r\n * @module toolProviderFactory\r\n * @version 1.0.0\r\n * @author NoEducation Team\r\n */\r\n\r\nimport { log } from '@/lib/logger';\r\nimport type {\r\n  ConnectableToolProvider,\r\n  ToolProviderFactoryOptions,\r\n  ToolProviderSet,\r\n  MCPClient,\r\n} from '../types';\r\nimport { toolProxyFactory, attachProxyToTool } from '../tools';\r\nimport {\r\n  experimental_createMCPClient as createMCPClient,\r\n  Tool,\r\n  ToolSet,\r\n} from 'ai';\r\nimport {\r\n  getResolvedPromises,\r\n  isAbortError,\r\n  isError,\r\n} from '@/lib/react-util/utility-methods';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { InstrumentedSseTransport } from '../instrumented-sse-transport';\r\nimport { FirstParameter } from '@/lib/typescript';\r\nimport { clientToolProviderFactory } from './client-tool-provider';\r\nimport { getToolCache } from '../cache';\r\nimport { getAllFeatureFlags } from '@/lib/site-util/feature-flags/server';\r\n\r\nexport const toolProviderFactory = async ({\r\n  impersonation,\r\n  ...options\r\n}: ToolProviderFactoryOptions): Promise<ConnectableToolProvider> => {\r\n  const onerror = ((error: unknown) => {\r\n    const le = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: 'MCPClientMessageHandler',\r\n      relog: true,\r\n    });\r\n    return {\r\n      role: 'assistant',\r\n      content: `An error occurred while connecting to the MCP server: ${le.message}. Please try again later.`,\r\n    };\r\n  }) as unknown as (error: unknown) => void;\r\n\r\n  try {\r\n    const user = impersonation ? impersonation.getUserContext() : undefined;\r\n    const userId = user ? String(user.userId) : undefined;\r\n    const features = await getAllFeatureFlags(userId);\r\n\r\n    type MCPClientConfig = FirstParameter<typeof createMCPClient>;\r\n    const tx: Omit<MCPClientConfig['transport'], 'headers'> = {\r\n      type: 'sse',\r\n      url: options.url,\r\n      headers: options.headers,\r\n      /**\r\n       * Handles SSE connection errors and returns user-friendly error messages.\r\n       * @param {unknown} error - The error that occurred during SSE connection\r\n       * @returns {object} Assistant message with error information\r\n       */\r\n      onerror,\r\n      /**\r\n       * Handles SSE connection close events with error recovery.\r\n       */\r\n      onclose: () => {\r\n        try {\r\n          log((l) => l.warn('MCP Client SSE Connection Closed'));\r\n        } catch (e) {\r\n          LoggedError.isTurtlesAllTheWayDownBaby(e, {\r\n            log: true,\r\n            source: 'MCPClientMessageHandler',\r\n            message: 'MCP Client SSE Close Error',\r\n            critical: true,\r\n          });\r\n        }\r\n      },\r\n      /**\r\n       * Handles incoming SSE messages with error protection.\r\n       * @param {unknown} message - The received SSE message\r\n       */\r\n      onmessage(message: unknown) {\r\n        try {\r\n          // Handle incoming messages if needed for debugging/monitoring\r\n          log((l) =>\r\n            l.info({ message: 'MCP Client SSE Message:', data: message }),\r\n          );\r\n        } catch (e) {\r\n          LoggedError.isTurtlesAllTheWayDownBaby(e, {\r\n            log: true,\r\n            source: 'MCPClientMessageHandler',\r\n            message: 'MCP Client SSE Message Error',\r\n            critical: true,\r\n            data: {\r\n              message,\r\n            },\r\n          });\r\n        }\r\n      },\r\n    };\r\n\r\n    // Create instrumented SSE transport with comprehensive error handling\r\n    const transport = new InstrumentedSseTransport({\r\n      url: options.url,\r\n      onerror,\r\n      ...tx,\r\n    });\r\n\r\n    // Create MCP client with transport and error handling\r\n    let mcpClient = await createMCPClient({\r\n      transport,\r\n      /**\r\n       * Handles uncaught errors from the MCP client with nested error protection.\r\n       * @param {unknown} error - The uncaught error from the MCP client\r\n       * @returns {object} Assistant message with error information\r\n       */\r\n      onUncaughtError: (error: unknown): object => {\r\n        try {\r\n          LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n            log: true,\r\n            source: 'MCPClientMessageHandler',\r\n            message: 'MCP Client SSE Uncaught Error',\r\n            critical: true,\r\n          });\r\n          return {\r\n            role: 'assistant',\r\n            content: [\r\n              {\r\n                type: 'text',\r\n                text: `An error occurred while processing your request: ${isError(error) ? error.message : String(error)}. Please try again later.`,\r\n              },\r\n            ],\r\n          };\r\n        } catch (e) {\r\n          // Fallback error handling if logging itself fails. This prevents the\r\n          // app from crashing, but swallows the error.  If you are seeing this\r\n          // message in logs, it indicates a deeper issue is at play.\r\n          log((l) => l.error('MCP Client Uncaught Error Handler Error:', e));\r\n          return {\r\n            role: 'assistant',\r\n            content: [\r\n              {\r\n                type: 'text',\r\n                text: `A critical error occurred while processing your request. Please try again later.`,\r\n              },\r\n            ],\r\n          };\r\n        }\r\n      },\r\n    });\r\n\r\n    // Check cache first for faster tool discovery\r\n    const toolCache = features?.mcp_cache_tools\r\n      ? getToolCache()\r\n      : {\r\n          getCachedTools: async () => Promise.resolve(null),\r\n          setCachedTools: async () => Promise.resolve(),\r\n          invalidateCache: async () => Promise.resolve(),\r\n        };\r\n    const cachedTools: ToolSet | null = await toolCache.getCachedTools(options);\r\n    let tools: ToolSet;\r\n\r\n    if (!cachedTools) {\r\n      // Cache miss: retrieve and filter tools based on access permissions\r\n      const allTools = await mcpClient.tools();\r\n      const filteredTools = options.allowWrite\r\n        ? allTools\r\n        : Object.entries(allTools).reduce((acc, [toolName, tool]) => {\r\n            // Filter out tools that require write access when in read-only mode\r\n            if ((tool.description?.indexOf('Write access') ?? -1) === -1) {\r\n              acc[toolName] = tool;\r\n            }\r\n            return acc;\r\n          }, {} as ToolSet);\r\n\r\n      // Cache the filtered tools for future requests\r\n      await toolCache.setCachedTools(options, filteredTools);\r\n\r\n      // Use the live tools directly (they have valid function context)\r\n      tools = filteredTools;\r\n    } else {\r\n      // Cache hit: wrap cached tools with proxies to restore function context\r\n      tools = Object.entries(cachedTools).reduce(\r\n        (acc, [toolName, cachedTool]) => {\r\n          acc[toolName] = toolProxyFactory<unknown, unknown>({\r\n            mcpClient: async (name: string) => {\r\n              const liveTools = await mcpClient.tools();\r\n              Object.entries(liveTools).forEach(([liveName, liveTool]) => {\r\n                const cachedTool = acc[liveName];\r\n                if (cachedTool) {\r\n                  attachProxyToTool(liveTool);\r\n                }\r\n              });\r\n              return liveTools[name] as Tool<unknown, unknown> | undefined;\r\n            },\r\n            name: toolName,\r\n            tool: cachedTool as Tool<unknown, unknown>,\r\n          });\r\n          return acc;\r\n        },\r\n        {} as ToolSet,\r\n      );\r\n    }\r\n\r\n    let isConnected = true;\r\n\r\n    // Return the connected tool provider interface\r\n    return {\r\n      /**\r\n       * Gets the underlying MCP client instance.\r\n       * @returns {MCPClient} The MCP client instance\r\n       */\r\n      get_mcpClient: (): MCPClient => mcpClient,\r\n\r\n      /**\r\n       * Checks if the provider is currently connected.\r\n       * @returns {boolean} True if connected, false otherwise\r\n       */\r\n      get_isConnected: (): boolean => isConnected,\r\n\r\n      /**\r\n       * Gets the filtered tool set based on access permissions.\r\n       * @returns {ToolSet} The available tools for this provider\r\n       */\r\n      get tools(): ToolSet {\r\n        return tools;\r\n      },\r\n\r\n      /**\r\n       * Disposes of the MCP client and cleans up resources.\r\n       * @async\r\n       * @returns {Promise<void>} Promise that resolves when disposal is complete\r\n       */\r\n      dispose: async (): Promise<void> => {\r\n        try {\r\n          await mcpClient.close();\r\n        } catch (e) {\r\n          // Downgrade AbortError noise on shutdown\r\n          if (isAbortError(e)) {\r\n            log((l) =>\r\n              l.verbose('toolProviderFactory.dispose: Ignoring AbortError'),\r\n            );\r\n          } else {\r\n            LoggedError.isTurtlesAllTheWayDownBaby(e, {\r\n              log: true,\r\n              source: 'toolProviderFactory dispose',\r\n              severity: 'error',\r\n              data: {\r\n                message: 'Error disposing MCP client',\r\n                options,\r\n              },\r\n            });\r\n          }\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Reconnects the provider with new access permissions.\r\n       * @async\r\n       * @param {object} options - Reconnection options\r\n       * @param {boolean} [options.allowWrite=false] - Whether to allow write access\r\n       * @returns {Promise<ConnectableToolProvider>} New provider instance with updated permissions\r\n       */\r\n      connect: async ({\r\n        allowWrite = false,\r\n      }: {\r\n        allowWrite?: boolean;\r\n      }): Promise<ConnectableToolProvider> => {\r\n        const disconnect = isConnected\r\n          ? await mcpClient.close()\r\n          : Promise.resolve();\r\n\r\n        // Invalidate cache when reconnecting with different permissions\r\n        if (allowWrite !== options.allowWrite) {\r\n          await toolCache.invalidateCache({ ...options, allowWrite });\r\n        }\r\n\r\n        const newTool = await toolProviderFactory({\r\n          ...options,\r\n          allowWrite,\r\n          impersonation,\r\n        });\r\n        mcpClient = newTool.get_mcpClient();\r\n        await disconnect;\r\n        isConnected = true;\r\n        return newTool;\r\n      },\r\n    };\r\n  } catch (error) {\r\n    // Graceful degradation: return stub provider on connection failure\r\n    LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: 'MCPClientMessageHandler',\r\n      message: `A critical failure occurred connecting to MCP server at [${options?.url}] - tools from this resource will not be available.`,\r\n      url: options?.url,\r\n    });\r\n    return {\r\n      /**\r\n       * Stub implementation - returns undefined as no client is available.\r\n       * @returns {MCPClient} Undefined cast to MCPClient type\r\n       */\r\n      get_mcpClient: (): MCPClient => undefined as unknown as MCPClient,\r\n\r\n      /**\r\n       * Stub implementation - always returns false for failed connections.\r\n       * @returns {boolean} Always false\r\n       */\r\n      get_isConnected: (): boolean => false as boolean,\r\n\r\n      /**\r\n       * Stub implementation - returns empty tool set for failed connections.\r\n       * @returns {ToolSet} Empty tool set\r\n       */\r\n      get tools(): ToolSet {\r\n        return {} as ToolSet;\r\n      },\r\n\r\n      /**\r\n       * Stub implementation - no-op disposal for failed connections.\r\n       * @async\r\n       * @returns {Promise<void>} Resolved promise\r\n       */\r\n      dispose: async (): Promise<void> => {},\r\n\r\n      /**\r\n       * Stub implementation - attempts to reconnect by creating a new provider.\r\n       * @async\r\n       * @param {object} options - Reconnection options\r\n       * @param {boolean} [options.allowWrite=false] - Whether to allow write access\r\n       * @returns {Promise<ConnectableToolProvider>} New provider instance\r\n       */\r\n      connect: async ({\r\n        allowWrite = false,\r\n      }: {\r\n        allowWrite?: boolean;\r\n      }): Promise<ConnectableToolProvider> => {\r\n        const newTool = await toolProviderFactory({\r\n          ...options,\r\n          allowWrite,\r\n          impersonation,\r\n        });\r\n        return newTool;\r\n      },\r\n    } as ConnectableToolProvider;\r\n  }\r\n};\r\n\r\nconst getResolvedProvidersWithCleanup = async (\r\n  promises: Promise<ConnectableToolProvider>[],\r\n  timeoutMs: number = 60 * 1000,\r\n): Promise<ConnectableToolProvider[]> => {\r\n  const categorized = await getResolvedPromises(promises, timeoutMs);\r\n\r\n  // Setup cleanup hooks for any MCP clients that are still pending after timeout\r\n  categorized.pending.forEach((p) => {\r\n    p.then((provider) => {\r\n      // Dispose of providers that resolve after timeout to prevent resource leaks\r\n      if (provider && typeof provider.dispose === 'function') {\r\n        provider.dispose().catch((e) => {\r\n          log((l) => l.error('Error disposing provider after rejection:', e));\r\n        });\r\n      }\r\n    }).catch((e) => {\r\n      // Log cleanup errors but continue execution\r\n      LoggedError.isTurtlesAllTheWayDownBaby(e, {\r\n        log: true,\r\n        relog: true,\r\n        source: 'toolProviderFactory::getResolvedProvidersWithCleanup',\r\n        severity: 'error',\r\n        message: 'Error during provider cleanup after rejection',\r\n      });\r\n      return Promise.resolve();\r\n    });\r\n  });\r\n\r\n  // Log aggregate error information for rejected promises\r\n  if (categorized.rejected.length > 0) {\r\n    LoggedError.isTurtlesAllTheWayDownBaby(\r\n      new AggregateError(\r\n        categorized.rejected,\r\n        'Some MCP clients failed to connect or returned errors',\r\n      ),\r\n      {\r\n        log: true,\r\n        source: 'getResolvedProvidersWithCleanup',\r\n        severity: 'error',\r\n        data: {\r\n          numberOfFailures: categorized.rejected.length,\r\n          timeoutMs,\r\n        },\r\n      },\r\n    );\r\n  }\r\n\r\n  // Log successful connection statistics for monitoring\r\n  log((l) =>\r\n    l.debug(\r\n      `MCP toolProviderFactory resolved; ${categorized.fulfilled.length} connections established.`,\r\n    ),\r\n  );\r\n  return categorized.fulfilled;\r\n};\r\n\r\n/**\r\n * Type guard to check if an object conforms to the ConnectableToolProvider interface.\r\n *\r\n * This function verifies that the provided object has all required methods of the\r\n * ConnectableToolProvider interface, ensuring type safety when working with dynamic\r\n * or unknown objects.\r\n *\r\n * @function isToolProvider\r\n * @param {unknown} check - The object to check\r\n * @returns {boolean} True if the object is a ConnectableToolProvider, false otherwise\r\n *\r\n * @example\r\n * ```typescript\r\n * const obj: unknown = getSomeObject();\r\n * if (isToolProvider(obj)) {\r\n *   // Now TypeScript knows obj is a ConnectableToolProvider\r\n *   const tools = obj.tools;\r\n * } else {\r\n *   console.error('Object is not a valid tool provider');\r\n * }\r\n * ```\r\n *\r\n * @see {@link ConnectableToolProvider} For the interface being checked\r\n *\r\n * @since 1.0.0\r\n */\r\nexport const isToolProvider = (\r\n  check: unknown,\r\n): check is ConnectableToolProvider => {\r\n  return (\r\n    typeof check === 'object' &&\r\n    !!check &&\r\n    'get_mcpClient' in check &&\r\n    'get_isConnected' in check &&\r\n    'tools' in check &&\r\n    'dispose' in check &&\r\n    'connect' in check &&\r\n    typeof (check as ConnectableToolProvider).get_mcpClient === 'function' &&\r\n    typeof (check as ConnectableToolProvider).get_isConnected === 'function' &&\r\n    typeof (check as ConnectableToolProvider).tools === 'function' &&\r\n    typeof (check as ConnectableToolProvider).tools === 'object' &&\r\n    typeof (check as ConnectableToolProvider).dispose === 'function' &&\r\n    typeof (check as ConnectableToolProvider).connect === 'function'\r\n  );\r\n};\r\n\r\n/**\r\n * Creates and manages multiple Model Context Protocol (MCP) client connections concurrently.\r\n *\r\n * This factory function establishes connections to multiple MCP servers simultaneously,\r\n * handling timeouts, failures, and resource cleanup automatically. It provides a unified\r\n * interface for working with tools from multiple providers.\r\n *\r\n * @async\r\n * @function toolProviderSetFactory\r\n * @param {ToolProviderFactoryOptions[]} providers - Array of provider configurations\r\n * @param {number} [timeoutMs=60000] - Timeout in milliseconds for each connection attempt\r\n * @returns {Promise<ToolProviderSet>} A promise that resolves to a collection of connected providers\r\n *\r\n * @description\r\n * **Features:**\r\n * - **Concurrent Connections**: All providers connect simultaneously for optimal performance\r\n * - **Fault Tolerance**: Failed connections don't prevent successful ones from working\r\n * - **Resource Management**: Automatic cleanup of failed or timed-out connections\r\n * - **Unified Tool Access**: Aggregates tools from all successful providers\r\n * - **Graceful Disposal**: Coordinated cleanup with timeout protection\r\n *\r\n * @example\r\n * ```typescript\r\n * // Connect to multiple MCP servers\r\n * const providerSet = await toolProviderSetFactory([\r\n *   {\r\n *     url: 'https://file-server.example.com/api',\r\n *     allowWrite: false,\r\n *     headers: { 'Authorization': 'Bearer token1' }\r\n *   },\r\n *   {\r\n *     url: 'https://email-server.example.com/api',\r\n *     allowWrite: true,\r\n *     headers: { 'Authorization': 'Bearer token2' }\r\n *   },\r\n *   {\r\n *     url: 'https://calendar-server.example.com/api',\r\n *     allowWrite: false\r\n *   }\r\n * ], 30000); // 30 second timeout per connection\r\n *\r\n * // Get all available tools from all connected providers\r\n * const allTools = providerSet.tools();\r\n * console.log(`Total tools available: ${Object.keys(allTools).length}`);\r\n *\r\n * // Clean up all providers when done\r\n * await providerSet.dispose();\r\n * ```\r\n *\r\n * @example\r\n * ```typescript\r\n * // Handle partial connection failures gracefully\r\n * const providerSet = await toolProviderSetFactory([\r\n *   { url: 'https://working-server.com/api' },\r\n *   { url: 'https://broken-server.com/api' },  // This may fail\r\n *   { url: 'https://slow-server.com/api' }     // This may timeout\r\n * ]);\r\n *\r\n * // Still get tools from successful connections\r\n * const availableTools = providerSet.tools();\r\n * console.log(`Connected to ${providerSet.providers.length} providers`);\r\n * ```\r\n *\r\n * @see {@link ToolProviderSet} For the returned provider set interface\r\n * @see {@link toolProviderFactory} For single provider connections\r\n * @see {@link getResolvedProvidersWithCleanup} For the internal connection management logic\r\n *\r\n * @since 1.0.0\r\n */\r\nexport const toolProviderSetFactory = async (\r\n  providers: Array<ToolProviderFactoryOptions | ConnectableToolProvider>,\r\n  timeoutMs: number = 180 * 1000,\r\n): Promise<ToolProviderSet> => {\r\n  // Create provider promises and wait for resolution with cleanup\r\n  const resolvedProviders = await getResolvedProvidersWithCleanup(\r\n    providers.map((options) =>\r\n      isToolProvider(options)\r\n        ? Promise.resolve(options)\r\n        : toolProviderFactory(options),\r\n    ),\r\n    timeoutMs,\r\n  );\r\n  const allProviders = [clientToolProviderFactory(), ...resolvedProviders];\r\n  const isHealthy = allProviders.length === providers.length;\r\n  return {\r\n    /** @type {ConnectableToolProvider[]} Array of successfully connected providers */\r\n    providers: allProviders,\r\n    get isHealthy(): boolean {\r\n      return isHealthy;\r\n    },\r\n    /**\r\n     * Aggregates tools from all connected providers into a single ToolSet.\r\n     *\r\n     * @returns {ToolSet} Combined tool set from all providers\r\n     * @description\r\n     * Merges tools from all successful provider connections. If multiple providers\r\n     * offer tools with the same name, the last provider's tool will take precedence.\r\n     */\r\n    get tools(): ToolSet {\r\n      return allProviders.reduce((acc, provider) => {\r\n        return { ...acc, ...provider.tools };\r\n      }, {} as ToolSet);\r\n    },\r\n\r\n    /**\r\n     * Disposes of all providers with timeout protection.\r\n     *\r\n     * @async\r\n     * @returns {Promise<void>} Promise that resolves when disposal is complete or times out\r\n     * @description\r\n     * Attempts to dispose all providers gracefully within a 30-second timeout.\r\n     * Uses `Promise.any` to ensure the function doesn't hang indefinitely if\r\n     * some providers fail to dispose properly. Suppresses AbortErrors that occur\r\n     * during disposal as these are expected during cleanup.\r\n     */\r\n    dispose: async (): Promise<void> => {\r\n      await Promise.any([\r\n        Promise.all(\r\n          allProviders.map(async (provider) => {\r\n            try {\r\n              await provider.dispose();\r\n            } catch (e) {\r\n              // Suppress AbortErrors during disposal as they're expected\r\n              if (isAbortError(e)) {\r\n                log((l) =>\r\n                  l.verbose(\r\n                    'toolProviderFactory.dispose: Ignoring AbortError from provider disposal',\r\n                  ),\r\n                );\r\n              } else {\r\n                // Re-throw non-AbortErrors so they can be properly logged\r\n                throw e;\r\n              }\r\n            }\r\n          }),\r\n        ),\r\n        new Promise((resolve) => setTimeout(resolve, 30 * 1000)), // Wait 30 seconds max for disposal\r\n      ]);\r\n    },\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\tools\\index.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\tools\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\tools\\tool-proxy.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1409,1412],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1409,1412],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":47,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1505,1508],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1505,1508],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\types.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mcp\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":428,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { UnwrapPromise } from '@/lib/typescript';\r\nimport type {\r\n  experimental_createMCPClient as createMCPClient,\r\n  ToolSet,\r\n} from 'ai';\r\nimport type { ImpersonationService } from '@/lib/auth/impersonation';\r\n\r\n/**\r\n * Type alias for an MCP (Model Context Protocol) client instance.\r\n *\r\n * This type represents the unwrapped promise result of creating an MCP client using\r\n * the experimental_createMCPClient function from the 'ai' library. It provides\r\n * type-safe access to MCP client functionality for tool discovery and execution.\r\n *\r\n * The MCPClient encapsulates the low-level protocol communication with MCP servers,\r\n * handling connection management, tool enumeration, and secure tool execution.\r\n * It abstracts away the complexities of the MCP wire protocol while providing\r\n * a clean, promise-based API for AI model interactions.\r\n *\r\n * @typedef {UnwrapPromise<ReturnType<typeof createMCPClient>>} MCPClient\r\n *\r\n * @example\r\n * ```typescript\r\n * // The MCPClient type is automatically inferred from the createMCPClient call\r\n * const client: MCPClient = await createMCPClient({\r\n *   transport: new SSETransport({ url: 'https://api.example.com/mcp' })\r\n * });\r\n *\r\n * // Use the client to interact with MCP servers\r\n * const tools = await client.listTools();\r\n * const result = await client.callTool('calculator', { expression: '2+2' });\r\n * ```\r\n *\r\n * @see {@link ConnectableToolProvider} for higher-level tool provider abstraction\r\n * @see {@link ToolSet} for the structure of available tools\r\n * @since 1.0.0\r\n */\r\nexport type MCPClient = UnwrapPromise<ReturnType<typeof createMCPClient>>;\r\n\r\n/**\r\n * Configuration options for creating and configuring tool provider factory instances.\r\n *\r\n * This interface defines the parameters needed to set up a tool provider that can\r\n * connect to MCP servers and manage tool discovery and execution. It supports\r\n * authentication, write permissions, tracing, and impersonation for secure tool access.\r\n *\r\n * The configuration controls how tool providers authenticate with MCP servers,\r\n * what permissions they have, and how they handle request context propagation.\r\n * Proper configuration is essential for security and functionality.\r\n *\r\n * @typedef {Object} ToolProviderFactoryOptions\r\n *\r\n * @property {string} url - The base URL of the MCP server to connect to. This should be\r\n *   a fully qualified URL including protocol (http/https) and port if non-standard.\r\n *   The URL must be accessible from the application server and support MCP protocol.\r\n * @property {() => Promise<Record<string, string>>} [headers] - Optional asynchronous function\r\n *   that returns HTTP headers to include with all requests to the MCP server. Commonly\r\n *   used for authentication tokens, API keys, or session identifiers. The function allows\r\n *   for dynamic header generation (e.g., token refresh).\r\n * @property {boolean} [allowWrite] - Optional flag controlling whether write-enabled tools\r\n *   should be included in the tool set. When false, only read-only tools are exposed.\r\n *   Defaults to false for security. Write operations typically require elevated permissions.\r\n * @property {Request} [req] - Optional Request object representing the incoming HTTP request.\r\n *   This can be used to propagate request-specific context such as headers, user info,\r\n *   or tracing data. Useful for maintaining request chains and audit trails.\r\n * @property {ImpersonationService} [impersonation] - Optional impersonation service instance\r\n *   for making authenticated requests on behalf of users. Enables secure delegation of\r\n *   tool execution permissions while maintaining proper access controls and audit logging.\r\n *\r\n * @example\r\n * ```typescript\r\n * // Basic configuration for a read-only tool provider\r\n * const basicOptions: ToolProviderFactoryOptions = {\r\n *   url: 'https://api.example.com/mcp'\r\n * };\r\n *\r\n * // Advanced configuration with authentication and write access\r\n * const advancedOptions: ToolProviderFactoryOptions = {\r\n *   url: 'https://secure-api.example.com/mcp',\r\n *   headers: async () => ({\r\n *     'Authorization': `Bearer ${await getAuthToken()}`,\r\n *     'X-API-Version': 'v2',\r\n *     'X-Request-ID': generateRequestId()\r\n *   }),\r\n *   allowWrite: true,\r\n *   req: incomingRequest,\r\n *   impersonation: impersonationService\r\n * };\r\n * ```\r\n *\r\n * @see {@link ConnectableToolProvider} for the resulting provider interface\r\n * @see {@link ImpersonationService} for user impersonation capabilities\r\n * @since 1.0.0\r\n */\r\nexport type ToolProviderFactoryOptions = {\r\n  url: string;\r\n  headers?: () => Promise<Record<string, string>>;\r\n  allowWrite?: boolean;\r\n  req?: Request;\r\n  impersonation?: ImpersonationService;\r\n};\r\n\r\n/**\r\n * Interface representing a tool provider that can connect to and manage MCP tools.\r\n *\r\n * This interface defines the contract for providers that establish connections to MCP\r\n * servers and provide access to their available tools. It supports connection management,\r\n * tool discovery, and resource cleanup operations.\r\n *\r\n * @typedef {Object} ConnectableToolProvider\r\n *\r\n * @property {() => MCPClient} get_mcpClient - Returns the underlying MCP client instance\r\n *   used for communication with the MCP server. The client handles the low-level protocol\r\n *   communication and tool execution.\r\n * @property {() => boolean} get_isConnected - Returns a boolean indicating whether the\r\n *   provider is currently connected to the MCP server. Connection status affects tool\r\n *   availability and execution capabilities.\r\n * @property {() => ToolSet} tools - Returns the current set of available tools from\r\n *   the connected MCP server. The tool set is dynamically updated based on server\r\n *   capabilities and connection permissions.\r\n * @property {() => Promise<void>} dispose - Asynchronously cleans up resources and\r\n *   disconnects from the MCP server. This method should be called when the provider\r\n *   is no longer needed to prevent resource leaks.\r\n * @property {(options: { allowWrite?: boolean }) => Promise<ConnectableToolProvider>} connect -\r\n *   Establishes a connection to the MCP server with optional write permissions.\r\n *   Returns a promise that resolves to the connected provider instance.\r\n *\r\n * @example\r\n * ```typescript\r\n * // Create and connect a tool provider\r\n * const provider: ConnectableToolProvider = await factory.create(options);\r\n *\r\n * // Check connection status\r\n * if (!provider.get_isConnected()) {\r\n *   // Establish connection with write permissions\r\n *   const connectedProvider = await provider.connect({ allowWrite: true });\r\n *\r\n *   // Access available tools\r\n *   const tools = connectedProvider.tools;\r\n *   console.log('Available tools:', Object.keys(tools));\r\n *\r\n *   // Use tools for AI interactions...\r\n *\r\n *   // Clean up when done\r\n *   await connectedProvider.dispose();\r\n * }\r\n * ```\r\n */\r\nexport type ConnectableToolProvider = {\r\n  get_mcpClient: () => MCPClient;\r\n  get_isConnected: () => boolean;\r\n  readonly tools: ToolSet;\r\n  dispose: () => Promise<void>;\r\n  connect: ({}: { allowWrite?: boolean }) => Promise<ConnectableToolProvider>;\r\n};\r\n\r\n/**\r\n * Interface representing a collection of tool providers with aggregated tool access.\r\n *\r\n * This interface defines a set of tool providers that work together to provide a unified\r\n * view of available tools from multiple MCP servers. It enables load balancing, failover,\r\n * and centralized tool management across distributed tool providers.\r\n *\r\n * @typedef {Object} ToolProviderSet\r\n *\r\n * @property {boolean} isHealthy - Indicates whether all requested tool providers were\r\n *   successfully connected and are operational.\r\n * @property {Array<ConnectableToolProvider>} providers - Array of individual tool provider\r\n *   instances that supply tools. Each provider may connect to different MCP servers or\r\n *   provide different tool sets based on their configuration.\r\n * @property {() => ToolSet} tools - Returns a unified ToolSet containing all available\r\n *   tools from all connected providers. Tool names are deduplicated, with provider-specific\r\n *   tools accessible through the aggregated interface.\r\n * @property {() => Promise<void>} dispose - Asynchronously disposes of all providers in\r\n *   the set, cleaning up resources and disconnecting from all MCP servers. This ensures\r\n *   proper cleanup of the entire provider collection.\r\n *\r\n * @example\r\n * ```typescript\r\n * // Create a set of tool providers\r\n * const providerSet: ToolProviderSet = await factory.createSet([\r\n *   { url: 'https://api1.example.com/mcp', allowWrite: false },\r\n *   { url: 'https://api2.example.com/mcp', allowWrite: true }\r\n * ]);\r\n *\r\n * // Get all available tools from all providers\r\n * const allTools = providerSet.tools;\r\n * console.log('Total tools available:', Object.keys(allTools).length);\r\n *\r\n * // Access provider information\r\n * providerSet.providers.forEach((provider, index) => {\r\n *   console.log(`Provider ${index} connected:`, provider.get_isConnected());\r\n * });\r\n *\r\n * // Clean up all providers\r\n * await providerSet.dispose();\r\n * ```\r\n */\r\nexport type ToolProviderSet = {\r\n  readonly isHealthy: boolean;\r\n  readonly tools: ToolSet;\r\n  providers: Array<ConnectableToolProvider>;\r\n  dispose: () => Promise<void>;\r\n};\r\n\r\n/**\r\n * Represents a cached tool provider entry with metadata for cache management.\r\n *\r\n * @property {number} lastAccessed - Timestamp (in milliseconds since epoch) when this\r\n *   cached entry was last accessed. Used for implementing time-based cache eviction\r\n *   policies like LRU (Least Recently Used) or TTL (Time To Live).\r\n * @property {string} userId - The unique identifier of the user who owns this cached\r\n *   tool provider. Used for user-scoped cache management and access control.\r\n * @property {string} sessionId - The unique identifier of the user session associated\r\n *   with this cached tool provider. Enables session-based cache invalidation and\r\n *   isolation between concurrent user sessions.\r\n *\r\n * @example\r\n * ```typescript\r\n * const cachedEntry: CachedToolProvider = {\r\n *   toolProviders: awai\r\n * This type encapsulates a tool provider set along with caching metadata used\r\n * for eviction policies, access tracking, and user/session association. The\r\n * cached entry tracks when it was last accessed to support time-based eviction\r\n * and usage analytics.\r\n *\r\n * @typedef {Object} CachedToolProvider\r\n *\r\n * @property {ToolProviderSet} toolProviders - The cached tool provider set containing\r\n *   the actual tool providers and their aggregated tools. This is the core cached\r\n *   resource that provit factory.createSet(options),\r\n *   lastAccessed: Date.now(),\r\n *   userId: 'user-123',\r\n *   sessionId: 'session-456'\r\n * };\r\n *\r\n * // Check if entry is stale (older than 30 minutes)\r\n * const thirtyMinutes = 30 * 60 * 1000;\r\n * const isStale = Date.now() - cachedEntry.lastAccessed > thirtyMinutes;\r\n *\r\n * if (isStale) {\r\n *   await cachedEntry.toolProviders.dispose();\r\n *   // Remove from cache\r\n * }\r\n * ```\r\n *\r\n * @see {@link ToolProviderSet} for the structure of cached tool providers\r\n * @see {@link UserToolProviderCache} for cache management interface\r\n * @since 1.0.0\r\n */\r\nexport type CachedToolProvider = {\r\n  toolProviders: ToolProviderSet;\r\n  lastAccessed: number;\r\n  userId: string;\r\n  sessionId: string;\r\n};\r\n\r\n/**\r\n * Configuration options for the user tool provider cache system.\r\n *\r\n * This interface defines the tuning parameters for the cache that manages tool\r\n * providers on a per-user basis. The configuration controls memory usage, cache\r\n * lifetime, and cleanup behavior to balance performance with resource constraints.\r\n *\r\n * Proper cache configuration is crucial for maintaining good performance while\r\n * preventing memory leaks and ensuring responsive tool access across user sessions.\r\n *\r\n * @typedef {Object} UserToolProviderCacheConfig\r\n *\r\n * @property {number} maxEntriesPerUser - Maximum number of cached tool providers\r\n *   allowed per user. When this limit is exceeded, older entries are evicted based\r\n *   on access time. Higher values improve performance but increase memory usage.\r\n *   Typical values range from 5-20 depending on user activity patterns.\r\n * @property {number} maxTotalEntries - Maximum total number of cached entries across\r\n *   all users. This global limit prevents the cache from consuming excessive memory\r\n *   during high load periods. When exceeded, least recently used entries are evicted\r\n *   regardless of user association.\r\n * @property {number} ttl - Time to live in milliseconds for cache entries. Entries\r\n *   older than this duration are considered stale and may be evicted during cleanup.\r\n *   This provides a baseline guarantee for cache freshness. Common values are in\r\n *   the range of 30 minutes to 2 hours.\r\n * @property {number} cleanupInterval - Interval in milliseconds between automatic\r\n *   cache cleanup operations. During cleanup, expired entries are removed and\r\n *   memory is reclaimed. Shorter intervals provide more aggressive cleanup but\r\n *   increase CPU overhead. Typical values are 5-15 minutes.\r\n *\r\n * @example\r\n * ```typescript\r\n * // Production configuration optimized for memory efficiency\r\n * const prodConfig: UserToolProviderCacheConfig = {\r\n *   maxEntriesPerUser: 10,\r\n *   maxTotalEntries: 1000,\r\n *   ttl: 60 * 60 * 1000, // 1 hour\r\n *   cleanupInterval: 10 * 60 * 1000 // 10 minutes\r\n * };\r\n *\r\n * // Development configuration for debugging\r\n * const devConfig: UserToolProviderCacheConfig = {\r\n *   maxEntriesPerUser: 50,\r\n *   maxTotalEntries: 5000,\r\n *   ttl: 24 * 60 * 60 * 1000, // 24 hours\r\n *   cleanupInterval: 60 * 1000 // 1 minute\r\n * };\r\n * ```\r\n *\r\n * @see {@link UserToolProviderCache} for the cache interface that uses this configuration\r\n * @since 1.0.0\r\n */\r\nexport type UserToolProviderCacheConfig = {\r\n  /** Maximum number of cached tool providers per user */\r\n  maxEntriesPerUser: number;\r\n  /** Maximum total entries across all users */\r\n  maxTotalEntries: number;\r\n  /** Time to live in milliseconds */\r\n  ttl: number;\r\n  /** Cleanup interval in milliseconds */\r\n  cleanupInterval: number;\r\n};\r\n\r\n/**\r\n * Interface for user-scoped tool provider cache operations.\r\n *\r\n * This interface defines the contract for a cache system that manages tool providers\r\n * on a per-user and per-session basis. It provides efficient access to tool providers\r\n * while implementing automatic cleanup, memory management, and invalidation strategies.\r\n *\r\n * The cache is designed to improve performance by reusing tool provider connections\r\n * across requests while ensuring proper resource cleanup and access control. It supports\r\n * both user-level and session-level invalidation for security and resource management.\r\n *\r\n * @typedef {Object} UserToolProviderCache\r\n *\r\n * @property {(userId: string, sessionId: string, config: { writeEnabled: boolean; memoryDisabled: boolean; headers?: Record<string, string>; }, factory: () => Promise<ToolProviderSet>) => Promise<ToolProviderSet>} getOrCreate -\r\n *   Retrieves an existing cached tool provider set or creates a new one for the specified\r\n *   user and session. The method implements cache lookup with fallback to factory creation.\r\n *   Updates access timestamps for cache management and applies configured limits.\r\n *   @param {string} userId - Unique identifier for the user requesting tool access\r\n *   @param {string} sessionId - Unique identifier for the current user session\r\n *   @param {Object} config - Configuration object controlling tool provider behavior\r\n *   @param {boolean} config.writeEnabled - Whether write-enabled tools should be included\r\n *   @param {boolean} config.memoryDisabled - Whether to disable caching for this request\r\n *   @param {Record<string, string>} [config.headers] - Optional headers for tool provider creation\r\n *   @param {() => Promise<ToolProviderSet>} factory - Async factory function to create tool providers when not cached\r\n *   @returns {Promise<ToolProviderSet>} The cached or newly created tool provider set\r\n *\r\n * @property {(userId: string) => void} invalidateUser - Removes all cached tool providers\r\n *   for a specific user across all their sessions. This method is used when user permissions\r\n *   change or when forcing a complete refresh of user's tool access. Properly disposes\r\n *   of all associated resources.\r\n *   @param {string} userId - The user ID whose cache entries should be invalidated\r\n *\r\n * @property {(userId: string, sessionId: string) => void} invalidateSession - Removes all\r\n *   cached tool providers for a specific user session. This method is used when sessions\r\n *   end or when session-specific permissions change. More granular than user-level invalidation.\r\n *   @param {string} userId - The user ID of the session to invalidate\r\n *   @param {string} sessionId - The session ID to invalidate\r\n *\r\n * @property {() => void} clear - Removes all cached tool providers across all users and\r\n *   sessions. This method performs a complete cache flush and properly disposes of all\r\n *   cached resources. Used during application shutdown or for emergency cleanup.\r\n *\r\n * @property {() => { totalEntries: number; userCounts: Record<string, number>; config: UserToolProviderCacheConfig; }} getStats -\r\n *   Returns comprehensive statistics about the current cache state. Provides insights\r\n *   into memory usage, user distribution, and configuration for monitoring and debugging.\r\n *   @returns {Object} Cache statistics including total entries, per-user counts, and configuration\r\n *\r\n * @property {() => void} shutdown - Performs graceful shutdown of the cache system,\r\n *   cleaning up all resources and stopping background cleanup processes. This method\r\n *   should be called during application shutdown to ensure proper resource cleanup.\r\n *\r\n * @example\r\n * ```typescript\r\n * // Get or create tool providers for a user session\r\n * const toolProviders = await cache.getOrCreate(\r\n *   'user-123',\r\n *   'session-456',\r\n *   {\r\n *     writeEnabled: true,\r\n *     memoryDisabled: false,\r\n *     headers: { 'Authorization': 'Bearer token' }\r\n *   },\r\n *   async () => await factory.createSet(options)\r\n * );\r\n *\r\n * // Use the tool providers\r\n * const result = await toolProviders.tools.calculator.call({ expression: '2+2' });\r\n *\r\n * // Check cache statistics\r\n * const stats = cache.getStats();\r\n * console.log(`Cache has ${stats.totalEntries} entries`);\r\n *\r\n * // Clean up for user logout\r\n * cache.invalidateUser('user-123');\r\n *\r\n * // Graceful shutdown\r\n * cache.shutdown();\r\n * ```\r\n *\r\n * @throws {CacheLimitExceededError} When cache limits are exceeded and eviction fails\r\n * @throws {ToolProviderCreationError} When factory function fails to create providers\r\n *\r\n * @see {@link UserToolProviderCacheConfig} for cache configuration options\r\n * @see {@link ToolProviderSet} for the structure of cached tool providers\r\n * @see {@link CachedToolProvider} for individual cache entry structure\r\n * @since 1.0.0\r\n */\r\nexport type UserToolProviderCache = {\r\n  getOrCreate(\r\n    userId: string,\r\n    sessionId: string,\r\n    config: {\r\n      writeEnabled: boolean;\r\n      memoryDisabled: boolean;\r\n      headers?: Record<string, string>;\r\n    },\r\n    factory: () => Promise<ToolProviderSet>,\r\n  ): Promise<ToolProviderSet>;\r\n  invalidateUser(userId: string): void;\r\n  invalidateSession(userId: string, sessionId: string): void;\r\n  clear(): void;\r\n  getStats(): {\r\n    totalEntries: number;\r\n    userCounts: Record<string, number>;\r\n    config: UserToolProviderCacheConfig;\r\n  };\r\n  shutdown(): void;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mem0\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mem0\\memoryclient-factory.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":162,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { MemoryClient } from './lib/client/mem0';\r\nimport type { MemoryOptions, Message } from './lib/client/types';\r\nimport type {\r\n  MemoryHealthCheckResponse,\r\n  HealthCheckParams,\r\n} from './types/health-check';\r\nimport { fromRequest, ImpersonationService } from '@/lib/auth/impersonation';\r\nimport { env } from '@/lib/site-util/env';\r\nimport { log } from '@/lib/logger';\r\n\r\n/**\r\n * Options for configuring the MemoryClient instance.\r\n *\r\n * @property projectId - The ID of the project to associate with the client.\r\n * @property orgId - The ID of the organization to associate with the client.\r\n * @property defaults - Default memory options to use for the client.\r\n * @property impersonation - Optional impersonation instance for authenticated calls.\r\n */\r\ntype ClientOptions = {\r\n  projectId?: string;\r\n  orgId?: string;\r\n  defaults?: MemoryOptions;\r\n  impersonation?: ImpersonationService;\r\n};\r\n\r\nexport type ExtendedMemoryClient = MemoryClient & {\r\n  healthCheck: (\r\n    params?: HealthCheckParams,\r\n  ) => Promise<MemoryHealthCheckResponse>;\r\n};\r\n\r\n/**\r\n * A specialized MemoryClient for SchoolLawyer use cases.\r\n *\r\n * @class SchoolLawyerMemoryClient\r\n * @extends MemoryClient\r\n * @private defaultOptions - Default memory options for the client.\r\n * @private #impersonation - Optional impersonation instance for authenticated calls.\r\n */\r\nclass SchoolLawyerMemoryClient\r\n  extends MemoryClient\r\n  implements ExtendedMemoryClient\r\n{\r\n  readonly defaultOptions: MemoryOptions;\r\n\r\n  /**\r\n   * Constructs a new SchoolLawyerMemoryClient instance.\r\n   *\r\n   * @param defaults - Default memory options.\r\n   * @param projectId - The ID of the project.\r\n   * @param orgId - The ID of the organization.\r\n   * @param impersonation - Optional impersonation instance.\r\n   * @param ops - Additional client options.\r\n   */\r\n  constructor({ defaults, projectId, orgId, ...ops }: ClientOptions) {\r\n    super({\r\n      ...ops,\r\n      projectId: (projectId ? projectId : env('MEM0_PROJECT_ID')) ?? undefined,\r\n      organizationId: (orgId ? orgId : env('MEM0_ORG_ID')) ?? undefined,\r\n      host: env('MEM0_API_HOST'),\r\n    });\r\n\r\n    this.defaultOptions = {\r\n      ...(defaults ?? {}),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Prepares the payload for memory operations.\r\n   *\r\n   * @param messages - Array of messages to include in the payload.\r\n   * @param options - Memory options to include in the payload.\r\n   * @returns The prepared payload object.\r\n   */\r\n  override _preparePayload(\r\n    messages: Array<Message>,\r\n    options: MemoryOptions,\r\n  ): object {\r\n    return super._preparePayload(messages, {\r\n      ...this.defaultOptions,\r\n      ...options,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Prepares the parameters for memory operations.\r\n   *\r\n   * @param options - Memory options to include in the parameters.\r\n   * @returns The prepared parameters object.\r\n   */\r\n  override _prepareParams(options: MemoryOptions): Record<string, string> {\r\n    return super._prepareParams({\r\n      ...this.defaultOptions,\r\n      ...options,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Performs a health check on the memory service.\r\n   *\r\n   * @param params - Optional parameters for the health check.\r\n   * @returns Promise resolving to the health check response.\r\n   */\r\n  async healthCheck(\r\n    params: HealthCheckParams = {},\r\n  ): Promise<MemoryHealthCheckResponse> {\r\n    const { strict = false, verbose = 1 } = params;\r\n    const searchParams = new URLSearchParams({\r\n      strict: strict.toString(),\r\n      verbose: verbose.toString(),\r\n    });\r\n\r\n    const url = `api/v1/stats/health-check?${searchParams.toString()}`;\r\n\r\n    try {\r\n      const response = await this._fetchWithErrorHandling(url, {\r\n        method: 'GET',\r\n        headers: this.headers,\r\n      });\r\n\r\n      return response as MemoryHealthCheckResponse;\r\n    } catch (error) {\r\n      log((l) => l.error('Memory health check failed', { error, url }));\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function for creating a MemoryClient instance.\r\n *\r\n * @param options - Configuration options for the MemoryClient.\r\n * @returns A new MemoryClient instance.\r\n *\r\n * @example\r\n * ```typescript\r\n * // Create with impersonation\r\n * const impersonation = await Impersonation.fromRequest(request);\r\n * const client = await memoryClientFactory({ impersonation });\r\n *\r\n * // Create with API key (fallback)\r\n * const client = await memoryClientFactory({});\r\n * ```\r\n */\r\nexport const memoryClientFactory = async <\r\n  TClient extends MemoryClient = MemoryClient,\r\n>(\r\n  options: ClientOptions,\r\n): Promise<TClient> => {\r\n  const clientOps = {\r\n    ...options,\r\n  };\r\n  if (!options.impersonation) {\r\n    const impersonateService = await fromRequest({});\r\n    if (impersonateService) {\r\n      clientOps.impersonation = impersonateService;\r\n    }\r\n  }\r\n  const ret = new SchoolLawyerMemoryClient(clientOps) as unknown as TClient;\r\n  return ret;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\mem0\\types\\health-check.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":12,"column":1,"nodeType":"Program","endLine":124,"endColumn":2}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Memory Health Check Types\r\n * ========================\r\n * \r\n * Type definitions for the Mem0 API health check response structure.\r\n * Based on the sample JSON structure from /api/v1/stats/health-check endpoint.\r\n */\r\n\r\n/**\r\n * Mem0 version and build information\r\n */\r\nexport interface Mem0Info {\r\n  version: string;\r\n  build_type: string;\r\n  build_info: string;\r\n  verbose: {\r\n    mem0_version: string;\r\n    build_details: {\r\n      type: string;\r\n      info: string;\r\n      path: string;\r\n    };\r\n    build_stamp: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Authentication service health status\r\n */\r\nexport interface AuthServiceHealth {\r\n  healthy: boolean;\r\n  enabled: boolean;\r\n  server_url: string;\r\n  realm: string;\r\n  client_id: string;\r\n  auth_url: string;\r\n  token_url: string;\r\n  jkws_url: string;\r\n}\r\n\r\n/**\r\n * Detailed health check information\r\n */\r\nexport interface HealthDetails {\r\n  client_active: boolean;\r\n  system_db_available: boolean;\r\n  vector_enabled: boolean;\r\n  vector_store_available: boolean;\r\n  graph_enabled: boolean;\r\n  graph_store_available: boolean;\r\n  history_store_available: boolean;\r\n  auth_service: AuthServiceHealth;\r\n  errors: string[];\r\n}\r\n\r\n/**\r\n * Complete health check response structure\r\n */\r\nexport interface MemoryHealthCheckResponse {\r\n  status: string;\r\n  message: string;\r\n  timestamp: string;\r\n  service: string;\r\n  mem0: Mem0Info;\r\n  details: HealthDetails;\r\n}\r\n\r\n/**\r\n * Parameters for health check endpoint\r\n */\r\nexport interface HealthCheckParams {\r\n  strict?: boolean;\r\n  verbose?: 0 | 1;\r\n}\r\n\r\n/**\r\n * Simplified health status for UI components\r\n */\r\nexport type HealthStatus = 'healthy' | 'warning' | 'error';\r\n\r\n/**\r\n * Determines the overall health status based on the health check details\r\n */\r\nexport function determineHealthStatus(details: HealthDetails): HealthStatus {\r\n  // Error if client is not active\r\n  if (!details.client_active) {\r\n    return 'error';\r\n  }\r\n\r\n  // Check if any critical services are unavailable\r\n  const criticalServices = [\r\n    details.system_db_available,\r\n    details.vector_store_available,\r\n    details.graph_store_available,\r\n    details.history_store_available,\r\n    details.auth_service.healthy,\r\n  ];\r\n\r\n  const unavailableServices = criticalServices.filter(service => !service);\r\n  \r\n  // Warning if one or more services are unavailable\r\n  if (unavailableServices.length > 0) {\r\n    return 'warning';\r\n  }\r\n\r\n  // Healthy if all services are available\r\n  return 'healthy';\r\n}\r\n\r\n/**\r\n * Get refresh interval based on health status\r\n */\r\nexport function getRefreshInterval(status: HealthStatus): number {\r\n  switch (status) {\r\n    case 'healthy':\r\n      return 3 * 60 * 1000; // 3 minutes\r\n    case 'warning':\r\n      return 30 * 1000; // 30 seconds\r\n    case 'error':\r\n      return 5 * 1000; // 5 seconds\r\n    default:\r\n      return 30 * 1000; // Default to 30 seconds\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\message-structure-preservation.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":21,"column":1,"nodeType":"Program","endLine":71,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Message Structure Preservation - Main exports\r\n *\r\n * This module provides a strongly-typed interface for message structure preservation,\r\n * replacing magic properties with type-safe, configurable options.\r\n *\r\n * @example\r\n * ```typescript\r\n * import {\r\n *   preserveMessageStructure,\r\n *   createPresetConfiguration,\r\n *   type MessageStructureOptions\r\n * } from '@/lib/ai/message-structure-preservation';\r\n *\r\n * const options = createPresetConfiguration('balanced');\r\n * const result = preserveMessageStructure(messages, options);\r\n * ```\r\n */\r\n\r\n// Core types and interfaces\r\nexport type {\r\n  MessageStructureOptions,\r\n  MessagePreservationResult,\r\n  PreservationStrategy,\r\n  MessagePartPreservationRules,\r\n  MetadataPreservationOptions,\r\n  ContentTransformationOptions,\r\n  ToolPreservationRules,\r\n  ContextualPreservationOptions,\r\n  PerformanceOptions,\r\n  PartialMessageStructureOptions,\r\n} from './types/message-structure-preservation';\r\n\r\n// Type guards and factory functions\r\nexport {\r\n  createMessageStructureOptions,\r\n  isPreservationEnabled,\r\n  hasMessageStructureOptions,\r\n  DEFAULT_MESSAGE_STRUCTURE_OPTIONS,\r\n} from './types/message-structure-preservation';\r\n\r\n// Utility functions\r\nexport {\r\n  preserveMessageStructure,\r\n  validateMessageStructureOptions,\r\n  createPresetConfiguration,\r\n  clearPreservationCache,\r\n  getPreservationCacheStats,\r\n} from './utils/message-structure-preservation';\r\n\r\n/**\r\n * Re-export common preset configurations for convenience\r\n */\r\nexport const PRESET_CONFIGURATIONS = {\r\n  minimal: 'minimal' as const,\r\n  balanced: 'balanced' as const,\r\n  comprehensive: 'comprehensive' as const,\r\n  performance: 'performance' as const,\r\n};\r\n\r\n/**\r\n * Common strategies for easy import\r\n */\r\nexport const PRESERVATION_STRATEGIES = {\r\n  full: 'full' as const,\r\n  contentOnly: 'content-only' as const,\r\n  semantic: 'semantic' as const,\r\n  minimal: 'minimal' as const,\r\n  custom: 'custom' as const,\r\n} as const;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\cacheWithRedis\\cacheEventHandlers.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":5,"column":1,"nodeType":"Program","endLine":104,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Cache event handlers for hit/miss scenarios and metrics\r\n */\r\n\r\nimport type { CacheableResponse } from './types';\r\nimport { getCacheConfig } from './config';\r\nimport { metricsCollector } from './metrics';\r\nimport { log } from '@/lib/logger';\r\nimport { generateChatId } from '@/lib/ai/core';\r\n\r\nconst config = getCacheConfig();\r\n\r\n/**\r\n * Handles cache hit logic with metrics and logging\r\n *\r\n * @param cacheKey - The cache key that was hit\r\n * @param parsed - The parsed cached response\r\n * @param context - Optional context string for logging\r\n */\r\nexport const handleCacheHit = (\r\n  cacheKey: string,\r\n  parsed: CacheableResponse,\r\n  context: string = '',\r\n): void => {\r\n  const responseSize =\r\n    parsed.content?.reduce(\r\n      (acc, part) => acc + (part.type === 'text' ? part.text.length : 0),\r\n      0,\r\n    ) || 0;\r\n\r\n  // Fix-up timestamps\r\n  if (\r\n    'response' in parsed &&\r\n    parsed.response &&\r\n    typeof parsed.response === 'object' &&\r\n    parsed.response !== null\r\n  ) {\r\n    if ('timestamp' in parsed.response && parsed.response.timestamp) {\r\n      try {\r\n        const responseObj = parsed.response as Record<string, unknown>;\r\n        responseObj.timestamp = new Date(Date.now());\r\n      } catch (error) {\r\n        log((l) =>\r\n          l.warn('Failed to parse timestamp in cached response', {\r\n            cacheKey,\r\n            error: String(error),\r\n          }),\r\n        );\r\n        // If parsing fails, we just leave it as is\r\n      }\r\n    }\r\n  }\r\n  if ('id' in parsed && parsed.id) {\r\n    try {\r\n      parsed.id = String(parsed.id) + generateChatId();\r\n    } catch (error) {\r\n      log((l) =>\r\n        l.warn('Failed to parse ID in cached response', {\r\n          cacheKey,\r\n          error: String(error),\r\n        }),\r\n      );\r\n      // If parsing fails, we just leave it as is\r\n    }\r\n  }\r\n\r\n  // Record metrics\r\n  if (config.enableMetrics) {\r\n    metricsCollector.recordHit(cacheKey, responseSize);\r\n  }\r\n\r\n  if (config.enableLogging) {\r\n    log((l) =>\r\n      l.verbose(\r\n        `🎯 ${context}Cache HIT for key: ${cacheKey.substring(0, config.maxKeyLogLength)}...`,\r\n      ),\r\n    );\r\n  }\r\n};\r\n\r\n/**\r\n * Handles cache miss logic with metrics and logging\r\n *\r\n * @param cacheKey - The cache key that was missed\r\n * @param context - Optional context string for logging\r\n */\r\nexport const handleCacheMiss = (\r\n  cacheKey: string,\r\n  context: string = '',\r\n): void => {\r\n  // Record cache miss\r\n  if (config.enableMetrics) {\r\n    metricsCollector.recordMiss(cacheKey);\r\n  }\r\n\r\n  if (config.enableLogging) {\r\n    log((l) =>\r\n      l.verbose(\r\n        `🔍 ${context}Cache MISS for key: ${cacheKey.substring(0, config.maxKeyLogLength)}...`,\r\n      ),\r\n    );\r\n  }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\cacheWithRedis\\cacheKeys.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":143,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createHash } from 'crypto';\r\nimport { getCacheConfig, validateCacheConfig } from './config';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\n\r\n// Enterprise configuration and metrics\r\nconst config = getCacheConfig();\r\nvalidateCacheConfig(config);\r\n\r\n/**\r\n * Creates a unique cache key from parameters and model information\r\n */\r\nexport const createCacheKey = (\r\n  params: Record<string, unknown>,\r\n  modelId?: string,\r\n): string => {\r\n  try {\r\n    const normalizeForKey = (value: unknown): string | undefined => {\r\n      const type = typeof value;\r\n      if (type !== 'boolean' && (value === null || value === undefined)) {\r\n        return undefined;\r\n      }\r\n      switch (type) {\r\n        case 'symbol':\r\n        case 'function':\r\n          return undefined;\r\n        case 'object':\r\n          // Handle objects and arrays by hashing large structures to avoid stringify issues\r\n          if (Array.isArray(value)) {\r\n            if (value.length === 0) {\r\n              return '[]';\r\n            }\r\n            // For large arrays, hash immediately to avoid stringify issues\r\n            if (value.length > 100) {\r\n              const hash = createHash('sha256');\r\n              value.forEach((item, index) => {\r\n                hash.update(`${index}:${normalizeForKey(item) || 'null'}`);\r\n              });\r\n              return hash.digest('hex');\r\n            }\r\n            // For smaller arrays, try JSON stringify with fallback to hashing\r\n            try {\r\n              const normalizedArray = value.map(normalizeForKey).sort();\r\n              const arrayJson = JSON.stringify(normalizedArray);\r\n              if (arrayJson.length > 1000) {\r\n                const hash = createHash('sha256');\r\n                normalizedArray.forEach((item, index) => {\r\n                  hash.update(`${index}:${item || 'null'}`);\r\n                });\r\n                return hash.digest('hex');\r\n              }\r\n              return arrayJson;\r\n            } catch {\r\n              // Fallback to hashing if stringify fails\r\n              const hash = createHash('sha256');\r\n              value.forEach((item, index) => {\r\n                hash.update(`${index}:${normalizeForKey(item) || 'null'}`);\r\n              });\r\n              return hash.digest('hex');\r\n            }\r\n          }\r\n\r\n          // For objects, check size and hash large ones\r\n          const entries = Object.entries(value as object).sort(([a], [b]) =>\r\n            a.localeCompare(b),\r\n          );\r\n\r\n          // For large objects, hash immediately to avoid stringify issues\r\n          if (entries.length > 50) {\r\n            const hash = createHash('sha256');\r\n            entries.forEach(([key, val]) => {\r\n              if (val !== undefined && val !== null) {\r\n                hash.update(`${key}:${normalizeForKey(val) || 'null'}`);\r\n              }\r\n            });\r\n            return hash.digest('hex');\r\n          }\r\n\r\n          // For smaller objects, try JSON stringify with fallback to hashing\r\n          try {\r\n            const normalizedObject = entries.reduce(\r\n              (acc, [key, val]) => {\r\n                if (val === undefined || val === null) {\r\n                  return acc;\r\n                }\r\n                acc[key] = normalizeForKey(val);\r\n                return acc;\r\n              },\r\n              {} as Record<string, unknown>,\r\n            );\r\n            const objectJson = JSON.stringify(normalizedObject);\r\n            if (objectJson.length > 1000) {\r\n              const hash = createHash('sha256');\r\n              entries.forEach(([key, val]) => {\r\n                if (val !== undefined && val !== null) {\r\n                  hash.update(`${key}:${normalizeForKey(val) || 'null'}`);\r\n                }\r\n              });\r\n              return hash.digest('hex');\r\n            }\r\n            return objectJson;\r\n          } catch {\r\n            // Fallback to hashing if stringify fails\r\n            const hash = createHash('sha256');\r\n            entries.forEach(([key, val]) => {\r\n              if (val !== undefined && val !== null) {\r\n                hash.update(`${key}:${normalizeForKey(val) || 'null'}`);\r\n              }\r\n            });\r\n            return hash.digest('hex');\r\n          }\r\n        default:\r\n          const stringValue = String(value);\r\n          // Hash very large string values to prevent issues\r\n          if (stringValue.length > 10000) {\r\n            return createHash('sha256').update(stringValue).digest('hex');\r\n          }\r\n          return stringValue;\r\n      }\r\n    };\r\n    const keyData = {\r\n      modelId: modelId || 'unknown',\r\n      params: {\r\n        ...params,\r\n      },\r\n    };\r\n    const keyString = normalizeForKey(keyData)?.replaceAll(/\\s|\\\\/g, '');\r\n    if (keyString === undefined) {\r\n      throw new Error('Cannot create cache key from undefined value');\r\n    }\r\n    const hash = createHash('sha256').update(keyString).digest('hex');\r\n    return `${config.cacheKeyPrefix}:${hash}`;\r\n  } catch (error) {\r\n    LoggedError.isTurtlesAllTheWayDownBaby(error, { log: true });\r\n    return '';\r\n  }\r\n};\r\n\r\n/**\r\n * Cache jail key for tracking problematic responses\r\n */\r\nexport const createJailKey = (cacheKey: string): string =>\r\n  `${config.jailKeyPrefix}:${cacheKey.replace(`${config.cacheKeyPrefix}:`, '')}`;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\cacheWithRedis\\cacheOperations.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":5,"column":1,"nodeType":"Program","endLine":177,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Cache operations utilities for Redis middleware\r\n */\r\n\r\nimport type { CacheableResponse, JailEntry } from './types';\r\nimport { getCacheConfig } from './config';\r\nimport { metricsCollector } from './metrics';\r\nimport { createJailKey } from './cacheKeys';\r\nimport type { getRedisClient } from './redis-client';\r\nimport { log } from '@/lib/logger';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { LanguageModelV2Content } from '@ai-sdk/provider';\r\n\r\nconst config = getCacheConfig();\r\n\r\n/**\r\n * Handles caching of a successful response\r\n *\r\n * @param redis - Redis client instance\r\n * @param cacheKey - The cache key to store under\r\n * @param response - The response to cache\r\n * @param context - Optional context string for logging\r\n */\r\nexport const cacheSuccessfulResponse = async (\r\n  redis: Awaited<ReturnType<typeof getRedisClient>>,\r\n  cacheKey: string,\r\n  response: CacheableResponse,\r\n  context: string = '',\r\n): Promise<void> => {\r\n  const extractText = (content: Array<LanguageModelV2Content>) => {\r\n    return content\r\n      .map((item) => (item.type === 'text' ? item.text : ''))\r\n      .filter((text) => text.length > 0)\r\n      .join(' ');\r\n  };\r\n  try {\r\n    const extractedText = extractText(response.content);\r\n\r\n    await redis.setEx(\r\n      cacheKey,\r\n      config.cacheTtl,\r\n      JSON.stringify({\r\n        text: extractedText,\r\n        finishReason: response.finishReason,\r\n        usage: response.usage,\r\n        warnings: response.warnings,\r\n        rawCall: response.rawCall,\r\n        rawResponse: response.rawResponse,\r\n        response: response.response,\r\n      }),\r\n    );\r\n\r\n    const responseSize = extractedText?.length || 0;\r\n\r\n    // Record metrics\r\n    if (config.enableMetrics) {\r\n      metricsCollector.recordStore(cacheKey, responseSize);\r\n    }\r\n\r\n    if (config.enableLogging) {\r\n      log((l) =>\r\n        l.verbose(\r\n          `💾 Cached successful ${context}response for key: ${cacheKey.substring(0, config.maxKeyLogLength)}...`,\r\n        ),\r\n      );\r\n    }\r\n  } catch (cacheStoreError) {\r\n    if (config.enableMetrics) {\r\n      metricsCollector.recordError(cacheKey, String(cacheStoreError));\r\n    }\r\n    if (config.enableLogging) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(cacheStoreError, {\r\n        message: `Error storing ${context}response in cache`,\r\n        data: {\r\n          cacheKey,\r\n        },\r\n        source: 'cacheWithRedis',\r\n        log: true,\r\n      });\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Handles cache jail logic for problematic responses\r\n *\r\n * @param redis - Redis client instance\r\n * @param cacheKey - The cache key for the response\r\n * @param response - The problematic response\r\n * @param context - Optional context string for logging\r\n */\r\nexport const handleCacheJail = async (\r\n  redis: Awaited<ReturnType<typeof getRedisClient>>,\r\n  cacheKey: string,\r\n  response: CacheableResponse,\r\n  context: string = '',\r\n): Promise<void> => {\r\n  const jailKey = createJailKey(cacheKey);\r\n\r\n  try {\r\n    // Get current jail data\r\n    const jailData = await redis.get(jailKey);\r\n    const jailEntry: JailEntry = jailData\r\n      ? JSON.parse(jailData)\r\n      : { count: 0, firstSeen: Date.now() };\r\n\r\n    // Increment count\r\n    jailEntry.count += 1;\r\n    jailEntry.lastSeen = Date.now();\r\n    jailEntry.lastResponse = {\r\n      finishReason: response.finishReason || 'unknown',\r\n      hasWarnings: !!(response.warnings && response.warnings.length > 0),\r\n      textLength:\r\n        response.content?.reduce(\r\n          (acc, part) => acc + (part.type === 'text' ? part.text.length : 0),\r\n          0,\r\n        ) || 0,\r\n    };\r\n\r\n    // Store updated jail entry\r\n    await redis.setEx(jailKey, config.jailTtl, JSON.stringify(jailEntry));\r\n\r\n    // Record metrics\r\n    if (config.enableMetrics) {\r\n      metricsCollector.recordJailUpdate(\r\n        cacheKey,\r\n        jailEntry.count,\r\n        config.jailThreshold,\r\n      );\r\n    }\r\n\r\n    if (config.enableLogging) {\r\n      log((l) =>\r\n        l.verbose(\r\n          `🏪 ${context}cache jail updated for key ${cacheKey.substring(0, config.maxKeyLogLength)}... (count: ${jailEntry.count}/${config.jailThreshold})`,\r\n        ),\r\n      );\r\n    }\r\n\r\n    // Check if we've hit the threshold\r\n    if (jailEntry.count >= config.jailThreshold) {\r\n      if (config.enableLogging) {\r\n        log((l) =>\r\n          l.verbose(\r\n            `🔓 ${context}cache jail threshold reached for key ${cacheKey.substring(0, config.maxKeyLogLength)}... - promoting to cache`,\r\n          ),\r\n        );\r\n      }\r\n\r\n      // Promote to cache\r\n      await cacheSuccessfulResponse(\r\n        redis,\r\n        cacheKey,\r\n        response,\r\n        `${context}problematic `,\r\n      );\r\n\r\n      // Record promotion metrics\r\n      if (config.enableMetrics) {\r\n        const responseSize =\r\n          response.content?.reduce(\r\n            (acc, part) => acc + (part.type === 'text' ? part.text.length : 0),\r\n            0,\r\n          ) || 0;\r\n        metricsCollector.recordJailPromotion(cacheKey, responseSize);\r\n      }\r\n    }\r\n  } catch (jailError) {\r\n    if (config.enableMetrics) {\r\n      metricsCollector.recordError(cacheKey, String(jailError));\r\n    }\r\n    if (config.enableLogging) {\r\n      console.error(`Error managing ${context}cache jail:`, jailError);\r\n    }\r\n  }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\cacheWithRedis\\cacheStrategy.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":5,"column":1,"nodeType":"Program","endLine":49,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Main cache strategy orchestrator\r\n */\r\n\r\nimport type { CacheableResponse } from './types';\r\nimport {\r\n  isSuccessfulResponse,\r\n  isProblematicResponse,\r\n} from './responseClassifiers';\r\nimport { cacheSuccessfulResponse, handleCacheJail } from './cacheOperations';\r\nimport { getCacheConfig } from './config';\r\nimport type { getRedisClient } from './redis-client';\r\nimport { log } from '@/lib/logger';\r\n\r\nconst config = getCacheConfig();\r\n\r\n/**\r\n * Handles the caching strategy for any response based on its classification\r\n *\r\n * @param redis - Redis client instance\r\n * @param cacheKey - The cache key for the response\r\n * @param response - The AI response to process\r\n * @param context - Optional context string for logging\r\n */\r\nexport const handleResponseCaching = async (\r\n  redis: Awaited<ReturnType<typeof getRedisClient>>,\r\n  cacheKey: string,\r\n  response: CacheableResponse,\r\n  context: string = '',\r\n): Promise<void> => {\r\n  const isSuccessful = isSuccessfulResponse(response);\r\n  const isProblematic = isProblematicResponse(response);\r\n\r\n  if (isSuccessful) {\r\n    await cacheSuccessfulResponse(redis, cacheKey, response, context);\r\n  } else if (isProblematic) {\r\n    await handleCacheJail(redis, cacheKey, response, context);\r\n  } else {\r\n    // Log why we're not caching\r\n    if (config.enableLogging) {\r\n      log((l) =>\r\n        l.warn(\r\n          `❌ Not caching ${context}response (finishReason: ${response.finishReason}, hasText: ${!!(response.content && response.content.length > 0)}) for key: ${cacheKey.substring(0, config.maxKeyLogLength)}...`,\r\n        ),\r\n      );\r\n    }\r\n  }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\cacheWithRedis\\cacheWithRedis.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":174,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type {\r\n  LanguageModelV2Middleware,\r\n  LanguageModelV2StreamPart,\r\n} from '@ai-sdk/provider';\r\nimport { getRedisClient } from './redis-client';\r\nimport { getCacheConfig, validateCacheConfig } from './config';\r\nimport { metricsCollector } from './metrics';\r\nimport { createCacheKey } from './cacheKeys';\r\nimport type { CacheableResponse } from './types';\r\nimport { handleCacheHit, handleCacheMiss } from './cacheEventHandlers';\r\nimport { createStreamFromCachedText } from './streamUtils';\r\nimport { handleResponseCaching } from './cacheStrategy';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { newUuid } from '@/lib/typescript/_record-decorators';\r\nimport { MiddlewareStateManager } from '../state-management';\r\n\r\n// Enterprise configuration and metrics\r\nconst config = getCacheConfig();\r\nvalidateCacheConfig(config);\r\n\r\n/**\r\n * Enterprise-grade Redis caching middleware for AI language models (Original Implementation)\r\n * - Configurable via environment variables\r\n * - Comprehensive metrics collection\r\n * - Caches successful responses immediately\r\n * - Uses \"cache jail\" for problematic responses (content-filter, other, warnings)\r\n * - Promotes jailed responses to cache after configurable threshold\r\n * - Never caches error responses\r\n */\r\nconst originalCacheWithRedis: LanguageModelV2Middleware = {\r\n  wrapGenerate: async ({ doGenerate, params, model }) => {\r\n    const cacheKey = createCacheKey(params, model?.modelId);\r\n\r\n    try {\r\n      if (cacheKey.length === 0) {\r\n        throw new Error('Cache key is empty, cannot proceed with caching.');\r\n      }\r\n      const redis = await getRedisClient();\r\n\r\n      // Try to get cached response\r\n      const cachedResponse = await redis.get(cacheKey);\r\n\r\n      if (cachedResponse) {\r\n        const parsed = JSON.parse(cachedResponse);\r\n        handleCacheHit(cacheKey, parsed);\r\n        return parsed as Awaited<ReturnType<typeof doGenerate>>;\r\n      }\r\n\r\n      handleCacheMiss(cacheKey);\r\n\r\n      // Generate new response\r\n      const result = await doGenerate();\r\n\r\n      // Handle caching strategy\r\n      await handleResponseCaching(redis, cacheKey, {\r\n        ...result,\r\n        id: newUuid(),\r\n      });\r\n\r\n      return result;\r\n    } catch (error) {\r\n      if (config.enableMetrics) {\r\n        metricsCollector.recordError(cacheKey, String(error));\r\n      }\r\n      if (config.enableLogging) {\r\n        LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n          log: true,\r\n        });\r\n      }\r\n      return await doGenerate();\r\n    }\r\n  },\r\n\r\n  wrapStream: async ({ doStream, params, model }) => {\r\n    const cacheKey = createCacheKey(params, model?.modelId);\r\n\r\n    try {\r\n      if (cacheKey.length === 0) {\r\n        throw new Error('Cache key is empty, cannot proceed with caching.');\r\n      }\r\n      const redis = await getRedisClient();\r\n\r\n      // Try to get cached response\r\n      const cachedResponse = await redis.get(cacheKey);\r\n\r\n      if (cachedResponse) {\r\n        const parsed = JSON.parse(cachedResponse);\r\n        handleCacheHit(cacheKey, parsed, 'Stream ');\r\n\r\n        // Convert cached text back to a stream\r\n        const cachedStream = createStreamFromCachedText(parsed);\r\n\r\n        return {\r\n          stream: cachedStream,\r\n          warnings: parsed.warnings,\r\n          rawCall: parsed.rawCall,\r\n          rawResponse: parsed.rawResponse,\r\n        };\r\n      }\r\n\r\n      handleCacheMiss(cacheKey, 'Stream ');\r\n\r\n      // Generate new stream\r\n      const { stream, ...rest } = await doStream();\r\n\r\n      let generatedText = '';\r\n      let finishReason = 'stop';\r\n      let usage: Record<string, unknown> | undefined = undefined;\r\n\r\n      const cacheStream = new TransformStream<\r\n        LanguageModelV2StreamPart,\r\n        LanguageModelV2StreamPart\r\n      >({\r\n        transform(chunk, controller) {\r\n          if (chunk.type === 'text-delta') {\r\n            generatedText += chunk.delta;\r\n          } else if ('text' in chunk) {\r\n            generatedText += chunk.text;\r\n          } else if (chunk.type === 'finish') {\r\n            finishReason = chunk.finishReason;\r\n            usage = chunk.usage;\r\n          }\r\n\r\n          controller.enqueue(chunk);\r\n        },\r\n\r\n        async flush() {\r\n          // Create response object for caching logic\r\n          const streamResponse: CacheableResponse = {\r\n            id: newUuid(),\r\n            content: [{ type: 'text', text: generatedText }],\r\n            finishReason,\r\n            usage,\r\n            rawResponse: (rest.response as Record<string, unknown>).body,\r\n          };\r\n\r\n          // Handle caching strategy for streaming response\r\n          await handleResponseCaching(\r\n            redis,\r\n            cacheKey,\r\n            streamResponse,\r\n            'stream ',\r\n          );\r\n        },\r\n      });\r\n\r\n      return {\r\n        stream: stream.pipeThrough(cacheStream),\r\n        ...rest,\r\n      };\r\n    } catch (error) {\r\n      if (config.enableMetrics) {\r\n        metricsCollector.recordError(cacheKey, String(error));\r\n      }\r\n      if (config.enableLogging) {\r\n        console.error('Redis cache error in wrapStream:', error);\r\n      }\r\n      return await doStream();\r\n    }\r\n  },\r\n};\r\n\r\n/**\r\n * Cache with Redis Middleware with State Management Support\r\n *\r\n * This middleware supports the state management protocol and can participate\r\n * in state collection and restoration operations.\r\n */\r\nexport const cacheWithRedis =\r\n  MiddlewareStateManager.Instance.basicMiddlewareWrapper({\r\n    middlewareId: 'cache-with-redis',\r\n    middleware: originalCacheWithRedis,\r\n  });\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\cacheWithRedis\\config.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":6,"column":1,"nodeType":"Program","endLine":84,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Enterprise-grade configuration for AI caching middleware\r\n * Supports environment variables with sensible defaults\r\n */\r\n\r\nexport interface CacheConfig {\r\n  /** Cache TTL in seconds (default: 24 hours) */\r\n  cacheTtl: number;\r\n  /** Cache jail threshold - number of occurrences before promotion (default: 3) */\r\n  jailThreshold: number;\r\n  /** Cache jail TTL in seconds (default: 24 hours) */\r\n  jailTtl: number;\r\n  /** Stream chunk size for cached responses (default: 5 characters) */\r\n  streamChunkSize: number;\r\n  /** Enable detailed logging (default: true) */\r\n  enableLogging: boolean;\r\n  /** Enable metrics collection (default: true) */\r\n  enableMetrics: boolean;\r\n  /** Cache key prefix (default: 'ai-cache') */\r\n  cacheKeyPrefix: string;\r\n  /** Jail key prefix (default: 'ai-jail') */\r\n  jailKeyPrefix: string;\r\n  /** Maximum cache key length for logging (default: 20) */\r\n  maxKeyLogLength: number;\r\n}\r\n\r\n/**\r\n * Parse environment variable as integer with fallback\r\n */\r\nfunction parseIntEnv(envVar: string | undefined, defaultValue: number): number {\r\n  if (!envVar) return defaultValue;\r\n  const parsed = parseInt(envVar, 10);\r\n  return isNaN(parsed) ? defaultValue : parsed;\r\n}\r\n\r\n/**\r\n * Parse environment variable as boolean with fallback\r\n */\r\nfunction parseBoolEnv(\r\n  envVar: string | undefined,\r\n  defaultValue: boolean,\r\n): boolean {\r\n  if (!envVar) return defaultValue;\r\n  return envVar.toLowerCase() === 'true' || envVar === '1';\r\n}\r\n\r\n/**\r\n * Get cache configuration from environment variables with defaults\r\n */\r\nexport function getCacheConfig(): CacheConfig {\r\n  return {\r\n    cacheTtl: parseIntEnv(process.env.AI_CACHE_TTL, 86400), // 24 hours\r\n    jailThreshold: parseIntEnv(process.env.AI_CACHE_JAIL_THRESHOLD, 3),\r\n    jailTtl: parseIntEnv(process.env.AI_CACHE_JAIL_TTL, 86400), // 24 hours\r\n    streamChunkSize: parseIntEnv(process.env.AI_CACHE_STREAM_CHUNK_SIZE, 5),\r\n    enableLogging: parseBoolEnv(process.env.AI_CACHE_ENABLE_LOGGING, true),\r\n    enableMetrics: parseBoolEnv(process.env.AI_CACHE_ENABLE_METRICS, true),\r\n    cacheKeyPrefix: process.env.AI_CACHE_KEY_PREFIX || 'ai-cache',\r\n    jailKeyPrefix: process.env.AI_CACHE_JAIL_KEY_PREFIX || 'ai-jail',\r\n    maxKeyLogLength: parseIntEnv(process.env.AI_CACHE_MAX_KEY_LOG_LENGTH, 20),\r\n  };\r\n}\r\n\r\n/**\r\n * Validate cache configuration\r\n */\r\nexport function validateCacheConfig(config: CacheConfig): void {\r\n  if (config.cacheTtl <= 0) {\r\n    throw new Error('Cache TTL must be positive');\r\n  }\r\n  if (config.jailThreshold <= 0) {\r\n    throw new Error('Jail threshold must be positive');\r\n  }\r\n  if (config.jailTtl <= 0) {\r\n    throw new Error('Jail TTL must be positive');\r\n  }\r\n  if (config.streamChunkSize <= 0) {\r\n    throw new Error('Stream chunk size must be positive');\r\n  }\r\n  if (config.maxKeyLogLength <= 0) {\r\n    throw new Error('Max key log length must be positive');\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\cacheWithRedis\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\cacheWithRedis\\metrics.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":13,"column":1,"nodeType":"Program","endLine":564,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Enterprise-grade metrics collection for AI caching middleware\r\n * Provides hooks for monitoring cache performance and jail behavior\r\n *\r\n * Features:\r\n * - OpenTelemetry integration for enterprise observability\r\n * - Prometheus-compatible metrics export\r\n * - Real-time event streaming and hooks\r\n * - Performance timing and response size tracking\r\n * - Error categorization and jail behavior monitoring\r\n */\r\n\r\nimport { log } from '@/lib/logger';\r\nimport { appMeters } from '@/lib/site-util/metrics';\r\n\r\n// OpenTelemetry Metrics - Enterprise observability\r\nconst cacheHitsCounter = appMeters.createCounter('ai_cache_hits_total', {\r\n  description: 'Total number of AI cache hits',\r\n  unit: '1',\r\n});\r\n\r\nconst cacheMissesCounter = appMeters.createCounter('ai_cache_misses_total', {\r\n  description: 'Total number of AI cache misses',\r\n  unit: '1',\r\n});\r\n\r\nconst cacheStoresCounter = appMeters.createCounter('ai_cache_stores_total', {\r\n  description: 'Total number of successful cache stores',\r\n  unit: '1',\r\n});\r\n\r\nconst jailPromotionsCounter = appMeters.createCounter(\r\n  'ai_cache_jail_promotions_total',\r\n  {\r\n    description:\r\n      'Total number of jail promotions (problematic responses cached)',\r\n    unit: '1',\r\n  },\r\n);\r\n\r\nconst cacheErrorsCounter = appMeters.createCounter('ai_cache_errors_total', {\r\n  description: 'Total number of cache operation errors',\r\n  unit: '1',\r\n});\r\n\r\nconst hitRateGauge = appMeters.createUpDownCounter('ai_cache_hit_rate', {\r\n  description: 'Current cache hit rate (0-1)',\r\n  unit: '1',\r\n});\r\n\r\nconst avgResponseSizeGauge = appMeters.createUpDownCounter(\r\n  'ai_cache_avg_response_size',\r\n  {\r\n    description: 'Average response size in characters',\r\n    unit: 'By',\r\n  },\r\n);\r\n\r\nconst responseSizeHistogram = appMeters.createHistogram(\r\n  'ai_cache_response_size_bytes',\r\n  {\r\n    description: 'Distribution of AI response sizes',\r\n    unit: 'By',\r\n  },\r\n);\r\n\r\nconst cacheOperationDuration = appMeters.createHistogram(\r\n  'ai_cache_operation_duration_ms',\r\n  {\r\n    description: 'Duration of cache operations in milliseconds',\r\n    unit: 'ms',\r\n  },\r\n);\r\n\r\nexport interface CacheMetrics {\r\n  /** Total cache hits */\r\n  cacheHits: number;\r\n  /** Total cache misses */\r\n  cacheMisses: number;\r\n  /** Total successful caches */\r\n  successfulCaches: number;\r\n  /** Total problematic responses */\r\n  problematicResponses: number;\r\n  /** Total jail promotions */\r\n  jailPromotions: number;\r\n  /** Total cache errors */\r\n  cacheErrors: number;\r\n  /** Cache hit rate (0-1) */\r\n  hitRate: number;\r\n  /** Average response size in characters */\r\n  avgResponseSize: number;\r\n  /** Total responses processed */\r\n  totalResponses: number;\r\n}\r\n\r\nexport interface CacheEvent {\r\n  type: 'hit' | 'miss' | 'store' | 'jail_update' | 'jail_promotion' | 'error';\r\n  cacheKey: string;\r\n  timestamp: number;\r\n  metadata?: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Metrics collector with thread-safe operations\r\n */\r\nclass MetricsCollector {\r\n  private metrics: CacheMetrics = {\r\n    cacheHits: 0,\r\n    cacheMisses: 0,\r\n    successfulCaches: 0,\r\n    problematicResponses: 0,\r\n    jailPromotions: 0,\r\n    cacheErrors: 0,\r\n    hitRate: 0,\r\n    avgResponseSize: 0,\r\n    totalResponses: 0,\r\n  };\r\n\r\n  private totalResponseSize = 0;\r\n  private events: CacheEvent[] = [];\r\n  private maxEvents = 1000; // Keep last 1000 events\r\n  private metricsHooks: Array<(metrics: CacheMetrics) => void> = [];\r\n  private eventHooks: Array<(event: CacheEvent) => void> = [];\r\n\r\n  /**\r\n   * Record a cache hit\r\n   */\r\n  recordHit(cacheKey: string, responseSize?: number): void {\r\n    const startTime = performance.now();\r\n\r\n    this.metrics.cacheHits++;\r\n    this.metrics.totalResponses++;\r\n\r\n    if (responseSize !== undefined) {\r\n      this.totalResponseSize += responseSize;\r\n      this.metrics.avgResponseSize =\r\n        this.totalResponseSize / this.metrics.totalResponses;\r\n\r\n      // OpenTelemetry metrics\r\n      responseSizeHistogram.record(responseSize, {\r\n        operation: 'hit',\r\n        cache_key: this.hashCacheKey(cacheKey),\r\n      });\r\n    }\r\n\r\n    this.updateHitRate();\r\n\r\n    // OpenTelemetry metrics\r\n    cacheHitsCounter.add(1, {\r\n      cache_key: this.hashCacheKey(cacheKey),\r\n    });\r\n\r\n    // Update hit rate gauge to current value\r\n    hitRateGauge.add(this.metrics.hitRate, {\r\n      cache_key: this.hashCacheKey(cacheKey),\r\n    });\r\n\r\n    // Update average response size gauge to current value\r\n    if (responseSize !== undefined) {\r\n      avgResponseSizeGauge.add(this.metrics.avgResponseSize, {\r\n        cache_key: this.hashCacheKey(cacheKey),\r\n      });\r\n    }\r\n\r\n    cacheOperationDuration.record(performance.now() - startTime, {\r\n      operation: 'hit',\r\n      cache_key: this.hashCacheKey(cacheKey),\r\n    });\r\n\r\n    this.addEvent({\r\n      type: 'hit',\r\n      cacheKey,\r\n      timestamp: Date.now(),\r\n      metadata: { responseSize },\r\n    });\r\n\r\n    this.notifyMetricsHooks();\r\n  }\r\n\r\n  /**\r\n   * Record a cache miss\r\n   */\r\n  recordMiss(cacheKey: string): void {\r\n    const startTime = performance.now();\r\n\r\n    this.metrics.cacheMisses++;\r\n    this.metrics.totalResponses++;\r\n    this.updateHitRate();\r\n\r\n    // OpenTelemetry metrics\r\n    cacheMissesCounter.add(1, {\r\n      cache_key: this.hashCacheKey(cacheKey),\r\n    });\r\n\r\n    hitRateGauge.add(this.metrics.hitRate, {\r\n      cache_key: this.hashCacheKey(cacheKey),\r\n    });\r\n\r\n    cacheOperationDuration.record(performance.now() - startTime, {\r\n      operation: 'miss',\r\n      cache_key: this.hashCacheKey(cacheKey),\r\n    });\r\n\r\n    this.addEvent({\r\n      type: 'miss',\r\n      cacheKey,\r\n      timestamp: Date.now(),\r\n    });\r\n\r\n    this.notifyMetricsHooks();\r\n  }\r\n\r\n  /**\r\n   * Record a successful cache store\r\n   */\r\n  recordStore(cacheKey: string, responseSize: number): void {\r\n    const startTime = performance.now();\r\n\r\n    this.metrics.successfulCaches++;\r\n\r\n    // OpenTelemetry metrics\r\n    cacheStoresCounter.add(1, {\r\n      cache_key: this.hashCacheKey(cacheKey),\r\n    });\r\n\r\n    responseSizeHistogram.record(responseSize, {\r\n      operation: 'store',\r\n      cache_key: this.hashCacheKey(cacheKey),\r\n    });\r\n\r\n    cacheOperationDuration.record(performance.now() - startTime, {\r\n      operation: 'store',\r\n      cache_key: this.hashCacheKey(cacheKey),\r\n    });\r\n\r\n    this.addEvent({\r\n      type: 'store',\r\n      cacheKey,\r\n      timestamp: Date.now(),\r\n      metadata: { responseSize },\r\n    });\r\n\r\n    this.notifyMetricsHooks();\r\n  }\r\n\r\n  /**\r\n   * Record a jail update\r\n   */\r\n  recordJailUpdate(cacheKey: string, count: number, threshold: number): void {\r\n    const startTime = performance.now();\r\n\r\n    this.metrics.problematicResponses++;\r\n\r\n    // OpenTelemetry metrics - track jail updates\r\n    cacheOperationDuration.record(performance.now() - startTime, {\r\n      operation: 'jail_update',\r\n      cache_key: this.hashCacheKey(cacheKey),\r\n      count: count.toString(),\r\n      threshold: threshold.toString(),\r\n    });\r\n\r\n    this.addEvent({\r\n      type: 'jail_update',\r\n      cacheKey,\r\n      timestamp: Date.now(),\r\n      metadata: { count, threshold },\r\n    });\r\n\r\n    this.notifyMetricsHooks();\r\n  }\r\n\r\n  /**\r\n   * Record a jail promotion\r\n   */\r\n  recordJailPromotion(cacheKey: string, responseSize: number): void {\r\n    const startTime = performance.now();\r\n\r\n    this.metrics.jailPromotions++;\r\n\r\n    // OpenTelemetry metrics\r\n    jailPromotionsCounter.add(1, {\r\n      cache_key: this.hashCacheKey(cacheKey),\r\n    });\r\n\r\n    responseSizeHistogram.record(responseSize, {\r\n      operation: 'jail_promotion',\r\n      cache_key: this.hashCacheKey(cacheKey),\r\n    });\r\n\r\n    cacheOperationDuration.record(performance.now() - startTime, {\r\n      operation: 'jail_promotion',\r\n      cache_key: this.hashCacheKey(cacheKey),\r\n    });\r\n\r\n    this.addEvent({\r\n      type: 'jail_promotion',\r\n      cacheKey,\r\n      timestamp: Date.now(),\r\n      metadata: { responseSize },\r\n    });\r\n\r\n    this.notifyMetricsHooks();\r\n  }\r\n\r\n  /**\r\n   * Record a cache error\r\n   */\r\n  recordError(cacheKey: string, error: string): void {\r\n    const startTime = performance.now();\r\n\r\n    this.metrics.cacheErrors++;\r\n\r\n    // OpenTelemetry metrics\r\n    cacheErrorsCounter.add(1, {\r\n      cache_key: this.hashCacheKey(cacheKey),\r\n      error_type: this.categorizeError(error),\r\n    });\r\n\r\n    cacheOperationDuration.record(performance.now() - startTime, {\r\n      operation: 'error',\r\n      cache_key: this.hashCacheKey(cacheKey),\r\n      error_type: this.categorizeError(error),\r\n    });\r\n\r\n    this.addEvent({\r\n      type: 'error',\r\n      cacheKey,\r\n      timestamp: Date.now(),\r\n      metadata: { error },\r\n    });\r\n\r\n    this.notifyMetricsHooks();\r\n  }\r\n\r\n  /**\r\n   * Get current metrics snapshot\r\n   */\r\n  getMetrics(): CacheMetrics {\r\n    return { ...this.metrics };\r\n  }\r\n\r\n  /**\r\n   * Get recent events\r\n   */\r\n  getEvents(limit?: number): CacheEvent[] {\r\n    const events = [...this.events];\r\n    return limit ? events.slice(-limit) : events;\r\n  }\r\n\r\n  /**\r\n   * Subscribe to metrics updates\r\n   */\r\n  onMetricsUpdate(callback: (metrics: CacheMetrics) => void): () => void {\r\n    this.metricsHooks.push(callback);\r\n    return () => {\r\n      const index = this.metricsHooks.indexOf(callback);\r\n      if (index > -1) {\r\n        this.metricsHooks.splice(index, 1);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Subscribe to events\r\n   */\r\n  onEvent(callback: (event: CacheEvent) => void): () => void {\r\n    this.eventHooks.push(callback);\r\n    return () => {\r\n      const index = this.eventHooks.indexOf(callback);\r\n      if (index > -1) {\r\n        this.eventHooks.splice(index, 1);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset all metrics\r\n   */\r\n  reset(): void {\r\n    this.metrics = {\r\n      cacheHits: 0,\r\n      cacheMisses: 0,\r\n      successfulCaches: 0,\r\n      problematicResponses: 0,\r\n      jailPromotions: 0,\r\n      cacheErrors: 0,\r\n      hitRate: 0,\r\n      avgResponseSize: 0,\r\n      totalResponses: 0,\r\n    };\r\n    this.totalResponseSize = 0;\r\n    this.events = [];\r\n  }\r\n\r\n  private updateHitRate(): void {\r\n    const total = this.metrics.cacheHits + this.metrics.cacheMisses;\r\n    this.metrics.hitRate = total > 0 ? this.metrics.cacheHits / total : 0;\r\n  }\r\n\r\n  /**\r\n   * Hash cache key for telemetry (avoid exposing sensitive data)\r\n   */\r\n  private hashCacheKey(cacheKey: string): string {\r\n    // Simple hash to avoid exposing sensitive cache keys in telemetry\r\n    let hash = 0;\r\n    for (let i = 0; i < cacheKey.length; i++) {\r\n      const char = cacheKey.charCodeAt(i);\r\n      hash = (hash << 5) - hash + char;\r\n      hash = hash & hash; // Convert to 32-bit integer\r\n    }\r\n    return Math.abs(hash).toString(16).substring(0, 8);\r\n  }\r\n\r\n  /**\r\n   * Categorize error types for telemetry\r\n   */\r\n  private categorizeError(error: string): string {\r\n    const errorLower = error.toLowerCase();\r\n    if (errorLower.includes('timeout') || errorLower.includes('ttl')) {\r\n      return 'timeout';\r\n    }\r\n    if (errorLower.includes('connection') || errorLower.includes('network')) {\r\n      return 'connection';\r\n    }\r\n    if (errorLower.includes('redis') || errorLower.includes('database')) {\r\n      return 'redis';\r\n    }\r\n    if (errorLower.includes('parse') || errorLower.includes('json')) {\r\n      return 'parse';\r\n    }\r\n    if (errorLower.includes('permission') || errorLower.includes('auth')) {\r\n      return 'auth';\r\n    }\r\n    return 'unknown';\r\n  }\r\n\r\n  private addEvent(event: CacheEvent): void {\r\n    this.events.push(event);\r\n    if (this.events.length > this.maxEvents) {\r\n      this.events.shift();\r\n    }\r\n    this.notifyEventHooks(event);\r\n  }\r\n\r\n  private notifyMetricsHooks(): void {\r\n    const metrics = this.getMetrics();\r\n    this.metricsHooks.forEach((hook) => {\r\n      try {\r\n        hook(metrics);\r\n      } catch (error) {\r\n        console.error('Error in metrics hook:', error);\r\n      }\r\n    });\r\n  }\r\n\r\n  private notifyEventHooks(event: CacheEvent): void {\r\n    this.eventHooks.forEach((hook) => {\r\n      try {\r\n        hook(event);\r\n      } catch (error) {\r\n        console.error('Error in event hook:', error);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// Global metrics collector instance\r\nconst metricsCollector = new MetricsCollector();\r\n\r\nexport { metricsCollector };\r\n\r\n/**\r\n * Helper function to set up basic console logging for metrics\r\n */\r\nexport function setupConsoleMetrics(): () => void {\r\n  return metricsCollector.onMetricsUpdate((metrics) => {\r\n    if (metrics.totalResponses % 10 === 0 && metrics.totalResponses > 0) {\r\n      log((l) =>\r\n        l.info(\r\n          `📊 Cache Metrics - Hit Rate: ${(metrics.hitRate * 100).toFixed(1)}%, ` +\r\n            `Hits: ${metrics.cacheHits}, Misses: ${metrics.cacheMisses}, ` +\r\n            `Jail Promotions: ${metrics.jailPromotions}, Errors: ${metrics.cacheErrors}`,\r\n        ),\r\n      );\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Helper function to set up Prometheus-style metrics export\r\n */\r\nexport function getPrometheusMetrics(): string {\r\n  const metrics = metricsCollector.getMetrics();\r\n  return [\r\n    `# HELP ai_cache_hits_total Total number of cache hits`,\r\n    `# TYPE ai_cache_hits_total counter`,\r\n    `ai_cache_hits_total ${metrics.cacheHits}`,\r\n    ``,\r\n    `# HELP ai_cache_misses_total Total number of cache misses`,\r\n    `# TYPE ai_cache_misses_total counter`,\r\n    `ai_cache_misses_total ${metrics.cacheMisses}`,\r\n    ``,\r\n    `# HELP ai_cache_hit_rate Current cache hit rate`,\r\n    `# TYPE ai_cache_hit_rate gauge`,\r\n    `ai_cache_hit_rate ${metrics.hitRate}`,\r\n    ``,\r\n    `# HELP ai_cache_jail_promotions_total Total number of jail promotions`,\r\n    `# TYPE ai_cache_jail_promotions_total counter`,\r\n    `ai_cache_jail_promotions_total ${metrics.jailPromotions}`,\r\n    ``,\r\n    `# HELP ai_cache_errors_total Total number of cache errors`,\r\n    `# TYPE ai_cache_errors_total counter`,\r\n    `ai_cache_errors_total ${metrics.cacheErrors}`,\r\n    ``,\r\n    `# HELP ai_cache_avg_response_size Average response size in characters`,\r\n    `# TYPE ai_cache_avg_response_size gauge`,\r\n    `ai_cache_avg_response_size ${metrics.avgResponseSize}`,\r\n  ].join('\\n');\r\n}\r\n\r\n/**\r\n * Helper function to update OpenTelemetry gauge metrics with current values\r\n * Call this periodically to ensure gauges reflect current state\r\n */\r\nexport function updateOpenTelemetryGauges(): void {\r\n  const metrics = metricsCollector.getMetrics();\r\n\r\n  // Update gauges with current values (reset and set)\r\n  hitRateGauge.add(metrics.hitRate, { source: 'periodic_update' });\r\n  avgResponseSizeGauge.add(metrics.avgResponseSize, {\r\n    source: 'periodic_update',\r\n  });\r\n}\r\n\r\n/**\r\n * Helper function to get OpenTelemetry metrics summary for debugging\r\n */\r\nexport function getOpenTelemetryMetricsSummary(): Record<string, unknown> {\r\n  const metrics = metricsCollector.getMetrics();\r\n  return {\r\n    opentelemetry_metrics: {\r\n      counters: {\r\n        ai_cache_hits_total: metrics.cacheHits,\r\n        ai_cache_misses_total: metrics.cacheMisses,\r\n        ai_cache_stores_total: metrics.successfulCaches,\r\n        ai_cache_jail_promotions_total: metrics.jailPromotions,\r\n        ai_cache_errors_total: metrics.cacheErrors,\r\n      },\r\n      gauges: {\r\n        ai_cache_hit_rate: metrics.hitRate,\r\n        ai_cache_avg_response_size: metrics.avgResponseSize,\r\n      },\r\n      histograms: {\r\n        ai_cache_response_size_bytes: 'tracked',\r\n        ai_cache_operation_duration_ms: 'tracked',\r\n      },\r\n    },\r\n    collection_info: {\r\n      total_events: metricsCollector.getEvents().length,\r\n      last_updated: new Date().toISOString(),\r\n    },\r\n  };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\cacheWithRedis\\redis-client.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":105,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createClient, RedisClientType } from 'redis';\r\nimport { env } from '@/lib/site-util/env';\r\nimport { isError } from '@/lib/react-util/utility-methods';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { log } from '@/lib/logger';\r\n\r\nexport type { RedisClientType } from 'redis';\r\n\r\n/**\r\n * Redis client singleton manager using global symbol registry\r\n */\r\nclass RedisClientManager {\r\n  /** Symbol-based global registry key for Redis client singleton. */\r\n  static readonly #REGISTRY_KEY = Symbol.for('@noeducation/redis:RedisClient');\r\n\r\n  /** Global singleton Redis client via symbol registry. */\r\n  private static get client(): RedisClientType | null {\r\n    type GlobalReg = { [k: symbol]: RedisClientType | null };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    return g[this.#REGISTRY_KEY] ?? null;\r\n  }\r\n  private static set client(value: RedisClientType | null) {\r\n    type GlobalReg = { [k: symbol]: RedisClientType | null };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    g[this.#REGISTRY_KEY] = value;\r\n  }\r\n\r\n  /**\r\n   * Get or create a Redis client instance\r\n   * Uses singleton pattern to ensure we reuse the same connection\r\n   */\r\n  static async getClient(): Promise<RedisClientType> {\r\n    if (!this.client) {\r\n      this.client = createClient({\r\n        url: env('REDIS_URL'),\r\n        password: env('REDIS_PASSWORD'),\r\n      });\r\n\r\n      this.client.on('error', (err) => {\r\n        LoggedError.isTurtlesAllTheWayDownBaby(err, {\r\n          message: 'Redis client error',\r\n          data: {\r\n            redisUrl: env('REDIS_URL'),\r\n          },\r\n          source: 'redis-client',\r\n          log: true,\r\n        });\r\n      });\r\n\r\n      this.client.on('connect', () => {\r\n        log((l) => l.info('Redis client connected'));\r\n      });\r\n\r\n      this.client.on('reconnecting', () => {\r\n        log((l) => l.warn('Redis client reconnecting'));\r\n      });\r\n\r\n      this.client.on('ready', () => {\r\n        log((l) => l.info('Redis client ready'));\r\n      });\r\n\r\n      await this.client.connect();\r\n    }\r\n\r\n    return this.client;\r\n  }\r\n\r\n  /**\r\n   * Close the Redis connection\r\n   * Should be called when the application shuts down\r\n   */\r\n  static async closeClient(): Promise<void> {\r\n    if (this.client) {\r\n      try {\r\n        await this.client.quit();\r\n      } catch (error) {\r\n        if (\r\n          !isError(error) ||\r\n          !error.message.includes('The client is closed')\r\n        ) {\r\n          console.error('Error closing Redis client:', error);\r\n          throw error; // Re-throw to ensure we handle this in the application shutdown\r\n        }\r\n      }\r\n      this.client = null;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get or create a Redis client instance\r\n * Uses singleton pattern to ensure we reuse the same connection\r\n */\r\nexport async function getRedisClient(): Promise<RedisClientType> {\r\n  return RedisClientManager.getClient();\r\n}\r\n\r\n/**\r\n * Close the Redis connection\r\n * Should be called when the application shuts down\r\n */\r\nexport async function closeRedisClient(): Promise<void> {\r\n  return RedisClientManager.closeClient();\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\cacheWithRedis\\responseClassifiers.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":5,"column":1,"nodeType":"Program","endLine":44,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Response classification utilities for cache middleware\r\n */\r\n\r\nimport type { CacheableResponse } from './types';\r\n\r\n/**\r\n * Determines if a response should be cached immediately (successful response)\r\n *\r\n * @param response - The AI response to evaluate\r\n * @returns true if the response is successful and should be cached immediately\r\n */\r\nexport const isSuccessfulResponse = (response: CacheableResponse): boolean => {\r\n  return !!(\r\n    response &&\r\n    response.finishReason !== 'error' &&\r\n    !!response.content &&\r\n    Array.isArray(response.content) &&\r\n    response.content.some((x) => x.type === 'text' && !!x.text) &&\r\n    response.finishReason !== 'other' &&\r\n    response.finishReason !== 'content-filter' &&\r\n    (!response.warnings || response.warnings.length === 0)\r\n  );\r\n};\r\n\r\n/**\r\n * Determines if a response should be put in cache jail (problematic but not error)\r\n *\r\n * @param response - The AI response to evaluate\r\n * @returns true if the response is problematic and should go to cache jail\r\n */\r\nexport const isProblematicResponse = (response: CacheableResponse): boolean => {\r\n  return !!(\r\n    response &&\r\n    !!response.content &&\r\n    Array.isArray(response.content) &&\r\n    response.content.length > 0 &&\r\n    response.finishReason !== 'error' && // Never jail errors\r\n    (response.finishReason === 'other' ||\r\n      response.finishReason === 'content-filter' ||\r\n      (response.warnings && response.warnings.length > 0))\r\n  );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\cacheWithRedis\\streamUtils.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":5,"column":1,"nodeType":"Program","endLine":66,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Stream utilities for converting cached responses to streams\r\n */\r\n\r\nimport type { LanguageModelV2StreamPart } from '@ai-sdk/provider';\r\nimport type { CacheableResponse } from './types';\r\nimport { getCacheConfig } from './config';\r\n\r\nconst config = getCacheConfig();\r\n\r\n/**\r\n * Converts cached text response to a ReadableStream for streaming APIs\r\n *\r\n * @param parsed - The cached response to convert to a stream\r\n * @returns A ReadableStream that emits the cached content as streaming chunks\r\n */\r\nexport const createStreamFromCachedText = (\r\n  parsed: CacheableResponse,\r\n): ReadableStream<LanguageModelV2StreamPart> => {\r\n  return new ReadableStream<LanguageModelV2StreamPart>({\r\n    start(controller) {\r\n      // Emit text deltas to simulate streaming\r\n      const text = parsed.content?.reduce((acc, part) => acc + (part.type === 'text' ? part.text : ''), '') || '';\r\n\r\n      for (let i = 0; i < text.length; i += config.streamChunkSize) {\r\n        const chunk = text.slice(i, i + config.streamChunkSize);\r\n        controller.enqueue({\r\n          type: 'text-delta',\r\n          id: parsed.id,\r\n          delta: chunk,\r\n        });\r\n      }\r\n\r\n      // Emit finish event with proper type casting\r\n      const finishReason = (parsed.finishReason || 'stop') as\r\n        | 'stop'\r\n        | 'length'\r\n        | 'content-filter'\r\n        | 'tool-calls'\r\n        | 'error'\r\n        | 'other'\r\n        | 'unknown';\r\n\r\n      if (parsed.usage) {\r\n        controller.enqueue({\r\n          type: 'finish',\r\n          finishReason,\r\n          usage: parsed.usage as {\r\n            inputTokens: number;\r\n            outputTokens: number;\r\n            totalTokens: number;\r\n          },\r\n        });\r\n      } else {\r\n        controller.enqueue({\r\n          type: 'finish',\r\n          finishReason,\r\n          usage: { inputTokens: 0, outputTokens: 0, totalTokens: 0 },\r\n        });\r\n      }\r\n\r\n      controller.close();\r\n    },\r\n  });\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\cacheWithRedis\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":34,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { LanguageModelV2Content } from '@ai-sdk/provider';\r\n\r\n/**\r\n * @fileoverview Type definitions for Redis cache middleware\r\n */\r\n\r\n/**\r\n * Represents a cacheable AI response with all relevant metadata\r\n */\r\nexport interface CacheableResponse {\r\n  id: string;\r\n  content: Array<LanguageModelV2Content>;\r\n  finishReason?: string;\r\n  usage?: Record<string, unknown>;\r\n  warnings?: unknown[];\r\n  rawCall?: unknown;\r\n  rawResponse?: unknown;\r\n  response?: unknown;\r\n}\r\n\r\n/**\r\n * Represents an entry in the cache jail system for problematic responses\r\n */\r\nexport interface JailEntry {\r\n  count: number;\r\n  firstSeen: number;\r\n  lastSeen?: number;\r\n  lastResponse?: {\r\n    finishReason: string;\r\n    hasWarnings: boolean;\r\n    textLength: number;\r\n  };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\chat-history\\create-chat-history-context.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\chat-history\\flush-handlers.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":14,"column":1,"nodeType":"Program","endLine":457,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Flush Handlers for Chat History Middleware\r\n *\r\n * This module provides utility functions for handling the completion of chat turns,\r\n * including finalizing messages, updating turn status, generating chat titles,\r\n * and handling error scenarios during the flush operation.\r\n *\r\n * @module lib/ai/middleware/chat-history/flush-handlers\r\n * @version 1.0.0\r\n * @since 2025-07-17\r\n */\r\n\r\n// import { chats, chatTurns, chatMessages } from '@/drizzle/schema';\r\nimport { and, eq, isNull } from 'drizzle-orm';\r\nimport { drizDb, schema } from '@/lib/drizzle-db';\r\nimport { log } from '@/lib/logger';\r\nimport type { FlushContext, FlushResult, FlushConfig } from './types';\r\nimport { instrumentFlushOperation } from './instrumentation';\r\nimport {\r\n  insertPendingAssistantMessage,\r\n  reserveTurnId,\r\n} from './import-incoming-message';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { summarizeMessageRecord } from '@/lib/ai/chat/message-optimizer-tools';\r\n\r\n/**\r\n * Default configuration for flush operations.\r\n */\r\nconst DEFAULT_FLUSH_CONFIG: FlushConfig = {\r\n  autoGenerateTitle: true,\r\n  maxTitleLength: 100,\r\n  titleWordCount: 6,\r\n};\r\n\r\n/**\r\n * Finalizes the assistant message by updating its content and marking it as complete.\r\n *\r\n * This function updates the assistant message with the final accumulated text\r\n * and changes its status from \"streaming\" to \"complete\".\r\n *\r\n * @param context - The flush context containing message details\r\n * @returns Promise that resolves when message is finalized\r\n *\r\n * @example\r\n * ```typescript\r\n * await finalizeAssistantMessage({\r\n *   chatId: 'chat-123',\r\n *   turnId: 1,\r\n *   messageId: 42,\r\n *   generatedText: 'Hello, how can I help you?',\r\n *   startTime: Date.now()\r\n * });\r\n * ```\r\n */\r\nexport async function finalizeAssistantMessage(\r\n  context: FlushContext,\r\n): Promise<void> {\r\n  try {\r\n    if (!context.messageId) {\r\n      if (!context.generatedText?.trim()) {\r\n        log((l) =>\r\n          l.warn('No pending message to finalize', {\r\n            chatId: context.chatId,\r\n            turnId: context.turnId,\r\n          }),\r\n        );\r\n        return;\r\n      }\r\n      await drizDb().transaction(async (tx) => {\r\n        let thisTurnId = context.turnId;\r\n        if (!thisTurnId) {\r\n          thisTurnId = await reserveTurnId(tx, context.chatId);\r\n          context.turnId = thisTurnId;\r\n        }\r\n        await insertPendingAssistantMessage(\r\n          tx,\r\n          context.chatId,\r\n          thisTurnId,\r\n          0,\r\n          0,\r\n          context.generatedText,\r\n        );\r\n      });\r\n      return;\r\n    }\r\n\r\n    await drizDb()\r\n      .update(schema.chatMessages)\r\n      .set(\r\n        context.generatedText\r\n          ? {\r\n              content: JSON.stringify([\r\n                { type: 'text', text: context.generatedText },\r\n              ]),\r\n              statusId: 2, // complete status\r\n            }\r\n          : {\r\n              statusId: 2, // complete status\r\n            },\r\n      )\r\n      .where(\r\n        and(\r\n          eq(schema.chatMessages.chatId, context.chatId),\r\n          eq(schema.chatMessages.turnId, context.turnId!),\r\n          eq(schema.chatMessages.messageId, context.messageId),\r\n        ),\r\n      );\r\n\r\n    log((l) =>\r\n      l.debug('Assistant message finalized', {\r\n        chatId: context.chatId,\r\n        turnId: context.turnId,\r\n        messageId: context.messageId,\r\n        textLength: context.generatedText.length,\r\n      }),\r\n    );\r\n  } catch (error) {\r\n    throw LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      message: 'Error finalizing assistant message',\r\n      data: {\r\n        chatId: context.chatId,\r\n        turnId: context.turnId,\r\n        messageId: context.messageId,\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Completes the chat turn by updating its status and recording performance metrics.\r\n *\r\n * This function marks the turn as complete, records the completion timestamp,\r\n * and calculates the total latency for the turn.\r\n *\r\n * @param context - The flush context containing turn details\r\n * @param latencyMs - The calculated latency in milliseconds\r\n * @returns Promise that resolves when turn is completed\r\n *\r\n * @example\r\n * ```typescript\r\n * await completeChatTurn(context, 1250); // 1.25 seconds\r\n * ```\r\n */\r\nexport async function completeChatTurn(\r\n  context: FlushContext,\r\n  latencyMs: number,\r\n): Promise<void> {\r\n  if (!context.turnId) {\r\n    log((l) =>\r\n      l.warn('No turn ID provided for completion', {\r\n        chatId: context.chatId,\r\n      }),\r\n    );\r\n    return;\r\n  }\r\n\r\n  try {\r\n    await drizDb()\r\n      .update(schema.chatTurns)\r\n      .set({\r\n        statusId: 2, // complete status\r\n        completedAt: new Date().toISOString(),\r\n        latencyMs,\r\n      })\r\n      .where(\r\n        and(\r\n          eq(schema.chatTurns.chatId, context.chatId),\r\n          eq(schema.chatTurns.turnId, context.turnId),\r\n        ),\r\n      );\r\n\r\n    drizDb()\r\n      .select()\r\n      .from(schema.chatMessages)\r\n      .where(\r\n        and(\r\n          eq(schema.chatMessages.chatId, context.chatId),\r\n          eq(schema.chatMessages.turnId, context.turnId!),\r\n          eq(schema.chatMessages.statusId, 2), // only complete messages\r\n          isNull(schema.chatMessages.optimizedContent),\r\n        ),\r\n      )\r\n      .execute()\r\n      .then((x) =>\r\n        x.map((m) =>\r\n          // Process each message for summarization\r\n          summarizeMessageRecord({\r\n            chatId: m.chatId,\r\n            turnId: m.turnId,\r\n            messageId: m.messageId,\r\n            //write: false,\r\n            write: true,\r\n          }).catch((error) => {\r\n            LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n              log: true,\r\n              message: 'Error summarizing message record',\r\n              data: {\r\n                chatId: context.chatId,\r\n                turnId: context.turnId,\r\n                messageId: context.messageId,\r\n              },\r\n            });\r\n            return Promise.resolve(m);\r\n          }),\r\n        ),\r\n      );\r\n    log((l) =>\r\n      l.debug('Chat turn completed', {\r\n        chatId: context.chatId,\r\n        turnId: context.turnId,\r\n        latencyMs,\r\n      }),\r\n    );\r\n  } catch (error) {\r\n    throw LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      message: 'Failed to complete chat turn',\r\n      data: {\r\n        chatId: context.chatId,\r\n        turnId: context.turnId,\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Generates and sets a chat title if one doesn't exist.\r\n *\r\n * This function automatically generates a title for new chats based on the\r\n * first few words of the generated response. It only runs if the chat\r\n * doesn't already have a title.\r\n *\r\n * @param context - The flush context containing chat details\r\n * @param config - Configuration for title generation\r\n * @returns Promise that resolves when title is set (or skipped)\r\n *\r\n * @example\r\n * ```typescript\r\n * await generateChatTitle(context, {\r\n *   autoGenerateTitle: true,\r\n *   maxTitleLength: 100,\r\n *   titleWordCount: 6\r\n * });\r\n * ```\r\n */\r\nexport async function generateChatTitle(\r\n  context: FlushContext,\r\n  config: FlushConfig = DEFAULT_FLUSH_CONFIG,\r\n): Promise<void> {\r\n  if (!config.autoGenerateTitle || !context.generatedText) {\r\n    return;\r\n  }\r\n\r\n  try {\r\n    // Check if chat already has a title\r\n    const existingTitle = await drizDb().query.chats.findFirst({\r\n      where: eq(schema.chats.id, context.chatId),\r\n      columns: { title: true },\r\n    });\r\n\r\n    if (existingTitle?.title) {\r\n      log((l) =>\r\n        l.debug('Chat already has title, skipping generation', {\r\n          chatId: context.chatId,\r\n          existingTitle: existingTitle.title,\r\n        }),\r\n      );\r\n      return;\r\n    }\r\n\r\n    // Generate title from first few words\r\n    const words = context.generatedText\r\n      .split(' ')\r\n      .slice(0, config.titleWordCount);\r\n    const title = words.join(' ').substring(0, config.maxTitleLength);\r\n\r\n    if (title.trim()) {\r\n      await drizDb()\r\n        .update(schema.chats)\r\n        .set({ title })\r\n        .where(eq(schema.chats.id, context.chatId));\r\n\r\n      log((l) =>\r\n        l.debug('Generated chat title', {\r\n          chatId: context.chatId,\r\n          title,\r\n          wordCount: words.length,\r\n        }),\r\n      );\r\n    }\r\n  } catch (error) {\r\n    // Title generation is non-critical; log structured error but do not throw.\r\n    LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      message: 'Failed to generate chat title',\r\n      data: {\r\n        chatId: context.chatId,\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Marks a chat turn as failed due to an error during processing.\r\n *\r\n * This function updates the turn status to \"error\", records the completion time,\r\n * and stores the error message for debugging purposes.\r\n *\r\n * @param context - The flush context containing turn details\r\n * @param error - The error that caused the turn to fail\r\n * @returns Promise that resolves when turn is marked as failed\r\n *\r\n * @example\r\n * ```typescript\r\n * await markTurnAsError(context, new Error('Database connection failed'));\r\n * ```\r\n */\r\nexport async function markTurnAsError(\r\n  context: FlushContext,\r\n  error: Error,\r\n): Promise<void> {\r\n  if (!context.turnId) {\r\n    log((l) =>\r\n      l.warn('No turn ID provided for error marking', {\r\n        chatId: context.chatId,\r\n        error: error.message,\r\n      }),\r\n    );\r\n    return;\r\n  }\r\n  try {\r\n    await drizDb()\r\n      .update(schema.chatTurns)\r\n      .set({\r\n        statusId: 3, // error status\r\n        completedAt: new Date().toISOString(),\r\n        errors: [error.message],\r\n      })\r\n      .where(\r\n        and(\r\n          eq(schema.chatTurns.chatId, context.chatId),\r\n          eq(schema.chatTurns.turnId, context.turnId),\r\n        ),\r\n      );\r\n\r\n    log((l) =>\r\n      l.info('Turn marked as error', {\r\n        chatId: context.chatId,\r\n        turnId: context.turnId,\r\n        error: error.message,\r\n      }),\r\n    );\r\n  } catch (updateError) {\r\n    LoggedError.isTurtlesAllTheWayDownBaby(updateError, {\r\n      log: true,\r\n      message: 'Failed to mark turn as error',\r\n      data: {\r\n        originalError: error.message,\r\n        chatId: context.chatId,\r\n        turnId: context.turnId,\r\n      },\r\n    });\r\n    // Don't throw - already in an error state\r\n  }\r\n}\r\n\r\n/**\r\n * Main flush handler that orchestrates the completion of a chat turn.\r\n *\r\n * This function coordinates all the steps needed to properly complete a chat turn:\r\n * 1. Finalizes the assistant message\r\n * 2. Completes the turn with performance metrics\r\n * 3. Generates a chat title if needed\r\n * 4. Logs completion details\r\n *\r\n * @param context - The flush context containing all necessary details\r\n * @param config - Optional configuration for flush behavior\r\n * @returns Promise resolving to the flush result\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = await handleFlush({\r\n *   chatId: 'chat-123',\r\n *   turnId: 1,\r\n *   messageId: 42,\r\n *   generatedText: 'Hello, how can I help you?',\r\n *   startTime: Date.now() - 1250\r\n * });\r\n *\r\n * if (result.success) {\r\n *   console.log(`Turn completed in ${result.latencyMs}ms`);\r\n * }\r\n * ```\r\n */\r\nexport async function handleFlush(\r\n  context: FlushContext,\r\n  config: FlushConfig = DEFAULT_FLUSH_CONFIG,\r\n): Promise<FlushResult> {\r\n  return await instrumentFlushOperation(context, async () => {\r\n    const startFlush = Date.now();\r\n    const processingTimeMs = startFlush - context.startTime;\r\n\r\n    try {\r\n      // Step 1: Finalize the assistant message\r\n      await finalizeAssistantMessage(context);\r\n\r\n      // Step 2: Complete the turn with metrics\r\n      await completeChatTurn(context, processingTimeMs);\r\n\r\n      // Step 3: Generate chat title if needed\r\n      await generateChatTitle(context, config);\r\n\r\n      // Step 4: Log successful completion\r\n      log((l) =>\r\n        l.info('Chat turn completed successfully', {\r\n          chatId: context.chatId,\r\n          turnId: context.turnId,\r\n          processingTimeMs,\r\n          generatedTextLength: context.generatedText.length,\r\n          flushDurationMs: Date.now() - startFlush,\r\n        }),\r\n      );\r\n\r\n      return {\r\n        success: true,\r\n        processingTimeMs,\r\n        textLength: context.generatedText.length,\r\n      };\r\n    } catch (error) {\r\n      const flushError = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        message: 'Error during flush operation',\r\n        data: {\r\n          chatId: context.chatId,\r\n          turnId: context.turnId,\r\n        },\r\n      });\r\n\r\n      // Attempt to mark turn as error (best-effort)\r\n      await markTurnAsError(context, flushError);\r\n\r\n      return {\r\n        success: false,\r\n        processingTimeMs,\r\n        textLength: context.generatedText.length,\r\n        error: flushError,\r\n      };\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Export default configuration for external use.\r\n */\r\nexport { DEFAULT_FLUSH_CONFIG };\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\chat-history\\import-incoming-message.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":49,"column":1,"nodeType":"Program","endLine":1150,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Chat Message Import and Processing System\r\n *\r\n * This module provides functionality for importing and persisting incoming chat messages\r\n * within the AI middleware pipeline. It handles the complete lifecycle of message ingestion,\r\n * from chat session management to message sequencing and database persistence.\r\n *\r\n * **Key Features:**\r\n * - **Smart Chat Session Management**: Automatic chat creation and upsert operations\r\n * - **Turn-Based Organization**: Structured conversation turns with unique identifiers\r\n * - **Message Sequencing**: Automatic ordering and ID generation for message continuity\r\n * - **Tool Call Support**: Comprehensive handling of tool-calling workflows and metadata\r\n * - **Transaction Safety**: Full database transaction support for data consistency\r\n * - **Status Tracking**: Real-time message and turn status management\r\n * - **Metadata Preservation**: Rich context storage for debugging and analytics\r\n *\r\n * **Architecture:**\r\n * ```\r\n * Incoming Request → Chat Upsert → Turn Creation → Message Import → Assistant Preparation\r\n *        ↓              ↓           ↓              ↓               ↓\r\n *    Validation    ID Generation   Sequencing   Persistence   Status Setup\r\n * ```\r\n *\r\n * **Database Schema Integration:**\r\n * - **chats**: Top-level conversation containers with user association\r\n * - **chat_turns**: Individual request/response cycles within conversations\r\n * - **chat_messages**: Atomic message units with role-based organization\r\n *\r\n * **Performance Characteristics:**\r\n * - Modular helper functions for maintainability and testing\r\n * - Batch message insertion for efficiency\r\n * - Optimized sequence generation for minimal database roundtrips\r\n * - Transactional consistency for data integrity\r\n * - Structured logging for operational monitoring\r\n *\r\n * **Use Cases:**\r\n * - AI chat application message persistence\r\n * - Conversation history management\r\n * - Tool-calling workflow tracking\r\n * - Multi-turn dialogue state management\r\n * - Analytics and debugging data collection\r\n *\r\n * @module import-incoming-message\r\n * @version 2.0.0\r\n * @author AI Middleware Team\r\n * @since 1.0.0\r\n */\r\n\r\nimport { schema } from '@/lib/drizzle-db/schema';\r\nimport type { ChatMessagesType, DbTransactionType } from '@/lib/drizzle-db';\r\nimport { ChatHistoryContext, ToolStatus } from './types';\r\nimport { eq, desc, and } from 'drizzle-orm';\r\nimport { log } from '@/lib/logger';\r\nimport { getNextSequence, getNewMessages, getItemOutput } from './utility';\r\nimport { generateChatId } from '@/lib/ai/core';\r\nimport type {\r\n  LanguageModelV2CallOptions,\r\n  LanguageModelV2ToolResultPart,\r\n  SharedV2ProviderOptions,\r\n} from '@ai-sdk/provider';\r\n\r\n// ============================================================================\r\n// Private Helper Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Resolves and normalizes chat ID from the context.\r\n *\r\n * @remarks\r\n * This function handles the conversion of various chat ID formats into a standardized\r\n * string format. It supports both string-based identifiers and numeric identifiers,\r\n * with intelligent fallback to auto-generated IDs when none are provided.\r\n *\r\n * **ID Resolution Strategy:**\r\n * - String IDs are preserved as-is, with fallback generation for null/undefined\r\n * - Numeric IDs are converted through the generateChatId utility for consistency\r\n * - Missing IDs trigger automatic generation with sequential numbering\r\n *\r\n * @param context - The chat history context containing the chat identifier\r\n * @returns A normalized string chat ID guaranteed to be valid\r\n *\r\n * @example\r\n * ```typescript\r\n * // String ID preservation\r\n * const stringId = getChatId({ chatId: 'chat_abc123' }); // Returns: 'chat_abc123'\r\n *\r\n * // Numeric ID conversion\r\n * const numericId = getChatId({ chatId: 42 }); // Returns: generated ID based on 42\r\n *\r\n * // Auto-generation fallback\r\n * const autoId = getChatId({ chatId: null }); // Returns: newly generated ID\r\n * ```\r\n */\r\nconst getChatId = (context: ChatHistoryContext): string =>\r\n  typeof context.chatId === 'string'\r\n    ? (context.chatId ?? generateChatId().id)\r\n    : generateChatId(context.chatId ?? 1).id;\r\n\r\n/**\r\n * Ensures a chat session exists in the database, creating it if necessary.\r\n *\r\n * @remarks\r\n * This function implements an idempotent upsert operation for chat sessions.\r\n * It checks for existing chats to avoid duplicates while creating new sessions\r\n * with comprehensive metadata when needed. The operation preserves existing\r\n * chat data and only creates new records when absolutely necessary.\r\n *\r\n * **Upsert Strategy:**\r\n * - Performs efficient existence check using SELECT with LIMIT 1\r\n * - Preserves existing chat sessions to maintain conversation continuity\r\n * - Creates new chats with rich metadata for debugging and analytics\r\n * - Associates chats with user accounts for proper access control\r\n *\r\n * **Metadata Storage:**\r\n * - Model configuration (name, temperature, topP)\r\n * - Request context (thread ID, first request ID)\r\n * - Creation timestamp for audit trails\r\n * - User association for access control\r\n *\r\n * @param tx - Active database transaction for consistency\r\n * @param chatId - The normalized chat ID to upsert\r\n * @param context - Chat context containing user and model information\r\n * @returns Promise that resolves when the upsert operation completes\r\n *\r\n * @example\r\n * ```typescript\r\n * // Upsert existing chat (no-op)\r\n * await upsertChat(transaction, 'existing_chat_123', context);\r\n *\r\n * // Create new chat with metadata\r\n * await upsertChat(transaction, 'new_chat_456', {\r\n *   userId: 789,\r\n *   model: 'gpt-4',\r\n *   temperature: 0.7,\r\n *   requestId: 'req_abc'\r\n * });\r\n * ```\r\n */\r\nexport const upsertChat = async (\r\n  tx: DbTransactionType,\r\n  chatId: string,\r\n  context: ChatHistoryContext,\r\n) => {\r\n  const existingChat =\r\n    (\r\n      await tx\r\n        .select({ id: schema.chats.id })\r\n        .from(schema.chats)\r\n        .where(eq(schema.chats.id, chatId))\r\n        .limit(1)\r\n        .execute()\r\n    ).length > 0;\r\n  if (existingChat) {\r\n    log((l) =>\r\n      l.debug(`Record ${chatId} already exists; no insert necessary.`),\r\n    );\r\n  } else {\r\n    await tx.insert(schema.chats).values({\r\n      id: String(chatId),\r\n      userId: Number(context.userId),\r\n      title: null,\r\n      createdAt: new Date().toISOString(),\r\n      metadata: {\r\n        model: context.model,\r\n        temperature: context.temperature,\r\n        topP: context.topP,\r\n        threadId: context.chatId,\r\n        firstRequestId: context.requestId,\r\n      },\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Reserves a unique turn ID for a new conversation turn.\r\n *\r\n * @remarks\r\n * This function generates and reserves a sequential turn identifier within a chat session.\r\n * Turn IDs ensure proper ordering of conversation cycles and enable efficient querying\r\n * of related messages. The function includes comprehensive error handling to ensure\r\n * sequence generation never fails silently.\r\n *\r\n * **Sequence Generation:**\r\n * - Uses the getNextSequence utility for atomic ID generation\r\n * - Ensures sequential ordering within chat sessions\r\n * - Prevents race conditions in concurrent scenarios\r\n * - Validates successful generation before returning\r\n *\r\n * **Error Handling:**\r\n * - Throws descriptive errors if sequence generation fails\r\n * - Includes chat ID context in error messages for debugging\r\n * - Ensures callers are aware of any generation failures\r\n *\r\n * @param tx - Active database transaction for consistency\r\n * @param chatId - The chat ID to generate a turn for\r\n * @returns Promise resolving to the reserved turn ID\r\n * @throws {Error} When sequence generation fails or returns invalid results\r\n *\r\n * @example\r\n * ```typescript\r\n * // Reserve turn ID for new conversation cycle\r\n * const turnId = await reserveTurnId(transaction, 'chat_abc123');\r\n * console.log(`Reserved turn: ${turnId}`); // e.g., \"Reserved turn: 5\"\r\n * ```\r\n */\r\nexport const reserveTurnId = async (\r\n  tx: DbTransactionType,\r\n  chatId: string,\r\n): Promise<number> => {\r\n  const thisTurnId = await getNextSequence({\r\n    tableName: 'chat_turns',\r\n    chatId: chatId,\r\n    tx,\r\n  }).then((ids) => ids[0]);\r\n  if (!thisTurnId) {\r\n    throw new Error(\r\n      'Unexpected failure retrieving next turn sequence for chat id ' + chatId,\r\n    );\r\n  }\r\n  return thisTurnId;\r\n};\r\n\r\n/**\r\n * Creates a new chat turn record with comprehensive metadata.\r\n *\r\n * @remarks\r\n * This function initializes a new conversation turn in the database with all\r\n * necessary tracking information. Turn records serve as containers for related\r\n * messages and provide audit trails for conversation analytics and debugging.\r\n *\r\n * **Turn Metadata:**\r\n * - Model configuration (name, temperature, topP)\r\n * - Request tracking (provider ID, request ID)\r\n * - Status management (waiting status for active turns)\r\n * - Performance metrics (latency placeholder, error/warning arrays)\r\n * - Creation timestamps for audit trails\r\n *\r\n * **Status Management:**\r\n * - Initial status is set to 1 (waiting/in-progress)\r\n * - Latency starts at 0 and will be updated on completion\r\n * - Error and warning arrays are initialized empty\r\n * - Provider ID links turn to originating request\r\n *\r\n * @param tx - Active database transaction for consistency\r\n * @param chatId - The chat ID this turn belongs to\r\n * @param turnId - The unique turn identifier\r\n * @param context - Chat context containing model and request information\r\n * @returns Promise that resolves when the turn record is created\r\n *\r\n * @example\r\n * ```typescript\r\n * // Create turn for GPT-4 conversation\r\n * await insertChatTurn(transaction, 'chat_123', 5, {\r\n *   requestId: 'req_abc',\r\n *   model: 'gpt-4',\r\n *   temperature: 0.7,\r\n *   topP: 0.9\r\n * });\r\n * ```\r\n */\r\nexport const insertChatTurn = async (\r\n  tx: DbTransactionType,\r\n  chatId: string,\r\n  turnId: number | undefined,\r\n  context: ChatHistoryContext,\r\n) => {\r\n  const thisTurnId = turnId ? turnId : await reserveTurnId(tx, chatId);\r\n  const providerId = ((rId: undefined | string) => {\r\n    if (!rId) {\r\n      return undefined;\r\n    }\r\n    const idxOf = rId.lastIndexOf(':');\r\n    if (idxOf === -1) {\r\n      return rId === chatId ? undefined : rId;\r\n    }\r\n    return rId.substring(idxOf + 1).trim();\r\n  })(context.requestId?.trim());\r\n  await tx.insert(schema.chatTurns).values({\r\n    chatId: chatId,\r\n    turnId: thisTurnId,\r\n    statusId: 1, // Waiting/in-progress\r\n    createdAt: new Date().toISOString(),\r\n    providerId,\r\n    temperature: context.temperature,\r\n    topP: context.topP,\r\n    warnings: [],\r\n    errors: [],\r\n    metadata: {\r\n      requestId: context.requestId,\r\n      model: context.model,\r\n    },\r\n  });\r\n};\r\n\r\n/**\r\n * Represents detailed information about a tool's execution state and data.\r\n * Used for tracking tool calls and results within chat messages.\r\n * @internal\r\n */\r\ntype ToolInfo = {\r\n  toolCallId?: string;\r\n  toolName?: string;\r\n  input?: string;\r\n  output?: string;\r\n  status: ToolStatus;\r\n  media?: string;\r\n  providerOptions?: {\r\n    [key in 'input' | 'output']?: SharedV2ProviderOptions;\r\n  };\r\n};\r\n\r\n/**\r\n * Reserves a batch of sequential message IDs for efficient insertion.\r\n *\r\n * @remarks\r\n * This function pre-allocates a contiguous range of message IDs to ensure\r\n * proper ordering and prevent race conditions during batch message insertion.\r\n * The reservation system guarantees that message IDs are sequential within\r\n * each turn, enabling efficient querying and maintaining conversation flow.\r\n *\r\n * **Batch Reservation Strategy:**\r\n * - Allocates exact count needed for efficiency\r\n * - Ensures sequential ordering within turns\r\n * - Prevents gaps in message sequences\r\n * - Validates successful reservation before returning\r\n *\r\n * **Error Handling:**\r\n * - Comprehensive validation of returned ID count\r\n * - Descriptive error messages with context\r\n * - Includes expected vs actual counts for debugging\r\n * - Prevents silent failures that could corrupt ordering\r\n *\r\n * @param tx - Active database transaction for consistency\r\n * @param chatId - The chat ID these messages belong to\r\n * @param turnId - The turn ID these messages belong to\r\n * @param count - Number of message IDs to reserve\r\n * @returns Promise resolving to array of reserved message IDs\r\n * @throws {Error} When reservation fails or returns incorrect count\r\n *\r\n * @example\r\n * ```typescript\r\n * // Reserve IDs for 3 user messages + 1 assistant response\r\n * const messageIds = await reserveMessageIds(transaction, 'chat_123', 5, 4);\r\n * console.log(messageIds); // [101, 102, 103, 104]\r\n * ```\r\n */\r\nexport const reserveMessageIds = async (\r\n  tx: DbTransactionType,\r\n  chatId: string,\r\n  turnId: number,\r\n  count: number,\r\n): Promise<number[]> => {\r\n  const messageIds = await getNextSequence({\r\n    tableName: 'chat_messages',\r\n    chatId: chatId,\r\n    turnId: turnId,\r\n    count: count,\r\n    tx,\r\n  });\r\n  if (!messageIds || messageIds.length < count) {\r\n    throw new Error(\r\n      `Failed to reserve enough message ids for chat ${chatId} turn ${turnId}. Expected ${count}, got ${messageIds?.length ?? 0}`,\r\n    );\r\n  }\r\n  return messageIds;\r\n};\r\n\r\n/**\r\n * Inserts a pending assistant message row to begin streaming content.\r\n *\r\n * @param tx - Active transaction\r\n * @param chatId - Chat identifier\r\n * @param turnId - Turn identifier\r\n * @param messageId - Pre-reserved message id\r\n * @param messageOrder - Sequential order for the message\r\n * @param content - Initial content payload (typically a JSON stringified text part array)\r\n */\r\nexport const insertPendingAssistantMessage = async (\r\n  tx: DbTransactionType,\r\n  chatId: string,\r\n  turnId: number,\r\n  messageId: number,\r\n  messageOrder: number,\r\n  content: string,\r\n) => {\r\n  await tx\r\n    .insert(schema.chatMessages)\r\n    .values({\r\n      chatId,\r\n      turnId,\r\n      messageId,\r\n      role: 'assistant',\r\n      content,\r\n      messageOrder,\r\n      statusId: 1, // pending/in-progress\r\n    })\r\n    // Use returning() to align with existing mocked insert chain in tests\r\n    .returning()\r\n    .execute();\r\n};\r\n\r\n/**\r\n * Simple type guard identifying tool-call parts.\r\n */\r\nconst isToolCallPart = (\r\n  item: unknown,\r\n): item is {\r\n  type: 'tool-call';\r\n  toolCallId?: string;\r\n  toolName?: string;\r\n  input?: unknown;\r\n} => {\r\n  return (\r\n    !!item &&\r\n    typeof item === 'object' &&\r\n    (item as { type?: unknown }).type === 'tool-call'\r\n  );\r\n};\r\n\r\n/**\r\n * Simple type guard identifying tool-result parts.\r\n */\r\nconst isToolResultPart = (\r\n  item: unknown,\r\n): item is {\r\n  type: 'tool-result' | 'dynamic-tool';\r\n  toolCallId?: string;\r\n  toolName?: string;\r\n  output?: unknown;\r\n  error?: unknown;\r\n} => {\r\n  return (\r\n    !!item &&\r\n    typeof item === 'object' &&\r\n    'type' in item &&\r\n    (item.type === 'tool-result' || item.type === 'dynamic-tool')\r\n  );\r\n};\r\n\r\n/**\r\n * Safely parse JSON-like strings into objects/arrays; otherwise return original value\r\n * @param value - The value to parse\r\n * @returns Parsed object/array or original value if parsing fails\r\n */\r\nconst parseMaybeJson = (value: unknown): unknown => {\r\n  if (typeof value !== 'string') return value;\r\n  const s = value.trim();\r\n  if (!s || (s[0] !== '{' && s[0] !== '[')) return value;\r\n  try {\r\n    return JSON.parse(s);\r\n  } catch {\r\n    return value;\r\n  }\r\n};\r\n\r\n/**\r\n * Internal utility method for merging a tool message field.\r\n *\r\n * @param prop - The property to process ('functionCall' or 'toolResult')\r\n * @param target - The target object to update\r\n * @param toolRow - The incoming tool message row\r\n * @param existing - The existing persisted message data\r\n * @param isNewerMessage - Whether the incoming message is newer than the existing one\r\n * @returns True if the target was updated, false otherwise\r\n * @remarks\r\n * This method encapsulates the logic for non-destructive merging of tool message fields.\r\n * It checks if the incoming message has new data for the specified property\r\n * and updates the target object accordingly, preserving existing data when appropriate.\r\n * The method returns a boolean indicating whether an update was made.\r\n */\r\nconst processField = ({\r\n  prop,\r\n  target,\r\n  toolRow,\r\n  existing,\r\n  isNewerMessage,\r\n}: {\r\n  prop: 'functionCall' | 'toolResult';\r\n  target: Partial<ChatMessagesType>;\r\n  toolRow: ChatMessageRowDraft;\r\n  existing: Pick<ChatMessagesType, 'functionCall' | 'toolResult' | 'statusId'>;\r\n  isNewerMessage: boolean;\r\n}): boolean => {\r\n  // If the incoming message has a value for this field\r\n  if (!!toolRow[prop]) {\r\n    // And the existing message does not\r\n    if (\r\n      !existing[prop] ||\r\n      // Or this is a newer message and the messages are different\r\n      (isNewerMessage && toolRow[prop] !== existing[prop])\r\n    ) {\r\n      target[prop] = toolRow[prop];\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Upserts a tool message by providerId, implementing non-destructive merge.\r\n *\r\n * @remarks\r\n * This function implements the core logic for tool message deduplication by:\r\n * 1. Looking for existing tool messages with the same providerId\r\n * 2. Only updating if the current turnId is greater than the stored modifiedTurnId\r\n * 3. Preserving existing functionCall data when adding toolResult\r\n * 4. Resetting optimization fields when updating\r\n * 5. Adding modifiedTurnId to metadata for tracking\r\n *\r\n * @param tx - Active database transaction\r\n * @param chatId - The chat ID\r\n * @param turnId - Current turn ID\r\n * @param toolRow - The tool message row to upsert\r\n * @returns Promise resolving to the messageId of the upserted record\r\n */\r\nexport const upsertToolMessage = async (\r\n  tx: DbTransactionType,\r\n  chatId: string,\r\n  turnId: number,\r\n  toolRow: ChatMessageRowDraft,\r\n): Promise<number | null> => {\r\n  if (!toolRow.providerId) {\r\n    // No providerId means we can't deduplicate, just insert normally\r\n    return null;\r\n  }\r\n\r\n  // Look for existing tool message with this providerId\r\n  const existingMessages = await tx\r\n    .select({\r\n      chatMessageId: schema.chatMessages.chatMessageId,\r\n      messageId: schema.chatMessages.messageId,\r\n      turnId: schema.chatMessages.turnId,\r\n      toolName: schema.chatMessages.toolName,\r\n      statusId: schema.chatMessages.statusId,\r\n      functionCall: schema.chatMessages.functionCall,\r\n      toolResult: schema.chatMessages.toolResult,\r\n      metadata: schema.chatMessages.metadata,\r\n      optimizedContent: schema.chatMessages.optimizedContent,\r\n    })\r\n    .from(schema.chatMessages)\r\n    .where(\r\n      and(\r\n        eq(schema.chatMessages.chatId, chatId),\r\n        eq(schema.chatMessages.providerId, toolRow.providerId),\r\n        eq(schema.chatMessages.role, 'tool'),\r\n      ),\r\n    )\r\n    .limit(1);\r\n\r\n  if (existingMessages.length === 0 || !existingMessages[0]) {\r\n    // No existing message, return null to signal normal insert\r\n    return null;\r\n  }\r\n  // Determine if we want to update the persisted row.  This is true if -\r\n  // 1. We have data they do not (eg we have a result but none is persisted)\r\n  // 2. We both have data and our turn > the last modified turn\r\n  const existing = existingMessages[0];\r\n  const existingMetadata =\r\n    (existing?.metadata as { modifiedTurnId?: number } | null) || {};\r\n  const lastModifiedTurnId = existingMetadata.modifiedTurnId || 0;\r\n  const isNewerMessage = turnId > lastModifiedTurnId;\r\n\r\n  let updated = false;\r\n\r\n  // Prepare update data with non-destructive merge\r\n  const updateData: Partial<typeof schema.chatMessages.$inferInsert> = {\r\n    functionCall: existing.functionCall,\r\n    toolResult: existing.toolResult,\r\n    statusId: existing.statusId,\r\n    metadata: {\r\n      ...existingMetadata,\r\n      providerOptions: {\r\n        ...(('providerOptions' in existingMetadata\r\n          ? existingMetadata.providerOptions\r\n          : null) ?? {}),\r\n        ...((typeof toolRow.metadata == 'object' &&\r\n        toolRow.metadata &&\r\n        'providerOptions' in toolRow.metadata\r\n          ? toolRow.metadata.providerOptions\r\n          : null) ?? {}),\r\n      },\r\n      modifiedTurnId: turnId,\r\n    },\r\n    // Reset optimization fields when updating\r\n    optimizedContent: null,\r\n  };\r\n\r\n  if (toolRow.statusId > (existing.statusId ?? -1)) {\r\n    // If incoming status is greater than (eg more complete) than existing, update it\r\n    updateData.statusId = toolRow.statusId;\r\n    updated = true;\r\n  }\r\n  if (\r\n    processField({\r\n      prop: 'functionCall',\r\n      target: updateData,\r\n      toolRow,\r\n      existing,\r\n      isNewerMessage,\r\n    })\r\n  ) {\r\n    updated = true;\r\n  }\r\n  if (\r\n    processField({\r\n      prop: 'toolResult',\r\n      target: updateData,\r\n      toolRow,\r\n      existing,\r\n      isNewerMessage,\r\n    })\r\n  ) {\r\n    updated = true;\r\n  }\r\n  if (!updated) {\r\n    // Return current id signals no update is necessary\r\n    return existing.messageId;\r\n  }\r\n  // If we reach here, we have updates to apply\r\n\r\n  // Don't overwrite existing toolResult if incoming is null\r\n  if (\r\n    updateData.metadata &&\r\n    typeof updateData.metadata == 'object' &&\r\n    'providerOptions' in updateData.metadata &&\r\n    updateData.metadata.providerOptions &&\r\n    Object.keys(updateData.metadata.providerOptions).length === 0\r\n  ) {\r\n    delete updateData.metadata.providerOptions;\r\n  }\r\n  // Update the existing record\r\n  await tx\r\n    .update(schema.chatMessages)\r\n    .set(updateData)\r\n    .where(eq(schema.chatMessages.chatMessageId, existing.chatMessageId));\r\n\r\n  log((l) =>\r\n    l.debug(\r\n      `Updated tool message for providerId ${toolRow.providerId} from turn ${existing.turnId} to ${turnId}`,\r\n    ),\r\n  );\r\n\r\n  return existing.messageId;\r\n};\r\n\r\n// ============================================================================\r\n// Main Export Function\r\n// ============================================================================\r\n\r\n/**\r\n * Gets the highest message order for a chat to ensure proper sequencing of new messages.\r\n *\r\n * @remarks\r\n * This function queries the database to find the highest message order number\r\n * for a specific chat session. This is essential for maintaining proper message\r\n * sequencing when adding new messages to existing conversations.\r\n *\r\n * @param tx - Active database transaction for consistency\r\n * @param chatId - The chat ID to query for message order\r\n * @returns Promise resolving to the highest message order (0 if no messages exist)\r\n */\r\nconst getLastMessageOrder = async (\r\n  tx: DbTransactionType,\r\n  chatId: string,\r\n): Promise<number> => {\r\n  const result = await tx\r\n    .select({ maxOrder: schema.chatMessages.messageOrder })\r\n    .from(schema.chatMessages)\r\n    .where(eq(schema.chatMessages.chatId, chatId))\r\n    .orderBy(desc(schema.chatMessages.messageOrder))\r\n    .limit(1);\r\n\r\n  return result.length > 0 ? result[0].maxOrder : 0;\r\n};\r\n\r\n/**\r\n * Imports and persists incoming chat messages within a transactional database context.\r\n *\r\n * @remarks\r\n * This function orchestrates the complete process of message ingestion for AI chat applications,\r\n * handling everything from chat session management to individual message persistence. It implements\r\n * a sophisticated workflow that ensures data consistency, proper sequencing, and comprehensive\r\n * metadata tracking throughout the message import process.\r\n *\r\n * **Workflow Overview:**\r\n * 1. **Chat ID Resolution**: Handles both string and numeric chat identifiers with fallback generation\r\n * 2. **Chat Session Upsert**: Creates new chats or validates existing ones with metadata preservation\r\n * 3. **Turn Management**: Generates unique turn identifiers for request/response cycles\r\n * 4. **Message Sequencing**: Reserves sequential message IDs for batch insertion\r\n * 5. **Content Processing**: Handles various message types including tool calls and responses\r\n * 6. **Assistant Preparation**: Creates pending assistant message for streaming responses\r\n *\r\n * **Modular Architecture:**\r\n * - Uses dedicated helper functions for maintainability and testing\r\n * - Each step is isolated for easier debugging and modification\r\n * - Comprehensive error handling at each stage\r\n * - Consistent logging for operational monitoring\r\n *\r\n * **Transaction Safety:**\r\n * - All operations occur within a single database transaction\r\n * - Ensures atomicity of the complete import process\r\n * - Automatic rollback on any failure point\r\n * - Maintains data consistency across all tables\r\n *\r\n * **Performance Optimizations:**\r\n * - Batch sequence generation minimizes database roundtrips\r\n * - Single batch insertion for all prompt messages\r\n * - Efficient existence checks for chat upsert operations\r\n * - Optimized queries with proper indexing support\r\n *\r\n * **Error Handling and Recovery:**\r\n * - Comprehensive validation at each processing stage\r\n * - Descriptive error messages with full context\r\n * - Graceful handling of edge cases and malformed input\r\n * - Automatic cleanup through transaction rollback\r\n *\r\n * @param params - The import operation parameters\r\n * @param params.tx - Active database transaction for consistency\r\n * @param params.context - Chat context containing user, model, and session information\r\n * @param params.params - Language model call options containing the message prompt\r\n * @param params.params.prompt - Array of messages to import into the conversation\r\n * @returns Promise resolving to import result with chat, turn, and message identifiers\r\n * @throws {Error} When sequence generation fails or message count validation errors occur\r\n *\r\n * @example\r\n * ```typescript\r\n * // Basic message import within a transaction\r\n * const result = await importIncomingMessage({\r\n *   tx: dbTransaction,\r\n *   context: {\r\n *     userId: 123,\r\n *     chatId: 'chat_abc123',\r\n *     model: 'gpt-4',\r\n *     temperature: 0.7,\r\n *     requestId: 'req_xyz789'\r\n *   },\r\n *   params: {\r\n *     prompt: [\r\n *       { role: 'user', content: 'Hello, can you help me?' },\r\n *       { role: 'assistant', content: 'Of course! How can I assist you?' }\r\n *     ]\r\n *   }\r\n * });\r\n *\r\n * console.log(`Chat: ${result.chatId}, Turn: ${result.turnId}, Message: ${result.messageId}`);\r\n * ```\r\n *\r\n * @example\r\n * ```typescript\r\n * // Tool call message import\r\n * const toolResult = await importIncomingMessage({\r\n *   tx: dbTransaction,\r\n *   context: {\r\n *     userId: 456,\r\n *     chatId: 'chat_def456',\r\n *     model: 'gpt-4',\r\n *     requestId: 'req_tool_123'\r\n *   },\r\n *   params: {\r\n *     prompt: [\r\n *       { role: 'user', content: 'What\\'s the weather like?' },\r\n *       {\r\n *         role: 'assistant',\r\n *         content: [{\r\n *           type: 'tool-call',\r\n *           toolCallId: 'call_123',\r\n *           toolName: 'getWeather',\r\n *           args: { location: 'San Francisco' }\r\n *         }]\r\n *       },\r\n *       {\r\n *         role: 'tool',\r\n *         content: [{\r\n *           toolCallId: 'call_123',\r\n *           result: { temperature: 72, condition: 'sunny' }\r\n *         }]\r\n *       }\r\n *     ]\r\n *   }\r\n * });\r\n * ```\r\n *\r\n * @example\r\n * ```typescript\r\n * // New chat creation with auto-generated ID\r\n * const newChatResult = await importIncomingMessage({\r\n *   tx: dbTransaction,\r\n *   context: {\r\n *     userId: 789,\r\n *     chatId: null, // Will auto-generate\r\n *     model: 'gpt-3.5-turbo',\r\n *     temperature: 0.5,\r\n *     topP: 0.9,\r\n *     requestId: 'req_new_chat'\r\n *   },\r\n *   params: {\r\n *     prompt: [\r\n *       { role: 'system', content: 'You are a helpful assistant.' },\r\n *       { role: 'user', content: 'Start a new conversation.' }\r\n *     ]\r\n *   }\r\n * });\r\n * ```\r\n */\r\nexport const importIncomingMessage = async ({\r\n  tx,\r\n  context,\r\n  params: { prompt, providerOptions: { backoffice = {} } = {} },\r\n}: {\r\n  /** Active database transaction ensuring consistency across all operations */\r\n  tx: DbTransactionType;\r\n  /** Chat context containing user, session, and model configuration */\r\n  context: ChatHistoryContext;\r\n  /** Language model call options containing the messages to import */\r\n  params: LanguageModelV2CallOptions;\r\n  /** Record identifier for the imported message */\r\n  messageId?: number;\r\n}) => {\r\n  // Resolve and normalize chat ID from context\r\n  const chatId = getChatId(context);\r\n  let currentMessageOrder = 0;\r\n  // Ensure chat session exists with proper metadata\r\n  await upsertChat(tx, chatId, context);\r\n\r\n  // Reserve unique turn ID for this conversation cycle\r\n  const thisTurnId = await reserveTurnId(tx, chatId);\r\n  log((l) =>\r\n    l.debug(`Reserved chat turn id: ${thisTurnId} for chat: ${chatId}`),\r\n  );\r\n\r\n  // Filter out messages that have already been saved in previous turns\r\n  const newMessages = await getNewMessages(tx, chatId, prompt, thisTurnId);\r\n\r\n  log((l) =>\r\n    l.debug(\r\n      `Filtered messages for chat ${chatId}: ${prompt.length} total, ${newMessages?.length || 0} new`,\r\n    ),\r\n  );\r\n\r\n  // Initialize turn record with comprehensive tracking information\r\n  await insertChatTurn(tx, chatId, thisTurnId, context);\r\n  backoffice.turnId = thisTurnId;\r\n\r\n  // Get the current highest message order for proper sequencing\r\n  let lastMessageOrder: number;\r\n  try {\r\n    lastMessageOrder = await getLastMessageOrder(tx, chatId);\r\n  } catch {\r\n    // If we can't get the last message order, default to 0\r\n    lastMessageOrder = 1;\r\n  }\r\n\r\n  // set current order to last message + 1\r\n  currentMessageOrder = lastMessageOrder + 1;\r\n\r\n  if (newMessages?.length) {\r\n    // Transform prompt into rows: tool-call/result -> single 'tool' row; other content grouped by role switches\r\n    const rows = flattenPromptToRows(\r\n      newMessages as LanguageModelV2CallOptions['prompt'],\r\n    );\r\n    if (rows.length > 0) {\r\n      const messageIds = await reserveMessageIds(\r\n        tx,\r\n        chatId,\r\n        thisTurnId,\r\n        rows.length,\r\n      );\r\n      await insertPromptMessages(\r\n        tx,\r\n        chatId,\r\n        thisTurnId,\r\n        messageIds,\r\n        rows,\r\n        currentMessageOrder,\r\n      );\r\n      currentMessageOrder += rows.length;\r\n    }\r\n  }\r\n  // Return comprehensive context for continued processing\r\n  return {\r\n    chatId,\r\n    turnId: thisTurnId,\r\n    messageId: undefined as number | undefined,\r\n    nextMessageOrder: currentMessageOrder,\r\n  };\r\n};\r\n\r\n// Removed unused bucketization helpers (replaced by flattenPromptToRows)\r\n\r\n// Draft row shape for chat_messages insertion\r\ntype ChatMessageRowDraft = {\r\n  role: 'user' | 'assistant' | 'tool' | 'system';\r\n  statusId: number;\r\n  content?: Array<Record<string, unknown>> | string | null;\r\n  toolName?: string | null;\r\n  functionCall?: unknown | null;\r\n  toolResult?: unknown | null;\r\n  providerId?: string | null;\r\n  metadata?: unknown | null;\r\n};\r\n\r\n// Convert prompt into rows honoring requirements 1-3\r\nconst flattenPromptToRows = (\r\n  prompt: LanguageModelV2CallOptions['prompt'],\r\n): ChatMessageRowDraft[] => {\r\n  const messages = Array.isArray(prompt) ? prompt : [prompt];\r\n  const rows: ChatMessageRowDraft[] = [];\r\n\r\n  let currentContentRow: {\r\n    role: ChatMessageRowDraft['role'];\r\n    content: Array<Record<string, unknown>>;\r\n  } | null = null;\r\n\r\n  const flushContent = () => {\r\n    if (currentContentRow && currentContentRow.content.length > 0) {\r\n      rows.push({\r\n        statusId: 1,\r\n        ...currentContentRow,\r\n      });\r\n    }\r\n    currentContentRow = null;\r\n  };\r\n\r\n  const pushToolRow = (info: ToolInfo) => {\r\n    let statusId: number;\r\n    switch (info.status) {\r\n      case 'pending':\r\n        statusId = 1;\r\n        break;\r\n      case 'content':\r\n        statusId = 2;\r\n        break;\r\n      case 'result':\r\n        statusId = 2;\r\n        break;\r\n      case 'error':\r\n        statusId = 3;\r\n        break;\r\n      default:\r\n        statusId = 1;\r\n        break;\r\n    }\r\n    const row: ChatMessageRowDraft = {\r\n      statusId,\r\n      role: 'tool',\r\n      content: info.media ? info.output : null,\r\n      toolName: info.toolName ?? null,\r\n      providerId: info.toolCallId ?? null,\r\n      functionCall: info.input ? parseMaybeJson(info.input) : null,\r\n      toolResult:\r\n        info.output || info.media\r\n          ? parseMaybeJson(info.media ?? info.output)\r\n          : null,\r\n      metadata: info.providerOptions\r\n        ? { providerOptions: info.providerOptions }\r\n        : undefined,\r\n    };\r\n    rows.push(row);\r\n  };\r\n\r\n  const pushContentItem = (\r\n    role: ChatMessageRowDraft['role'],\r\n    value: unknown,\r\n  ) => {\r\n    // early-exit on null/undefined/empty-string\r\n    if (!value) {\r\n      return;\r\n    }\r\n    let item: Record<string, unknown>;\r\n    // If we have an object we have to to some special handling\r\n    if (typeof value === 'object') {\r\n      if ('text' in value) {\r\n        // If it has a text property then just take it as is (note tools have already been removed by processContentPart)\r\n        item = value;\r\n      } else if (Array.isArray(value)) {\r\n        // If it's an array then we flatten it out by processing each item individually\r\n        for (const part of value as unknown[]) {\r\n          processContentPart(part, role);\r\n        }\r\n        // And then early exit - nothing left to do for this part\r\n        return;\r\n      } else {\r\n        // Otherwise, we stringify the object as a JSON text part (although honestly I think now that we're upgraded to v5 we could also prob just take as-is?)\r\n        item = { type: 'text', value: JSON.stringify(value) };\r\n      }\r\n    } else {\r\n      // Otherwise it's a non-object raw value, so we turn it into a text part\r\n      item = {\r\n        type: 'text',\r\n        text: typeof value === 'string' ? value : JSON.stringify(value),\r\n      };\r\n    }\r\n    // Append to the current content row or flush and start anew\r\n    if (!currentContentRow || currentContentRow.role !== role) {\r\n      flushContent();\r\n      currentContentRow = { role, content: [item] };\r\n    } else {\r\n      currentContentRow.content.push(item);\r\n    }\r\n  };\r\n\r\n  const processContentPart = (\r\n    part: unknown,\r\n    role: ChatMessageRowDraft['role'],\r\n  ) => {\r\n    if (!part) return;\r\n    // Handle tool-calls special...\r\n    if (isToolCallPart(part)) {\r\n      flushContent();\r\n      pushToolRow({\r\n        status: 'pending',\r\n        toolCallId: part.toolCallId,\r\n        toolName: part.toolName,\r\n        input:\r\n          part.input != null\r\n            ? typeof part.input === 'string'\r\n              ? part.input\r\n              : JSON.stringify(part.input)\r\n            : undefined,\r\n        providerOptions: (part as { providerOptions?: SharedV2ProviderOptions })\r\n          .providerOptions\r\n          ? {\r\n              input: (part as { providerOptions?: SharedV2ProviderOptions })\r\n                .providerOptions,\r\n            }\r\n          : undefined,\r\n      });\r\n      return;\r\n    }\r\n    // Handle tool-results special...\r\n    if (isToolResultPart(part)) {\r\n      flushContent();\r\n      const parsed = getItemOutput(part as LanguageModelV2ToolResultPart);\r\n      pushToolRow({\r\n        ...parsed,\r\n        toolCallId: (part as { toolCallId?: string }).toolCallId,\r\n        toolName: (part as { toolName?: string }).toolName,\r\n        providerOptions: (part as { providerOptions?: SharedV2ProviderOptions })\r\n          .providerOptions\r\n          ? {\r\n              output: (part as { providerOptions?: SharedV2ProviderOptions })\r\n                .providerOptions,\r\n            }\r\n          : undefined,\r\n      });\r\n      flushContent();\r\n      return;\r\n    }\r\n    // Otherwise fallback to normal content item processing\r\n    pushContentItem(role, part);\r\n  };\r\n\r\n  for (const message of messages) {\r\n    const role = (message.role as ChatMessageRowDraft['role']) ?? 'user';\r\n\r\n    if (typeof message.content === 'string') {\r\n      pushContentItem(role, message.content);\r\n      continue;\r\n    }\r\n    if (Array.isArray(message.content)) {\r\n      for (const part of message.content as unknown[]) {\r\n        processContentPart(part, role);\r\n      }\r\n      continue;\r\n    }\r\n    if (!!message.content) {\r\n      processContentPart(message.content, role);\r\n      continue;\r\n    }\r\n    pushContentItem(\r\n      role,\r\n      'value' in message && !!message.value ? message.value : message,\r\n    );\r\n  }\r\n\r\n  flushContent();\r\n  return rows;\r\n};\r\n\r\nconst insertPromptMessages = async (\r\n  tx: DbTransactionType,\r\n  chatId: string,\r\n  turnId: number,\r\n  messageIds: number[],\r\n  rows: ChatMessageRowDraft[],\r\n  startOrder: number,\r\n) => {\r\n  let messageOrder = startOrder;\r\n  const rowsToInsert: Array<typeof schema.chatMessages.$inferInsert> = [];\r\n  let messageIdIndex = 0;\r\n\r\n  // Process each row, checking for tool message upserts\r\n  for (const row of rows) {\r\n    if (row.role === 'tool' && row.providerId) {\r\n      // Try to upsert the tool message\r\n      const upsertedMessageId = await upsertToolMessage(\r\n        tx,\r\n        chatId,\r\n        turnId,\r\n        row,\r\n      );\r\n\r\n      if (upsertedMessageId !== null) {\r\n        // Message was updated, skip inserting a new row\r\n        log((l) =>\r\n          l.debug(\r\n            `Tool message upserted for providerId ${row.providerId}, messageId: ${upsertedMessageId}`,\r\n          ),\r\n        );\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // For non-tool messages or tool messages that couldn't be upserted, add to insert batch\r\n    const messageId =\r\n      messageIdIndex < messageIds.length ? messageIds[messageIdIndex] : 0;\r\n    messageIdIndex++;\r\n\r\n    const rowData = {\r\n      chatId,\r\n      turnId,\r\n      messageId,\r\n      role: row.role,\r\n      content:\r\n        typeof row.content === 'string'\r\n          ? row.content\r\n          : row.content != null\r\n            ? JSON.stringify(row.content)\r\n            : null,\r\n      toolName: row.toolName ?? null,\r\n      functionCall: row.functionCall ?? null,\r\n      toolResult: row.toolResult ?? null,\r\n      providerId: row.providerId ?? null,\r\n      metadata:\r\n        row.role === 'tool' && row.providerId\r\n          ? { modifiedTurnId: turnId, ...((row.metadata as object) || {}) }\r\n          : (row.metadata ?? null),\r\n      messageOrder: messageOrder++,\r\n      statusId: 2,\r\n    };\r\n\r\n    rowsToInsert.push(rowData);\r\n  }\r\n\r\n  // Insert any remaining non-upserted messages\r\n  if (rowsToInsert.length > 0) {\r\n    await tx.insert(schema.chatMessages).values(rowsToInsert).execute();\r\n  }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\chat-history\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":273,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type {\r\n  LanguageModelV2,\r\n  LanguageModelV2Middleware,\r\n  LanguageModelV2StreamPart,\r\n} from '@ai-sdk/provider';\r\n\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport type { ChatHistoryContext } from './types';\r\nimport { enqueueStream, ProcessingQueue } from './processing-queue';\r\nimport { JSONValue, simulateReadableStream, wrapLanguageModel } from 'ai';\r\nimport { MiddlewareStateManager } from '../state-management';\r\nimport { log } from '@/lib/logger';\r\nimport { ToolMap } from '../../services/model-stats/tool-map';\r\nimport { createToolOptimizingMiddleware } from '../tool-optimizing-middleware';\r\nexport type { ChatHistoryContext } from './types';\r\nexport {\r\n  instrumentFlushOperation,\r\n  instrumentStreamChunk,\r\n  instrumentMiddlewareInit,\r\n  recordQueueOperation,\r\n  createChatHistoryError,\r\n} from './instrumentation';\r\nexport {\r\n  createAgentHistoryContext,\r\n  createUserChatHistoryContext,\r\n} from './create-chat-history-context';\r\n/**\r\n * Creates a middleware for chat history management that wraps language model streaming and generation operations.\r\n *\r\n * This middleware is responsible for:\r\n * - Initializing message persistence for each chat turn.\r\n * - Maintaining FIFO order of streamed message chunks using a processing queue.\r\n * - Persisting generated text and message metadata upon completion of streaming or generation.\r\n * - Logging and suppressing errors to ensure chat operations continue even if persistence fails.\r\n *\r\n * The middleware exposes three hooks:\r\n * - `wrapStream`: Wraps the streaming operation, enqueues each chunk for ordered processing, and persists the final message.\r\n * - `wrapGenerate`: Wraps the text generation operation, persists the generated message, and handles errors gracefully.\r\n * - `transformParams`: Allows for transformation of parameters before processing (currently a passthrough).\r\n *\r\n * @param context - The chat history context containing persistence and logging utilities.\r\n * @returns A middleware object implementing `LanguageModelddleware` for chat history management.\r\n *\r\n * @remarks\r\n * - If message persistence initialization fails, the middleware falls back to the original stream/generation.\r\n * - Errors during chunk processing or message persistence are logged but do not interrupt the chat flow.\r\n * - The middleware is designed to be transparent and robust, ensuring chat history is reliably persisted without impacting user experience.\r\n *\r\n * @example\r\n * ```typescript\r\n * import { createChatHistoryMiddleware } from '@/lib/ai/middleware/chat-history';\r\n * import { myChatHistoryContext } from './my-context';\r\n *\r\n * const chatHistoryMiddleware = createChatHistoryMiddleware(myChatHistoryContext);\r\n *\r\n * // Use with your language model pipeline\r\n * const model = wrapModel(aiModelFactory('hifi'), [ chatHistoryMiddleware ]);\r\n *\r\n * ```\r\n */\r\nconst createOriginalChatHistoryMiddleware = (\r\n  context: ChatHistoryContext,\r\n): LanguageModelV2Middleware => {\r\n  // Create processing queue to maintain FIFO order\r\n  const processingQueue = new ProcessingQueue();\r\n\r\n  return {\r\n    wrapStream: async ({ doStream, params }) => {\r\n      try {\r\n        const { stream, ...rest } = await doStream();\r\n        const streamContext = await enqueueStream({\r\n          stream,\r\n          params,\r\n          context,\r\n          processingQueue,\r\n        });\r\n        return {\r\n          stream: streamContext.stream,\r\n          ...rest,\r\n        };\r\n      } catch (error) {\r\n        // Log then suppress error\r\n        LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n          log: true,\r\n          source: 'ChatHistoryMiddleware',\r\n          message: 'Error in streaming chat history middleware',\r\n          critical: true,\r\n          data: {\r\n            chatId: context.chatId,\r\n            turnId: context.turnId,\r\n            context,\r\n          },\r\n        });\r\n        // If middleware setup fails, still continue with the original stream\r\n        return doStream();\r\n      }\r\n    },\r\n\r\n    wrapGenerate: async ({ doGenerate, params }) => {\r\n      const result = await doGenerate();\r\n      try {\r\n        const stream: ReadableStream<LanguageModelV2StreamPart> =\r\n          simulateReadableStream<LanguageModelV2StreamPart>({\r\n            chunks: result.content as LanguageModelV2StreamPart[],\r\n            chunkDelayInMs: 0,\r\n            initialDelayInMs: 0,\r\n          });\r\n        const streamContext = await enqueueStream({\r\n          stream,\r\n          params,\r\n          context,\r\n          processingQueue,\r\n        });\r\n        streamContext.result.catch((error) => {\r\n          LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n            log: true,\r\n            source: 'ChatHistoryMiddleware',\r\n            message: 'Error in streaming chat history middleware',\r\n            critical: true,\r\n            data: {\r\n              chatId: context.chatId,\r\n              turnId: context.turnId,\r\n              context,\r\n            },\r\n          });\r\n        });\r\n      } catch (error) {\r\n        LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n          log: true,\r\n          source: 'ChatHistoryMiddleware',\r\n          message: 'Error in streaming chat history middleware',\r\n          critical: true,\r\n          data: {\r\n            chatId: context.chatId,\r\n            turnId: context.turnId,\r\n            context,\r\n          },\r\n        });\r\n      }\r\n      return result;\r\n    },\r\n\r\n    transformParams: async ({ params }) => {\r\n      // Pass tools to ToolMap for scanning/registration\r\n      const { tools = [] } = params;\r\n      try {\r\n        await ToolMap.getInstance().then((x) => x.scanForTools(tools));\r\n      } catch (error) {\r\n        LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n          log: true,\r\n          source: 'ChatHistoryMiddleware',\r\n          message: 'Error in transforming parameters',\r\n          critical: true,\r\n          data: {\r\n            chatId: context.chatId,\r\n            turnId: context.turnId,\r\n            context,\r\n          },\r\n        });\r\n        throw error;\r\n      }\r\n      return {\r\n        ...params,\r\n        tools,\r\n      };\r\n    },\r\n  };\r\n};\r\n\r\n/**\r\n * Chat History Middleware State Interface\r\n */\r\ninterface ChatHistoryState {\r\n  currentMessageOrder: number;\r\n  generatedText: string;\r\n  startTime: number;\r\n  contextData: {\r\n    chatId?: string;\r\n    turnId?: string;\r\n    messageId?: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Creates a middleware for chat history management with State Management Support.\r\n *\r\n * This middleware supports the state management protocol and can participate\r\n * in state collection and restoration operations, preserving processing state\r\n * across operations.\r\n *\r\n * @param context - The chat history context containing persistence and logging utilities.\r\n * @returns A stateful middleware object that supports state serialization.\r\n */\r\nexport const createChatHistoryMiddleware = (\r\n  context: ChatHistoryContext,\r\n): LanguageModelV2Middleware => {\r\n  // State that can be serialized/restored\r\n  let sharedState: ChatHistoryState = {\r\n    currentMessageOrder: 0,\r\n    generatedText: '',\r\n    startTime: Date.now(),\r\n    contextData: {},\r\n  };\r\n\r\n  const originalMiddleware = createOriginalChatHistoryMiddleware(context);\r\n\r\n  return MiddlewareStateManager.Instance.statefulMiddlewareWrapper<\r\n    ChatHistoryState & Record<string, JSONValue>\r\n  >({\r\n    middlewareId: 'chat-history',\r\n    middleware: originalMiddleware,\r\n    serialize: (): Promise<ChatHistoryState & Record<string, JSONValue>> =>\r\n      Promise.resolve({\r\n        ...sharedState,\r\n      }),\r\n    deserialize: ({\r\n      state,\r\n    }: {\r\n      state: ChatHistoryState & Record<string, JSONValue>;\r\n    }) => {\r\n      if (state) {\r\n        sharedState = {\r\n          ...sharedState,\r\n          ...state,\r\n          // Convert elapsed time back to absolute start time\r\n          startTime: Date.now() - (state.startTime || 0),\r\n        };\r\n\r\n        log((l) =>\r\n          l.debug('Chat history state restored', {\r\n            messageOrder: sharedState.currentMessageOrder,\r\n            textLength: sharedState.generatedText.length,\r\n            elapsedTime: Date.now() - sharedState.startTime,\r\n            contextData: sharedState.contextData,\r\n          }),\r\n        );\r\n      }\r\n      return Promise.resolve();\r\n    },\r\n  }) as LanguageModelV2Middleware;\r\n};\r\n\r\nexport const createChatHistoryMiddlewareEx =\r\n  createOriginalChatHistoryMiddleware;\r\n\r\nexport const wrapChatHistoryMiddleware = ({\r\n  model,\r\n  chatHistoryContext,\r\n}: {\r\n  model: LanguageModelV2;\r\n  chatHistoryContext: ChatHistoryContext;\r\n}) => {\r\n  if (!chatHistoryContext) {\r\n    throw new TypeError('chatHistoryContext is required');\r\n  }\r\n  if (!model) {\r\n    throw new TypeError('model is required');\r\n  }\r\n  return wrapLanguageModel({\r\n    model,\r\n    middleware: [\r\n      createToolOptimizingMiddleware({\r\n        userId: chatHistoryContext.userId,\r\n        chatHistoryId: chatHistoryContext.requestId,\r\n        enableMessageOptimization: true,\r\n        optimizationThreshold: 5,\r\n        enableToolScanning: true,\r\n      }),\r\n      createChatHistoryMiddleware(chatHistoryContext),\r\n    ],\r\n  });\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\chat-history\\instrumentation.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":13,"column":1,"nodeType":"Program","endLine":406,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview OpenTelemetry Instrumentation for Chat History Middleware\r\n *\r\n * This module provides comprehensive observability for the chat history middleware system,\r\n * focusing on error tracking, performance monitoring, and operational metrics. It captures\r\n * key metrics from flush operations and provides structured error attribution.\r\n *\r\n * @module lib/ai/middleware/chat-history/instrumentation\r\n * @version 1.0.0\r\n * @since 2025-07-25\r\n */\r\n\r\nimport { trace, metrics, SpanStatusCode, SpanKind } from '@opentelemetry/api';\r\nimport type {\r\n  FlushResult,\r\n  FlushContext,\r\n  ChatHistoryContext,\r\n  StreamHandlerResult,\r\n} from './types';\r\nimport { isError } from '@/lib/react-util/utility-methods';\r\n\r\n// Tracer and meter instances for chat history operations\r\nconst tracer = trace.getTracer('chat-history-middleware', '1.0.0');\r\nconst meter = metrics.getMeter('chat-history-middleware', '1.0.0');\r\n\r\n// Metrics instruments\r\nconst flushOperationHistogram = meter.createHistogram(\r\n  'chat_history_flush_duration',\r\n  {\r\n    description: 'Duration of chat history flush operations in milliseconds',\r\n    unit: 'ms',\r\n  },\r\n);\r\n\r\nconst flushOperationCounter = meter.createCounter(\r\n  'chat_history_flush_operations_total',\r\n  {\r\n    description: 'Total number of chat history flush operations',\r\n  },\r\n);\r\n\r\nconst streamChunkCounter = meter.createCounter(\r\n  'chat_history_stream_chunks_total',\r\n  {\r\n    description: 'Total number of stream chunks processed',\r\n  },\r\n);\r\n\r\nconst textLengthHistogram = meter.createHistogram('chat_history_text_length', {\r\n  description: 'Length of generated text content in characters',\r\n  unit: 'chars',\r\n});\r\n\r\nconst errorCounter = meter.createCounter('chat_history_errors_total', {\r\n  description: 'Total number of errors in chat history operations',\r\n});\r\n\r\n/**\r\n * Instruments a flush operation with comprehensive observability.\r\n *\r\n * Creates a span for the flush operation and records detailed metrics including\r\n * duration, text length, success/failure rates, and error attribution.\r\n *\r\n * @param context - The flush context containing operation details\r\n * @param operation - The async flush operation to instrument\r\n * @returns Promise resolving to the flush result with added observability\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = await instrumentFlushOperation(flushContext, async () => {\r\n *   return await handleFlush(context, config);\r\n * });\r\n * ```\r\n */\r\nexport async function instrumentFlushOperation<T extends FlushResult>(\r\n  context: FlushContext,\r\n  operation: () => Promise<T>,\r\n): Promise<T> {\r\n  const span = tracer.startSpan('chat_history.flush', {\r\n    kind: SpanKind.INTERNAL,\r\n    attributes: {\r\n      'chat.id': context.chatId,\r\n      'chat.turn_id': context.turnId || 0,\r\n      'chat.message_id': context.messageId || 0,\r\n      'chat.text_length': context.generatedText.length,\r\n      'operation.type': 'flush',\r\n    },\r\n  });\r\n\r\n  const startTime = Date.now();\r\n\r\n  try {\r\n    const result = await operation();\r\n\r\n    // Record success metrics\r\n    const duration = Date.now() - startTime;\r\n\r\n    span.setAttributes({\r\n      'operation.success': result.success,\r\n      'operation.duration_ms': result.processingTimeMs,\r\n      'operation.text_length': result.textLength,\r\n      'operation.flush_duration_ms': duration,\r\n    });\r\n\r\n    // Record histograms for performance analysis\r\n    flushOperationHistogram.record(result.processingTimeMs, {\r\n      operation: 'flush',\r\n      success: result.success.toString(),\r\n      has_error: (!!result.error).toString(),\r\n    });\r\n\r\n    textLengthHistogram.record(result.textLength, {\r\n      operation: 'flush',\r\n      success: result.success.toString(),\r\n    });\r\n\r\n    // Count successful operations\r\n    flushOperationCounter.add(1, {\r\n      operation: 'flush',\r\n      success: result.success.toString(),\r\n      has_error: (!!result.error).toString(),\r\n    });\r\n\r\n    if (result.error) {\r\n      // Record error details\r\n      span.recordException(result.error);\r\n      span.setStatus({\r\n        code: SpanStatusCode.ERROR,\r\n        message: result.error.message,\r\n      });\r\n\r\n      span.setAttributes({\r\n        'error.type': result.error.constructor.name,\r\n        'error.message': result.error.message,\r\n        'error.retry_recommended': result.retryRecommended || false,\r\n      });\r\n\r\n      errorCounter.add(1, {\r\n        operation: 'flush',\r\n        error_type: result.error.constructor.name,\r\n        retry_recommended: (result.retryRecommended || false).toString(),\r\n      });\r\n    } else {\r\n      span.setStatus({ code: SpanStatusCode.OK });\r\n    }\r\n\r\n    // Add metadata if available\r\n    if (result.metadata) {\r\n      span.setAttributes({\r\n        'operation.metadata_keys': Object.keys(result.metadata).join(','),\r\n      });\r\n    }\r\n\r\n    return result;\r\n  } catch (error) {\r\n    const errorObj = isError(error) ? error : new Error(String(error));\r\n\r\n    span.recordException(errorObj);\r\n    span.setStatus({ code: SpanStatusCode.ERROR, message: errorObj.message });\r\n\r\n    span.setAttributes({\r\n      'operation.success': false,\r\n      'error.type': errorObj.constructor.name,\r\n      'error.message': errorObj.message,\r\n    });\r\n\r\n    errorCounter.add(1, {\r\n      operation: 'flush',\r\n      error_type: errorObj.constructor.name,\r\n      retry_recommended: 'unknown',\r\n    });\r\n\r\n    flushOperationCounter.add(1, {\r\n      operation: 'flush',\r\n      success: 'false',\r\n      has_error: 'true',\r\n    });\r\n\r\n    throw error;\r\n  } finally {\r\n    span.end();\r\n  }\r\n}\r\n\r\n/**\r\n * Instruments stream chunk processing with lightweight observability.\r\n *\r\n * Records metrics for stream chunk processing including chunk types,\r\n * processing success rates, and text accumulation patterns.\r\n *\r\n * @param chunkType - The type of stream chunk being processed\r\n * @param context - The stream handler context\r\n * @param operation - The async chunk processing operation\r\n * @returns Promise resolving to the processing result\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = await instrumentStreamChunk('text-delta', context, async () => {\r\n *   return await handleTextDelta(chunk, context);\r\n * });\r\n * ```\r\n */\r\nexport async function instrumentStreamChunk(\r\n  chunkType: string,\r\n  context: { chatId: string; turnId: number; messageId?: number },\r\n  operation: () => Promise<StreamHandlerResult>,\r\n): Promise<StreamHandlerResult> {\r\n  try {\r\n    const result = await operation();\r\n\r\n    // Record chunk processing metrics\r\n    streamChunkCounter.add(1, {\r\n      chunk_type: chunkType,\r\n      success: result.success.toString(),\r\n    });\r\n\r\n    if (!result.success) {\r\n      errorCounter.add(1, {\r\n        operation: 'stream_chunk',\r\n        error_type: 'processing_failure',\r\n        chunk_type: chunkType,\r\n      });\r\n    }\r\n\r\n    return result;\r\n  } catch (error) {\r\n    const errorObj = error instanceof Error ? error : new Error(String(error));\r\n    const span = tracer.startSpan('chat_history.chunk_error', {\r\n      kind: SpanKind.INTERNAL,\r\n      attributes: {\r\n        'operation.type': 'process_chunk',\r\n        code: SpanStatusCode.ERROR,\r\n        'error.message': errorObj.message,\r\n        'operation.success': false,\r\n        'error.type': errorObj.constructor.name,\r\n      },\r\n    });\r\n    try {\r\n      span.recordException(errorObj);\r\n\r\n      streamChunkCounter.add(1, {\r\n        chunk_type: chunkType,\r\n        success: 'false',\r\n      });\r\n\r\n      errorCounter.add(1, {\r\n        operation: 'stream_chunk',\r\n        error_type: errorObj.constructor.name,\r\n        chunk_type: chunkType,\r\n      });\r\n\r\n      throw error;\r\n    } finally {\r\n      span.end();\r\n    }\r\n  }\r\n}\r\n/**\r\n * Instruments chat history middleware initialization.\r\n *\r\n * Creates a span for the middleware setup and records configuration attributes\r\n * for observability and debugging purposes.\r\n *\r\n * @param context - The chat history context being initialized\r\n * @param operation - The async initialization operation\r\n * @returns Promise resolving to the initialization result\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = await instrumentMiddlewareInit(context, async () => {\r\n *   return await initializeMessagePersistence(context, params);\r\n * });\r\n * ```\r\n */\r\nexport async function instrumentMiddlewareInit<T>(\r\n  context: ChatHistoryContext,\r\n  operation: () => Promise<T>,\r\n): Promise<T> {\r\n  const span = tracer.startSpan('chat_history.middleware_init', {\r\n    kind: SpanKind.INTERNAL,\r\n    attributes: {\r\n      'operation.type': 'middleware_init',\r\n      // Add any context-specific attributes here\r\n    },\r\n  });\r\n\r\n  try {\r\n    const result = await operation();\r\n\r\n    span.setStatus({ code: SpanStatusCode.OK });\r\n    span.setAttributes({\r\n      'operation.success': true,\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    const errorObj = error instanceof Error ? error : new Error(String(error));\r\n\r\n    span.recordException(errorObj);\r\n    span.setStatus({ code: SpanStatusCode.ERROR, message: errorObj.message });\r\n\r\n    span.setAttributes({\r\n      'operation.success': false,\r\n      'error.type': errorObj.constructor.name,\r\n      'error.message': errorObj.message,\r\n    });\r\n\r\n    errorCounter.add(1, {\r\n      operation: 'middleware_init',\r\n      error_type: errorObj.constructor.name,\r\n    });\r\n\r\n    throw error;\r\n  } finally {\r\n    span.end();\r\n  }\r\n}\r\n\r\n/**\r\n * Records a processing queue operation metric.\r\n *\r\n * Lightweight metric recording for queue operations without creating spans.\r\n * Useful for high-frequency operations where span overhead might be excessive.\r\n *\r\n * @param operation - The type of queue operation\r\n * @param success - Whether the operation succeeded\r\n * @param queueSize - Current size of the processing queue\r\n *\r\n * @example\r\n * ```typescript\r\n * recordQueueOperation('enqueue', true, 5);\r\n * recordQueueOperation('process', false, 4);\r\n * ```\r\n */\r\nexport function recordQueueOperation(\r\n  operation: 'enqueue' | 'process' | 'complete',\r\n  success: boolean,\r\n  queueSize?: number,\r\n): void {\r\n  const queueOperationCounter = meter.createCounter(\r\n    'chat_history_queue_operations_total',\r\n    {\r\n      description: 'Total number of processing queue operations',\r\n    },\r\n  );\r\n\r\n  queueOperationCounter.add(1, {\r\n    operation,\r\n    success: success.toString(),\r\n  });\r\n\r\n  if (queueSize !== undefined) {\r\n    const queueSizeGauge = meter.createUpDownCounter(\r\n      'chat_history_queue_size',\r\n      {\r\n        description: 'Current size of the processing queue',\r\n      },\r\n    );\r\n\r\n    queueSizeGauge.add(operation === 'enqueue' ? 1 : -1, {\r\n      operation,\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a custom error with additional context for better observability.\r\n *\r\n * Enhances error objects with chat-specific context that will be captured\r\n * by the instrumentation spans and metrics.\r\n *\r\n * @param message - The error message\r\n * @param context - Chat context for error attribution\r\n * @param originalError - Optional original error to wrap\r\n * @returns Enhanced error with chat context\r\n *\r\n * @example\r\n * ```typescript\r\n * throw createChatHistoryError(\r\n *   'Failed to persist message',\r\n *   { chatId: 'chat-123', turnId: 1 },\r\n *   originalError\r\n * );\r\n * ```\r\n */\r\nexport function createChatHistoryError(\r\n  message: string,\r\n  context: { chatId: string; turnId?: number; messageId?: number },\r\n  originalError?: Error,\r\n): Error {\r\n  const error = new Error(message);\r\n  error.name = 'ChatHistoryError';\r\n  error.cause = originalError;\r\n\r\n  // Add structured context to error for better observability\r\n  Object.assign(error, {\r\n    chatContext: {\r\n      chatId: context.chatId,\r\n      turnId: context.turnId,\r\n      messageId: context.messageId,\r\n    },\r\n  });\r\n\r\n  return error;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\chat-history\\message-persistence.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":12,"column":1,"nodeType":"Program","endLine":210,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Message Persistence Utilities for Chat History Middleware\r\n *\r\n * This module provides shared utilities for handling message persistence across\r\n * both streaming and text completion modes in the chat history middleware.\r\n *\r\n * @module lib/ai/middleware/chat-history/message-persistence\r\n * @version 1.0.0\r\n * @since 2025-07-25\r\n */\r\n\r\nimport type { LanguageModelV2CallOptions } from '@ai-sdk/provider';\r\nimport { JSONValue } from 'ai';\r\nimport { drizDb } from '@/lib/drizzle-db';\r\nimport { log } from '@/lib/logger';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport type {\r\n  ChatHistoryContext,\r\n  FlushContext,\r\n  MessageCompletionContext,\r\n  MessagePersistenceInit,\r\n} from './types';\r\nimport { importIncomingMessage } from './import-incoming-message';\r\nimport { handleFlush } from './flush-handlers';\r\nimport {\r\n  instrumentMiddlewareInit,\r\n  createChatHistoryError,\r\n} from './instrumentation';\r\nimport { generateChatId } from '../../core';\r\n\r\n/**\r\n * Initializes message persistence by creating chat, turn, and message records.\r\n * This is used by both streaming and text completion modes.\r\n *\r\n * @param context - The chat history context\r\n * @param params - The language model call parameters\r\n * @returns Promise resolving to the initialized persistence data\r\n *\r\n * @example\r\n * ```typescript\r\n * const { chatId, turnId, messageId } = await initializeMessagePersistence(\r\n *   context,\r\n *   params\r\n * );\r\n * ```\r\n */\r\nexport const initializeMessagePersistence = async (\r\n  context: ChatHistoryContext,\r\n  params: LanguageModelV2CallOptions,\r\n): Promise<MessagePersistenceInit> => {\r\n  try {\r\n    const ret = await drizDb().transaction(async (tx) =>\r\n      importIncomingMessage({\r\n        tx,\r\n        context,\r\n        params,\r\n      }),\r\n    );\r\n    return {\r\n      ...ret,\r\n      turnId: ret.turnId.toString(),\r\n    };\r\n  } catch (error) {\r\n    // Create enhanced error for better observability\r\n    const enhancedError = createChatHistoryError(\r\n      'Error initializing message persistence',\r\n      {\r\n        chatId: context.chatId || 'unknown',\r\n        turnId: undefined,\r\n        messageId: undefined,\r\n      },\r\n      error instanceof Error ? error : new Error(String(error)),\r\n    );\r\n\r\n    LoggedError.isTurtlesAllTheWayDownBaby(enhancedError, {\r\n      log: true,\r\n      source: 'MessagePersistence',\r\n      message: 'Error initializing message persistence',\r\n      critical: true,\r\n      data: {\r\n        context,\r\n        userId: context.userId,\r\n        chatId: context.chatId,\r\n      },\r\n    });\r\n    throw enhancedError;\r\n  }\r\n};\r\n\r\n/**\r\n * Completes message persistence by finalizing the message and turn.\r\n * This is used by both streaming and text completion modes.\r\n *\r\n * @param completionContext - The context for completing the message\r\n * @returns Promise resolving to the flush result\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = await completeMessagePersistence({\r\n *   chatId: 'chat-123',\r\n *   turnId: 1,\r\n *   messageId: 42,\r\n *   generatedText: 'Generated response text',\r\n *   startTime: Date.now() - 1000\r\n * });\r\n * ```\r\n */\r\nexport const completeMessagePersistence = async (\r\n  completionContext: MessageCompletionContext,\r\n) => {\r\n  try {\r\n    // Create flush context for the completion\r\n    const flushContext: FlushContext = {\r\n      chatId: completionContext.chatId,\r\n      turnId: completionContext.turnId,\r\n      messageId: completionContext.messageId,\r\n      generatedText: completionContext.generatedText,\r\n      startTime: completionContext.startTime,\r\n    };\r\n    // Handle completion using the existing flush logic\r\n    const flushResult = await handleFlush(flushContext);\r\n\r\n    if (!flushResult.success && flushResult.error) {\r\n      log((l) =>\r\n        l.error('Error completing message persistence', {\r\n          error: flushResult.error,\r\n          turnId: completionContext.turnId,\r\n          chatId: completionContext.chatId,\r\n        }),\r\n      );\r\n    } else {\r\n      log((l) =>\r\n        l.debug('Message persistence completed successfully', {\r\n          chatId: completionContext.chatId,\r\n          turnId: completionContext.turnId,\r\n          messageId: completionContext.messageId,\r\n          textLength: completionContext.generatedText.length,\r\n\r\n          processingTimeMs: flushResult.processingTimeMs,\r\n        }),\r\n      );\r\n    }\r\n\r\n    return flushResult;\r\n  } catch (error) {\r\n    LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: 'MessagePersistence',\r\n      message: 'Error completing message persistence',\r\n      critical: true,\r\n      data: {\r\n        chatId: completionContext.chatId,\r\n        turnId: completionContext.turnId,\r\n        messageId: completionContext.messageId,\r\n      },\r\n    });\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Safely handles message persistence initialization with error handling.\r\n * Returns null if initialization fails to allow continued operation.\r\n *\r\n * @param context - The chat history context\r\n * @param params - The language model call parameters\r\n * @returns Promise resolving to initialization data or null if failed\r\n */\r\nexport const safeInitializeMessagePersistence = async (\r\n  context: ChatHistoryContext,\r\n  params: LanguageModelV2CallOptions,\r\n): Promise<MessagePersistenceInit | null> => {\r\n  try {\r\n    context.chatId ??= generateChatId().id;\r\n    params.providerOptions ??= {};\r\n    params.providerOptions.backoffice ??= {} as Record<string, JSONValue>;\r\n    params.providerOptions.backoffice.chatId = context.chatId;\r\n    return await instrumentMiddlewareInit(context, async () => {\r\n      return await initializeMessagePersistence(context, params);\r\n    });\r\n  } catch {\r\n    // Error already logged in initializeMessagePersistence and instrumentation\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Safely handles message persistence completion with error handling.\r\n * Logs errors but doesn't throw to avoid breaking the response flow.\r\n *\r\n * @param completionContext - The context for completing the message\r\n * @returns Promise resolving to flush result or a failure result\r\n */\r\nexport const safeCompleteMessagePersistence = async (\r\n  completionContext: MessageCompletionContext,\r\n) => {\r\n  try {\r\n    return await completeMessagePersistence(completionContext);\r\n  } catch {\r\n    // Error already logged in completeMessagePersistence\r\n    // Return a failure result instead of throwing\r\n    return {\r\n      success: false,\r\n      processingTimeMs: Date.now() - completionContext.startTime,\r\n      textLength: completionContext.generatedText.length,\r\n      error: new Error('Message persistence completion failed'),\r\n    };\r\n  }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\chat-history\\processing-queue.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":13,"column":1,"nodeType":"Program","endLine":337,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Sequential Processing Queue for Chat History\r\n *\r\n * This module provides a queue-based system to ensure that stream chunks\r\n * are processed in FIFO order, even when individual database operations\r\n * have varying completion times.\r\n *\r\n * @module lib/ai/middleware/chat-history/processing-queue\r\n * @version 1.0.0\r\n * @since 2025-07-17\r\n */\r\n\r\nimport type {\r\n  LanguageModelV2CallOptions,\r\n  LanguageModelV2StreamPart,\r\n} from '@ai-sdk/provider';\r\nimport { log } from '@/lib/logger';\r\nimport { ensureCreateResult } from './stream-handler-result';\r\nimport { processStreamChunk } from './stream-handlers';\r\nimport type {\r\n  ChatHistoryContext,\r\n  QueuedTask,\r\n  StreamHandlerContext,\r\n  StreamHandlerResult,\r\n} from './types';\r\nimport { recordQueueOperation } from './instrumentation';\r\nimport { ChatMessagesType } from '@/lib/drizzle-db/drizzle-types';\r\nimport {\r\n  safeCompleteMessagePersistence,\r\n  safeInitializeMessagePersistence,\r\n} from './message-persistence';\r\nimport { isError } from '@/lib/react-util/core';\r\n\r\n/**\r\n * Sequential processing queue that maintains FIFO order for database operations.\r\n *\r\n * This queue ensures that even if individual database operations complete at\r\n * different speeds, the results are applied in the correct order to maintain\r\n * data consistency and proper state management.\r\n *\r\n * @example\r\n * ```typescript\r\n * const queue = new ProcessingQueue();\r\n *\r\n * // Add chunks - they'll be processed in order\r\n * queue.enqueue(chunk1, context1);\r\n * queue.enqueue(chunk2, context2);\r\n * queue.enqueue(chunk3, context3);\r\n *\r\n * // Even if chunk2 completes first, results applied in order\r\n * ```\r\n */\r\nexport class ProcessingQueue {\r\n  private queue: QueuedTask[] = [];\r\n  private processing = false;\r\n  private nextTaskId = 1;\r\n\r\n  /**\r\n   * Adds a chunk to the processing queue.\r\n   *\r\n   * The chunk will be processed in FIFO order, ensuring that state updates\r\n   * are applied sequentially even if database operations complete out of order.\r\n   *\r\n   * @param chunk - The stream chunk to process\r\n   * @param context - The processing context\r\n   * @returns Promise that resolves when the chunk has been processed\r\n   */\r\n  async enqueue(\r\n    chunk: LanguageModelV2StreamPart,\r\n    context: StreamHandlerContext,\r\n  ): Promise<void> {\r\n    return new Promise<void>((resolve, reject) => {\r\n      const task: QueuedTask = {\r\n        id: this.nextTaskId++,\r\n        chunk,\r\n        context: { ...context }, // Create a copy of the context\r\n        promise: Promise.resolve(),\r\n        resolve,\r\n        reject,\r\n      };\r\n\r\n      this.queue.push(task);\r\n\r\n      // Record queue metrics\r\n      recordQueueOperation('enqueue', true, this.queue.length);\r\n\r\n      this.processQueue();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Processes a single task by calling the stream chunk handler.\r\n   *\r\n   * @param task - The task to process\r\n   * @returns Promise that resolves with the processing result\r\n   */\r\n  private async processTask(task: QueuedTask): Promise<void> {\r\n    try {\r\n      const result = await processStreamChunk(task.chunk, task.context);\r\n\r\n      if (!result.success) {\r\n        recordQueueOperation('process', false, this.queue.length);\r\n        throw new Error(`Processing failed for chunk type: ${task.chunk.type}`);\r\n      }\r\n\r\n      // Store result on the task for later application\r\n      task.result = result;\r\n      recordQueueOperation('process', true, this.queue.length);\r\n    } catch (error) {\r\n      recordQueueOperation('process', false, this.queue.length);\r\n      log((l) =>\r\n        l.error('Task processing failed', {\r\n          error,\r\n          taskId: task.id,\r\n          chunkType: task.chunk.type,\r\n          chatId: task.context.chatId,\r\n          turnId: task.context.turnId,\r\n        }),\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Processes the queue in FIFO order, waiting for each task to complete\r\n   * before applying its results and moving to the next task.\r\n   */\r\n  private async processQueue(): Promise<void> {\r\n    if (this.processing || this.queue.length === 0) {\r\n      return;\r\n    }\r\n\r\n    this.processing = true;\r\n\r\n    try {\r\n      while (this.queue.length > 0) {\r\n        const task = this.queue[0];\r\n\r\n        try {\r\n          // Process the task now, not when it was enqueued\r\n          await this.processTask(task);\r\n\r\n          // Apply the result in order\r\n          const result = task.result;\r\n          if (result) {\r\n            // Update the context for subsequent tasks\r\n            this.updateSubsequentContexts(result);\r\n          }\r\n\r\n          task.resolve();\r\n          recordQueueOperation('complete', true, this.queue.length - 1);\r\n        } catch (error) {\r\n          recordQueueOperation('complete', false, this.queue.length - 1);\r\n          task.reject(\r\n            error instanceof Error ? error : new Error(String(error)),\r\n          );\r\n        }\r\n\r\n        // Remove completed task\r\n        this.queue.shift();\r\n      }\r\n    } finally {\r\n      this.processing = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the context for all remaining tasks in the queue.\r\n   *\r\n   * This ensures that state changes (like updated message order or\r\n   * accumulated text) are propagated to subsequent tasks.\r\n   *\r\n   * @param result - The result from the completed task\r\n   */\r\n  private updateSubsequentContexts(result: StreamHandlerResult): void {\r\n    for (const task of this.queue) {\r\n      if (result.currentMessageOrder !== undefined) {\r\n        task.context.currentMessageOrder = result.currentMessageOrder;\r\n      }\r\n      task.context.generatedText = result.generatedText;\r\n      task.context.messageId = result.currentMessageId;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the current queue length for monitoring purposes.\r\n   *\r\n   * @returns The number of tasks currently in the queue\r\n   */\r\n  getQueueLength(): number {\r\n    return this.queue.length;\r\n  }\r\n\r\n  /**\r\n   * Checks if the queue is currently processing tasks.\r\n   *\r\n   * @returns True if processing is active, false otherwise\r\n   */\r\n  isProcessing(): boolean {\r\n    return this.processing;\r\n  }\r\n}\r\n\r\ntype StreamContext = {\r\n  chatId: string;\r\n  turnId: string;\r\n  messageId: number | undefined;\r\n  currentMessageOrder: number;\r\n  toolCalls: Map<string, ChatMessagesType>;\r\n  streamedText: string;\r\n  errors: Error[];\r\n  generatedJSON: Array<Record<string, unknown>>;\r\n};\r\n\r\nexport const enqueueStream = async ({\r\n  stream,\r\n  params,\r\n  context,\r\n  processingQueue,\r\n}: {\r\n  stream: ReadableStream<LanguageModelV2StreamPart>;\r\n  params: LanguageModelV2CallOptions;\r\n  context: ChatHistoryContext;\r\n  processingQueue: ProcessingQueue;\r\n}): Promise<{\r\n  stream: ReadableStream<LanguageModelV2StreamPart>;\r\n  generatedText: Promise<string>;\r\n  result: Promise<StreamContext>;\r\n}> => {\r\n  const startTime = Date.now();\r\n  const generatedText = Promise.withResolvers<string>();\r\n  const result = Promise.withResolvers<StreamContext>();\r\n  // Initialize message persistence\r\n  const messagePersistence = await safeInitializeMessagePersistence(\r\n    context,\r\n    params,\r\n  );\r\n  if (!messagePersistence) {\r\n    throw new Error('Failed to initialize message persistence');\r\n  }\r\n  const { chatId, turnId, messageId } = messagePersistence;\r\n\r\n  const streamContext: StreamContext = {\r\n    chatId,\r\n    currentMessageOrder: 0,\r\n    turnId,\r\n    messageId,\r\n    streamedText: '',\r\n    toolCalls: new Map<string, ChatMessagesType>(),\r\n    errors: [],\r\n    generatedJSON: [],\r\n  };\r\n\r\n  const transformStream = new TransformStream<\r\n    LanguageModelV2StreamPart,\r\n    LanguageModelV2StreamPart\r\n  >({\r\n    async transform(chunk, controller) {\r\n      // Enqueue chunk immediately for maximum transparency\r\n      // If this fails, let the error propagate - don't try again\r\n      controller.enqueue(chunk);\r\n      // Process chunk through queue to maintain FIFO order\r\n      const handlerContext: StreamHandlerContext = ensureCreateResult({\r\n        chatId: streamContext.chatId!,\r\n        turnId: parseInt(streamContext.turnId!, 10),\r\n        toolCalls: streamContext.toolCalls,\r\n        messageId: streamContext.messageId,\r\n        currentMessageOrder: streamContext.currentMessageOrder,\r\n        generatedText: streamContext.streamedText,\r\n        generatedJSON: streamContext.generatedJSON,\r\n      });\r\n      // Queue processing maintains order and updates local state\r\n      processingQueue\r\n        .enqueue(chunk, handlerContext)\r\n        .then(() => {\r\n          // Context is updated by the queue processor\r\n          // Get the latest state for subsequent chunks\r\n          streamContext.currentMessageOrder =\r\n            handlerContext.currentMessageOrder;\r\n          streamContext.streamedText = handlerContext.generatedText;\r\n          streamContext.messageId = handlerContext.messageId;\r\n        })\r\n        .catch((error: Error) => {\r\n          log((l) =>\r\n            l.error('Queued chunk processing failed', {\r\n              error,\r\n              turnId: streamContext.turnId,\r\n              chatId: streamContext.chatId,\r\n              chunkType: chunk.type,\r\n              queueLength: processingQueue.getQueueLength(),\r\n            }),\r\n          );\r\n          streamContext.errors.push(error);\r\n        });\r\n    },\r\n\r\n    async flush() {\r\n      try {\r\n        // Complete message persistence using shared utility\r\n        await safeCompleteMessagePersistence({\r\n          chatId: streamContext.chatId,\r\n          turnId: Number(streamContext.turnId),\r\n          messageId: streamContext.messageId,\r\n          generatedText: streamContext.streamedText,\r\n          startTime,\r\n        });\r\n        generatedText.resolve(streamContext.streamedText);\r\n        result.resolve(streamContext);\r\n      } catch (error) {\r\n        log((l) =>\r\n          l.error('Failed to finalize message persistence state.', {\r\n            error,\r\n            turnId: streamContext.turnId,\r\n            chatId: streamContext.chatId,\r\n          }),\r\n        );\r\n        streamContext.errors.push(\r\n          isError(error) ? error : new Error(String(error)),\r\n        );\r\n      }\r\n      context.turnId = streamContext.turnId;\r\n      generatedText.resolve(streamContext.streamedText);\r\n      if (streamContext.errors.length > 0) {\r\n        result.reject(streamContext);\r\n      } else {\r\n        result.resolve(streamContext);\r\n      }\r\n    },\r\n  });\r\n\r\n  return {\r\n    stream: stream.pipeThrough(transformStream),\r\n    generatedText: generatedText.promise,\r\n    result: result.promise,\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\chat-history\\stream-handler-result.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":25,"column":1,"nodeType":"Program","endLine":81,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Chat history stream handler: result factory helpers.\r\n *\r\n * This module augments a given `StreamHandlerContext` with a `createResult`\r\n * helper when one isn't already provided. The factory method standardizes how\r\n * `StreamHandlerResult` objects are produced from the context during streaming\r\n * pipelines, ensuring consistent defaults and override semantics.\r\n *\r\n * Behavior of `createResult`:\r\n * - With no argument: returns a `StreamHandlerResult` seeded from the context\r\n *   with `success: true`.\r\n * - With a boolean: returns the base result with only the `success` field set\r\n *   to the provided boolean.\r\n * - With a partial object: shallow-merges the provided fields over a base\r\n *   result seeded from the context. For known fields, explicit keys in the\r\n *   patch override the base; unspecified keys retain base values.\r\n *\r\n * Known fields merged from the context:\r\n * - `currentMessageId`\r\n * - `currentMessageOrder`\r\n * - `generatedText`\r\n * - `toolCalls`\r\n * - `success` (defaults to true)\r\n */\r\nimport type { StreamHandlerContext, StreamHandlerResult } from './types';\r\n\r\n/**\r\n * Internal helper shape used while attaching the `createResult` factory.\r\n * When present, `createResult` produces a `StreamHandlerResult` based on the\r\n * current context with optional overrides.\r\n */\r\ntype MaybeCreateResultContext =\r\n  | boolean\r\n  | (Omit<StreamHandlerContext, 'createResult'> &\r\n      Pick<Partial<StreamHandlerContext>, 'createResult'>);\r\n\r\n/**\r\n * Ensures a context has a `createResult` factory.\r\n *\r\n * If `context.createResult` already exists and is a function, the context is\r\n * returned unchanged. Otherwise, a default implementation is attached which:\r\n * - Seeds a base result from the provided context fields\r\n *   (`currentMessageId`, `currentMessageOrder`, `generatedText`, `toolCalls`)\r\n *   and `success: true`.\r\n * - Supports a boolean argument to set only `success`.\r\n * - Supports a partial object argument to shallow-merge explicit overrides on\r\n *   top of the base (unspecified fields retain base values).\r\n *\r\n * Contract (createResult):\r\n * - Input: `undefined | boolean | Partial<StreamHandlerResult>`\r\n * - Output: `StreamHandlerResult`\r\n * - Override precedence: explicit keys in the patch object win; otherwise the\r\n *   base value from context is preserved.\r\n *\r\n * @param context Stream handler context that may or may not include a\r\n * pre-defined `createResult` factory.\r\n * @returns A context guaranteed to include `createResult`.\r\n */\r\nexport const ensureCreateResult = (\r\n  context?: MaybeCreateResultContext,\r\n): StreamHandlerContext => {\r\n  const thisContext = context ?? {};\r\n  const thisCreateResult = ((successOrPatch) => {\r\n    const isSuccessFlag = typeof successOrPatch === 'boolean';\r\n    return {\r\n      success: true,\r\n      ...thisContext,\r\n      ...(isSuccessFlag\r\n        ? {\r\n            success: successOrPatch as boolean,\r\n          }\r\n        : successOrPatch),\r\n    } as StreamHandlerResult;\r\n  }) as StreamHandlerContext['createResult'];\r\n  const ret = {\r\n    createResult: thisCreateResult,\r\n    ...thisCreateResult(context),\r\n  } as StreamHandlerContext;\r\n  return ret;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\chat-history\\stream-handlers.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":13,"column":1,"nodeType":"Program","endLine":1052,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":321,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":321,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10668,10671],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10668,10671],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Stream Chunk Handlers for Chat History Middleware\r\n *\r\n * This module provides utility functions for handling different types of streaming chunks\r\n * in the chat history middleware. Each handler is responsible for processing a specific\r\n * type of stream chunk and updating the database accordingly.\r\n *\r\n * @module lib/ai/middleware/chat-history/stream-handlers\r\n * @version 1.0.0\r\n * @since 2025-07-17\r\n */\r\n\r\nimport type {\r\n  LanguageModelV2ToolResultPart,\r\n  LanguageModelV2StreamPart,\r\n  LanguageModelV2ToolCall,\r\n} from '@ai-sdk/provider';\r\nimport { chatMessages, chatTurns, tokenUsage } from '@/drizzle/schema';\r\nimport { eq, and } from 'drizzle-orm';\r\nimport {\r\n  ChatMessagesType,\r\n  DbTransactionType,\r\n  drizDb,\r\n  schema,\r\n} from '@/lib/drizzle-db';\r\nimport { log } from '@/lib/logger';\r\nimport { getNextSequence } from './utility';\r\nimport type { StreamHandlerContext, StreamHandlerResult } from './types';\r\nimport { instrumentStreamChunk } from './instrumentation';\r\nimport { ensureCreateResult } from './stream-handler-result';\r\nimport {\r\n  reserveMessageIds,\r\n  upsertToolMessage,\r\n} from './import-incoming-message';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\n\r\n// ---------------------------------------------------------------------------\r\n// Lightweight per-id buffers for explicit streaming types\r\n// ---------------------------------------------------------------------------\r\n/**\r\n * Unique symbol used to store a Map of open text buffers on the context.\r\n *\r\n * The map is keyed by chunk id and stores the accumulated text until a\r\n * corresponding `text-end` event is received.\r\n */\r\nconst OPEN_TEXT_SYM = Symbol.for('chat-history.openTextBuffers');\r\n\r\n/**\r\n * Unique symbol used to store a Map of open reasoning buffers on the context.\r\n *\r\n * The map is keyed by chunk id and stores the accumulated reasoning content\r\n * until a corresponding `reasoning-end` event is received.\r\n */\r\nconst OPEN_REASONING_SYM = Symbol.for('chat-history.openReasoningBuffers');\r\n\r\n/**\r\n * Unique symbol used to store a Map of open tool-input buffers on the context.\r\n *\r\n * The map is keyed by chunk id and stores an object containing the tool name\r\n * (if provided) and the raw input value until `tool-input-end` finalizes it.\r\n */\r\nconst OPEN_TOOL_INPUT_SYM = Symbol.for('chat-history.openToolInputBuffers');\r\n\r\n/**\r\n * Buffer structure used during streaming to accumulate tool input.\r\n * - `toolName` may be undefined if not provided by the stream part\r\n * - `value` contains the raw concatenated input text (possibly JSON)\r\n */\r\ntype ToolInputBuffer = { toolName?: string; value: string };\r\n\r\n/**\r\n * Gets the per-context map that tracks in-progress text buffers.\r\n * Creates the map on first access.\r\n *\r\n * @param context - Current stream handler context\r\n * @returns Map keyed by part id with accumulated text\r\n */\r\nfunction getOpenText(context: StreamHandlerContext): Map<string, string> {\r\n  const bag = context as unknown as Record<PropertyKey, unknown>;\r\n  if (!bag[OPEN_TEXT_SYM]) {\r\n    bag[OPEN_TEXT_SYM] = new Map<string, string>();\r\n  }\r\n  return bag[OPEN_TEXT_SYM] as Map<string, string>;\r\n}\r\n\r\n/**\r\n * Gets the per-context map that tracks in-progress reasoning buffers.\r\n * Creates the map on first access.\r\n *\r\n * @param context - Current stream handler context\r\n * @returns Map keyed by part id with accumulated reasoning text\r\n */\r\nfunction getOpenReasoning(context: StreamHandlerContext): Map<string, string> {\r\n  const bag = context as unknown as Record<PropertyKey, unknown>;\r\n  if (!bag[OPEN_REASONING_SYM]) {\r\n    bag[OPEN_REASONING_SYM] = new Map<string, string>();\r\n  }\r\n  return bag[OPEN_REASONING_SYM] as Map<string, string>;\r\n}\r\n\r\n/**\r\n * Gets the per-context map that tracks in-progress tool-input buffers.\r\n * Creates the map on first access.\r\n *\r\n * @param context - Current stream handler context\r\n * @returns Map keyed by part id with `{ toolName?, value }`\r\n */\r\nfunction getOpenToolInput(\r\n  context: StreamHandlerContext,\r\n): Map<string, ToolInputBuffer> {\r\n  const bag = context as unknown as Record<PropertyKey, unknown>;\r\n  if (!bag[OPEN_TOOL_INPUT_SYM]) {\r\n    bag[OPEN_TOOL_INPUT_SYM] = new Map<string, ToolInputBuffer>();\r\n  }\r\n  return bag[OPEN_TOOL_INPUT_SYM] as Map<string, ToolInputBuffer>;\r\n}\r\n\r\n/**\r\n * Flushes any generated content parts accumulated in `context.generatedJSON`\r\n * as a pending assistant message, then resets message state for subsequent parts.\r\n *\r\n * Behavior:\r\n * - Reserves a new `messageId` when one isn't already present (assistant reply\r\n *   in-progress) and writes a `chatMessages` row with `statusId: 2` (pending/in-progress),\r\n *   `role: 'assistant'`, and the JSON content.\r\n * - After a successful transaction, clears `context.messageId`, increments\r\n *   `context.currentMessageOrder`, and resets `context.generatedJSON`.\r\n *\r\n * Errors are captured via `LoggedError.isTurtlesAllTheWayDownBaby` and do not\r\n * throw out of this function.\r\n *\r\n * @param context - Current stream handler context containing accumulated parts\r\n */\r\nconst flushMessageParts = async ({\r\n  context,\r\n}: {\r\n  context: StreamHandlerContext;\r\n}) => {\r\n  const { messageId, chatId, turnId, generatedJSON, currentMessageOrder } =\r\n    context;\r\n  if (!generatedJSON || !generatedJSON.length) {\r\n    return;\r\n  }\r\n  await drizDb().transaction(async (tx) => {\r\n    try {\r\n      // Reserve message ID for pending assistant response\r\n      let thisMessageId: number | undefined;\r\n      if (!messageId) {\r\n        const [tempMessageId] = await reserveMessageIds(\r\n          tx,\r\n          chatId,\r\n          Number(turnId),\r\n          1,\r\n        );\r\n        thisMessageId = tempMessageId;\r\n        context.messageId = thisMessageId;\r\n      } else {\r\n        thisMessageId = messageId!;\r\n      }\r\n      await tx\r\n        .insert(schema.chatMessages)\r\n        .values({\r\n          chatId: chatId!,\r\n          turnId: Number(turnId!),\r\n          messageId: thisMessageId!,\r\n          role: 'assistant',\r\n          content: JSON.stringify(generatedJSON),\r\n          messageOrder: currentMessageOrder,\r\n          statusId: 2, // pending/in-progress\r\n        })\r\n        // Use returning() to align with existing mocked insert chain in tests\r\n        .returning()\r\n        .execute();\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        data: {\r\n          chatId,\r\n          turnId,\r\n          messageId,\r\n          generatedJSON,\r\n        },\r\n      });\r\n    }\r\n  });\r\n  // if we committed OK, clear out pending message id and bump order\r\n  context.messageId = undefined;\r\n  context.currentMessageOrder++;\r\n  context.generatedJSON = [];\r\n};\r\n\r\n/**\r\n * Marks the specified assistant message as in-progress/complete according to\r\n * the middleware's status semantics.\r\n *\r\n * This updates the `chat_messages` row identified by (chatId, turnId, messageId)\r\n * and sets `statusId: 2`. Intended to close out a reserved/previous message\r\n * before attaching results or moving to the next one.\r\n *\r\n * @param tx - Active Drizzle transaction\r\n * @param messageId - The message id to mark as complete/pending\r\n * @param chatId - Chat identifier\r\n * @param turnId - Turn identifier\r\n * @returns Promise resolving to true on successful update\r\n * @throws Error when `messageId` is not provided\r\n */\r\nconst completePendingMessage = async ({\r\n  tx,\r\n  messageId,\r\n  chatId,\r\n  turnId,\r\n}: {\r\n  tx: DbTransactionType;\r\n  messageId: number | undefined;\r\n  chatId: string;\r\n  turnId: number;\r\n}) => {\r\n  if (!messageId) {\r\n    throw new Error('No messageId provided to completePendingMessage');\r\n  }\r\n  // Close out next message\r\n  await tx\r\n    .update(chatMessages)\r\n    .set({\r\n      statusId: 2,\r\n    })\r\n    .where(\r\n      and(\r\n        eq(chatMessages.chatId, chatId),\r\n        eq(chatMessages.turnId, turnId),\r\n        eq(chatMessages.messageId, messageId),\r\n      ),\r\n    );\r\n  return true;\r\n};\r\n\r\n/**\r\n * Handles tool-call stream chunks by creating new tool message records.\r\n *\r\n * This function processes tool call chunks from the AI model, creating new\r\n * message records in the database to track tool invocations and their parameters.\r\n * Each tool call gets its own message with a complete status.\r\n *\r\n * @param chunk - The tool-call stream chunk\r\n * @param context - The current stream handler context\r\n * @returns Promise resolving to the updated context and success status\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = await handleToolCall(\r\n *   {\r\n *     type: 'tool-call',\r\n *     toolName: 'search',\r\n *     args: { query: 'example' }\r\n *   },\r\n *   {\r\n *     chatId: 'chat-123',\r\n *     turnId: 1,\r\n *     currentMessageOrder: 2,\r\n *     generatedText: 'Hello'\r\n *   }\r\n * );\r\n * console.log(result.currentMessageOrder); // 3\r\n * ```\r\n */\r\nexport const handleToolCall = async (\r\n  chunk: Extract<LanguageModelV2ToolCall, { type: 'tool-call' }>,\r\n  context: StreamHandlerContext,\r\n): Promise<StreamHandlerResult> => {\r\n  ensureCreateResult(context);\r\n  try {\r\n    const { chatId, turnId, generatedText, currentMessageOrder, toolCalls } =\r\n      context;\r\n    await drizDb().transaction(async (tx) => {\r\n      await flushMessageParts({ context });\r\n      // Safely parse input JSON if present; tolerate empty/invalid inputs\r\n      let parsedInput: unknown = undefined;\r\n      const rawInput = (chunk.input ?? '').toString();\r\n      const trimmed = rawInput.trim();\r\n      if (trimmed.length > 0) {\r\n        try {\r\n          parsedInput = JSON.parse(rawInput);\r\n        } catch {\r\n          // keep as undefined; DB column may be JSON-only\r\n          parsedInput = undefined;\r\n        }\r\n      }\r\n\r\n      // Create tool message row draft for upsert logic\r\n      const toolRow = {\r\n        role: 'tool' as const,\r\n        statusId: 1,\r\n        content: generatedText,\r\n        toolName: chunk.toolName,\r\n        functionCall: parsedInput ?? null,\r\n        providerId: chunk.toolCallId,\r\n        metadata: null,\r\n        toolResult: null,\r\n      };\r\n\r\n      // Try to upsert the tool message first\r\n      let upsertedMessageId: number | null = null;\r\n      try {\r\n        upsertedMessageId = await upsertToolMessage(\r\n          tx,\r\n          chatId,\r\n          Number(turnId),\r\n          toolRow,\r\n        );\r\n      } catch (error) {\r\n        // In test environments, upsert might fail - fall back to normal creation\r\n        log((l) =>\r\n          l.debug(\r\n            `Tool message upsert failed, falling back to creation: ${error}`,\r\n          ),\r\n        );\r\n        upsertedMessageId = null;\r\n      }\r\n\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      let toolCall: any = null;\r\n      let actualMessageId: number;\r\n\r\n      if (upsertedMessageId !== null) {\r\n        // Message was updated, fetch the existing record\r\n        actualMessageId = upsertedMessageId;\r\n        try {\r\n          const existingMessages = await tx\r\n            .select()\r\n            .from(chatMessages)\r\n            .where(\r\n              and(\r\n                eq(chatMessages.chatId, chatId),\r\n                eq(chatMessages.messageId, actualMessageId),\r\n              ),\r\n            )\r\n            .limit(1)\r\n            .execute();\r\n          toolCall = existingMessages[0] || null;\r\n        } catch (error) {\r\n          // In test environments, selects might fail - create a mock tool call\r\n          log((l) =>\r\n            l.debug(\r\n              `Failed to fetch updated tool message, creating mock: ${error}`,\r\n            ),\r\n          );\r\n          toolCall = {\r\n            chatMessageId: 1,\r\n            messageId: actualMessageId,\r\n            providerId: chunk.toolCallId,\r\n            toolName: chunk.toolName,\r\n            role: 'tool',\r\n            content: generatedText,\r\n            functionCall: parsedInput ?? null,\r\n          };\r\n        }\r\n      } else {\r\n        // No existing message found, create a new one\r\n        const nextMessageId = await getNextSequence({\r\n          tx,\r\n          tableName: 'chat_messages',\r\n          chatId,\r\n          turnId: Number(turnId),\r\n          count: 1,\r\n        }).then((ids) => ids[0]);\r\n        actualMessageId = nextMessageId;\r\n\r\n        toolCall = (\r\n          await tx\r\n            .insert(chatMessages)\r\n            .values({\r\n              chatId,\r\n              turnId: Number(turnId),\r\n              role: 'tool',\r\n              content: generatedText,\r\n              messageId: nextMessageId,\r\n              providerId: chunk.toolCallId,\r\n              toolName: chunk.toolName,\r\n              functionCall: parsedInput ?? null,\r\n              messageOrder: currentMessageOrder,\r\n              statusId: 1, // complete status for tool calls\r\n              metadata: { modifiedTurnId: Number(turnId) },\r\n            })\r\n            .returning()\r\n            .execute()\r\n        ).at(0);\r\n      }\r\n      if (toolCall) {\r\n        if (!toolCall.providerId) {\r\n          log((l) =>\r\n            l.warn(\r\n              'Tool call was not assigned a provider id, result resolution may fail.',\r\n              toolCall,\r\n            ),\r\n          );\r\n        }\r\n        toolCalls.set(toolCall.providerId ?? '[missing]', toolCall);\r\n\r\n        log((l) =>\r\n          l.debug(\r\n            `Tool message handled for providerId ${chunk.toolCallId}: ${upsertedMessageId !== null ? 'updated' : 'created'} messageId ${actualMessageId}`,\r\n          ),\r\n        );\r\n      } else {\r\n        log((l) =>\r\n          l.error('Failed to create or update tool call message', {\r\n            log: true,\r\n            data: {\r\n              chatId,\r\n              turnId,\r\n              toolName: chunk.toolName,\r\n              args: chunk.input,\r\n              generatedText,\r\n              wasUpsert: upsertedMessageId !== null,\r\n            },\r\n          }),\r\n        );\r\n      }\r\n    });\r\n\r\n    return context.createResult({\r\n      currentMessageId: undefined,\r\n      currentMessageOrder: currentMessageOrder + 1,\r\n      generatedText: '',\r\n    });\r\n  } catch (error) {\r\n    log((l) =>\r\n      l.error('Error handling tool-call chunk', {\r\n        error,\r\n        turnId: context.turnId,\r\n        chatId: context.chatId,\r\n        toolName: chunk.toolName,\r\n        args: chunk.input,\r\n      }),\r\n    );\r\n    return context.createResult(false);\r\n  }\r\n};\r\n\r\n/**\r\n * Finds a pending tool call record associated with the given result chunk.\r\n *\r\n * Lookup strategy:\r\n * 1) Check the in-memory `toolCalls` map for `toolCallId`\r\n * 2) Query the database by `(chatId, providerId)`\r\n * 3) Fallback: if a `[missing]` placeholder exists in the map and the\r\n *    `toolName` matches, adopt it and update its `providerId`\r\n *\r\n * @param params.chunk - The incoming tool result part\r\n * @param params.toolCalls - In-memory map of known tool calls by provider id\r\n * @param params.chatId - Chat id for DB lookup\r\n * @param params.tx - Database transaction to perform the query\r\n * @returns The matched pending tool call row, or undefined if not found\r\n */\r\nconst findPendingToolCall = async ({\r\n  chunk: { toolCallId, toolName },\r\n  toolCalls,\r\n  chatId,\r\n  tx,\r\n}: {\r\n  chunk: LanguageModelV2ToolResultPart;\r\n  toolCalls: Map<string, ChatMessagesType>;\r\n  chatId: string;\r\n  tx: DbTransactionType;\r\n}) => {\r\n  let pendingCall =\r\n    toolCalls.get(toolCallId) ??\r\n    (await tx\r\n      .select()\r\n      .from(chatMessages)\r\n      .where(\r\n        and(\r\n          eq(chatMessages.chatId, chatId),\r\n          eq(chatMessages.providerId, toolCallId),\r\n        ),\r\n      )\r\n      .limit(1)\r\n      .execute()\r\n      .then((x) => x.at(0)));\r\n  if (!pendingCall) {\r\n    const maybeMatch = toolCalls.get('[missing]');\r\n    if (maybeMatch && maybeMatch.toolName === toolName) {\r\n      pendingCall = maybeMatch;\r\n      pendingCall.providerId = toolCallId;\r\n      toolCalls.set(pendingCall.providerId, pendingCall);\r\n      toolCalls.delete('[missing]');\r\n    }\r\n  }\r\n  return pendingCall;\r\n};\r\n\r\n/**\r\n * Appends a tool error to the current turn and marks the turn as error.\r\n *\r\n * Reads the existing `chat_turns` row, extends the `errors` array with the\r\n * serialized tool result output, and sets `statusId: 3`.\r\n *\r\n * @param tx - Database transaction\r\n * @param chatId - Chat identifier\r\n * @param turnId - Turn identifier\r\n * @param chunk - Tool result part containing the error output\r\n */\r\nconst setTurnError = async ({\r\n  tx,\r\n  chatId,\r\n  turnId,\r\n  chunk,\r\n}: {\r\n  tx: DbTransactionType;\r\n  chatId: string;\r\n  turnId: number;\r\n  chunk: LanguageModelV2ToolResultPart;\r\n}) => {\r\n  try {\r\n    const turn = await tx\r\n      .select({\r\n        errors: chatTurns.errors,\r\n        statusId: chatTurns.statusId,\r\n      })\r\n      .from(chatTurns)\r\n      .where(and(eq(chatTurns.chatId, chatId), eq(chatTurns.turnId, turnId)))\r\n      .limit(1)\r\n      .execute()\r\n      .then((x) => x.at(0));\r\n    if (!turn) {\r\n      log((l) =>\r\n        l.warn('Turn not found when saving tool result', { chatId, turnId }),\r\n      );\r\n      return;\r\n    }\r\n    await tx\r\n      .update(chatTurns)\r\n      .set({\r\n        errors: [\r\n          ...(turn.errors ? Array.from(turn.errors) : []),\r\n          JSON.stringify(chunk.output),\r\n        ],\r\n        statusId: 3,\r\n      })\r\n      .where(and(eq(chatTurns.chatId, chatId), eq(chatTurns.turnId, turnId)));\r\n  } catch (error) {\r\n    LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      data: {\r\n        chatId,\r\n        turnId,\r\n        toolName: chunk.toolName,\r\n        providerId: chunk.toolCallId,\r\n      },\r\n      message: 'Error setting turn error from tool result',\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Handles tool-result stream chunks by updating the originating tool call\r\n * message with the tool's output and any provider metadata, and by setting\r\n * error status on the turn when appropriate.\r\n *\r\n * Steps:\r\n * - Flush any buffered assistant parts so DB state is consistent\r\n * - Complete the pending assistant message if one exists\r\n * - Find the originating tool call (memory or DB fallback)\r\n * - Update the message `statusId` (2 success, 3 error), `toolResult`,\r\n *   `metadata`, and append any concurrent generated text to `content`\r\n * - On error outputs, also record the error on the turn via `setTurnError`\r\n *\r\n * Returns a result that clears `currentMessageId` and `generatedText` to\r\n * prepare for subsequent parts.\r\n *\r\n * @param chunk - Tool result part emitted by the provider\r\n * @param context - Current stream handler context\r\n * @returns A `StreamHandlerResult` indicating success and updated fields\r\n */\r\nexport const handleToolResult = async (\r\n  chunk: LanguageModelV2ToolResultPart,\r\n  context: StreamHandlerContext,\r\n): Promise<StreamHandlerResult> => {\r\n  ensureCreateResult(context);\r\n  try {\r\n    const { chatId, turnId, generatedText, messageId, toolCalls } = context;\r\n    flushMessageParts({ context });\r\n    await drizDb().transaction(async (tx) => {\r\n      await completePendingMessage({\r\n        tx,\r\n        messageId,\r\n        chatId,\r\n        turnId: Number(turnId),\r\n      });\r\n      // Try to match against a pending tool call first\r\n      let pendingCall = await findPendingToolCall({\r\n        chatId,\r\n        toolCalls,\r\n        chunk,\r\n        tx,\r\n      });\r\n\r\n      // If no pending call found, try upsert logic\r\n      if (!pendingCall && chunk.toolCallId) {\r\n        // Create tool message row draft for upsert logic\r\n        const toolRow = {\r\n          role: 'tool' as const,\r\n          statusId: 2,\r\n          content: generatedText,\r\n          toolName: chunk.toolName,\r\n          functionCall: null,\r\n          providerId: chunk.toolCallId,\r\n          metadata: null,\r\n          toolResult:\r\n            chunk.output !== undefined ? JSON.stringify(chunk.output) : null,\r\n        };\r\n\r\n        const upsertedMessageId = await upsertToolMessage(\r\n          tx,\r\n          chatId,\r\n          Number(turnId),\r\n          toolRow,\r\n        );\r\n\r\n        if (upsertedMessageId !== null) {\r\n          // Message was updated via upsert, fetch the record\r\n          try {\r\n            const existingMessages = await tx\r\n              .select()\r\n              .from(chatMessages)\r\n              .where(\r\n                and(\r\n                  eq(chatMessages.chatId, chatId),\r\n                  eq(chatMessages.messageId, upsertedMessageId),\r\n                ),\r\n              )\r\n              .limit(1)\r\n              .execute();\r\n            pendingCall = existingMessages[0] || null;\r\n\r\n            log((l) =>\r\n              l.debug(\r\n                `Tool result upserted for providerId ${chunk.toolCallId}, messageId: ${upsertedMessageId}`,\r\n              ),\r\n            );\r\n          } catch (error) {\r\n            // In test environments, selects might fail\r\n            log((l) =>\r\n              l.debug(`Failed to fetch upserted tool message: ${error}`),\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      if (pendingCall) {\r\n        const metadata: Record<PropertyKey, unknown> = pendingCall.metadata\r\n          ? { ...pendingCall.metadata }\r\n          : {};\r\n        let statusId = 2;\r\n        if (\r\n          chunk.output.type === 'error-json' ||\r\n          chunk.output.type === 'error-text'\r\n        ) {\r\n          statusId = 3;\r\n          metadata.toolErrorResult = chunk.output;\r\n          await setTurnError({ tx, chatId, turnId: Number(turnId), chunk });\r\n        }\r\n        if (chunk.providerOptions) {\r\n          metadata.toolResultProviderMeta = chunk.providerOptions;\r\n        }\r\n\r\n        // Update metadata with turn tracking\r\n        metadata.modifiedTurnId = Number(turnId);\r\n\r\n        await tx\r\n          .update(chatMessages)\r\n          .set({\r\n            statusId,\r\n            toolResult:\r\n              chunk.output !== undefined ? JSON.stringify(chunk.output) : null,\r\n            metadata: metadata,\r\n            content: `${pendingCall.content ?? ''}\\n${generatedText}`,\r\n          })\r\n          .where(\r\n            and(\r\n              eq(chatMessages.chatId, chatId),\r\n              eq(chatMessages.turnId, Number(turnId)),\r\n              eq(chatMessages.messageId, pendingCall.messageId),\r\n            ),\r\n          );\r\n      } else {\r\n        log((l) =>\r\n          l.warn('No pending tool call found for chunk and upsert failed', {\r\n            chatId,\r\n            turnId,\r\n            toolName: chunk.toolName,\r\n            providerId: chunk.toolCallId,\r\n          }),\r\n        );\r\n      }\r\n    });\r\n\r\n    return context.createResult({\r\n      currentMessageId: undefined,\r\n      generatedText: '',\r\n    });\r\n  } catch (error) {\r\n    LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      data: {\r\n        chatId: context.chatId,\r\n        turnId: context.turnId,\r\n        toolName: chunk.toolName,\r\n        providerId: chunk.toolCallId,\r\n      },\r\n      message: 'Error handling tool-result chunk',\r\n    });\r\n    return context.createResult(false);\r\n  }\r\n};\r\n\r\n/**\r\n * Handles finish stream chunks by recording token usage statistics.\r\n *\r\n * This function processes the final chunk from the AI model stream, recording\r\n * token usage statistics including prompt tokens, completion tokens, and total\r\n * token count for billing and analytics purposes.\r\n *\r\n * @param chunk - The finish stream chunk\r\n * @param context - The current stream handler context\r\n * @returns Promise resolving to the updated context and success status\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = await handleFinish(\r\n *   {\r\n *     type: 'finish',\r\n *     usage: {\r\n *       promptTokens: 50,\r\n *       completionTokens: 25\r\n *     }\r\n *   },\r\n *   {\r\n *     chatId: 'chat-123',\r\n *     turnId: 1,\r\n *     currentMessageOrder: 3,\r\n *     generatedText: 'Hello world'\r\n *   }\r\n * );\r\n * console.log(result.success); // true\r\n * ```\r\n */\r\nexport async function handleFinish(\r\n  chunk: Extract<LanguageModelV2StreamPart, { type: 'finish' }>,\r\n  context: StreamHandlerContext,\r\n): Promise<StreamHandlerResult> {\r\n  ensureCreateResult(context);\r\n  try {\r\n    // Save token usage if available\r\n    if (\r\n      chunk.usage &&\r\n      context.turnId &&\r\n      ((chunk.usage.inputTokens ?? 0) > 0 ||\r\n        (chunk.usage.outputTokens ?? 0) > 0 ||\r\n        context.messageId !== undefined)\r\n    ) {\r\n      await drizDb().transaction(async (tx) => {\r\n        if (context.messageId) {\r\n          await tx\r\n            .update(chatMessages)\r\n            .set({\r\n              statusId: 2,\r\n            })\r\n            .where(\r\n              and(\r\n                eq(chatMessages.chatId, context.chatId),\r\n                eq(chatMessages.turnId, Number(context.turnId)),\r\n                eq(chatMessages.messageId, context.messageId),\r\n              ),\r\n            );\r\n        }\r\n        await tx.insert(tokenUsage).values({\r\n          chatId: context.chatId,\r\n          turnId: Number(context.turnId),\r\n          promptTokens: chunk.usage.inputTokens,\r\n          completionTokens: chunk.usage.outputTokens,\r\n          totalTokens: chunk.usage.totalTokens,\r\n        });\r\n      });\r\n    }\r\n    // Tests expect currentMessageId to be undefined in the finish result\r\n    return context.createResult({ currentMessageId: undefined });\r\n  } catch (error) {\r\n    LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      data: {\r\n        chatId: context.chatId,\r\n        turnId: context.turnId,\r\n        usage: chunk.usage,\r\n      },\r\n      source: 'chat-middleware::stream-handler:handleFinish',\r\n    });\r\n    log((l) =>\r\n      l.error('Error handling finish chunk', {\r\n        error,\r\n        turnId: context.turnId,\r\n        chatId: context.chatId,\r\n        usage: chunk.usage,\r\n      }),\r\n    );\r\n    return context.createResult(false);\r\n  }\r\n}\r\n\r\n/**\r\n * Main dispatcher function that routes stream chunks to appropriate handlers.\r\n *\r\n * This function acts as a central dispatcher, examining the chunk type and\r\n * routing it to the appropriate specialized handler function. It provides\r\n * a unified interface for processing all types of stream chunks.\r\n *\r\n * @param chunk - The stream chunk to process\r\n * @param context - The current stream handler context\r\n * @returns Promise resolving to the updated context and success status\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = await processStreamChunk(chunk, context);\r\n * if (result.success) {\r\n *   // Update context with new values\r\n *   context.currentMessageOrder = result.currentMessageOrder;\r\n *   context.generatedText = result.generatedText;\r\n * }\r\n * ```\r\n */\r\nexport async function processStreamChunk(\r\n  chunk: LanguageModelV2StreamPart | LanguageModelV2ToolResultPart,\r\n  context: StreamHandlerContext,\r\n): Promise<StreamHandlerResult> {\r\n  ensureCreateResult(context);\r\n  return await instrumentStreamChunk(chunk.type, context, async () => {\r\n    switch (chunk.type) {\r\n      // ----- Text parts -----\r\n      case 'text-start': {\r\n        const { id } = chunk as Extract<\r\n          LanguageModelV2StreamPart,\r\n          { type: 'text-start' }\r\n        >;\r\n        getOpenText(context).set(id, '');\r\n        return context.createResult(true);\r\n      }\r\n      case 'text-delta': {\r\n        const { id, delta } = chunk as Extract<\r\n          LanguageModelV2StreamPart,\r\n          { type: 'text-delta' }\r\n        >;\r\n        const map = getOpenText(context);\r\n        if (!map.has(id)) map.set(id, '');\r\n        map.set(id, (map.get(id) || '') + delta);\r\n        return context.createResult({\r\n          generatedText: context.generatedText + delta,\r\n        });\r\n      }\r\n      case 'text-end': {\r\n        const { id } = chunk as Extract<\r\n          LanguageModelV2StreamPart,\r\n          { type: 'text-end' }\r\n        >;\r\n        const map = getOpenText(context);\r\n        const text = map.get(id) || '';\r\n        map.delete(id);\r\n        if (text) context.generatedJSON.push({ type: 'text', text });\r\n        return context.createResult(true);\r\n      }\r\n\r\n      // ----- Reasoning parts -----\r\n      case 'reasoning-start': {\r\n        const { id } = chunk as Extract<\r\n          LanguageModelV2StreamPart,\r\n          { type: 'reasoning-start' }\r\n        >;\r\n        getOpenReasoning(context).set(id, '');\r\n        return context.createResult(true);\r\n      }\r\n      case 'reasoning-delta': {\r\n        const { id, delta } = chunk as Extract<\r\n          LanguageModelV2StreamPart,\r\n          { type: 'reasoning-delta' }\r\n        >;\r\n        const map = getOpenReasoning(context);\r\n        if (!map.has(id)) map.set(id, '');\r\n        map.set(id, (map.get(id) || '') + delta);\r\n        return context.createResult(true);\r\n      }\r\n      case 'reasoning-end': {\r\n        const { id } = chunk as Extract<\r\n          LanguageModelV2StreamPart,\r\n          { type: 'reasoning-end' }\r\n        >;\r\n        const map = getOpenReasoning(context);\r\n        const text = map.get(id) || '';\r\n        map.delete(id);\r\n        if (text) context.generatedJSON.push({ type: 'reasoning', text });\r\n        return context.createResult(true);\r\n      }\r\n\r\n      // ----- Tool input (pre tool-call) -----\r\n      case 'tool-input-start': {\r\n        const { id, toolName } = chunk as Extract<\r\n          LanguageModelV2StreamPart,\r\n          { type: 'tool-input-start' }\r\n        >;\r\n        getOpenToolInput(context).set(id, { toolName, value: '' });\r\n        return context.createResult(true);\r\n      }\r\n      case 'tool-input-delta': {\r\n        const { id, delta } = chunk as Extract<\r\n          LanguageModelV2StreamPart,\r\n          { type: 'tool-input-delta' }\r\n        >;\r\n        const map = getOpenToolInput(context);\r\n        const buf = map.get(id) || { value: '' };\r\n        buf.value = (buf.value || '') + delta;\r\n        map.set(id, buf);\r\n        return context.createResult(true);\r\n      }\r\n      case 'tool-input-end': {\r\n        const { id } = chunk as Extract<\r\n          LanguageModelV2StreamPart,\r\n          { type: 'tool-input-end' }\r\n        >;\r\n        const map = getOpenToolInput(context);\r\n        const buf = map.get(id);\r\n        if (buf) {\r\n          const t = (buf.value ?? '').trim();\r\n          if (t.length > 0) {\r\n            let input: unknown = buf.value;\r\n            if (\r\n              (t.startsWith('{') && t.endsWith('}')) ||\r\n              (t.startsWith('[') && t.endsWith(']'))\r\n            ) {\r\n              try {\r\n                input = JSON.parse(buf.value);\r\n              } catch {\r\n                /* keep raw */\r\n              }\r\n            }\r\n            context.generatedJSON.push({\r\n              type: 'tool-input',\r\n              id,\r\n              ...(buf.toolName ? { toolName: buf.toolName } : {}),\r\n              input,\r\n            });\r\n          }\r\n          map.delete(id);\r\n        }\r\n        return context.createResult(true);\r\n      }\r\n\r\n      case 'tool-call':\r\n        return await handleToolCall(chunk, context);\r\n\r\n      case 'tool-result':\r\n        if (!('output' in chunk)) {\r\n          log((l) =>\r\n            l.warn('Received tool result without output', {\r\n              chunk,\r\n              context,\r\n            }),\r\n          );\r\n          return context.createResult({\r\n            generatedText: context.generatedText + JSON.stringify(chunk),\r\n          });\r\n        }\r\n        return await handleToolResult(chunk, context);\r\n\r\n      case 'finish':\r\n        return await handleFinish(chunk, context);\r\n\r\n      // ----- Other parts and fallback handling -----\r\n      case 'file':\r\n      case 'source':\r\n      case 'raw':\r\n      case 'response-metadata':\r\n      case 'stream-start': {\r\n        // Store as-is for observability; these are not text content\r\n        context.generatedJSON.push(chunk as Record<string, unknown>);\r\n        return context.createResult(true);\r\n      }\r\n\r\n      case 'error': {\r\n        // Append to text for visibility, and store raw\r\n        context.generatedText =\r\n          context.generatedText +\r\n          JSON.stringify(chunk as Record<string, unknown>);\r\n        context.generatedJSON.push(chunk as Record<string, unknown>);\r\n        const result = context.createResult(true);\r\n        (\r\n          result as unknown as {\r\n            chatId: string;\r\n            turnId: number;\r\n            messageId?: number;\r\n          }\r\n        ).chatId = context.chatId;\r\n        (\r\n          result as unknown as {\r\n            chatId: string;\r\n            turnId: number;\r\n            messageId?: number;\r\n          }\r\n        ).turnId = context.turnId;\r\n        (\r\n          result as unknown as {\r\n            chatId: string;\r\n            turnId: number;\r\n            messageId?: number;\r\n          }\r\n        ).messageId = context.messageId;\r\n        return result;\r\n      }\r\n\r\n      default: {\r\n        // Unknown chunk: append to text to match existing tests\r\n        const appended =\r\n          context.generatedText +\r\n          JSON.stringify(chunk as Record<string, unknown>);\r\n        context.generatedText = appended;\r\n        const result = context.createResult({\r\n          generatedText: appended,\r\n        });\r\n        (\r\n          result as unknown as {\r\n            chatId: string;\r\n            turnId: number;\r\n            messageId?: number;\r\n          }\r\n        ).chatId = context.chatId;\r\n        (\r\n          result as unknown as {\r\n            chatId: string;\r\n            turnId: number;\r\n            messageId?: number;\r\n          }\r\n        ).turnId = context.turnId;\r\n        (\r\n          result as unknown as {\r\n            chatId: string;\r\n            turnId: number;\r\n            messageId?: number;\r\n          }\r\n        ).messageId = context.messageId;\r\n        return result;\r\n      }\r\n    }\r\n  });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\chat-history\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":52,"column":1,"nodeType":"Program","endLine":956,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Chat History Middleware Type Definitions\r\n *\r\n * This module provides comprehensive type definitions for the AI chat history middleware system.\r\n * It defines the core data structures and interfaces used throughout the message processing\r\n * pipeline, from initial chat context through streaming response handling to final persistence.\r\n *\r\n * **Type Categories:**\r\n * - **Context Types**: Core session and processing context information\r\n * - **Stream Processing Types**: Real-time message streaming and chunk handling\r\n * - **Task Management Types**: Asynchronous processing queue and task coordination\r\n * - **Completion Types**: Turn finalization and persistence operations\r\n * - **Configuration Types**: System behavior and feature control settings\r\n *\r\n * **Key Design Principles:**\r\n * - **Type Safety**: Strong typing for all middleware operations and data flows\r\n * - **Flexibility**: Optional properties enable progressive enhancement and backward compatibility\r\n * - **Composability**: Interfaces designed for extension and reuse across components\r\n * - **Performance**: Minimal overhead types optimized for high-throughput scenarios\r\n * - **Debugging**: Rich metadata support for operational monitoring and troubleshooting\r\n *\r\n * **Data Flow Architecture:**\r\n * ```\r\n * ChatHistoryContext → StreamHandlerContext → QueuedTask → FlushContext\r\n *        ↓                    ↓                 ↓           ↓\r\n *   Session Setup      Stream Processing   Task Queue   Completion\r\n * ```\r\n * - **Database Operations**: Structured for efficient ORM and query operations\r\n * - **Middleware Pipeline**: Designed for seamless integration with processing chains\r\n * - **Real-time Systems**: Optimized for streaming and asynchronous processing\r\n *\r\n * **Performance Characteristics:**\r\n * - Minimal memory footprint for high-volume chat applications\r\n * - Efficient serialization for database storage and network transmission\r\n * - Type-safe operations preventing runtime errors and data corruption\r\n * - Structured logging support for monitoring and analytics\r\n *\r\n * **Use Cases:**\r\n * - AI chat application development\r\n * - Real-time conversation streaming\r\n * - Message persistence and history management\r\n * - Multi-turn dialogue state tracking\r\n * - Tool-calling workflow coordination\r\n * - Chat analytics and monitoring\r\n *\r\n * @module chat-history-types\r\n * @version 2.0.0\r\n * @author AI Middleware Team\r\n * @since 1.0.0\r\n */\r\n\r\nimport type { DbTransactionType, ChatMessagesType } from '@/lib/drizzle-db';\r\nimport { LanguageModelV2StreamPart } from '@ai-sdk/provider';\r\nimport { Span } from '@opentelemetry/api';\r\n\r\n// ============================================================================\r\n// Core Context Types\r\n// ============================================================================\r\n\r\n/**\r\n * Core context information required for chat history operations.\r\n *\r\n * @remarks\r\n * This interface serves as the foundational context for all chat history middleware\r\n * operations. It carries essential session information, user identification, and\r\n * model configuration throughout the processing pipeline. The interface is designed\r\n * with optional properties to support progressive enhancement and backward compatibility.\r\n *\r\n * **Context Lifecycle:**\r\n * - Created at the start of each chat request\r\n * - Passed through all middleware stages\r\n * - Used for database operations and logging\r\n * - Preserved for audit trails and analytics\r\n *\r\n * **Security Considerations:**\r\n * - User ID enables proper access control and data isolation\r\n * - Chat ID allows session continuity and conversation threading\r\n * - Request ID enables distributed tracing and debugging\r\n *\r\n * **Model Configuration:**\r\n * - Model name enables provider-specific handling\r\n * - Temperature and topP control response generation characteristics\r\n * - Configuration is preserved for reproducibility and debugging\r\n *\r\n * @interface ChatHistoryContext\r\n * @category Core Context\r\n * @example\r\n * ```typescript\r\n * // Basic chat context for new conversation\r\n * const context: ChatHistoryContext = {\r\n *   userId: 'user_123',\r\n *   requestId: 'req_abc789'\r\n * };\r\n *\r\n * // Complete context with model configuration\r\n * const fullContext: ChatHistoryContext = {\r\n *   userId: 'user_456',\r\n *   chatId: 'chat_def123',\r\n *   requestId: 'req_xyz456',\r\n *   model: 'gpt-4',\r\n *   temperature: 0.7,\r\n *   topP: 0.9\r\n * };\r\n * ```\r\n */\r\nexport interface ChatHistoryContext {\r\n  processingTimeMs?: number;\r\n  /**\r\n   * Unique identifier for the user initiating the chat.\r\n   * Used for access control, data isolation, and audit trails.\r\n   */\r\n  userId: string;\r\n\r\n  /**\r\n   * Optional unique identifier for the chat session.\r\n   * When provided, enables conversation continuity and threading.\r\n   * When omitted, a new chat session will be created automatically.\r\n   */\r\n  chatId?: string;\r\n\r\n  /**\r\n   * Optional unique identifier for the current turn within the chat session.\r\n   * When provided, enables precise tracking of user interactions and model responses.\r\n   * When omitted, a new turn will be created automatically.\r\n   */\r\n  turnId?: string;\r\n\r\n  /**\r\n   * Optional unique identifier for the current request.\r\n   * Enables distributed tracing, debugging, and request correlation.\r\n   * Recommended for production systems and monitoring.\r\n   */\r\n  requestId?: string;\r\n\r\n  /**\r\n   * Optional name of the AI model being used.\r\n   * Enables provider-specific handling and response optimization.\r\n   * Examples: 'gpt-4', 'gpt-3.5-turbo', 'claude-3'\r\n   */\r\n  model?: string;\r\n\r\n  /**\r\n   * Optional temperature setting for response generation.\r\n   * Controls randomness in model responses (0.0 = deterministic, 1.0 = creative).\r\n   * Preserved for reproducibility and debugging purposes.\r\n   */\r\n  temperature?: number;\r\n\r\n  /**\r\n   * Optional top-p (nucleus sampling) setting for response generation.\r\n   * Controls diversity of model responses (0.1 = focused, 1.0 = diverse).\r\n   * Preserved for reproducibility and debugging purposes.\r\n   */\r\n  topP?: number;\r\n\r\n  /**\r\n   * Optional metadata associated with the current request.\r\n   * Can be used to store additional context or parameters for processing.\r\n   */\r\n  metadata?: Record<PropertyKey, unknown>;\r\n\r\n  /**\r\n   * Timestamp indicating when the chat context was created.\r\n   */\r\n  beganAt: Date;\r\n\r\n  /**\r\n   * Current iteration number for the chat context.\r\n   * Used to track the progression of the conversation.\r\n   * Note this differs from the turn number in that it\r\n   * is calculated by chat context instance, not the overall\r\n   * conversation.\r\n   */\r\n  iteration: number;\r\n\r\n  /**\r\n   * opentelemetry span instance for tracing.\r\n   */\r\n  span: Span;\r\n\r\n  /**\r\n   * Current error state for the chat context.\r\n   * Used to track any errors that occur during processing.\r\n   */\r\n  error: unknown;\r\n\r\n  /**\r\n   * Disposes of the chat context and releases any resources.\r\n   * @returns A promise that resolves when the context is disposed.\r\n   */\r\n  dispose: () => Promise<void>;\r\n}\r\n\r\n/**\r\n * Represents the execution status of a tool within a chat message.\r\n * @internal\r\n */\r\nexport type ToolStatus = 'pending' | 'result' | 'error' | 'content';\r\n\r\n// ============================================================================\r\n// Stream Processing Types\r\n// ============================================================================\r\n\r\n/**\r\n * Context information required for processing individual stream chunks.\r\n *\r\n * @remarks\r\n * This interface maintains the state needed during real-time stream processing.\r\n * It tracks the current position in the conversation, accumulates generated content,\r\n * and provides the necessary identifiers for database operations. The context is\r\n * updated as each stream chunk is processed to maintain consistency.\r\n *\r\n * **Stream Processing Flow:**\r\n * - Created when streaming begins for a conversation turn\r\n * - Updated with each incoming stream chunk\r\n * - Tracks message ordering and content accumulation\r\n * - Used for incremental database updates\r\n *\r\n * **State Management:**\r\n * - Message ordering ensures proper conversation flow\r\n * - Text accumulation enables incremental content building\r\n * - Identifiers link chunks to database records\r\n * - Context preservation enables error recovery\r\n *\r\n * **Performance Considerations:**\r\n * - Minimal state to reduce memory overhead\r\n * - Efficient string accumulation for large responses\r\n * - Fast lookup identifiers for database operations\r\n * - Immutable design for thread safety\r\n *\r\n * @interface StreamHandlerContext\r\n * @category Stream Processing\r\n * @example\r\n * ```typescript\r\n * // Initial stream context setup\r\n * const streamContext: StreamHandlerContext = {\r\n *   chatId: 'chat_123',\r\n *   turnId: 5,\r\n *   messageId: 42,\r\n *   currentMessageOrder: 3,\r\n *   generatedText: ''\r\n * };\r\n *\r\n * // Context after processing several chunks\r\n * const updatedContext: StreamHandlerContext = {\r\n *   ...streamContext,\r\n *   generatedText: 'Hello, I can help you with...',\r\n *   currentMessageOrder: 4\r\n * };\r\n * ```\r\n */\r\nexport interface StreamHandlerContext {\r\n  /**\r\n   * Unique identifier for the current chat session.\r\n   * Links stream chunks to their conversation context.\r\n   */\r\n  chatId: string;\r\n\r\n  /**\r\n   * Unique identifier for the current conversation turn.\r\n   * Groups related messages within a request/response cycle.\r\n   */\r\n  turnId: number;\r\n\r\n  /**\r\n   * Optional unique identifier for the assistant message being generated.\r\n   * Used for incremental updates to the response content.\r\n   */\r\n  messageId?: number;\r\n\r\n  /**\r\n   * Current position in the message ordering sequence.\r\n   * Ensures proper message flow and conversation continuity.\r\n   */\r\n  currentMessageOrder: number;\r\n\r\n  /**\r\n   * Accumulated text content from processed stream chunks.\r\n   * Built incrementally as the AI response is generated.\r\n   */\r\n  generatedText: string;\r\n\r\n  /**\r\n   * Structured collection of objects reconstructed from phased streaming\r\n   * parts (*-start / *-delta / *-end). Each entry is one logical object; for\r\n   * streaming objects (like tool-input) the final assembled form is pushed\r\n   * on *-end. Non-streaming generic *-start parts are pushed immediately as\r\n   * normalized objects with their '-start' suffix removed.\r\n   */\r\n  generatedJSON: Array<Record<string, unknown>>;\r\n\r\n  /**\r\n   * A map of currently known tool calls that are awaiting response.\r\n   */\r\n  toolCalls: Map<string, ChatMessagesType>;\r\n\r\n  /**\r\n   * Creates a StreamHandlerResult from the current context.\r\n   * @returns The created StreamHandlerResult.\r\n   */\r\n  createResult: (\r\n    success?: boolean | Partial<StreamHandlerResult>,\r\n  ) => StreamHandlerResult;\r\n}\r\n\r\n/**\r\n * Result information returned after processing a stream chunk.\r\n *\r\n * @remarks\r\n * This interface captures the outcome of processing an individual stream chunk,\r\n * including updated state information and success status. It enables the calling\r\n * code to track processing progress, handle errors gracefully, and maintain\r\n * consistent state across the streaming pipeline.\r\n *\r\n * **Result Processing:**\r\n * - Success flag indicates whether chunk was processed without errors\r\n * - Updated counters enable state synchronization\r\n * - Accumulated text tracks content generation progress\r\n * - Error information (when success is false) enables recovery\r\n *\r\n * **State Synchronization:**\r\n * - Message order tracking prevents sequence corruption\r\n * - Text accumulation enables incremental UI updates\r\n * - Success status enables error handling and retry logic\r\n * - Consistent return format simplifies calling code\r\n *\r\n * **Error Handling:**\r\n * - Boolean success flag for simple error checking\r\n * - Preserved state even on failure for recovery\r\n * - Consistent interface regardless of outcome\r\n * - Enables graceful degradation and retry strategies\r\n *\r\n * @interface StreamHandlerResult\r\n * @category Stream Processing\r\n * @example\r\n * ```typescript\r\n * // Successful chunk processing\r\n * const successResult: StreamHandlerResult = {\r\n *   currentMessageOrder: 4,\r\n *   generatedText: 'Hello, I can help you...',\r\n *   success: true\r\n * };\r\n *\r\n * // Failed chunk processing (with preserved state)\r\n * const errorResult: StreamHandlerResult = {\r\n *   currentMessageOrder: 3, // Previous valid state\r\n *   generatedText: 'Hello, I can',\r\n *   success: false\r\n * };\r\n * ```\r\n */\r\nexport interface StreamHandlerResult {\r\n  /**\r\n   *the conversation identifier for the\r\n   * processed chunk.\r\n   *\r\n   */\r\n  chatId: string;\r\n\r\n  /**\r\n   * This is the numeric turn identifier associated with\r\n   * the processed chunk.\r\n   *\r\n   */\r\n  turnId: number;\r\n\r\n  /**\r\n   * messageId of the current chunk being processed.\r\n   *\r\n   */\r\n  messageId: number;\r\n  /**\r\n   * Message identifier to assign to the next messsage record created.\r\n   */\r\n  currentMessageId: number | undefined;\r\n  /**\r\n   * Updated message order counter after processing the chunk.\r\n   * Reflects the current position in the conversation sequence.\r\n   */\r\n  currentMessageOrder: number;\r\n\r\n  /**\r\n   * Updated accumulated text after processing the chunk.\r\n   * Contains all generated content up to this point in the response.\r\n   */\r\n  generatedText: string;\r\n\r\n  /**\r\n   * Updated accumulated JSON objects added to the pending stream.\r\n   * Contains all generated content included in the current message up to this point in the response.\r\n   */\r\n  generatedJSON: Array<Record<string, unknown>>;\r\n\r\n  /**\r\n   * Map of tool IDs to their corresponding chat messages.\r\n   * Tracks all tool invocations and their responses.\r\n   */\r\n  toolCalls: Map<string, ChatMessagesType>;\r\n\r\n  /**\r\n   * Indicates whether the stream chunk was successfully processed.\r\n   * When false, the chunk processing encountered an error or exception.\r\n   */\r\n  success: boolean;\r\n}\r\n\r\n// ============================================================================\r\n// Task Management Types\r\n// ============================================================================\r\n\r\n/**\r\n * Represents a queued processing task for asynchronous stream chunk handling.\r\n *\r\n * @remarks\r\n * This interface defines the structure for tasks in the asynchronous processing queue.\r\n * Each task represents a single stream chunk that needs to be processed, along with\r\n * its context and the promises needed for coordination. The queue enables ordered\r\n * processing while maintaining system responsiveness.\r\n *\r\n * **Queue Management:**\r\n * - Tasks are processed in order to maintain conversation flow\r\n * - Each task has a unique ID for tracking and debugging\r\n * - Promises enable asynchronous coordination and error handling\r\n * - Results are stored for subsequent processing stages\r\n *\r\n * **Asynchronous Coordination:**\r\n * - Promise-based design enables non-blocking operations\r\n * - Resolve/reject functions provide completion signaling\r\n * - Context preservation enables stateful processing\r\n * - Result storage enables downstream consumption\r\n *\r\n * **Error Handling:**\r\n * - Individual task errors don't block the queue\r\n * - Reject functions enable error propagation\r\n * - Context preservation enables retry operations\r\n * - Result tracking enables debugging and monitoring\r\n *\r\n * **Performance Benefits:**\r\n * - Non-blocking queue processing maintains system responsiveness\r\n * - Ordered execution preserves conversation integrity\r\n * - Parallel preparation enables pipeline optimization\r\n * - Memory-efficient task representation\r\n *\r\n * @interface QueuedTask\r\n * @category Task Management\r\n * @example\r\n * ```typescript\r\n * // Create a new queued task\r\n * const task: QueuedTask = {\r\n *   id: 1,\r\n *   chunk: { type: 'text-delta', textDelta: 'Hello' },\r\n *   context: streamContext,\r\n *   promise: taskPromise,\r\n *   resolve: () => console.log('Task completed'),\r\n *   reject: (error) => console.error('Task failed:', error)\r\n * };\r\n *\r\n * // Task after processing\r\n * const completedTask: QueuedTask = {\r\n *   ...task,\r\n *   result: {\r\n *     currentMessageOrder: 4,\r\n *     generatedText: 'Hello, world',\r\n *     success: true\r\n *   }\r\n * };\r\n * ```\r\n */\r\nexport interface QueuedTask {\r\n  /**\r\n   * Unique identifier for the task within the processing queue.\r\n   * Used for tracking, debugging, and ensuring ordered processing.\r\n   */\r\n  id: number;\r\n\r\n  /**\r\n   * The stream chunk data to be processed.\r\n   * Contains the actual AI-generated content or metadata from the stream.\r\n   */\r\n  chunk: LanguageModelV2StreamPart;\r\n\r\n  /**\r\n   * Processing context required for handling the chunk.\r\n   * Maintains state information and identifiers for database operations.\r\n   */\r\n  context: StreamHandlerContext;\r\n\r\n  /**\r\n   * Promise that resolves when the task processing completes.\r\n   * Enables asynchronous coordination and error handling.\r\n   */\r\n  promise: Promise<void>;\r\n\r\n  /**\r\n   * Function to call when task processing succeeds.\r\n   * Signals successful completion to waiting consumers.\r\n   */\r\n  resolve: () => void;\r\n\r\n  /**\r\n   * Function to call when task processing fails.\r\n   * Enables error propagation and recovery strategies.\r\n   */\r\n  reject: (error: Error) => void;\r\n\r\n  /**\r\n   * Optional result from processing the task.\r\n   * Populated after successful completion for downstream consumption.\r\n   */\r\n  result?: StreamHandlerResult;\r\n}\r\n\r\n// ============================================================================\r\n// Completion and Persistence Types\r\n// ============================================================================\r\n\r\n/**\r\n * Context information required for flush operations when completing a chat turn.\r\n *\r\n * @remarks\r\n * This interface provides all necessary information for finalizing a conversation turn,\r\n * including content persistence, performance metrics calculation, and status updates.\r\n * The flush operation represents the final stage of message processing, ensuring\r\n * all data is properly saved and the turn is marked as complete.\r\n *\r\n * **Flush Operations:**\r\n * - Final content persistence to database\r\n * - Performance metrics calculation and storage\r\n * - Turn status updates and completion signaling\r\n * - Analytics data preparation and logging\r\n *\r\n * **Performance Tracking:**\r\n * - Start time enables latency calculation\r\n * - Content length tracking for analytics\r\n * - Processing metrics for monitoring\r\n * - Error tracking for debugging\r\n *\r\n * **Data Integrity:**\r\n * - Final text represents complete generated response\r\n * - Identifiers ensure proper database targeting\r\n * - Timing data enables performance analysis\r\n * - Complete context for audit trails\r\n *\r\n * **Analytics Support:**\r\n * - Turn completion metrics\r\n * - Response length statistics\r\n * - Performance benchmarking data\r\n * - Error rate and pattern tracking\r\n *\r\n * @interface FlushContext\r\n * @category Completion\r\n * @example\r\n * ```typescript\r\n * // Flush context for completed conversation\r\n * const flushContext: FlushContext = {\r\n *   chatId: 'chat_123',\r\n *   turnId: 5,\r\n *   messageId: 42,\r\n *   generatedText: 'Complete AI response here...',\r\n *   startTime: Date.now() - 2500 // 2.5 seconds ago\r\n * };\r\n *\r\n * // Minimal flush context (IDs optional for some operations)\r\n * const minimalFlush: FlushContext = {\r\n *   chatId: 'chat_456',\r\n *   generatedText: 'Short response',\r\n *   startTime: Date.now() - 500\r\n * };\r\n * ```\r\n */\r\nexport interface FlushContext {\r\n  /**\r\n   * Unique identifier of the chat/conversation being completed.\r\n   * Links the flush operation to the specific conversation context.\r\n   */\r\n  chatId: string;\r\n\r\n  /**\r\n   * Turn number within the conversation (optional for some operations).\r\n   * Enables sequencing and ordering of conversation exchanges.\r\n   */\r\n  turnId?: number;\r\n\r\n  /**\r\n   * Unique database identifier for the message record (optional).\r\n   * Used for direct database targeting when available.\r\n   */\r\n  messageId?: number;\r\n\r\n  /**\r\n   * Complete generated text content from the AI response.\r\n   * Represents the final accumulated content for persistence.\r\n   */\r\n  generatedText: string;\r\n\r\n  /**\r\n   * Timestamp when the generation process began.\r\n   * Used for calculating response latency and performance metrics.\r\n   */\r\n  startTime: number;\r\n}\r\n\r\n/**\r\n * Result information returned from flush operations after completing chat persistence.\r\n *\r\n * @remarks\r\n * This interface captures the outcomes and metrics from finalizing a conversation turn,\r\n * providing essential feedback for monitoring, analytics, and error handling. The flush\r\n * result represents the final status of message processing and includes both success\r\n * indicators and performance metrics.\r\n *\r\n * **Operation Status:**\r\n * - Success flag indicates completion state\r\n * - Error information for debugging failures\r\n * - Database operation confirmations\r\n * - Processing stage indicators\r\n *\r\n * **Performance Metrics:**\r\n * - Processing duration calculation\r\n * - Content length statistics\r\n * - Database operation timing\r\n * - Resource usage indicators\r\n *\r\n * **Quality Assurance:**\r\n * - Data integrity verification\r\n * - Completion status validation\r\n * - Error categorization and reporting\r\n * - Audit trail information\r\n *\r\n * **Analytics Data:**\r\n * - Response generation timing\r\n * - Content volume metrics\r\n * - Success/failure rates\r\n * - Performance benchmarking\r\n *\r\n * **Error Recovery:**\r\n * - Detailed error information\r\n * - Recovery action suggestions\r\n * - Retry coordination data\r\n * - Failure pattern tracking\r\n *\r\n * @interface FlushResult\r\n * @category Completion\r\n * @example\r\n * ```typescript\r\n * // Successful flush result\r\n * const successResult: FlushResult = {\r\n *   success: true,\r\n *   processingTimeMs: 1250,\r\n *   contentLength: 486,\r\n *   finalMessageId: 42\r\n * };\r\n *\r\n * // Failed flush result with error details\r\n * const errorResult: FlushResult = {\r\n *   success: false,\r\n *   error: new Error('Database connection timeout'),\r\n *   processingTimeMs: 5000,\r\n *   contentLength: 320,\r\n *   retryRecommended: true\r\n * };\r\n *\r\n * // Minimal successful result\r\n * const minimalResult: FlushResult = {\r\n *   success: true,\r\n *   processingTimeMs: 800\r\n * };\r\n * ```\r\n *\r\n * @property success Indicates whether the flush operation completed successfully.\r\n * @property error Error information if the flush operation failed.\r\n * @property processingTimeMs Total time spent processing the flush operation in milliseconds.\r\n * @property contentLength Length of the content that was persisted during the flush.\r\n * @property finalMessageId Database ID of the final persisted message record.\r\n * @property retryRecommended Indicates whether a retry of the operation is recommended.\r\n * @property metadata Additional metadata about the flush operation.\r\n * @property textLength Length of the final generated text content.\r\n */\r\nexport interface FlushResult {\r\n  /**\r\n   * Indicates whether the flush operation completed successfully.\r\n   * Critical for determining if the conversation turn was properly finalized.\r\n   */\r\n  success: boolean;\r\n\r\n  /**\r\n   * Error information if the flush operation failed.\r\n   * Provides detailed debugging information and recovery options.\r\n   */\r\n  error?: Error;\r\n\r\n  /**\r\n   * Total time spent processing the flush operation in milliseconds.\r\n   * Used for performance monitoring and optimization analysis.\r\n   */\r\n  processingTimeMs: number;\r\n\r\n  /**\r\n   * Length of the final generated text content.\r\n   * Useful for analytics and content volume tracking.\r\n   */\r\n  textLength: number;\r\n\r\n  /**\r\n   * Length of the content that was persisted during the flush.\r\n   * Useful for analytics and content volume tracking.\r\n   */\r\n  contentLength?: number;\r\n\r\n  /**\r\n   * Database ID of the final persisted message record.\r\n   * Enables direct referencing and follow-up operations.\r\n   */\r\n  finalMessageId?: number;\r\n\r\n  /**\r\n   * Indicates whether a retry of the operation is recommended.\r\n   * Helps coordinate error recovery and resilience strategies.\r\n   */\r\n  retryRecommended?: boolean;\r\n\r\n  /**\r\n   * Additional metadata about the flush operation.\r\n   * Flexible field for implementation-specific information.\r\n   */\r\n  metadata?: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Configuration options for controlling flush operation behavior and timing.\r\n *\r\n * @remarks\r\n * This interface defines parameters that control how and when flush operations are\r\n * executed during conversation completion. It provides fine-grained control over\r\n * timing, persistence behavior, error handling, and performance optimization.\r\n *\r\n * **Timing Control:**\r\n * - Flush interval determines periodic persistence frequency\r\n * - Timeout settings prevent hanging operations\r\n * - Debounce options optimize batch processing\r\n * - Immediate flush overrides for critical operations\r\n *\r\n * **Performance Optimization:**\r\n * - Batch size controls database efficiency\r\n * - Buffer management reduces I/O overhead\r\n * - Compression options for large content\r\n * - Memory usage optimization settings\r\n *\r\n * **Reliability Features:**\r\n * - Retry configuration for failed operations\r\n * - Backup persistence strategies\r\n * - Data integrity verification\r\n * - Recovery mechanism controls\r\n *\r\n * **Monitoring Integration:**\r\n * - Metrics collection enablement\r\n * - Performance tracking options\r\n * - Error reporting configuration\r\n * - Analytics data preparation\r\n *\r\n * **Customization Options:**\r\n * - Content filtering rules\r\n * - Persistence format selection\r\n * - Compression algorithms\r\n * - Storage destination routing\r\n *\r\n * @interface FlushConfig\r\n * @category Configuration\r\n * @example\r\n * ```typescript\r\n * // Standard production configuration\r\n * const prodConfig: FlushConfig = {\r\n *   autoGenerateTitle: true,\r\n *   maxTitleLength: 100,\r\n *   titleWordCount: 8,\r\n *   flushIntervalMs: 1000,\r\n *   timeoutMs: 5000,\r\n *   enableMetrics: true,\r\n *   batchSize: 50,\r\n *   retryAttempts: 3,\r\n *   compressionEnabled: true\r\n * };\r\n *\r\n * // Development configuration with verbose logging\r\n * const devConfig: FlushConfig = {\r\n *   autoGenerateTitle: true,\r\n *   maxTitleLength: 150,\r\n *   titleWordCount: 10,\r\n *   flushIntervalMs: 500,\r\n *   timeoutMs: 10000,\r\n *   enableMetrics: true,\r\n *   verboseLogging: true,\r\n *   retryAttempts: 1\r\n * };\r\n *\r\n * // Minimal configuration for testing\r\n * const testConfig: FlushConfig = {\r\n *   autoGenerateTitle: false,\r\n *   maxTitleLength: 50,\r\n *   titleWordCount: 5\r\n * };\r\n * ```\r\n */\r\nexport interface FlushConfig {\r\n  /**\r\n   * Whether to automatically generate chat titles based on conversation content.\r\n   * When enabled, uses AI to create descriptive titles from initial exchanges.\r\n   */\r\n  autoGenerateTitle: boolean;\r\n\r\n  /**\r\n   * Maximum character length for generated chat titles.\r\n   * Ensures titles remain readable and fit within UI constraints.\r\n   */\r\n  maxTitleLength: number;\r\n\r\n  /**\r\n   * Target number of words to include in generated titles.\r\n   * Balances descriptiveness with brevity for optimal readability.\r\n   */\r\n  titleWordCount: number;\r\n\r\n  /**\r\n   * Interval in milliseconds between periodic flush operations.\r\n   * Controls how frequently partial content is persisted to storage.\r\n   */\r\n  flushIntervalMs?: number;\r\n\r\n  /**\r\n   * Maximum time in milliseconds to wait for flush operations to complete.\r\n   * Prevents hanging operations and ensures system responsiveness.\r\n   */\r\n  timeoutMs?: number;\r\n\r\n  /**\r\n   * Whether to collect and report performance metrics during flush operations.\r\n   * Enables monitoring and optimization of persistence performance.\r\n   */\r\n  enableMetrics?: boolean;\r\n\r\n  /**\r\n   * Number of messages to batch together for efficient database operations.\r\n   * Optimizes I/O performance while maintaining reasonable memory usage.\r\n   */\r\n  batchSize?: number;\r\n\r\n  /**\r\n   * Maximum number of retry attempts for failed flush operations.\r\n   * Provides resilience against transient failures and network issues.\r\n   */\r\n  retryAttempts?: number;\r\n\r\n  /**\r\n   * Whether to enable content compression for large messages.\r\n   * Reduces storage requirements and network overhead for substantial responses.\r\n   */\r\n  compressionEnabled?: boolean;\r\n\r\n  /**\r\n   * Whether to enable verbose logging during flush operations.\r\n   * Useful for development and debugging of persistence workflows.\r\n   */\r\n  verboseLogging?: boolean;\r\n}\r\n/**\r\n * Result information returned when initializing message persistence.\r\n *\r\n * @remarks\r\n * This interface captures identifiers provisioned at the start of a persistence\r\n * operation for a chat turn (e.g., reserving message IDs). These identifiers are\r\n * passed forward to subsequent steps that complete the persistence process.\r\n *\r\n * @interface MessagePersistenceInit\r\n * @category Completion\r\n * @example\r\n * ```typescript\r\n * const init: MessagePersistenceInit = {\r\n *   chatId: 'chat_123',\r\n *   turnId: '5',\r\n *   messageId: 42\r\n * };\r\n * ```\r\n */\r\nexport interface MessagePersistenceInit {\r\n  /**\r\n   * Unique identifier of the chat/conversation being persisted.\r\n   */\r\n  chatId: string;\r\n\r\n  /**\r\n   * String representation of the current turn id (may be coerced from number\r\n   * by upstream utilities). Used for sequencing and DB targeting.\r\n   */\r\n  turnId: string;\r\n\r\n  /**\r\n   * Optional reserved message identifier for the assistant response.\r\n   * When present, downstream steps should use this id for updates.\r\n   */\r\n  messageId?: number;\r\n}\r\n\r\n/**\r\n * Context information required to complete message persistence for a chat turn.\r\n *\r\n * @remarks\r\n * This interface is provided to the finalization step that writes the completed\r\n * content, updates message/turn status, and records performance metrics.\r\n *\r\n * @interface MessageCompletionContext\r\n * @category Completion\r\n * @example\r\n * ```typescript\r\n * const completion: MessageCompletionContext = {\r\n *   chatId: 'chat_123',\r\n *   turnId: 5,\r\n *   messageId: 42,\r\n *   generatedText: 'Final response',\r\n *   startTime: Date.now() - 1200\r\n * };\r\n * ```\r\n */\r\nexport interface MessageCompletionContext {\r\n  /**\r\n   * Optional Drizzle transaction instance for atomic DB operations.\r\n   * When provided, all completion writes should be performed with this txn.\r\n   */\r\n  tx?: DbTransactionType;\r\n\r\n  /**\r\n   * Identifier of the chat/conversation being completed.\r\n   */\r\n  chatId: string;\r\n\r\n  /**\r\n   * Optional numeric turn id (preferred form for DB operations).\r\n   */\r\n  turnId?: number;\r\n\r\n  /**\r\n   * Optional message id of the message to finalize.\r\n   */\r\n  messageId?: number;\r\n\r\n  /**\r\n   * The final accumulated text content to persist for the assistant message.\r\n   */\r\n  generatedText: string;\r\n\r\n  /**\r\n   * Epoch milliseconds timestamp indicating when generation started.\r\n   * Used to compute processing duration/latency.\r\n   */\r\n  startTime: number;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\chat-history\\utility.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":401,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type {\r\n  LanguageModelV2CallOptions,\r\n  LanguageModelV2FilePart,\r\n  LanguageModelV2ReasoningPart,\r\n  LanguageModelV2TextPart,\r\n  LanguageModelV2ToolCallPart,\r\n  LanguageModelV2ToolResultPart,\r\n} from '@ai-sdk/provider';\r\nimport { schema } from '@/lib/drizzle-db/schema';\r\nimport { type DbTransactionType, drizDbWithInit } from '@/lib/drizzle-db';\r\nimport { eq, desc } from 'drizzle-orm';\r\nimport { ToolStatus } from './types';\r\n\r\nexport const getNextSequence = async ({\r\n  chatId,\r\n  tableName,\r\n  count = 1,\r\n  tx,\r\n  ...props\r\n}:\r\n  | {\r\n      chatId: string;\r\n      tableName: 'chat_turns';\r\n      count?: number;\r\n      tx?: DbTransactionType;\r\n    }\r\n  | {\r\n      chatId: string;\r\n      tableName: 'chat_messages';\r\n      turnId: number;\r\n      count?: number;\r\n      tx?: DbTransactionType;\r\n    }) => {\r\n  // Check to see if a turn id was provided in context.\r\n  // NOTE: Fallback value of 0 is used instead of undefined, as\r\n  // this keeps turnId a number type and sumplifies use of the value\r\n  // downstream.\r\n  const turnId = 'turnId' in props ? props.turnId : 0;\r\n  const scopedIds = await (tx ? Promise.resolve(tx) : drizDbWithInit()).then(\r\n    (db) =>\r\n      db.execute<{ allocate_scoped_ids: number }>(\r\n        `SELECT * FROM allocate_scoped_ids('${tableName}', '${chatId}', ${turnId}, ${count})`,\r\n      ),\r\n  );\r\n  const ret: Array<number> = scopedIds.map(\r\n    (x) => x.allocate_scoped_ids as number,\r\n  );\r\n  return ret;\r\n};\r\n\r\nexport const normalizeOutput = (value: unknown): string => {\r\n  if (typeof value === 'string') {\r\n    return value;\r\n  }\r\n  return JSON.stringify(value ?? 'null');\r\n};\r\n// Extract tool-result input/output/error as strings for storage\r\nexport const getItemOutput = (\r\n  item:\r\n    | (LanguageModelV2ToolResultPart & { type: 'tool-result' | 'dynamic-tool' })\r\n    | null\r\n    | undefined,\r\n): { status: ToolStatus; output?: string; media?: string } => {\r\n  if (!item || !item.output) {\r\n    return { status: 'pending' };\r\n  }\r\n  switch (item.output.type) {\r\n    case 'text':\r\n    case 'json': {\r\n      // Check if the value contains an isError flag\r\n      const parsedValue =\r\n        typeof item.output.value === 'string'\r\n          ? (() => {\r\n              try {\r\n                return JSON.parse(item.output.value);\r\n              } catch {\r\n                return item.output.value;\r\n              }\r\n            })()\r\n          : item.output.value;\r\n\r\n      const isError =\r\n        parsedValue &&\r\n        typeof parsedValue === 'object' &&\r\n        'isError' in parsedValue &&\r\n        parsedValue.isError === true;\r\n\r\n      return {\r\n        status: isError ? 'error' : 'result',\r\n        output: normalizeOutput(item.output.value),\r\n      };\r\n    }\r\n    case 'content':\r\n      return item.output.value.reduce(\r\n        (acc, curr) => {\r\n          if ('data' in curr) {\r\n            acc.media = (acc.media ?? '') + normalizeOutput(curr.data);\r\n          }\r\n          if ('value' in curr) {\r\n            acc.output = (acc.output ?? '') + normalizeOutput(curr.value);\r\n          }\r\n          return acc;\r\n        },\r\n        { status: 'result' } as {\r\n          status: ToolStatus;\r\n          media?: string;\r\n          output?: string;\r\n        },\r\n      );\r\n    case 'error-json':\r\n    case 'error-text':\r\n      return { status: 'error', output: normalizeOutput(item.output) };\r\n    default:\r\n      break;\r\n  }\r\n  return { status: 'result', output: normalizeOutput(item.output) };\r\n};\r\n\r\n/**\r\n * Identifies new messages by comparing incoming prompt with existing chat messages.\r\n *\r\n * @remarks\r\n * This function performs message deduplication by comparing incoming messages\r\n * against existing messages in the chat session. It identifies which messages\r\n * from the prompt array are truly new and haven't been saved before.\r\n *\r\n * **Comparison Strategy:**\r\n * - Messages are compared by role and content for exact matches\r\n * - Tool messages use providerId-based deduplication with turn validation\r\n * - Only messages not found in existing chat history are considered new\r\n * - Maintains message order from the original prompt array\r\n * - Handles various content types (string and complex content structures)\r\n *\r\n * **Tool Message Update Logic:**\r\n * - For tool messages with existing providerId: returns message for update processing\r\n * - Update eligibility determined by currentTurnId > stored.metadata.modifiedTurnId\r\n * - Non-destructive merge preserves existing functionCall/toolResult data\r\n *\r\n * **Performance Optimizations:**\r\n * - Queries existing messages only once per chat session\r\n * - Uses efficient array operations for comparison\r\n * - Minimizes database operations by batching lookups\r\n *\r\n * @param tx - Active database transaction for consistency\r\n * @param chatId - The chat ID to check for existing messages\r\n * @param incomingMessages - Array of messages from the prompt\r\n * @param currentTurnId - Current turn ID for tool message update validation\r\n * @returns Promise resolving to array of messages that need processing (new inserts + eligible updates)\r\n *\r\n * @example\r\n * ```typescript\r\n * const messages = await getNewMessages(transaction, 'chat_123', [\r\n *   { role: 'user', content: 'Hello' },        // Already exists - filtered out\r\n *   { role: 'assistant', content: 'Hi there' }, // Already exists - filtered out\r\n *   { role: 'user', content: 'How are you?' }   // New message - included\r\n * ], 3);\r\n * // Returns: [{ role: 'user', content: 'How are you?' }]\r\n * ```\r\n */\r\nexport const getNewMessages = async (\r\n  tx: DbTransactionType,\r\n  chatId: string,\r\n  incomingMessages: LanguageModelV2CallOptions['prompt'],\r\n  currentTurnId?: number,\r\n): Promise<LanguageModelV2CallOptions['prompt']> => {\r\n  // Handle null/undefined incomingMessages gracefully\r\n  if (!incomingMessages || incomingMessages.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  // Get all existing messages for this chat, ordered by creation\r\n  const existingMessages = await tx\r\n    .select({\r\n      role: schema.chatMessages.role,\r\n      content: schema.chatMessages.content,\r\n      messageOrder: schema.chatMessages.messageOrder,\r\n      providerId: schema.chatMessages.providerId,\r\n      metadata: schema.chatMessages.metadata,\r\n      toolName: schema.chatTool.toolName,\r\n      input: schema.chatToolCalls.input,\r\n      output: schema.chatToolCalls.output,\r\n    })\r\n    .from(schema.chatMessages)\r\n    .leftJoin(\r\n      schema.chatToolCalls,\r\n      eq(schema.chatMessages.chatMessageId, schema.chatToolCalls.chatMessageId),\r\n    )\r\n    .leftJoin(\r\n      schema.chatTool,\r\n      eq(schema.chatToolCalls.chatToolId, schema.chatTool.chatToolId),\r\n    )\r\n    .where(eq(schema.chatMessages.chatId, chatId))\r\n    .orderBy(desc(schema.chatMessages.messageOrder))\r\n    .then((results) =>\r\n      (results ?? []).filter(Boolean).map((record) => {\r\n        // if we do not have a record, or it does not have content, or the content is not a string,\r\n        // // there nothing for us to do\r\n        if (!record.content || typeof record.content !== 'string') {\r\n          return record;\r\n        }\r\n        // Parse content into it's native / non-string representation\r\n        try {\r\n          const parsed = JSON.parse(record.content);\r\n          record.content = parsed;\r\n        } catch {\r\n          // Nothing for us to do - leave it as a string.\r\n        }\r\n        return record;\r\n      }),\r\n    );\r\n  // If no existing messages, all incoming messages are new\r\n  if (existingMessages.length === 0) {\r\n    return incomingMessages;\r\n  }\r\n\r\n  // Helper function to normalize content for comparison\r\n  const normalizeContentForComparison = (\r\n    input: unknown,\r\n    { skipTools = false }: { skipTools?: boolean } = {},\r\n  ): string => {\r\n    if (!input) {\r\n      return '';\r\n    }\r\n    if (typeof input === 'string') {\r\n      return input ?? '';\r\n    }\r\n    if (typeof input === 'object' && !!input) {\r\n      let content: string = '';\r\n      if (Array.isArray(input)) {\r\n        return input\r\n          .map((x) => normalizeContentForComparison(x, { skipTools }))\r\n          .filter(Boolean)\r\n          .join('\\n');\r\n      }\r\n      if ('content' in input && !input.content) {\r\n        if (typeof input.content === 'object') {\r\n          if (Array.isArray(input.content)) {\r\n            content += input.content\r\n              .map((x) => normalizeContentForComparison(x, { skipTools }))\r\n              .filter(Boolean)\r\n              .join('\\n');\r\n          } else {\r\n            content += normalizeContentForComparison(input.content, {\r\n              skipTools,\r\n            });\r\n          }\r\n        } else {\r\n          content += input?.content?.toString()?.trim() ?? '';\r\n        }\r\n      }\r\n      if ('text' in input) {\r\n        content += input?.text?.toString()?.trim() ?? '';\r\n      } else if ('type' in input) {\r\n        switch (input.type) {\r\n          case 'text':\r\n            content += (input as { text?: string }).text?.toString() ?? '';\r\n            break;\r\n          case 'tool-call':\r\n          case 'tool-result':\r\n            if (!skipTools) {\r\n              const fnInput =\r\n                'input' in input && input.input\r\n                  ? `(${JSON.stringify(input.input)})`\r\n                  : '';\r\n              const fnOutput =\r\n                'output' in input && input.output\r\n                  ? ` => ${JSON.stringify(input.output)}`\r\n                  : '';\r\n              const fnName =\r\n                'toolName' in input && input.toolName ? input.toolName : '';\r\n              const fnId =\r\n                'toolCallId' in input && input.toolCallId\r\n                  ? ` [${input.toolCallId}]`\r\n                  : '';\r\n              content += (fnName + fnId + fnInput + fnOutput).trim();\r\n            }\r\n            break;\r\n          default:\r\n            // content += JSON.stringify(input);\r\n            break;\r\n        }\r\n      }\r\n      return content;\r\n    }\r\n    return '';\r\n  };\r\n\r\n  // Create a normalized representation of existing messages for comparison\r\n  const existingMessageSignatures = new Set(\r\n    existingMessages.map((msg) => {\r\n      const normalizedContent = normalizeContentForComparison(msg.content);\r\n      return `${msg.role}:${normalizedContent}`;\r\n    }),\r\n  );\r\n\r\n  // Create a set of existing tool provider IDs with their metadata for tool message deduplication\r\n  const existingToolProviderIds = new Map(\r\n    existingMessages\r\n      .filter((msg) => msg.role === 'tool' && msg.providerId)\r\n      .map((msg) => [\r\n        msg.providerId!,\r\n        {\r\n          modifiedTurnId:\r\n            (msg.metadata as { modifiedTurnId?: number } | null)\r\n              ?.modifiedTurnId || 0,\r\n        },\r\n      ]),\r\n  );\r\n\r\n  // Filter incoming messages to only include those not already persisted\r\n  const newMessages = incomingMessages.filter((incomingMsg) => {\r\n    // Special handling for tool messages - check for updates based on turn ID\r\n    if (incomingMsg.role === 'tool') {\r\n      // For explicit tool role messages, check if any part has a toolCallId that exists\r\n      let toolCallId: string | undefined;\r\n\r\n      if (Array.isArray(incomingMsg.content)) {\r\n        for (const part of incomingMsg.content) {\r\n          if (\r\n            part &&\r\n            typeof part === 'object' &&\r\n            'toolCallId' in part &&\r\n            part.toolCallId\r\n          ) {\r\n            toolCallId = part.toolCallId as string;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // If we found a tool call ID and it exists, check if update is needed\r\n      if (toolCallId && existingToolProviderIds.has(toolCallId)) {\r\n        const existingMeta = existingToolProviderIds.get(toolCallId)!;\r\n\r\n        // Include message if current turn is greater than last modified turn\r\n        if (currentTurnId && currentTurnId > existingMeta.modifiedTurnId) {\r\n          return true; // Include for update processing\r\n        }\r\n\r\n        return false; // Skip - either no current turn or turn not newer\r\n      }\r\n    }\r\n\r\n    // For assistant messages that contain tool calls, check individual tool calls\r\n    if (\r\n      incomingMsg.role === 'assistant' &&\r\n      Array.isArray(incomingMsg.content)\r\n    ) {\r\n      const toolCalls = incomingMsg.content.filter(\r\n        (\r\n          part:\r\n            | LanguageModelV2TextPart\r\n            | LanguageModelV2FilePart\r\n            | LanguageModelV2ReasoningPart\r\n            | LanguageModelV2ToolCallPart\r\n            | LanguageModelV2ToolResultPart,\r\n        ) => part?.type === 'tool-call' && part?.toolCallId,\r\n      );\r\n\r\n      // If this message contains only tool calls, check update eligibility\r\n      if (\r\n        toolCalls.length > 0 &&\r\n        toolCalls.length === incomingMsg.content.length\r\n      ) {\r\n        // Check if any tool call needs updating\r\n        const hasUpdatableCall = toolCalls.some(\r\n          (\r\n            call:\r\n              | LanguageModelV2TextPart\r\n              | LanguageModelV2FilePart\r\n              | LanguageModelV2ReasoningPart\r\n              | LanguageModelV2ToolCallPart\r\n              | LanguageModelV2ToolResultPart,\r\n          ) => {\r\n            if (!('toolCallId' in call)) {\r\n              return false; // Skip if no toolCallId present\r\n            }\r\n            if (!existingToolProviderIds.has(call.toolCallId)) {\r\n              return true; // New tool call\r\n            }\r\n            const existingMeta = existingToolProviderIds.get(call.toolCallId)!;\r\n            return currentTurnId && currentTurnId > existingMeta.modifiedTurnId;\r\n          },\r\n        );\r\n\r\n        return hasUpdatableCall;\r\n      }\r\n    }\r\n\r\n    // Standard content-based deduplication for other messages\r\n    const normalizedIncomingContent = normalizeContentForComparison(\r\n      incomingMsg.content,\r\n    );\r\n    const incomingSignature = `${incomingMsg.role}:${normalizedIncomingContent}`;\r\n\r\n    return !existingMessageSignatures.has(incomingSignature);\r\n  });\r\n\r\n  return newMessages;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\key-rate-limiter\\metrics-utils.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":45,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { rateLimitMetrics } from './metrics';\r\nimport type { ModelClassification } from './types';\r\n\r\n/**\r\n * Records performance metrics for request processing.\r\n * \r\n * @param startTime - The start time of the request in milliseconds\r\n * @param modelClassification - The model classification\r\n * @param operationType - The type of operation ('generate' or 'stream')\r\n */\r\nexport function recordRequestMetrics(\r\n  startTime: number,\r\n  modelClassification: ModelClassification,\r\n  operationType: 'generate' | 'stream'\r\n): void {\r\n  const duration = Date.now() - startTime;\r\n  rateLimitMetrics.recordProcessingDuration(duration, modelClassification);\r\n  \r\n  console.log(`${operationType} finished successfully in ${duration}ms for model ${modelClassification}`);\r\n}\r\n\r\n/**\r\n * Gets the current provider from a model key or defaults to 'azure'.\r\n * \r\n * @param modelKey - Optional model key to extract provider from\r\n * @returns The provider ('azure' or 'google')\r\n */\r\nexport function getCurrentProvider(modelKey?: string): 'azure' | 'google' {\r\n  if (modelKey?.includes('google')) {\r\n    return 'google';\r\n  }\r\n  return 'azure'; // Default assumption\r\n}\r\n\r\n/**\r\n * Constructs a model key from provider and classification.\r\n * \r\n * @param provider - The model provider\r\n * @param classification - The model classification\r\n * @returns The constructed model key\r\n */\r\nexport function constructModelKey(provider: string, classification: ModelClassification): string {\r\n  return `${provider}:${classification}`;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\key-rate-limiter\\metrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\key-rate-limiter\\middleware.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":332,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { LanguageModelV2StreamPart } from '@ai-sdk/provider';\r\nimport { getRetryErrorInfo } from '@/lib/ai/chat';\r\nimport {\r\n  isModelAvailable,\r\n  getModelAvailabilityStatus,\r\n} from '@/lib/ai/aiModelFactory';\r\nimport { rateLimitMetrics } from './metrics';\r\nimport type {\r\n  ModelClassification,\r\n  ModelFailoverConfig,\r\n  RetryRateLimitMiddlewareType,\r\n  RateLimitRetryContext,\r\n  RateLimitFactoryOptions,\r\n} from './types';\r\nimport { log } from '@/lib/logger';\r\nimport { checkModelAvailabilityAndFallback } from './model-availability';\r\nimport {\r\n  handleRateLimitError,\r\n  disableModelFromRateLimit,\r\n} from './rate-limit-handler';\r\nimport {\r\n  recordRequestMetrics,\r\n  getCurrentProvider,\r\n  constructModelKey,\r\n} from './metrics-utils';\r\nimport { LanguageModel } from 'ai';\r\nimport { ModelMap } from '../../services/model-stats/model-map';\r\nimport { MiddlewareStateManager } from '../state-management';\r\n\r\ntype RateLimitRetryState = {\r\n  rateLimitContext: RateLimitRetryContext;\r\n  timestamp: number;\r\n};\r\n\r\n// Model classification mapping - extract from model identifier\r\nconst getModelClassification = async ({\r\n  model = 'unknown',\r\n}: { model?: LanguageModel } = {}): Promise<ModelClassification> => {\r\n  return await (await ModelMap.getInstance())\r\n    .normalizeProviderModel(model)\r\n    .then((x) => x.classification);\r\n};\r\n\r\n// Provider and model failover logic\r\nconst getFailoverConfig = (currentProvider: string): ModelFailoverConfig => {\r\n  const primaryProvider = currentProvider.includes('azure')\r\n    ? 'azure'\r\n    : 'google';\r\n  const fallbackProvider = primaryProvider === 'azure' ? 'google' : 'azure';\r\n\r\n  return {\r\n    primaryProvider,\r\n    fallbackProvider,\r\n    // modelClassification,\r\n  };\r\n};\r\n\r\nexport const retryRateLimitMiddlewareFactory = async (\r\n  factoryOptions: RateLimitFactoryOptions | RateLimitRetryContext,\r\n): Promise<RetryRateLimitMiddlewareType> => {\r\n  /**\r\n   * Advanced rate limit middleware context data\r\n   */\r\n  let rateLimitContext = await (async () => {\r\n    if ('modelClass' in factoryOptions) {\r\n      return factoryOptions;\r\n    }\r\n    // If factoryOptions is a FactoryOptions, derive context from it\r\n    const { model } = factoryOptions;\r\n    if (!model) {\r\n      throw new Error('Model is required to create rate limit context');\r\n    }\r\n    const normalModel = await (\r\n      await ModelMap.getInstance()\r\n    ).normalizeProviderModel(model);\r\n    const modelClass = await getModelClassification({\r\n      model: normalModel.modelId,\r\n    });\r\n    const { primaryProvider, fallbackProvider } = getFailoverConfig(\r\n      normalModel.provider,\r\n    );\r\n    return {\r\n      modelClass,\r\n      failover: {\r\n        primaryProvider,\r\n        fallbackProvider,\r\n      },\r\n    };\r\n  })();\r\n\r\n  /**\r\n   * Original rate limit middleware implementation\r\n   */\r\n  const originalRetryRateLimitMiddleware: RetryRateLimitMiddlewareType = {\r\n    rateLimitContext: () => ({ ...rateLimitContext }),\r\n\r\n    wrapGenerate: async ({ doGenerate, params }) => {\r\n      const startTime = Date.now();\r\n      const modelClassification = rateLimitContext.modelClass;\r\n\r\n      console.log('Advanced rate limit middleware - doGenerate called');\r\n      console.log(`Model classification: ${modelClassification}`);\r\n\r\n      // Check if current model is available, attempt fallback if not\r\n      const currentProvider = getCurrentProvider();\r\n      const currentModelKey = constructModelKey(\r\n        currentProvider,\r\n        modelClassification,\r\n      );\r\n\r\n      try {\r\n        await checkModelAvailabilityAndFallback(\r\n          currentModelKey,\r\n          modelClassification,\r\n          rateLimitContext.failover,\r\n          {\r\n            ...params,\r\n            ...{\r\n              chatId: 'unassigned',\r\n              turnId: '1',\r\n              ...(params?.providerOptions?.backoffice ?? {}),\r\n            },\r\n          },\r\n        );\r\n      } catch (error) {\r\n        // Model unavailable and no fallback - error already thrown with appropriate message\r\n        throw error;\r\n      }\r\n\r\n      try {\r\n        const result = await doGenerate();\r\n\r\n        recordRequestMetrics(startTime, modelClassification, 'generate');\r\n        console.log('doGenerate finished successfully');\r\n        return result;\r\n      } catch (error) {\r\n        recordRequestMetrics(startTime, modelClassification, 'generate');\r\n\r\n        // Use utility function to handle rate limit errors\r\n        await handleRateLimitError(\r\n          error,\r\n          currentModelKey,\r\n          modelClassification,\r\n          rateLimitContext.failover,\r\n          {\r\n            ...params,\r\n            ...{\r\n              chatId: 'unassigned',\r\n              turnId: '1',\r\n              ...(params?.providerOptions?.backoffice ?? {}),\r\n            },\r\n          },\r\n          'generate',\r\n        );\r\n        // This line should never be reached as handleRateLimitError always throws\r\n        throw error;\r\n      }\r\n    },\r\n\r\n    wrapStream: async ({ doStream, params, model }) => {\r\n      const startTime = Date.now();\r\n      const modelClassification = await getModelClassification({ model });\r\n\r\n      console.log('Advanced rate limit middleware - doStream called');\r\n      console.log(`Model classification: ${modelClassification}`);\r\n\r\n      // Similar model availability check as in wrapGenerate\r\n      const currentProvider = getCurrentProvider();\r\n      const currentModelKey = constructModelKey(\r\n        currentProvider,\r\n        modelClassification,\r\n      );\r\n\r\n      try {\r\n        await checkModelAvailabilityAndFallback(\r\n          currentModelKey,\r\n          modelClassification,\r\n          getFailoverConfig(currentProvider),\r\n          {\r\n            ...params,\r\n            ...{\r\n              chatId: 'unassigned',\r\n              turnId: '1',\r\n              ...(params?.providerOptions?.backoffice ?? {}),\r\n            },\r\n          },\r\n        );\r\n      } catch (error) {\r\n        // Model unavailable and no fallback - error already thrown with appropriate message\r\n        throw error;\r\n      }\r\n\r\n      try {\r\n        const { stream, ...rest } = await doStream();\r\n        let generatedText = '';\r\n        let hasError = false;\r\n\r\n        const transformStream = new TransformStream<\r\n          LanguageModelV2StreamPart,\r\n          LanguageModelV2StreamPart\r\n        >({\r\n          transform(chunk, controller) {\r\n            if (chunk.type === 'text-delta') {\r\n              generatedText += chunk.delta;\r\n            }\r\n\r\n            // Check for error chunks that might indicate rate limiting\r\n            if (chunk.type === 'error') {\r\n              hasError = true;\r\n              const rateLimitErrorInfo = getRetryErrorInfo(chunk.error);\r\n              if (\r\n                rateLimitErrorInfo?.isRetry &&\r\n                rateLimitErrorInfo.retryAfter\r\n              ) {\r\n                console.log(\r\n                  `Stream rate limit detected: ${rateLimitErrorInfo.retryAfter}s`,\r\n                );\r\n                disableModelFromRateLimit(\r\n                  currentModelKey,\r\n                  rateLimitErrorInfo.retryAfter,\r\n                );\r\n                rateLimitMetrics.recordError(\r\n                  'stream_rate_limit',\r\n                  modelClassification,\r\n                );\r\n              }\r\n            }\r\n\r\n            controller.enqueue(chunk);\r\n          },\r\n\r\n          flush() {\r\n            recordRequestMetrics(startTime, modelClassification, 'stream');\r\n\r\n            if (!hasError) {\r\n              console.log('doStream finished successfully');\r\n              console.log(`Generated text length: ${generatedText.length}`);\r\n            }\r\n          },\r\n        });\r\n\r\n        return {\r\n          stream: stream.pipeThrough(transformStream),\r\n          ...rest,\r\n        };\r\n      } catch (error) {\r\n        recordRequestMetrics(startTime, modelClassification, 'stream');\r\n\r\n        // Handle rate limit errors using utility function\r\n        await handleRateLimitError(\r\n          error,\r\n          currentModelKey,\r\n          modelClassification,\r\n          getFailoverConfig(currentProvider),\r\n          params,\r\n          'stream_setup',\r\n        );\r\n        // This line should never be reached as handleRateLimitError always throws\r\n        throw error;\r\n      }\r\n    },\r\n\r\n    transformParams: async ({ params }) => {\r\n      console.log('transformParams called - checking model availability');\r\n\r\n      const modelClassification = rateLimitContext.modelClass;\r\n      const currentProvider =\r\n        rateLimitContext.failover?.primaryProvider ?? 'azure';\r\n      const currentModelKey = `${currentProvider}:${modelClassification}`;\r\n\r\n      // Log current model availability status\r\n      const availabilityStatus = getModelAvailabilityStatus();\r\n      log((l) => l.verbose('Model availability status:', availabilityStatus));\r\n\r\n      // If current model is not available, we could potentially modify params here\r\n      // to use a different model, but this would require careful handling\r\n      if (!isModelAvailable(currentModelKey)) {\r\n        log((l) =>\r\n          l.warn(`Requested model ${currentModelKey} is not available`),\r\n        );\r\n      }\r\n      // Forward to token tracking middleware to generate token counts\r\n      return {\r\n        ...params,\r\n      };\r\n    },\r\n  };\r\n\r\n  const serializeState = async (): Promise<RateLimitRetryState> => {\r\n    return Promise.resolve({\r\n      rateLimitContext,\r\n      timestamp: Date.now(),\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Stateful wrapper with rate limit context preservation\r\n   */\r\n  const statefulMiddleware =\r\n    MiddlewareStateManager.Instance.statefulMiddlewareWrapper<RateLimitRetryState>(\r\n      {\r\n        middlewareId: 'retry-rate-limiter',\r\n        middleware: {\r\n          ...originalRetryRateLimitMiddleware,\r\n          serializeState,\r\n          deserializeState: ({\r\n            state: {\r\n              rateLimitContext: rateLimiteContextFromState,\r\n              timestamp: timestampFromState,\r\n            },\r\n          }) => {\r\n            if (rateLimiteContextFromState) {\r\n              rateLimitContext = rateLimiteContextFromState;\r\n            }\r\n            log((l) =>\r\n              l.debug('Rate limiter state restored', {\r\n                context: rateLimitContext,\r\n                age: Date.now() - (timestampFromState || 0),\r\n              }),\r\n            );\r\n            return Promise.resolve();\r\n          },\r\n        },\r\n      },\r\n    ) as RetryRateLimitMiddlewareType;\r\n\r\n  // Add the rateLimitContext method to the stateful middleware\r\n  statefulMiddleware.rateLimitContext = () => ({ ...rateLimitContext });\r\n\r\n  return statefulMiddleware;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\key-rate-limiter\\model-availability.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":140,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { log } from '@/lib/logger';\r\nimport { isModelAvailable } from '@/lib/ai/aiModelFactory';\r\nimport { rateLimitQueueManager } from './queue-manager';\r\nimport { rateLimitMetrics } from './metrics';\r\nimport type {\r\n  ModelClassification,\r\n  ModelFailoverConfig,\r\n  RateLimitedRequest,\r\n} from './types';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { RateRetryError } from '@/lib/react-util/errors/rate-retry-error';\r\n\r\n// Check if model is available and get fallback if needed\r\nexport function getAvailableModel(\r\n  provider: 'azure' | 'google',\r\n  classification: ModelClassification,\r\n): string | null {\r\n  const modelKey = `${provider}:${classification}`;\r\n  return isModelAvailable(modelKey) ? modelKey : null;\r\n}\r\n\r\n/**\r\n * Retry delay for model requests.\r\n */\r\nexport const CHAT_RETRY_DELAY_MS = 90 * 1000; // 90 seconds\r\n\r\n/**\r\n * Checks model availability and handles fallback logic.\r\n * If no models are available, enqueues the request for retry.\r\n *\r\n * @param currentModelKey - The current model key being checked\r\n * @param modelClassification - The model classification\r\n * @param failoverConfig - The failover configuration\r\n * @param params - The request parameters\r\n * @returns The available model key or throws an error if none available\r\n */\r\nexport async function checkModelAvailabilityAndFallback(\r\n  currentModelKey: string,\r\n  modelClassification: ModelClassification,\r\n  failoverConfig: ModelFailoverConfig | undefined,\r\n  params: Record<string, unknown> & {\r\n    prompt?: unknown[];\r\n    chatId: string;\r\n    turnId: string;\r\n  },\r\n): Promise<string | void> {\r\n  if (!isModelAvailable(currentModelKey)) {\r\n    log((l) =>\r\n      l.warn(`Model ${currentModelKey} is disabled, attempting fallback`),\r\n    );\r\n\r\n    if (failoverConfig) {\r\n      const fallbackModelKey = getAvailableModel(\r\n        failoverConfig.fallbackProvider,\r\n        modelClassification,\r\n      );\r\n\r\n      if (fallbackModelKey) {\r\n        log((l) => l.info(`Using fallback model: ${fallbackModelKey}`));\r\n        return fallbackModelKey;\r\n        // Note: In a real implementation, we'd need to modify the params to use the fallback model\r\n        // This would require integration with the model factory to switch providers\r\n      } else {\r\n        // No fallback available, enqueue for retry\r\n        const requestId = await enqueueRequestForRetry(\r\n          modelClassification,\r\n          params,\r\n          'no_models_available',\r\n        );\r\n\r\n        throw new RateRetryError({\r\n          chatId: params.chatId,\r\n          turnId: params.turnId,\r\n          retryId: requestId,\r\n          retryAfter: new Date(Date.now() + 90000), // Retry after 1.5 minute\r\n        });\r\n      }\r\n    } else {\r\n      // No failover config, enqueue for retry\r\n      const retryId = await enqueueRequestForRetry(\r\n        modelClassification,\r\n        params,\r\n        'no_models_available',\r\n      );\r\n\r\n      throw new RateRetryError({\r\n        chatId: params.chatId,\r\n        turnId: params.turnId,\r\n        retryId,\r\n        retryAfter: new Date(Date.now() + 90000), // Retry after 1.5 minute\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Enqueues a request for retry processing when models are unavailable or rate limited.\r\n *\r\n * @param modelClassification - The model classification\r\n * @param params - The request parameters\r\n * @param errorType - The type of error causing the enqueue\r\n * @returns The generated request ID\r\n */\r\nexport const enqueueRequestForRetry = async (\r\n  modelClassification: ModelClassification,\r\n  {\r\n    prompt,\r\n    ...params\r\n  }: Record<string, unknown> & {\r\n    prompt?: unknown[];\r\n    chatId: string;\r\n    turnId: string;\r\n  },\r\n  errorType: string,\r\n): Promise<string> => {\r\n  if (!prompt || prompt.length === 0) {\r\n    throw new TypeError(\r\n      'Unable to locate prompt; this request does not support delayed run enqueuing.',\r\n    );\r\n  }\r\n  const requestId = uuidv4();\r\n  const rateLimitedRequest: RateLimitedRequest = {\r\n    id: requestId,\r\n    modelClassification,\r\n    request: { params, messages: prompt },\r\n    metadata: {\r\n      submittedAt: new Date().toISOString(),\r\n      chatTurnId: String(params.chatTurnId ?? '1'),\r\n      chatHistoryId: String(params.chatHistoryId ?? 'unassigned'),\r\n      retryAfter: new Date(Date.now() + CHAT_RETRY_DELAY_MS).valueOf(), // Retry after 90 seconds\r\n      generation: 1,\r\n    },\r\n  };\r\n\r\n  await rateLimitQueueManager.enqueueRequest(rateLimitedRequest);\r\n  rateLimitMetrics.recordError(errorType, modelClassification);\r\n\r\n  return requestId;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\key-rate-limiter\\queue-manager.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":131,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getRedisClient } from '../cacheWithRedis/redis-client';\r\nimport type { RateLimitedRequest, ProcessedResponse } from './types';\r\n\r\nconst REDIS_PREFIX = 'rate-limit';\r\nconst EXPIRATION_HOURS = 6;\r\nconst EXPIRATION_SECONDS = EXPIRATION_HOURS * 60 * 60;\r\n\r\nexport class RateLimitQueueManager {\r\n  /**\r\n   * Returns a singleton instance using a Symbol-backed global registry.\r\n   * This avoids duplicate instances across HMR, SSR, or multi-bundle scenarios.\r\n   */\r\n  static getInstance(): RateLimitQueueManager {\r\n    const GLOBAL_KEY = Symbol.for('@noeducation/key-rate-limiter:QueueManager');\r\n    const globalRegistry = globalThis as unknown as {\r\n      [key: symbol]: RateLimitQueueManager | undefined;\r\n    };\r\n    if (!globalRegistry[GLOBAL_KEY]) {\r\n      globalRegistry[GLOBAL_KEY] = new RateLimitQueueManager();\r\n    }\r\n    return globalRegistry[GLOBAL_KEY]!;\r\n  }\r\n\r\n  private getQueueKey(generation: 1 | 2, modelClassification: string): string {\r\n    return `${REDIS_PREFIX}:queue:gen${generation}:${modelClassification}`;\r\n  }\r\n\r\n  private getResponseKey(requestId: string): string {\r\n    return `${REDIS_PREFIX}:response:${requestId}`;\r\n  }\r\n\r\n  async enqueueRequest(request: RateLimitedRequest): Promise<void> {\r\n    const redis = await getRedisClient();\r\n    const queueKey = this.getQueueKey(\r\n      request.metadata.generation,\r\n      request.modelClassification,\r\n    );\r\n\r\n    await redis\r\n      .multi()\r\n      .lPush(queueKey, JSON.stringify(request))\r\n      .expire(queueKey, EXPIRATION_SECONDS)\r\n      .exec();\r\n  }\r\n\r\n  async dequeueRequests(\r\n    generation: 1 | 2,\r\n    modelClassification: string,\r\n    maxCount: number = 10,\r\n  ): Promise<RateLimitedRequest[]> {\r\n    const redis = await getRedisClient();\r\n    const queueKey = this.getQueueKey(generation, modelClassification);\r\n\r\n    const requests = await redis.lRange(queueKey, 0, maxCount - 1);\r\n    if (requests.length > 0) {\r\n      await redis.lTrim(queueKey, requests.length, -1);\r\n    }\r\n\r\n    return requests.map((req) => JSON.parse(req) as RateLimitedRequest);\r\n  }\r\n\r\n  async getQueueSize(\r\n    generation: 1 | 2,\r\n    modelClassification: string,\r\n  ): Promise<number> {\r\n    const redis = await getRedisClient();\r\n    const queueKey = this.getQueueKey(generation, modelClassification);\r\n    return await redis.lLen(queueKey);\r\n  }\r\n\r\n  async storeResponse(response: ProcessedResponse): Promise<void> {\r\n    const redis = await getRedisClient();\r\n    const responseKey = this.getResponseKey(response.id);\r\n\r\n    await redis\r\n      .multi()\r\n      .set(responseKey, JSON.stringify(response))\r\n      .expire(responseKey, EXPIRATION_SECONDS)\r\n      .exec();\r\n  }\r\n\r\n  async getResponse(requestId: string): Promise<ProcessedResponse | null> {\r\n    const redis = await getRedisClient();\r\n    const responseKey = this.getResponseKey(requestId);\r\n\r\n    const response = await redis.get(responseKey);\r\n    return response ? (JSON.parse(response) as ProcessedResponse) : null;\r\n  }\r\n\r\n  async removeResponse(requestId: string): Promise<void> {\r\n    const redis = await getRedisClient();\r\n    const responseKey = this.getResponseKey(requestId);\r\n    await redis.del(responseKey);\r\n  }\r\n\r\n  async checkIfRequestExists(requestId: string): Promise<boolean> {\r\n    const redis = await getRedisClient();\r\n    const responseKey = this.getResponseKey(requestId);\r\n\r\n    // Check both queue and response storage\r\n    const responseExists = await redis.exists(responseKey);\r\n    if (responseExists) {\r\n      return true;\r\n    }\r\n\r\n    // Check all queues for the request\r\n    const modelClassifications = ['hifi', 'lofi', 'completions', 'embedding'];\r\n    for (const classification of modelClassifications) {\r\n      for (const generation of [1, 2] as const) {\r\n        const queueKey = this.getQueueKey(generation, classification);\r\n        const requests = await redis.lRange(queueKey, 0, -1);\r\n        const requestExists = requests.some((req) => {\r\n          try {\r\n            const parsed = JSON.parse(req) as RateLimitedRequest;\r\n            return parsed.id === requestId;\r\n          } catch {\r\n            return false;\r\n          }\r\n        });\r\n        if (requestExists) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n\r\nexport const rateLimitQueueManager = RateLimitQueueManager.getInstance();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\key-rate-limiter\\rate-limit-handler.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":116,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getRetryErrorInfo } from '@/lib/ai/chat';\r\nimport { log } from '@/lib/logger';\r\nimport { temporarilyDisableModel } from '@/lib/ai/aiModelFactory';\r\nimport { rateLimitMetrics } from './metrics';\r\nimport type { ModelClassification, ModelFailoverConfig } from './types';\r\nimport {\r\n  enqueueRequestForRetry,\r\n  getAvailableModel,\r\n  CHAT_RETRY_DELAY_MS,\r\n} from './model-availability';\r\nimport { RateRetryError } from '@/lib/react-util/errors/rate-retry-error';\r\n\r\n/**\r\n * Disables a model based on rate limit headers.\r\n *\r\n * @param modelKey - The model key to disable\r\n * @param retryAfter - The retry after duration in seconds\r\n */\r\nexport function disableModelFromRateLimit(\r\n  modelKey: string,\r\n  retryAfter: number,\r\n): void {\r\n  const disableDurationMs = Math.max(retryAfter * 1000, 60000); // At least 1 minute\r\n  console.warn(\r\n    `Rate limit detected for ${modelKey}, disabling for ${disableDurationMs}ms`,\r\n  );\r\n  temporarilyDisableModel(modelKey, disableDurationMs);\r\n  rateLimitMetrics.recordError('rate_limit_disable', modelKey);\r\n}\r\n\r\n/**\r\n * Handles rate limit errors by disabling the current model, attempting fallback,\r\n * and enqueueing the request for retry if needed.\r\n *\r\n * @param error - The error that occurred\r\n * @param currentModelKey - The current model key that hit the rate limit\r\n * @param modelClassification - The model classification\r\n * @param failoverConfig - The failover configuration\r\n * @param params - The request parameters\r\n * @param errorContext - Additional context for error types ('generate', 'stream', 'stream_setup')\r\n * @returns The request ID if enqueued, otherwise rethrows the original error\r\n */\r\nexport async function handleRateLimitError(\r\n  error: unknown,\r\n  currentModelKey: string,\r\n  modelClassification: ModelClassification,\r\n  failoverConfig: ModelFailoverConfig | undefined,\r\n  params: Record<string, unknown>,\r\n  errorContext: 'generate' | 'stream' | 'stream_setup' = 'generate',\r\n): Promise<never> {\r\n  const rateLimitErrorInfo = getRetryErrorInfo(error);\r\n\r\n  if (rateLimitErrorInfo?.isRetry && rateLimitErrorInfo.retryAfter) {\r\n    log((l) =>\r\n      l.warn(`Rate limit detected: ${rateLimitErrorInfo.retryAfter}s`),\r\n    );\r\n\r\n    // Disable the current model\r\n    disableModelFromRateLimit(currentModelKey, rateLimitErrorInfo.retryAfter);\r\n\r\n    // Try fallback if available\r\n    if (failoverConfig) {\r\n      const fallbackModelKey = getAvailableModel(\r\n        failoverConfig.fallbackProvider,\r\n        modelClassification,\r\n      );\r\n      if (fallbackModelKey && fallbackModelKey !== currentModelKey) {\r\n        console.log(`Attempting fallback to: ${fallbackModelKey}`);\r\n        // Note: Would need to retry with fallback model here\r\n        // For now, enqueue for later processing\r\n      }\r\n    }\r\n\r\n    // Enqueue for retry processing\r\n    const errorType =\r\n      errorContext === 'generate'\r\n        ? 'rate_limit_enqueue'\r\n        : errorContext === 'stream'\r\n          ? 'stream_rate_limit'\r\n          : 'stream_rate_limit_enqueue';\r\n\r\n    const requestId = await enqueueRequestForRetry(\r\n      modelClassification,\r\n      {\r\n        ...params,\r\n        ...{\r\n          chatId: 'unassigned',\r\n          turnId: '1',\r\n          ...((params?.providerMetadata as Record<string, unknown>)\r\n            ?.backoffice ?? {}),\r\n        },\r\n      },\r\n      errorType,\r\n    );\r\n\r\n    // Create context-specific error message\r\n    throw new RateRetryError({\r\n      chatId: String(params.chatId ?? 'unassigned'),\r\n      turnId: String(params.turnId ?? '1'),\r\n      retryId: String(requestId),\r\n      retryAfter: new Date(Date.now() + CHAT_RETRY_DELAY_MS),\r\n    });\r\n  }\r\n\r\n  // Not a rate limit error, record as other error and rethrow\r\n  const errorType =\r\n    errorContext === 'generate'\r\n      ? 'other_error'\r\n      : errorContext === 'stream'\r\n        ? 'stream_rate_limit'\r\n        : 'stream_other_error';\r\n\r\n  rateLimitMetrics.recordError(errorType, modelClassification);\r\n  throw error;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\key-rate-limiter\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\memory-middleware.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":80,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'memoryClientFactory' is defined but never used.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":29,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type {\r\n  LanguageModelV2Middleware,\r\n  LanguageModelV2StreamPart,\r\n} from '@ai-sdk/provider';\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nimport { memoryClientFactory } from '../mem0';\r\nimport { log } from '@/lib/logger';\r\nimport { MiddlewareStateManager } from './state-management';\r\n\r\n/**\r\n * Memory Middleware (Original Implementation)\r\n *\r\n * This middleware adds memory-related system prompts to enhance AI responses\r\n * with context from previous interactions.\r\n */\r\nconst originalMemoryMiddleware: LanguageModelV2Middleware = {\r\n  wrapStream: async ({ doStream }) => {\r\n    const { stream, ...rest } = await doStream();\r\n    const transformStream = new TransformStream<\r\n      LanguageModelV2StreamPart,\r\n      LanguageModelV2StreamPart\r\n    >({\r\n      transform(chunk, controller) {\r\n        controller.enqueue(chunk);\r\n      },\r\n      flush() {\r\n        log((l) => l.verbose('Memory middleware stream flushed'));\r\n      },\r\n    });\r\n\r\n    return {\r\n      stream: stream.pipeThrough(transformStream),\r\n      ...rest,\r\n    };\r\n  },\r\n\r\n  transformParams: async ({ params }) => {\r\n    /*    \r\n    // Create a memory client instance with the necessary configuration\r\n    const memoryClient = await memoryClientFactory({\r\n      // TODO: infer userid and projectid from params\r\n    });\r\n    const memories = memoryClient.search(params.query, {\r\n      limit: 10,\r\n      enable_graph: true,\r\n    });\r\n    */\r\n    params.prompt = [\r\n      {\r\n        role: 'system',\r\n        content:\r\n          'You are a helpful assistant equipped with an advanced memory module that enables you to remember past interactions.' +\r\n          ' Your memory is designed to assist you in providing more relevant and personalized responses based on previous conversations.' +\r\n          ' Before generating a response, you will search your memory for relevant past interactions.' +\r\n          ' If you find relevant memories, you will incorporate them into your response.' +\r\n          ' If no relevant memories are found, you will respond based solely on the current prompt.' +\r\n          ' After generating a response, you will update your memory with the new interaction.',\r\n      },\r\n      ...(params.prompt || []),\r\n    ];\r\n\r\n    return params;\r\n  },\r\n};\r\n\r\n/**\r\n * Memory Middleware with State Management Support\r\n *\r\n * This middleware supports the state management protocol and can participate\r\n * in state collection and restoration operations.\r\n */\r\nexport const memoryMiddleware =\r\n  MiddlewareStateManager.Instance.basicMiddlewareWrapper({\r\n    middlewareId: 'memory-middleware',\r\n    middleware: originalMemoryMiddleware,\r\n  });\r\n\r\nexport default memoryMiddleware;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\set-normalized-defaults.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":239,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type {\r\n  JSONValue,\r\n  LanguageModelV2Middleware,\r\n  LanguageModelV2StreamPart,\r\n} from '@ai-sdk/provider';\r\nimport { MiddlewareStateManager } from './state-management';\r\n\r\n/**\r\n * Default telemetry configuration for normalized chat requests\r\n */\r\nconst DEFAULT_TELEMETRY = {\r\n  isEnabled: true,\r\n  functionId: 'generic-chat-request',\r\n  metadata: {},\r\n} as const;\r\n\r\nconst jsonExpression = () =>\r\n  /\\`\\`\\`json[\\s\\n\\r]*((?:\\[[\\s\\n\\r]*)?{[\\s\\S]*?}(?:[\\s\\n\\r]*\\])?)[\\s\\n\\r]*\\`\\`\\`/;\r\n\r\n/**\r\n * Checks if response text is wrapped in ```json blocks\r\n */\r\nfunction isJsonCodeBlock(text: string): boolean {\r\n  return jsonExpression().test(text);\r\n}\r\n\r\n/**\r\n * Checks if response text is valid JSON (starts with {, ends with }, and parses successfully)\r\n */\r\nfunction isValidJsonObject(text: string): boolean {\r\n  const trimmed = text.trim();\r\n  if (\r\n    (trimmed.startsWith('{') && trimmed.endsWith('}')) ||\r\n    (trimmed.startsWith('[') && trimmed.endsWith(']'))\r\n  ) {\r\n    try {\r\n      const parsed = JSON.parse(trimmed);\r\n      return parsed !== null && typeof parsed === 'object';\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Extracts JSON content from ```json code blocks\r\n */\r\nexport const extractJsonFromCodeBlock = (text: string): string => {\r\n  const match = jsonExpression().exec(text);\r\n  if (!match) {\r\n    throw new Error('No valid JSON code block found');\r\n  }\r\n  return match[1];\r\n};\r\n\r\n/**\r\n * Checks if structured output is empty or blank\r\n */\r\nfunction isStructuredOutputEmpty(result: Record<string, unknown>): boolean {\r\n  if (!result.providerMetadata) {\r\n    return true;\r\n  }\r\n\r\n  const metadata = result.providerMetadata as Record<string, unknown>;\r\n  const structured = metadata.structuredOutputs;\r\n\r\n  // Check if it's empty object, null, undefined, or empty string\r\n  if (\r\n    !structured ||\r\n    structured === null ||\r\n    structured === undefined ||\r\n    structured === '' ||\r\n    (typeof structured === 'object' && Object.keys(structured).length === 0)\r\n  ) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Safely parses JSON string, returns null if invalid\r\n */\r\nfunction safeJsonParse(jsonString: string): unknown {\r\n  try {\r\n    return JSON.parse(jsonString);\r\n  } catch {\r\n    return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * Set Normalized Defaults Middleware (Original Implementation)\r\n *\r\n * This middleware:\r\n * 1. On request: Sets default experimental_telemetry if not present\r\n * 2. On response: Detects JSON code blocks and valid JSON objects, converts to structured output if structured output is empty\r\n */\r\nexport const originalSetNormalizedDefaultsMiddleware: LanguageModelV2Middleware =\r\n  {\r\n    /**\r\n     * Transform parameters to add default telemetry if missing\r\n     */\r\n    transformParams: async ({ params }) => {\r\n      // Cast params to allow access to experimental properties\r\n      const modifiedParams = { ...params } as typeof params & {\r\n        experimental_telemetry?: typeof DEFAULT_TELEMETRY;\r\n      };\r\n\r\n      // Set default telemetry if not present\r\n      if (!modifiedParams.experimental_telemetry) {\r\n        modifiedParams.experimental_telemetry = DEFAULT_TELEMETRY;\r\n      }\r\n\r\n      return modifiedParams;\r\n    },\r\n\r\n    /**\r\n     * Wrap generate to post-process response for JSON code blocks and valid JSON objects\r\n     */\r\n    wrapGenerate: async ({ doGenerate }) => {\r\n      const result = await doGenerate();\r\n\r\n      if (typeof result.response?.body !== 'string') {\r\n        return result;\r\n      }\r\n      result.providerMetadata = result.providerMetadata || {};\r\n      if (isStructuredOutputEmpty(result)) {\r\n        let jsonContent: string | undefined = undefined;\r\n\r\n        // Check if response text is a JSON code block\r\n        if (isJsonCodeBlock(result.response.body)) {\r\n          jsonContent = extractJsonFromCodeBlock(result.response.body);\r\n        }\r\n        // Check if response text is valid JSON object\r\n        else if (isValidJsonObject(result.response.body)) {\r\n          jsonContent = result.response.body.trim();\r\n        }\r\n\r\n        if (jsonContent) {\r\n          const parsedJson = safeJsonParse(jsonContent);\r\n\r\n          if (parsedJson) {\r\n            // Create modified result with structured output\r\n            const modifiedResult = {\r\n              ...result,\r\n              providerMetadata: {\r\n                ...((result.providerMetadata as Record<string, unknown>) || {}),\r\n                structuredOutputs: parsedJson as Record<string, JSONValue>,\r\n              },\r\n            };\r\n\r\n            return modifiedResult;\r\n          }\r\n        }\r\n      }\r\n\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * Wrap stream to post-process response for JSON code blocks and valid JSON objects\r\n     */\r\n    wrapStream: async ({ doStream }) => {\r\n      const { stream, ...rest } = await doStream();\r\n\r\n      let accumulatedText = '';\r\n\r\n      const transformStream = new TransformStream<\r\n        LanguageModelV2StreamPart,\r\n        LanguageModelV2StreamPart\r\n      >({\r\n        transform(chunk, controller) {\r\n          // Accumulate text deltas\r\n          if (chunk.type === 'text-delta') {\r\n            accumulatedText += chunk.delta;\r\n          }\r\n\r\n          // If this is a finish chunk and we have accumulated text that could be JSON\r\n          if (chunk.type === 'finish' && accumulatedText) {\r\n            let jsonContent: string | null = null;\r\n\r\n            // Check if accumulated text is a JSON code block\r\n            if (isJsonCodeBlock(accumulatedText)) {\r\n              jsonContent = extractJsonFromCodeBlock(accumulatedText);\r\n            }\r\n            // Check if accumulated text is valid JSON object\r\n            else if (isValidJsonObject(accumulatedText)) {\r\n              jsonContent = accumulatedText.trim();\r\n            }\r\n\r\n            if (jsonContent) {\r\n              const parsedJson = safeJsonParse(jsonContent);\r\n\r\n              if (parsedJson !== null) {\r\n                // Modify the finish chunk to include structured output\r\n                const chunkWithMeta = chunk as Record<string, unknown>;\r\n                const modifiedChunk = {\r\n                  ...chunk,\r\n                  providerMetadata: {\r\n                    ...((chunkWithMeta.providerMetadata as Record<\r\n                      string,\r\n                      unknown\r\n                    >) || {}),\r\n                    structuredOutputs: parsedJson as Record<string, JSONValue>,\r\n                  },\r\n                };\r\n                controller.enqueue(modifiedChunk);\r\n                return;\r\n              }\r\n            }\r\n          }\r\n\r\n          controller.enqueue(chunk);\r\n        },\r\n      });\r\n\r\n      return {\r\n        stream: stream.pipeThrough(transformStream),\r\n        ...rest,\r\n      };\r\n    },\r\n  };\r\n\r\n/**\r\n * Set Normalized Defaults Middleware with State Management Support\r\n *\r\n * This middleware supports the state management protocol and can participate\r\n * in state collection and restoration operations.\r\n */\r\nexport const setNormalizedDefaultsMiddleware =\r\n  MiddlewareStateManager.Instance.basicMiddlewareWrapper({\r\n    middlewareId: 'set-normalized-defaults',\r\n    middleware: originalSetNormalizedDefaultsMiddleware,\r\n  });\r\n\r\nexport default setNormalizedDefaultsMiddleware;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\state-management\\create-stateful-middleware.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":25,"column":1,"nodeType":"Program","endLine":420,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Stateful Middleware Wrapper\r\n *\r\n * This module exports helpers to adapt arbitrary language-model middleware so it can\r\n * participate in the repository's state management protocol. The wrapper exposes\r\n * two public factory functions:\r\n *\r\n * - `createStatefulMiddleware(config)` – wraps an existing middleware and enables\r\n *   state collection/restoration hooks (serialize/deserialize) to be invoked when\r\n *   special provider options indicating `collect` or `restore` are present.\r\n *\r\n * The implementation is intentionally lightweight: it inspects the wrapped middleware\r\n * for `serializeState`, `deserializeState`, and `getMiddlewareId`. If absent, a\r\n * no-op serializer/deserializer is provided. During state-collection requests the\r\n * wrapper will call the middleware serializer and append the serialized state into\r\n * the shared `providerOptions[STATE_PROTOCOL.OPTIONS_ROOT].results` array. During\r\n * state-restoration requests the wrapper will pop a state entry from that array and\r\n * pass it to the middleware's `deserializeState`.\r\n *\r\n * This file focuses on documentation and a clear, typed contract for middleware\r\n * authors to implement serializable state handlers. It does not change runtime\r\n * semantics of wrapped middleware.\r\n */\r\n\r\nimport type { LanguageModelV2Middleware } from '@ai-sdk/provider';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { log } from '@/lib/logger';\r\nimport {\r\n  STATE_PROTOCOL,\r\n  type StatefulMiddlewareConfig,\r\n  type StateManagementParams,\r\n  type SerializableState,\r\n  type StateManagementProviderOptions,\r\n  type SerializableLanguageModelMiddleware,\r\n  SerializableMiddleware,\r\n} from './types';\r\n\r\n/**\r\n * Key names for the state management provider options.\r\n */\r\ntype StateManagementProviderOptionsKey = keyof StateManagementProviderOptions;\r\n\r\n/**\r\n * Options used to construct a stateful middleware wrapper.\r\n *\r\n * @template T - The serializable state shape produced/consumed by the wrapped middleware.\r\n * @template TMiddlewareId - A string literal type that uniquely identifies the middleware.  Defaults to `string`.\r\n *\r\n * @property {StatefulMiddlewareConfig<TMiddlewareId>} StatefulMiddlewareConfig -\r\n *   Inherits the stateful wrapper configuration (priority, etc.).\r\n * @property {SerializableLanguageModelMiddleware<TMiddlewareId, T> | LanguageModelV2Middleware} originalMiddleware\r\n *   The middleware instance being wrapped. If the provided middleware implements\r\n *   `serializeState`, `deserializeState`, and `getMiddlewareId`, those implementations\r\n *   will be used; otherwise the wrapper provides no-op defaults.\r\n */\r\ntype CreateMiddlewareOptions<\r\n  T extends SerializableState = SerializableState,\r\n  TMiddlewareId extends string = string,\r\n> = StatefulMiddlewareConfig<TMiddlewareId> & {\r\n  /** The original middleware to wrap. */\r\n  originalMiddleware:\r\n    | SerializableLanguageModelMiddleware<TMiddlewareId, T>\r\n    | LanguageModelV2Middleware;\r\n};\r\n\r\n/**\r\n * Retrieve (or optionally create) the middleware state bag inside the\r\n * `providerOptions` object.\r\n *\r\n * The state management protocol keeps state in a namespaced property on\r\n * `params.providerOptions` identified by `STATE_PROTOCOL.OPTIONS_ROOT`.\r\n * This helper safely reads that object and will create it when `options.create`\r\n * is true.\r\n *\r\n * @param {Pick<StateManagementParams, 'providerOptions'>} params - The generate params\r\n *   object provided to middleware. May contain `providerOptions` which stores protocol\r\n *   baggage.\r\n * @param {{create?: boolean}} [options] - If `{create: true}` and the state bag is\r\n *   missing, a new object will be created and attached to `params.providerOptions`.\r\n * @returns {StateManagementProviderOptions | undefined} The internal state bag or\r\n *   `undefined` when it's absent and `create` is not requested.\r\n */\r\nconst middlewareStateFromOptions = (\r\n  params: Pick<StateManagementParams, 'providerOptions'>,\r\n  options?: { create?: boolean },\r\n) => {\r\n  let providerOptions = params?.providerOptions;\r\n  if (!providerOptions) {\r\n    providerOptions = {};\r\n    params.providerOptions = providerOptions;\r\n  }\r\n  const create =\r\n    typeof options === 'object' && options ? options.create === true : false;\r\n  let ret = providerOptions[STATE_PROTOCOL.OPTIONS_ROOT];\r\n  if (!ret && create) {\r\n    ret = {};\r\n    providerOptions[STATE_PROTOCOL.OPTIONS_ROOT] = ret;\r\n  }\r\n  return ret;\r\n};\r\n\r\n/**\r\n * Read a single property from the middleware state bag.\r\n *\r\n * This convenience wraps `middlewareStateFromOptions` and provides typed access\r\n * to named fields on the protocol bag. If the bag does not exist and `create` is\r\n * not set, `undefined` is returned.\r\n *\r\n * @param {Pick<StateManagementParams, 'providerOptions'>} source - The params\r\n *   container potentially containing `providerOptions`.\r\n * @param {{create?: boolean; field: StateManagementProviderOptionsKey} | StateManagementProviderOptionsKey} options\r\n *   Either the literal key to read (e.g. `STATE_PROTOCOL.COLLECT`) or an object\r\n *   describing the field and whether to create the bag if missing.\r\n * @returns {any} The stored value for the requested field, or `undefined`.\r\n */\r\nconst middlewarePropFromOptions = (\r\n  source: Pick<StateManagementParams, 'providerOptions'>,\r\n  options:\r\n    | { create?: boolean; field: StateManagementProviderOptionsKey }\r\n    | StateManagementProviderOptionsKey,\r\n) => {\r\n  const create =\r\n    typeof options === 'object' && options ? options.create === true : false;\r\n  const props = middlewareStateFromOptions(source, { create });\r\n  if (!props) {\r\n    return undefined;\r\n  }\r\n  if (typeof options === 'object') {\r\n    const field = options.field;\r\n    if (field) {\r\n      return props[field];\r\n    }\r\n    throw new TypeError('field is required');\r\n  }\r\n  return props[options];\r\n};\r\n\r\n/**\r\n * Return `true` when the current generate invocation is intended to collect\r\n * state from middleware in the chain.\r\n *\r\n * If `true`, middleware should attempt to consume an entry from the shared\r\n * state bag and apply it via their `deserializeState` implementation.\r\n *\r\n * Middleware authors should use this helper to detect collection phases and\r\n * avoid performing normal generation work when the caller is requesting only\r\n * serialized state.\r\n *\r\n * @param {StateManagementParams} options - The middleware invocation params.\r\n * @returns {boolean} `true` when a state-collection request is in progress.\r\n */\r\nexport const isStateCollectionRequest = (\r\n  options: StateManagementParams,\r\n): boolean =>\r\n  middlewarePropFromOptions(options, STATE_PROTOCOL.COLLECT) === true;\r\n\r\n/**\r\n * Return `true` when the current generate invocation is intended to restore\r\n * previously collected middleware state.\r\n *\r\n * If `true`, middleware should attempt to consume an entry from the shared\r\n * state bag and apply it via their `deserializeState` implementation.\r\n *\r\n * @param {StateManagementParams} options - The middleware invocation params.\r\n * @returns {boolean} `true` when a state-restoration request is in progress.\r\n */\r\nexport const isStateRestorationRequest = (\r\n  options: StateManagementParams,\r\n): boolean =>\r\n  middlewarePropFromOptions(options, STATE_PROTOCOL.RESTORE) === true;\r\n\r\n/**\r\n * Run the middleware's `serializeState` hook and append the resulting state to\r\n * the protocol state bag.\r\n *\r\n * Contract & behavior:\r\n * - Calls the provided `serialize` function with `{ config, params }` and\r\n *   expects a serializable object in return.\r\n * - Ensures the protocol bag and `results` array exist (creates them when\r\n *   necessary).\r\n * - Avoids duplicating identical states in the `results` array: if the last\r\n *   recorded entry for this middleware already matches the newly serialized\r\n *   value (using `Object.is` on the state object), the value will not be\r\n *   pushed again.\r\n * - Exceptions thrown by `serialize` are captured and sent to `LoggedError`\r\n *   for diagnostic logging but will not crash the entire collection process.\r\n *\r\n * @template T - The serializable state type produced by the middleware.\r\n * @param {Object} args\r\n * @param {StatefulMiddlewareConfig} args.config - The wrapper configuration.\r\n * @param {string} args.middlewareId - The unique middleware identifier.\r\n * @param {SerializableMiddleware<T>['serializeState']} args.serialize - The\r\n *   middleware's serialize handler.\r\n * @param {StateManagementParams} args.params - The current middleware params.\r\n * @returns {Promise<T>} The serialized state that was recorded (or an empty\r\n *   object if serialization failed).\r\n */\r\nconst handleStateCollection = async <T extends SerializableState>({\r\n  middlewareId,\r\n  serialize,\r\n  params,\r\n  config,\r\n}: {\r\n  config: StatefulMiddlewareConfig;\r\n  middlewareId: string;\r\n  serialize: SerializableMiddleware<T>['serializeState'];\r\n  params: StateManagementParams;\r\n}): Promise<T> => {\r\n  let state: T = {} as T;\r\n  let ops: StateManagementProviderOptions = {};\r\n  try {\r\n    // Retrieve state from serializer\r\n    state = await serialize({ config, params });\r\n    // Append to\r\n    const check = middlewareStateFromOptions(params, { create: true });\r\n    if (!check) {\r\n      throw new SyntaxError('Failed to create middleware statebag');\r\n    }\r\n    ops = check;\r\n  } catch (error) {\r\n    LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: 'StatefuleMiddleware::handleStateCollection',\r\n      data: {\r\n        state: state,\r\n        middlewareId,\r\n        params,\r\n      },\r\n    });\r\n  }\r\n  const target = ops[STATE_PROTOCOL.RESULTS];\r\n  if (!target || !Array.isArray(target)) {\r\n    throw new TypeError('Failed to retrieve middleware state');\r\n  }\r\n  // Check to see if we have already been added to the statebag\r\n  let addToBag;\r\n  if (target.length === 0) {\r\n    addToBag = true;\r\n  } else {\r\n    const lastItem = target[target.length - 1];\r\n    if (lastItem[0] === middlewareId && Object.is(lastItem[1], state)) {\r\n      addToBag = false;\r\n    } else {\r\n      addToBag = true;\r\n    }\r\n  }\r\n  // Add if necessary\r\n  if (addToBag) {\r\n    target.push([middlewareId, state]);\r\n  }\r\n  // And return\r\n  return state;\r\n};\r\n\r\n/**\r\n * Restore a middleware's state by popping the next available state entry off\r\n * the shared protocol results array and calling the middleware's\r\n * `deserializeState` handler.\r\n *\r\n * Contract & behavior:\r\n * - If no state bag or results array exists the function logs a warning and\r\n *   returns early (no-op).\r\n * - If the popped entry's middleware id does not match `middlewareId`, a\r\n *   warning is logged and restoration is skipped (this guards against\r\n *   accidental mismatch ordering).\r\n * - Any errors thrown by `deserialize` are captured and reported via\r\n *   `LoggedError` but are not re-thrown.\r\n *\r\n * @template T - The serializable state type expected by the middleware.\r\n * @param {Object} args\r\n * @param {StatefulMiddlewareConfig} args.config - The wrapper configuration.\r\n * @param {string} args.middlewareId - The unique middleware identifier.\r\n * @param {SerializableMiddleware<T>['deserializeState']} args.deserialize - The\r\n *   middleware's deserialize handler.\r\n * @param {StateManagementParams} args.params - The current middleware params.\r\n * @returns {Promise<void>} Resolves when restoration completes or is skipped.\r\n */\r\nconst handleStateRestoration = async <T extends SerializableState>({\r\n  config,\r\n  middlewareId,\r\n  deserialize,\r\n  params,\r\n}: {\r\n  config: StatefulMiddlewareConfig;\r\n  middlewareId: string;\r\n  deserialize: SerializableMiddleware<T>['deserializeState'];\r\n  params: StateManagementParams;\r\n}): Promise<void> => {\r\n  // Pop the first block off the array\r\n  const ops = middlewareStateFromOptions(params, { create: true });\r\n  if (!ops) {\r\n    throw new SyntaxError('Failed to create middleware statebag');\r\n  }\r\n  const target = ops[STATE_PROTOCOL.RESULTS];\r\n  if (!target) {\r\n    log((l) =>\r\n      l.warn('No statebag found during state restoration', { middlewareId }),\r\n    );\r\n    return;\r\n  }\r\n  const source = target.shift();\r\n  if (!source) {\r\n    log((l) =>\r\n      l.warn('No state found during state restoration', { middlewareId }),\r\n    );\r\n    return;\r\n  }\r\n  if (source[0] !== middlewareId) {\r\n    log((l) =>\r\n      l.warn('Middleware ID mismatch during state restoration', {\r\n        middlewareId,\r\n      }),\r\n    );\r\n    return;\r\n  }\r\n  // Pass state to deserializer for processing\r\n  try {\r\n    await deserialize({ config, params, state: source[1] as T });\r\n  } catch (error) {\r\n    LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: 'StatefuleMiddleware::handleStateRestoration',\r\n      data: {\r\n        state: source[1] as T,\r\n        middlewareId,\r\n        params,\r\n      },\r\n    });\r\n  }\r\n  // And that's all she wrote - return to caller\r\n};\r\n/**\r\n * Create a middleware wrapper that enables participation in the state\r\n * management protocol.\r\n *\r\n * The returned middleware implements the `LanguageModelV2Middleware` shape and\r\n * will intercept the `wrapGenerate` call to perform either state collection or\r\n * state restoration when `params.providerOptions` contains the specialized\r\n * protocol keys (see `STATE_PROTOCOL`). For regular generate calls the wrapper\r\n * delegates to the underlying middleware (or the provided `doGenerate` when\r\n * there is no wrapped middleware).\r\n *\r\n * Important notes for implementers:\r\n * - The wrapper will call `serializeState` during collection requests and\r\n *   append the result into the shared `results` array. The serializer is\r\n *   expected to return a serializable plain object (or a Promise resolving to\r\n *   one).\r\n * - During restoration requests the wrapper will pop the first entry off the\r\n *   `results` array and forward it to `deserializeState` for rehydration.\r\n * - The wrapper is defensive: serialization/deserialization exceptions are\r\n *   captured and logged but do not abort the overall operation.\r\n *\r\n * @template T - The middleware's serializable state type.\r\n * @template TMiddlewareId - The middleware id literal type.\r\n * @param {CreateMiddlewareOptions<T, TMiddlewareId>} config - Wrapper options\r\n *   containing `middlewareId`, `originalMiddleware`, and optional state handlers.\r\n * @returns {LanguageModelV2Middleware} A middleware ready to be composed into\r\n *   a language model middleware chain.\r\n */\r\nexport const createStatefulMiddleware = <\r\n  T extends SerializableState = SerializableState,\r\n  TMiddlewareId extends string = string,\r\n>(\r\n  config: CreateMiddlewareOptions<T, TMiddlewareId>,\r\n): LanguageModelV2Middleware => {\r\n  const { middlewareId, originalMiddleware } = config;\r\n  const serializer: SerializableLanguageModelMiddleware<TMiddlewareId, T> = {\r\n    getMiddlewareId:\r\n      'getMiddlewareId' in originalMiddleware &&\r\n      typeof originalMiddleware.getMiddlewareId === 'function'\r\n        ? originalMiddleware.getMiddlewareId\r\n        : () => middlewareId,\r\n    serializeState:\r\n      'serializeState' in originalMiddleware &&\r\n      typeof originalMiddleware.serializeState === 'function'\r\n        ? originalMiddleware.serializeState\r\n        : () => Promise.resolve({} as T),\r\n    deserializeState:\r\n      'deserializeState' in originalMiddleware &&\r\n      typeof originalMiddleware.deserializeState === 'function'\r\n        ? originalMiddleware.deserializeState\r\n        : () => Promise.resolve(),\r\n  };\r\n\r\n  return {\r\n    ...originalMiddleware,\r\n    wrapGenerate: async (options) => {\r\n      const { params } = options;\r\n      let callInnerMiddleware = true;\r\n      // Handle state collection\r\n      if (isStateCollectionRequest(params)) {\r\n        await handleStateCollection({\r\n          middlewareId,\r\n          serialize: serializer.serializeState,\r\n          params,\r\n          config,\r\n        });\r\n        callInnerMiddleware = false;\r\n      }\r\n\r\n      // Handle state restoration\r\n      if (isStateRestorationRequest(params)) {\r\n        await handleStateRestoration({\r\n          middlewareId,\r\n          deserialize: serializer.deserializeState,\r\n          params,\r\n          config,\r\n        });\r\n        callInnerMiddleware = false;\r\n      }\r\n      // Pass the call on down the chain...usually to our wrapped middleware,\r\n      // unless this was a state management request in which case route it to\r\n      // the next link in the chain.\r\n      return callInnerMiddleware && originalMiddleware.wrapGenerate\r\n        ? await originalMiddleware.wrapGenerate(options)\r\n        : options.doGenerate();\r\n    },\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\state-management\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":9,"column":1,"nodeType":"Program","endLine":21,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview State Management Module Exports\r\n *\r\n * This module provides middleware state management capabilities including\r\n * state collection, restoration, and persistence protocol support.\r\n */\r\n\r\n// Core types and interfaces\r\nexport {\r\n  STATE_PROTOCOL,\r\n  type SerializableState,\r\n  type StatefulMiddlewareConfig,\r\n  type StateManagementParams,\r\n  type SerializableMiddleware,\r\n  type SerializableLanguageModelMiddleware,\r\n  type MiddlewareMetadata,\r\n} from './types';\r\n\r\n// State management middleware\r\nexport { MiddlewareStateManager } from './middleware-state-manager';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\state-management\\middleware-state-manager.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":8,"column":1,"nodeType":"Program","endLine":317,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview State Management Middleware Implementation\r\n *\r\n * This middleware intercepts special protocol prompts for state collection and restoration.\r\n * It must be placed first in the middleware chain to capture all middleware states.\r\n */\r\n\r\nimport type {\r\n  LanguageModelV2Middleware,\r\n  LanguageModelV2,\r\n  LanguageModelV2TextPart,\r\n} from '@ai-sdk/provider';\r\nimport { log } from '@/lib/logger';\r\nimport {\r\n  SerializableLanguageModelMiddleware,\r\n  SerializableMiddleware,\r\n  SerializableState,\r\n  STATE_PROTOCOL,\r\n} from './types';\r\nimport {\r\n  createStatefulMiddleware,\r\n  isStateCollectionRequest,\r\n  isStateRestorationRequest,\r\n} from './create-stateful-middleware';\r\nimport { generateText, wrapLanguageModel } from 'ai';\r\n\r\n/**\r\n * State Management Middleware that handles protocol prompts for state collection and restoration\r\n *\r\n * This middleware:\r\n * - Intercepts STATE_PROTOCOL.COLLECT prompts to collect middleware states\r\n * - Intercepts STATE_PROTOCOL.RESTORE prompts to restore middleware states\r\n * - Must be the first middleware in the chain to capture all downstream states\r\n */\r\nexport class MiddlewareStateManager {\r\n  /** Symbol-based global registry key for MiddlewareStateManager singleton. */\r\n  static readonly #REGISTRY_KEY = Symbol.for(\r\n    '@noeducation/middleware:MiddlewareStateManager',\r\n  );\r\n\r\n  /**\r\n   * Global singleton instance via symbol registry.\r\n   * Use `MiddlewareStateManager.Instance` or the factory `createStateManagementMiddleware`\r\n   * to obtain a reference.\r\n   * @private\r\n   * @type {MiddlewareStateManager | undefined}\r\n   */\r\n  // implements\r\n  //  SerializableMiddleware<BasicMiddlewareState>\r\n  static get #globalInstance(): MiddlewareStateManager | undefined {\r\n    type GlobalReg = { [k: symbol]: MiddlewareStateManager | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    return g[this.#REGISTRY_KEY];\r\n  }\r\n  static set #globalInstance(value: MiddlewareStateManager | undefined) {\r\n    type GlobalReg = { [k: symbol]: MiddlewareStateManager | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    g[this.#REGISTRY_KEY] = value;\r\n  }\r\n  /**\r\n   * Reset the global singleton instance. Intended for tests and reinitialization.\r\n   * Calling this will drop the existing global instance and allow a new one to be created.\r\n   * @returns {void}\r\n   */\r\n  static reset(): void {\r\n    const instance = this.#globalInstance;\r\n    if (instance) {\r\n      this.#globalInstance = undefined;\r\n    }\r\n  }\r\n  /**\r\n   * Accessor for the global MiddlewareStateManager singleton.\r\n   * Creates the instance lazily on first access.\r\n   * @returns {MiddlewareStateManager}\r\n   */\r\n  static get Instance() {\r\n    if (!this.#globalInstance) {\r\n      this.#globalInstance = new MiddlewareStateManager();\r\n    }\r\n    return this.#globalInstance;\r\n  }\r\n  /**\r\n   * Return a stable identifier for this middleware instance.\r\n   * This id is used by the state protocol to reference the middleware's saved state.\r\n   * @returns {'state-manager'} Middleware id literal\r\n   */\r\n  getMiddlewareId(): 'state-manager' {\r\n    return 'state-manager';\r\n  }\r\n  /**\r\n   * Return the underlying middleware implementation used by the wrapper helpers.\r\n   * Consumers may use this to examine or re-wrap the middleware.\r\n   * @returns {LanguageModelV2Middleware} Middleware implementation\r\n   */\r\n  getMiddlewareInstance() {\r\n    return this.#middleware;\r\n  }\r\n  /**\r\n   * Serialize the current state of middleware in the pipeline.\r\n   * This function asks downstream middleware to write their serializable state into\r\n   * the `STATE_PROTOCOL.RESULTS` provider options and returns the collected snapshot.\r\n   *\r\n   * Note: the implementation uses `generateText` with protocol providerOptions to\r\n   * trigger state collection. The returned state is a list of [middlewareId, state]\r\n   * tuples together with a timestamp.\r\n   *\r\n   * @param {{ model: LanguageModelV2 }} params - The language model used to perform the protocol call.\r\n   * @returns {Promise<{ timestamp: number; state: Array<[string, SerializableState]> }>} Collected state snapshot and timestamp\r\n   */\r\n  async serializeState({ model }: { model: LanguageModelV2 }): Promise<{\r\n    timestamp: number;\r\n    state: Array<[string, SerializableState]>;\r\n  }> {\r\n    const stateItems: Array<[string, SerializableState]> = [];\r\n    log((l) => l.verbose(`Taking snapshot of workflow state.`));\r\n    const providerOptions = {\r\n      [STATE_PROTOCOL.OPTIONS_ROOT]: {\r\n        [STATE_PROTOCOL.RESULTS]: stateItems,\r\n        [STATE_PROTOCOL.COLLECT]: true,\r\n      },\r\n    };\r\n    const result = await generateText({\r\n      model,\r\n      providerOptions,\r\n      prompt: [\r\n        {\r\n          role: 'user',\r\n          content: [{ type: 'text', text: 'Serializing pipeline state' }],\r\n          providerOptions,\r\n        },\r\n      ],\r\n    });\r\n    log((l) => l.verbose(`Generated text for state serialization:`, result));\r\n    // Serialize the state of all middleware\r\n    return Promise.resolve({ state: stateItems, timestamp: Date.now() });\r\n  }\r\n  /**\r\n   * Restore previously serialized middleware state.\r\n   *\r\n   * The `state` parameter accepts either the raw array of tuples or the wrapper\r\n   * object produced by `serializeState` ({ timestamp, state }). The method triggers\r\n   * downstream middleware by executing `generateText` with providerOptions instructing\r\n   * each middleware to restore from the provided `STATE_PROTOCOL.RESULTS` payload.\r\n   *\r\n   * @param {{ state: Array<[string, SerializableState]> | { timestamp: number; state: Array<[string, SerializableState]> }, model: LanguageModelV2 }} params\r\n   * @returns {Promise<void>}\r\n   */\r\n  async deserializeState({\r\n    state,\r\n    model,\r\n  }: {\r\n    model: LanguageModelV2;\r\n    state:\r\n      | Array<[string, SerializableState]>\r\n      | { timestamp: number; state: Array<[string, SerializableState]> };\r\n  }): Promise<void> {\r\n    const timestamp = 'timestamp' in state ? state.timestamp : Date.now();\r\n    const stateItems = Array.isArray(state) ? state : state.state;\r\n    log((l) => l.verbose(`Restoring state from ${new Date(timestamp)}.`));\r\n    const providerOptions = {\r\n      [STATE_PROTOCOL.OPTIONS_ROOT]: {\r\n        [STATE_PROTOCOL.RESULTS]: stateItems,\r\n        [STATE_PROTOCOL.RESTORE]: true,\r\n      },\r\n    };\r\n    const result = await generateText({\r\n      model,\r\n      providerOptions,\r\n      prompt: [\r\n        {\r\n          role: 'user',\r\n          content: [{ type: 'text', text: 'Restoring pipeline state' }],\r\n          providerOptions,\r\n        },\r\n      ],\r\n    });\r\n    log((l) => l.verbose(`Generated text for state restoration:`, result));\r\n  }\r\n  /**\r\n   * Wrap a plain (non-serializable) middleware with stateful behaviour.\r\n   * This helper returns a middleware that speaks the state protocol but delegates\r\n   * to the provided `middleware` for actual behavior.\r\n   *\r\n   * @param {{ middlewareId: string; middleware: LanguageModelV2Middleware }} args\r\n   * @returns {LanguageModelV2Middleware} Wrapped middleware\r\n   */\r\n  basicMiddlewareWrapper({\r\n    middlewareId,\r\n    middleware,\r\n  }: {\r\n    middlewareId: string;\r\n    middleware: LanguageModelV2Middleware;\r\n  }): LanguageModelV2Middleware {\r\n    return createStatefulMiddleware({\r\n      middlewareId,\r\n      originalMiddleware: middleware,\r\n    });\r\n  }\r\n  /**\r\n   * Wrap a middleware that already supports serialization (or provide custom\r\n   * serialize/deserialize handlers) and produce a stateful middleware compatible\r\n   * with the pipeline state protocol.\r\n   *\r\n   * The generic `TState` should match the serializable state shape produced by the\r\n   * middleware being wrapped.\r\n   *\r\n   * @template TState\r\n   * @param {{ middlewareId: string; middleware: LanguageModelV2Middleware | SerializableLanguageModelMiddleware<string, TState>; serialize?: SerializableMiddleware<TState>['serializeState']; deserialize?: SerializableMiddleware<TState>['deserializeState'] }} args\r\n   * @returns {LanguageModelV2Middleware} Wrapped stateful middleware\r\n   */\r\n  statefulMiddlewareWrapper<\r\n    TState extends SerializableState = SerializableState,\r\n  >({\r\n    middlewareId,\r\n    middleware,\r\n    serialize,\r\n    deserialize,\r\n  }: {\r\n    middlewareId: string;\r\n    middleware:\r\n      | LanguageModelV2Middleware\r\n      | SerializableLanguageModelMiddleware<string, TState>;\r\n    serialize?: SerializableMiddleware<TState>['serializeState'];\r\n    deserialize?: SerializableMiddleware<TState>['deserializeState'];\r\n  }): LanguageModelV2Middleware {\r\n    const serializeState =\r\n      ('serializeState' in middleware\r\n        ? middleware.serializeState\r\n        : serialize) ?? serialize;\r\n    const deserializeState =\r\n      ('deserializeState' in middleware\r\n        ? middleware.deserializeState\r\n        : deserialize) ?? deserialize;\r\n    const getMiddlewareId =\r\n      'getMiddlewareId' in middleware\r\n        ? middleware.getMiddlewareId\r\n        : () => middlewareId;\r\n    return createStatefulMiddleware({\r\n      middlewareId,\r\n      originalMiddleware: {\r\n        ...middleware,\r\n        serializeState,\r\n        deserializeState,\r\n        getMiddlewareId,\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Initialize a LanguageModelV2 instance with the state-management middleware wired in.\r\n   * This helper wraps the provided model and installs the middleware so that calls to the\r\n   * model will be intercepted for state collection/restoration protocol messages.\r\n   *\r\n   * @param {{ model: LanguageModelV2 } | LanguageModelV2} props - The language model to wrap.\r\n   *    It can be wrapped in a property object or passed in as the first argument.\r\n   * @returns {LanguageModelV2} Wrapped language model\r\n   */\r\n  initializeModel(\r\n    props: LanguageModelV2 | { model: LanguageModelV2 },\r\n  ): LanguageModelV2 {\r\n    const model = 'model' in props ? props.model : props;\r\n    const ret = wrapLanguageModel({\r\n      model,\r\n      middleware: this.#middleware,\r\n    });\r\n    return ret;\r\n  }\r\n  /**\r\n   * Core middleware implementation that intercepts generate calls.\r\n   * It recognizes state-collection and state-restoration requests via the\r\n   * `isStateCollectionRequest` / `isStateRestorationRequest` helpers and returns\r\n   * a deterministic, serializable response used by the protocol.\r\n   *\r\n   * @private\r\n   * @returns {LanguageModelV2Middleware} Middleware object exposing `wrapGenerate`\r\n   */\r\n  get #middleware(): LanguageModelV2Middleware {\r\n    return {\r\n      wrapGenerate: async ({ model, params, doGenerate }) => {\r\n        if (\r\n          isStateRestorationRequest(params) ||\r\n          isStateCollectionRequest(params)\r\n        ) {\r\n          const { prompt } = params;\r\n\r\n          const text = (\r\n            prompt\r\n              .flatMap((msg) => (Array.isArray(msg.content) ? msg.content : []))\r\n              .filter(\r\n                (p) => p.type === 'text' && p.text?.length,\r\n              ) as LanguageModelV2TextPart[]\r\n          )\r\n            .map((p) => p.text)\r\n            .join('\\n');\r\n          return {\r\n            finishReason: 'stop',\r\n            usage: { inputTokens: 0, outputTokens: 0, totalTokens: 0 },\r\n            content: [\r\n              {\r\n                type: 'text',\r\n                text: `Response to: ${text}`,\r\n              },\r\n            ],\r\n            warnings: [],\r\n            response: {\r\n              id: 'state-operation-result',\r\n              timestamp: new Date(),\r\n              modelId: model.modelId,\r\n            },\r\n          };\r\n        }\r\n        return doGenerate();\r\n      },\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\state-management\\state-management-middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\state-management\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":21,"column":1,"nodeType":"Program","endLine":253,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview State Management Protocol Types and Interfaces\r\n *\r\n * @module lib/ai/middleware/state-management/types\r\n *\r\n * This module declares the TypeScript types and runtime constants that define\r\n * the state-management protocol used by language-model middleware in this\r\n * repository. The protocol enables middleware to participate in two special\r\n * request modes:\r\n *\r\n * - State collection: middleware are asked to serialize their internal state so\r\n *   that it can be transported and later restored.\r\n * - State restoration: previously serialized states are supplied back to the\r\n *   middleware so they can re-hydrate their internal runtime state.\r\n *\r\n * Protocol data is passed via a namespaced property on `params.providerOptions`.\r\n * Middleware authors should implement the `SerializableMiddleware` interface to\r\n * opt-in to serialization and restoration.\r\n */\r\n\r\nimport type {\r\n  LanguageModelV2Middleware,\r\n  LanguageModelV2CallOptions,\r\n  SharedV2ProviderOptions,\r\n} from '@ai-sdk/provider';\r\nimport { JSONValue } from 'ai';\r\n\r\n/**\r\n * STATE_PROTOCOL constants\r\n *\r\n * These keys are the canonical property names used to signal state-collection\r\n * or restoration requests and to hold the serialized results. The\r\n * `OPTIONS_ROOT` value is a GUID-like key used to avoid clobbering regular\r\n * provider options.\r\n *\r\n * Example usage:\r\n * ```ts\r\n * params.providerOptions = params.providerOptions || {};\r\n * params.providerOptions[STATE_PROTOCOL.OPTIONS_ROOT] = {\r\n *   [STATE_PROTOCOL.COLLECT]: true,\r\n * };\r\n * ```\r\n */\r\nexport const STATE_PROTOCOL = {\r\n  /** When present and truthy, participating middleware should serialize state. */\r\n  COLLECT: '__COLLECT_MIDDLEWARE_STATE__',\r\n  /** When present and truthy, participating middleware should consume restored state. */\r\n  RESTORE: '__RESTORE_MIDDLEWARE_STATE__',\r\n  /** The property name used to store serialized middleware results (FIFO array). */\r\n  RESULTS: '__MIDDLEWARE_STATE_RESULT__',\r\n  /** Namespaced root used to store the state protocol bag inside providerOptions. */\r\n  OPTIONS_ROOT: '9bd3f8a1-2c5f-4e5b-9c7a-6f1e2d3c4b5a',\r\n} as const;\r\n\r\n/**\r\n * Serializable state data shape\r\n *\r\n * Middleware state is represented as a plain object whose property values are\r\n * JSON-serializable. `JSONValue` is imported from the `ai` package and covers\r\n * primitives, arrays and nested objects composed of JSON-compatible values.\r\n *\r\n * Implementations are expected to return values matching this shape from\r\n * `serializeState` and accept the same shape for `deserializeState`.\r\n */\r\nexport type SerializableState = Record<string, JSONValue>;\r\n\r\n/**\r\n * Interface for middleware that can serialize and restore state.\r\n *\r\n * Middleware implementing this interface are expected to provide three pieces\r\n * of functionality:\r\n *\r\n * - `getMiddlewareId` — returns a stable identifier for the middleware\r\n * - `serializeState` — returns a JSON-serializable representation of current state\r\n * - `deserializeState` — re-applies a previously serialized state\r\n *\r\n * These functions are invoked by the state-management wrapper during collection\r\n * and restoration flows.\r\n */\r\nexport type SerializableMiddleware<\r\n  T extends SerializableState = SerializableState,\r\n> = {\r\n  /**\r\n   * Get the unique identifier for this middleware instance.\r\n   * @param props - The wrapper configuration for the middleware instance.\r\n   * @returns A stable string identifier used to match state entries during restore.\r\n   */\r\n  getMiddlewareId(props: { config: StatefulMiddlewareConfig }): string;\r\n\r\n  /**\r\n   * Serialize the current middleware state into a JSON-compatible object.\r\n   * @param props.params - The current generate call parameters (may include providerOptions).\r\n   * @param props.config - The wrapper configuration for this middleware.\r\n   * @returns A Promise resolving to the serializable state object.\r\n   */\r\n  serializeState(props: {\r\n    params: StateManagementParams;\r\n    config: StatefulMiddlewareConfig;\r\n  }): Promise<T>;\r\n\r\n  /**\r\n   * Restore middleware state from a previously serialized object.\r\n   * @param props.state - The serialized state to restore.\r\n   * @param props.params - The current generate call parameters.\r\n   * @param props.config - The wrapper configuration for this middleware.\r\n   */\r\n  deserializeState(props: {\r\n    state: T;\r\n    params: StateManagementParams;\r\n    config: StatefulMiddlewareConfig;\r\n  }): Promise<void>;\r\n};\r\n\r\n/**\r\n * Interface that middleware must implement to participate in the state management protocol\r\n */\r\n/**\r\n * Combined middleware type that includes the language-model middleware shape\r\n * and the serializable state contract.\r\n *\r\n * This type is used when a middleware both participates in the v2 middleware\r\n * pipeline and implements serialize/deserialize helpers.\r\n */\r\nexport type SerializableLanguageModelMiddleware<\r\n  TMiddlewareId extends string = string,\r\n  T extends SerializableState = SerializableState,\r\n> = LanguageModelV2Middleware &\r\n  SerializableMiddleware<T> & {\r\n    /**\r\n     * Get the unique identifier for this middleware instance.\r\n     * @param props.options - The wrapper configuration object provided to the middleware.\r\n     * @returns A typed middleware id literal (TMiddlewareId).\r\n     */\r\n    getMiddlewareId(props: {\r\n      options: StatefulMiddlewareConfig;\r\n    }): TMiddlewareId;\r\n  };\r\n\r\n/**\r\n * Configuration for the createStatefulMiddleware wrapper\r\n */\r\n/**\r\n * Configuration object supplied to the stateful middleware wrapper.\r\n *\r\n * The only required property is `middlewareId` — a stable identifier used when\r\n * serializing and restoring middleware state. The wrapper passes this object\r\n * to serializer and deserializer helpers so they can use configuration values\r\n * if needed.\r\n */\r\nexport interface StatefulMiddlewareConfig<\r\n  TMiddlewareId extends string = string,\r\n> {\r\n  /** Unique identifier for the middleware. */\r\n  middlewareId: TMiddlewareId;\r\n}\r\n\r\n/**\r\n * Provider-level options used to drive the state protocol.\r\n *\r\n * This type extends an open record (so other provider options may co-exist)\r\n * and adds three optional, namespaced properties used by the protocol:\r\n *\r\n * - `RESULTS` — an array used as a FIFO queue that stores `[middlewareId, state]`\r\n *   tuples produced during collection.\r\n * - `RESTORE` — boolean flag indicating the current call should restore state.\r\n * - `COLLECT` — boolean flag indicating the current call should collect state.\r\n */\r\nexport type StateManagementProviderOptions = Record<string, JSONValue> & {\r\n  /**\r\n   * A FIFO-based array used to store middleware id and state value during serialization.\r\n   * Each entry is a two-tuple `[middlewareId, serializedState]`.\r\n   */\r\n  [STATE_PROTOCOL.RESULTS]?: Array<[string, SerializableState]>;\r\n  /** When true participating middleware should read state from the statebag. */\r\n  [STATE_PROTOCOL.RESTORE]?: boolean;\r\n  /** When true participating middleware should store current state to the statebag. */\r\n  [STATE_PROTOCOL.COLLECT]?: boolean;\r\n};\r\n\r\n/**\r\n * Extended parameters for middleware that include state management\r\n */\r\n/**\r\n * Extended middleware call parameters that include the state-management\r\n * protocol bag.\r\n *\r\n * `StateManagementParams` extends the normal `LanguageModelV2CallOptions` and\r\n * augments `providerOptions` to optionally contain the protocol's\r\n * `OPTIONS_ROOT` bag. Middleware should treat `providerOptions` as potentially\r\n * containing the protocol object and use the namespaced keys on that object to\r\n * coordinate collection/restore flows.\r\n */\r\nexport interface StateManagementParams extends LanguageModelV2CallOptions {\r\n  /**\r\n   * Extends {@link SharedV2ProviderOptions} with state management protocol support.\r\n   * The `OPTIONS_ROOT` property is where the protocol stores its control flags\r\n   * and results array.\r\n   */\r\n  providerOptions?: SharedV2ProviderOptions & {\r\n    /**\r\n     * \"Magic\" statebag used to smuggle in state management protocol support.\r\n     * Middleware and wrappers should only touch this property when participating\r\n     * in the protocol; other callers should ignore it.\r\n     */\r\n    [STATE_PROTOCOL.OPTIONS_ROOT]?: StateManagementProviderOptions;\r\n  };\r\n}\r\n\r\n/**\r\n * Database schema for middleware metadata\r\n */\r\n/**\r\n * Optional database schema for storing middleware metadata.\r\n *\r\n * This structure is primarily used by administrative tooling that discovers\r\n * and manages pluggable middleware. It is not required for runtime protocol\r\n * operation but provides useful metadata for registration UIs and auditing.\r\n */\r\nexport type MiddlewareMetadata = {\r\n  /** Unique identifier for the middleware. */\r\n  id: string;\r\n\r\n  /** Human-readable name of the middleware. */\r\n  name: string;\r\n\r\n  /** Path to the JavaScript file that implements the middleware. */\r\n  implementationPath: string;\r\n\r\n  /** Optional description of what the middleware does. */\r\n  description?: string;\r\n\r\n  /** Whether the middleware supports state serialization. */\r\n  supportsStateSerialization: boolean;\r\n\r\n  /** Timestamp when the middleware was registered. */\r\n  createdAt: Date;\r\n\r\n  /** Timestamp when the middleware metadata was last updated. */\r\n  updatedAt: Date;\r\n\r\n  /** Whether the middleware is currently active. */\r\n  isActive: boolean;\r\n};\r\n\r\n/**\r\n * Small, common state shape that middleware may use as a baseline for\r\n * testing/examples. Real middleware will define richer state shapes.\r\n */\r\nexport type BasicMiddlewareState = {\r\n  /** Epoch milliseconds when the state snapshot was taken. */\r\n  timestamp: number;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\tokenStatsTracking\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":47,"column":1,"nodeType":"Program","endLine":63,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Token Statistics Tracking Module\r\n *\r\n * This module provides comprehensive token consumption tracking and quota management\r\n * for AI model usage. It includes:\r\n *\r\n * - Real-time token usage tracking per model/provider\r\n * - Sliding window statistics (minute, hour, day)\r\n * - Quota configuration and enforcement\r\n * - Redis caching for fast access\r\n * - PostgreSQL persistence for system of record\r\n *\r\n * @example Basic usage with middleware\r\n * ```typescript\r\n * import { tokenStatsMiddleware } from '@/lib/ai/middleware/tokenStatsTracking';\r\n * import { wrapLanguageModel } from 'ai';\r\n *\r\n * const model = wrapLanguageModel({\r\n *   model: baseModel,\r\n *   middleware: tokenStatsMiddleware({ enableQuotaEnforcement: true })\r\n * });\r\n * ```\r\n *\r\n * @example Direct service usage\r\n * ```typescript\r\n * import { getTokenStatsService } from '@/lib/ai/middleware/tokenStatsTracking';\r\n *\r\n * // Check quota before making a request\r\n * const quotaCheck = await getTokenStatsService().checkQuota('azure', 'hifi', 1000);\r\n * if (!quotaCheck.allowed) {\r\n *   throw new Error(quotaCheck.reason);\r\n * }\r\n *\r\n * // Record usage after a successful request\r\n * await getTokenStatsService().safeRecordTokenUsage('azure', 'hifi', {\r\n *   promptTokens: 100,\r\n *   completionTokens: 200,\r\n *   totalTokens: 300\r\n * });\r\n *\r\n * // Get current statistics\r\n * const stats = await getTokenStatsService().getTokenStats('azure', 'hifi');\r\n * console.log(`Current minute usage: ${stats.currentMinuteTokens}`);\r\n * ```\r\n */\r\n\r\nexport { getInstance as getTokenStatsService } from '../../services/model-stats/token-stats-service';\r\n\r\nexport {\r\n  type TokenUsageData,\r\n  type ModelQuota,\r\n  type TokenStats,\r\n  type QuotaCheckResult,\r\n  type TokenStatsMiddlewareConfig,\r\n  type TokenStatsServiceType,\r\n} from './types';\r\n\r\nexport {\r\n  tokenStatsMiddleware,\r\n  tokenStatsWithQuotaMiddleware,\r\n  tokenStatsLoggingOnlyMiddleware,\r\n} from './tokenStatsMiddleware';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\tokenStatsTracking\\tokenStatsMiddleware.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":599,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getInstance } from '../../services/model-stats/token-stats-service';\r\nimport { log } from '@/lib/logger';\r\nimport {\r\n  QuotaCheckResult,\r\n  QuotaEnforcementError,\r\n  TokenStatsMiddlewareConfig,\r\n  TokenUsageData,\r\n} from './types';\r\nimport { countTokens } from '../../core/count-tokens';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { MiddlewareStateManager } from '../state-management';\r\n\r\nimport {\r\n  LanguageModelV2,\r\n  LanguageModelV2CallOptions,\r\n  LanguageModelV2StreamPart,\r\n  LanguageModelV2Middleware,\r\n} from '@ai-sdk/provider';\r\nimport { ModelMap } from '../../services/model-stats/model-map';\r\nimport { isResourceNotFoundError } from '../../services/chat/errors/resource-not-found-error';\r\nimport { SerializableLanguageModelMiddleware } from '../state-management/types';\r\n\r\ntype DoGenerateReturnType = ReturnType<LanguageModelV2['doGenerate']>;\r\ntype DoStreamReturnType = ReturnType<LanguageModelV2['doStream']>;\r\ntype TokenStatsTransformParamsType = LanguageModelV2CallOptions & {\r\n  providerOptions?: LanguageModelV2CallOptions['providerOptions'] & {\r\n    backOffice?: {\r\n      estTokens?: number;\r\n    };\r\n  };\r\n};\r\n\r\n/**\r\n * Extract provider and model name from various model ID formats\r\n */\r\nconst extractProviderAndModel = async (\r\n  modelId: string | LanguageModelV2,\r\n): Promise<{ provider: string; modelName: string }> => {\r\n  const modelMap = await ModelMap.getInstance();\r\n  const parts = await modelMap.normalizeProviderModel(modelId);\r\n  parts.rethrow();\r\n  const { provider, modelName } = parts;\r\n  return {\r\n    provider,\r\n    modelName,\r\n  };\r\n};\r\n\r\nconst isQuotaEnforcementError = (\r\n  error: unknown,\r\n): error is QuotaEnforcementError =>\r\n  typeof error === 'object' &&\r\n  !!error &&\r\n  'message' in error &&\r\n  'quota' in error &&\r\n  typeof error.quota === 'object';\r\n\r\nconst quotaCheck = async ({\r\n  provider,\r\n  modelName,\r\n  estimatedTokens,\r\n  enableQuotaEnforcement = true,\r\n  enableLogging = true,\r\n}: {\r\n  provider: string;\r\n  modelName: string;\r\n  estimatedTokens: number;\r\n  enableQuotaEnforcement: boolean;\r\n  enableLogging: boolean;\r\n}): Promise<QuotaCheckResult> => {\r\n  try {\r\n    const quotaCheck = await getInstance().checkQuota(\r\n      provider,\r\n      modelName,\r\n      estimatedTokens,\r\n    );\r\n    if (quotaCheck.allowed) {\r\n      if (enableLogging) {\r\n        log((l) =>\r\n          l.verbose('Quota check passed', {\r\n            provider,\r\n            modelName,\r\n            estimatedTokens,\r\n            currentUsage: quotaCheck.currentUsage,\r\n          }),\r\n        );\r\n      }\r\n      return quotaCheck;\r\n    }\r\n    if (enableLogging) {\r\n      log((l) =>\r\n        l.warn('Request failed quota check', {\r\n          provider,\r\n          modelName,\r\n          reason: quotaCheck.reason,\r\n          currentUsage: quotaCheck.currentUsage,\r\n          quota: quotaCheck.quota,\r\n        }),\r\n      );\r\n    }\r\n    if (enableQuotaEnforcement) {\r\n      const error: QuotaEnforcementError = new Error(\r\n        `Quota exceeded: ${quotaCheck.reason}`,\r\n      );\r\n      // Attach quota information to error for upstream handling\r\n      error.quota = quotaCheck;\r\n      throw error;\r\n    }\r\n  } catch (error) {\r\n    // Re-throw quota violations, only catch actual quota checking errors\r\n    if (isQuotaEnforcementError(error)) {\r\n      throw error;\r\n    }\r\n    // If quota checking fails, log but don't block (fail open)\r\n    if (enableLogging) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        source: 'tokenStatsMiddleware.quotaCheck',\r\n        log: enableLogging,\r\n        data: {\r\n          provider,\r\n          modelName,\r\n          estimatedTokens,\r\n        },\r\n      });\r\n    }\r\n  }\r\n  return { allowed: true, reason: 'Quota check failed, allowing request' };\r\n};\r\n\r\nconst wrapGenerate = async ({\r\n  doGenerate,\r\n  model,\r\n  config: {\r\n    provider: configProvider,\r\n    modelName: configModelName,\r\n    enableLogging = true,\r\n    enableQuotaEnforcement = false,\r\n  },\r\n  params: {\r\n    providerOptions: {\r\n      backOffice: { estTokens: estimatedTokens = 0 } = {},\r\n    } = {},\r\n  },\r\n}: {\r\n  doGenerate: () => DoGenerateReturnType;\r\n  model: string | LanguageModelV2;\r\n  config: TokenStatsMiddlewareConfig;\r\n  params: TokenStatsTransformParamsType;\r\n}): Promise<DoGenerateReturnType> => {\r\n  try {\r\n    const { provider, modelName, rethrow } = await ModelMap.getInstance().then(\r\n      (x) => x.normalizeProviderModel(model),\r\n    );\r\n    try {\r\n      rethrow();\r\n      if (enableLogging) {\r\n        log((l) =>\r\n          l.verbose('Token stats middleware processing request', {\r\n            provider,\r\n            modelName,\r\n          }),\r\n        );\r\n      }\r\n      await quotaCheck({\r\n        provider,\r\n        modelName,\r\n        estimatedTokens,\r\n        enableQuotaEnforcement,\r\n        enableLogging,\r\n      });\r\n    } catch (error) {\r\n      // If quota enforcement is not enabled then we still want to run\r\n      // the request if the model is not found\r\n      if (isResourceNotFoundError(error)) {\r\n        if (enableLogging) {\r\n          LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n            log: true,\r\n            data: {\r\n              severity: 'warning',\r\n              message: 'Unknown model',\r\n              model,\r\n            },\r\n          });\r\n        }\r\n        if (enableQuotaEnforcement) {\r\n          throw error;\r\n        }\r\n      } else {\r\n        throw error;\r\n      }\r\n    }\r\n    // Execute the request\r\n    try {\r\n      const result = await doGenerate();\r\n      // Post-request usage recording\r\n      if (result.usage) {\r\n        const tokenUsage: TokenUsageData = {\r\n          promptTokens: result?.usage?.inputTokens ?? 0,\r\n          completionTokens: result?.usage?.outputTokens ?? 0,\r\n          totalTokens: result?.usage?.totalTokens ?? 0,\r\n        };\r\n        // If the provider and modelName are available, record the token usage\r\n        if (provider && modelName) {\r\n          getInstance()\r\n            .safeRecordTokenUsage(provider, modelName, tokenUsage)\r\n            .catch((error: unknown) => {\r\n              if (enableLogging) {\r\n                log((l) =>\r\n                  l.error('Failed to record token usage', {\r\n                    provider,\r\n                    modelName,\r\n                    tokenUsage,\r\n                    error:\r\n                      error instanceof Error ? error.message : String(error),\r\n                  }),\r\n                );\r\n              }\r\n            });\r\n        }\r\n        if (enableLogging) {\r\n          log((l) =>\r\n            l.silly('Token usage recorded', {\r\n              provider,\r\n              modelName,\r\n              tokenUsage,\r\n            }),\r\n          );\r\n        }\r\n      }\r\n      return result;\r\n    } catch (error) {\r\n      if (isQuotaEnforcementError(error)) {\r\n        // If this is a quota enforcement error, re-throw it\r\n        throw error;\r\n      }\r\n      throw LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        source: 'tokenStatsMiddleware.wrapGenerate',\r\n        log: enableLogging,\r\n        data: {\r\n          provider,\r\n          modelName,\r\n          estimatedTokens,\r\n        },\r\n      });\r\n    }\r\n  } catch (error) {\r\n    if (isQuotaEnforcementError(error)) {\r\n      // If this is a quota enforcement error, re-throw it\r\n      throw error;\r\n    } else {\r\n      // Otherwise it's a critical error; log/rethrow\r\n      throw LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        source: 'tokenStatsMiddleware.wrapGenerate',\r\n        log: enableLogging,\r\n        data: {\r\n          provider:\r\n            configProvider || typeof model === 'string' ? '' : model.provider,\r\n          modelName:\r\n            configModelName || typeof model === 'string'\r\n              ? model\r\n              : model.modelId,\r\n          estimatedTokens,\r\n        },\r\n      });\r\n    }\r\n  }\r\n};\r\n\r\nconst wrapStream = async ({\r\n  doStream,\r\n  model,\r\n  config: {\r\n    provider: configProvider,\r\n    modelName: configModelName,\r\n    enableLogging = true,\r\n    enableQuotaEnforcement = false,\r\n  },\r\n  params: {\r\n    providerOptions: {\r\n      backOffice: { estTokens: estimatedTokens = 0 } = {},\r\n    } = {},\r\n  },\r\n}: {\r\n  doStream: () => DoStreamReturnType;\r\n  model: string | LanguageModelV2;\r\n  config: TokenStatsMiddlewareConfig;\r\n  params: TokenStatsTransformParamsType;\r\n}): Promise<DoStreamReturnType> => {\r\n  let provider: string = '';\r\n  let modelName: string = '';\r\n\r\n  try {\r\n    // Extract provider and model info from the model instance\r\n    const { provider: providerFromProps, modelName: modelNameFromProps } =\r\n      await (typeof model === 'string'\r\n        ? extractProviderAndModel(model)\r\n        : configProvider && configModelName\r\n          ? { provider: configProvider, modelName: configModelName }\r\n          : model.provider && model.modelId\r\n            ? { provider: model.provider, modelName: model.modelId }\r\n            : extractProviderAndModel(model));\r\n\r\n    provider = providerFromProps;\r\n    modelName = modelNameFromProps;\r\n\r\n    if (enableLogging) {\r\n      log((l) =>\r\n        l.verbose('Token stats middleware processing stream request', {\r\n          provider,\r\n          modelName,\r\n        }),\r\n      );\r\n    }\r\n\r\n    // Pre-stream quota check\r\n    await quotaCheck({\r\n      provider,\r\n      modelName,\r\n      estimatedTokens,\r\n      enableQuotaEnforcement,\r\n      enableLogging,\r\n    });\r\n  } catch (error) {\r\n    const le = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      source: 'tokenStatsMiddleware.wrapStream',\r\n      log: enableLogging,\r\n      data: {\r\n        provider,\r\n        modelName,\r\n        estimatedTokens,\r\n      },\r\n    });\r\n    if (isQuotaEnforcementError(error) || isResourceNotFoundError(error)) {\r\n      // If this is a quota enforcement error or a model lookup error and quota enforcement is enabled, re-throw it\r\n      if (enableQuotaEnforcement) {\r\n        throw enableLogging ? le : error;\r\n      }\r\n    } else {\r\n      throw enableLogging ? le : error;\r\n    }\r\n  }\r\n\r\n  try {\r\n    const result = await doStream();\r\n\r\n    // Track token usage during streaming\r\n    let promptTokens = 0;\r\n    let completionTokens = 0;\r\n    let generatedText = '';\r\n    let hasFinished = false;\r\n\r\n    // Create a transform stream to wrap the original stream\r\n    const transformStream = new TransformStream<\r\n      LanguageModelV2StreamPart,\r\n      LanguageModelV2StreamPart\r\n    >({\r\n      transform(chunk, controller) {\r\n        try {\r\n          // Track text generation for token counting\r\n          if (chunk.type === 'text-delta') {\r\n            generatedText += chunk.delta;\r\n          }\r\n\r\n          // Extract usage information from finish chunks\r\n          if (chunk.type === 'finish') {\r\n            hasFinished = true;\r\n            if (chunk.usage) {\r\n              promptTokens = chunk.usage.inputTokens || 0;\r\n              completionTokens = chunk.usage.outputTokens || 0;\r\n            }\r\n          }\r\n\r\n          // Pass through the chunk\r\n          controller.enqueue(chunk);\r\n        } catch (error) {\r\n          LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n            source: 'tokenStatsMiddleware.streamTransform',\r\n            log: enableLogging,\r\n            data: {\r\n              provider,\r\n              modelName,\r\n              chunkType: chunk.type,\r\n            },\r\n          });\r\n        }\r\n      },\r\n\r\n      flush() {\r\n        // If I don't have a provider and model id then there's nothing for me to do...\r\n        if (!provider || !modelName) {\r\n          return;\r\n        }\r\n        try {\r\n          // Record token usage after stream completion\r\n          if (hasFinished || generatedText.length > 0) {\r\n            // If we don't have exact usage from the stream, estimate completion tokens\r\n            if (completionTokens === 0 && generatedText.length > 0) {\r\n              completionTokens = Math.ceil(generatedText.length / 4); // Rough estimation\r\n            }\r\n\r\n            // If we don't have prompt tokens, use the estimated value\r\n            if (promptTokens === 0) {\r\n              promptTokens = estimatedTokens;\r\n            }\r\n\r\n            const tokenUsage: TokenUsageData = {\r\n              promptTokens,\r\n              completionTokens,\r\n              totalTokens: promptTokens + completionTokens,\r\n            };\r\n\r\n            // Record usage asynchronously to avoid blocking the stream\r\n            if (tokenUsage.totalTokens > 0) {\r\n              getInstance()\r\n                .safeRecordTokenUsage(provider, modelName, tokenUsage)\r\n                .catch((error: unknown) => {\r\n                  if (enableLogging) {\r\n                    log((l) =>\r\n                      l.error('Failed to record token usage for stream', {\r\n                        provider,\r\n                        modelName,\r\n                        tokenUsage,\r\n                        error:\r\n                          error instanceof Error\r\n                            ? error.message\r\n                            : String(error),\r\n                      }),\r\n                    );\r\n                  }\r\n                });\r\n\r\n              if (enableLogging) {\r\n                log((l) =>\r\n                  l.silly('Stream token usage recorded', {\r\n                    provider,\r\n                    modelName,\r\n                    tokenUsage,\r\n                    generatedTextLength: generatedText.length,\r\n                  }),\r\n                );\r\n              }\r\n            }\r\n          }\r\n        } catch (error) {\r\n          LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n            source: 'tokenStatsMiddleware.streamTransformFlush',\r\n            log: enableLogging,\r\n            data: {\r\n              provider,\r\n              modelName,\r\n            },\r\n          });\r\n        }\r\n      },\r\n    });\r\n\r\n    // Return the result with the transformed stream\r\n    return {\r\n      ...result,\r\n      stream: result.stream.pipeThrough(transformStream),\r\n    };\r\n  } catch (error) {\r\n    throw LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      source: 'tokenStatsMiddleware.wrapStream',\r\n      log: enableLogging,\r\n      data: {\r\n        provider,\r\n        modelName,\r\n        estimatedTokens,\r\n      },\r\n    });\r\n  }\r\n};\r\n\r\nexport const transformParams = async ({\r\n  params: { prompt, providerOptions: providerMetadata = {}, ...params },\r\n  config: { enableLogging = true },\r\n}: {\r\n  config: TokenStatsMiddlewareConfig;\r\n  params: TokenStatsTransformParamsType;\r\n}): Promise<TokenStatsTransformParamsType> => {\r\n  try {\r\n    const tokens = countTokens({ prompt, enableLogging });\r\n    providerMetadata.backOffice = {\r\n      ...(providerMetadata.backOffice ?? {}),\r\n      estTokens: tokens,\r\n    };\r\n  } catch (error) {\r\n    LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      source: 'tokenStatsMiddleware.transformParams',\r\n      log: enableLogging,\r\n    });\r\n  }\r\n  return {\r\n    ...params,\r\n    prompt,\r\n    providerOptions: providerMetadata,\r\n  };\r\n};\r\n\r\n/**\r\n * Create token statistics tracking middleware\r\n *\r\n * This middleware:\r\n * 1. Checks quotas before making requests (if enforcement is enabled)\r\n * 2. Records actual token usage after successful requests\r\n * 3. Logs quota violations and usage statistics\r\n * 4. Participates in state management protocol\r\n */\r\nconst createOriginalTokenStatsMiddleware = (\r\n  config: TokenStatsMiddlewareConfig = {},\r\n): LanguageModelV2Middleware => {\r\n  const { provider: p, modelName: m } = config ?? {};\r\n  const setupModelProviderOverrides = () => ({\r\n    overrideProvider: p ? () => p! as string : undefined,\r\n    overrideModelId: m ? () => m! as string : undefined,\r\n  });\r\n  let { overrideProvider, overrideModelId } = setupModelProviderOverrides();\r\n  const thisInstance = {\r\n    wrapGenerate: async (props) =>\r\n      wrapGenerate({\r\n        ...props,\r\n        config,\r\n      }),\r\n    wrapStream: async (props) =>\r\n      wrapStream({\r\n        ...props,\r\n        config,\r\n      }),\r\n    transformParams: async (props) =>\r\n      transformParams({\r\n        ...props,\r\n        config,\r\n      }),\r\n    getMiddlewareId: () => 'token-stats-tracking',\r\n    serializeState: () => Promise.resolve({ config: JSON.stringify(config) }),\r\n    deserializeState: ({ state }) => {\r\n      const { config: configFromState } = state;\r\n      if (!configFromState) {\r\n        return Promise.reject(\r\n          new TypeError('Missing required property \"config\".'),\r\n        );\r\n      }\r\n      config = JSON.parse(\r\n        configFromState.toString(),\r\n      ) as TokenStatsMiddlewareConfig;\r\n      ({ overrideProvider, overrideModelId } = setupModelProviderOverrides());\r\n      if (overrideProvider) {\r\n        thisInstance.overrideProvider = overrideProvider;\r\n      }\r\n      if (overrideModelId) {\r\n        thisInstance.overrideModelId = overrideModelId;\r\n      }\r\n      return Promise.resolve();\r\n    },\r\n    overrideProvider,\r\n    overrideModelId,\r\n  } as SerializableLanguageModelMiddleware;\r\n  return thisInstance;\r\n};\r\n\r\n/**\r\n * Create token statistics tracking middleware with State Management Support\r\n *\r\n * This middleware supports the state management protocol and can participate\r\n * in state collection and restoration operations.\r\n */\r\nexport const tokenStatsMiddleware = (\r\n  config: TokenStatsMiddlewareConfig = {},\r\n): LanguageModelV2Middleware =>\r\n  MiddlewareStateManager.Instance.statefulMiddlewareWrapper({\r\n    middlewareId: 'token-stats-tracking',\r\n    middleware: createOriginalTokenStatsMiddleware(config),\r\n  });\r\n\r\n/**\r\n * Create token statistics middleware with quota enforcement enabled\r\n */\r\nexport const tokenStatsWithQuotaMiddleware = (\r\n  config: Omit<TokenStatsMiddlewareConfig, 'enableQuotaEnforcement'> = {},\r\n) =>\r\n  tokenStatsMiddleware({\r\n    enableLogging: true,\r\n    ...config,\r\n    enableQuotaEnforcement: true,\r\n  });\r\n\r\n/**\r\n * Create token statistics middleware with only logging (no quota enforcement)\r\n */\r\nexport const tokenStatsLoggingOnlyMiddleware = (\r\n  config: Omit<TokenStatsMiddlewareConfig, 'enableQuotaEnforcement'> = {},\r\n) =>\r\n  tokenStatsMiddleware({\r\n    ...config,\r\n    enableLogging: true,\r\n    enableQuotaEnforcement: false,\r\n  });\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\tokenStatsTracking\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":22,"column":1,"nodeType":"Program","endLine":160,"endColumn":3}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module lib/ai/middleware/tokenStatsTracking/types\r\n * @fileoverview\r\n * TypeScript interfaces and types for token usage tracking, quota enforcement, and provider/model responses\r\n * in the AI middleware system. These types are used throughout the token statistics tracking middleware,\r\n * service, and related components to ensure type safety and consistent data structures.\r\n *\r\n * @author NoEducation Team\r\n * @version 1.0.0\r\n * @since 2025-01-01\r\n */\r\n\r\n/**\r\n * Represents token usage data for a single request or operation.\r\n * Used to record prompt, completion, and total tokens consumed.\r\n *\r\n * @property {number} promptTokens - Number of tokens used for the prompt.\r\n * @property {number} completionTokens - Number of tokens used for the completion.\r\n * @property {number} totalTokens - Total tokens used (prompt + completion).\r\n * @property {number} [estimatedTokens] - Optional estimated token count (for streaming or partial requests).\r\n */\r\nexport interface TokenUsageData {\r\n  promptTokens: number;\r\n  completionTokens: number;\r\n  totalTokens: number;\r\n  estimatedTokens?: number;\r\n}\r\n\r\n/**\r\n * Represents quota configuration for a specific model and provider.\r\n * Used to enforce limits on token usage per message, minute, or day.\r\n *\r\n * @property {string} id - Unique identifier for the quota record.\r\n * @property {string} provider - Provider ID (e.g., 'azure', 'google').\r\n * @property {string} modelName - Model name (e.g., 'hifi', 'gemini-pro').\r\n * @property {number} [maxTokensPerMessage] - Maximum tokens allowed per message/request.\r\n * @property {number} [maxTokensPerMinute] - Maximum tokens allowed per minute.\r\n * @property {number} [maxTokensPerDay] - Maximum tokens allowed per day.\r\n * @property {boolean} isActive - Whether the quota is currently enforced.\r\n */\r\nexport interface ModelQuota {\r\n  id: string;\r\n  provider: string;\r\n  modelName: string;\r\n  maxTokensPerMessage?: number;\r\n  maxTokensPerMinute?: number;\r\n  maxTokensPerDay?: number;\r\n  isActive: boolean;\r\n}\r\n\r\n/**\r\n * Result of a quota check operation.\r\n * Indicates whether a request is allowed, the reason for denial, current usage, and quota details.\r\n *\r\n * @property {boolean} allowed - Whether the request is allowed under current quota.\r\n * @property {string} [reason] - Optional reason for denial (e.g., 'Rate limit exceeded').\r\n * @property {TokenStats} [currentUsage] - Current token usage statistics.\r\n * @property {ModelQuota} [quota] - Quota configuration used for the check.\r\n * @property {Date} [tryAgainAfter] - Optional timestamp indicating when to retry.\r\n */\r\nexport interface QuotaCheckResult {\r\n  allowed: boolean;\r\n  reason?: string;\r\n  currentUsage?: TokenStats;\r\n  quota?: ModelQuota;\r\n  tryAgainAfter?: Date;\r\n}\r\n\r\n/**\r\n * Aggregated token usage statistics for a provider/model.\r\n * Used for reporting and quota enforcement.\r\n *\r\n * @property {number} currentMinuteTokens - Tokens used in the current minute.\r\n * @property {number} lastHourTokens - Tokens used in the last hour.\r\n * @property {number} last24HoursTokens - Tokens used in the last 24 hours.\r\n * @property {number} requestCount - Number of requests made in the tracked period.\r\n */\r\nexport interface TokenStats {\r\n  currentMinuteTokens: number;\r\n  lastHourTokens: number;\r\n  last24HoursTokens: number;\r\n  requestCount: number;\r\n}\r\n\r\n/**\r\n * Configuration options for the token statistics tracking middleware.\r\n * Allows enabling logging, quota enforcement, and overriding provider/model.\r\n *\r\n * @property {boolean} [enableLogging] - Enable verbose logging for token usage.\r\n * @property {boolean} [enableQuotaEnforcement] - Enable quota enforcement logic.\r\n * @property {string} [provider] - Override provider for the middleware (default: extracted from model ID).\r\n * @property {string} [modelName] - Override model name for the middleware (default: extracted from model ID).\r\n */\r\nexport interface TokenStatsMiddlewareConfig {\r\n  enableLogging?: boolean;\r\n  enableQuotaEnforcement?: boolean;\r\n  provider?: string;\r\n  modelName?: string;\r\n}\r\n\r\n/**\r\n * Error type for quota enforcement failures.\r\n * Extends the standard Error object and includes quota check result details.\r\n *\r\n * @property {QuotaCheckResult} [quota] - Quota check result associated with the error.\r\n */\r\nexport type QuotaEnforcementError = Error & {\r\n  quota?: QuotaCheckResult\r\n};\r\n\r\n/**\r\n * Response type for provider/model operations.\r\n * Used to return provider/model information and error details from service methods.\r\n *\r\n * @property {unknown} [error] - Optional error object if the operation failed.\r\n * @property {string} providerId - Unique provider identifier.\r\n * @property {string} provider - Provider name.\r\n * @property {string} modelName - Model name.\r\n * @property {() => void} rethrow - Function to rethrow the error if needed.\r\n */\r\nexport type ProviderModelResponse = {\r\n  error?: unknown;\r\n  providerId: string;\r\n  provider: string;\r\n  modelName: string;\r\n  rethrow: () => void;\r\n};\r\n\r\n/**\r\n * Type representing all public members of TokenStatsService.\r\n * Used for strong typing of the TokenStatsService singleton and for mocking in tests.\r\n *\r\n * @property {function} getQuota - Retrieves quota configuration for a provider/model.\r\n * @property {function} getTokenStats - Retrieves token usage statistics for a provider/model.\r\n * @property {function} checkQuota - Checks if a token usage request is allowed under current quota.\r\n * @property {function} safeRecordTokenUsage - Safely records token usage for a provider/model.\r\n * @property {function} getUsageReport - Retrieves a comprehensive usage report for a provider/model.\r\n */\r\nexport type TokenStatsServiceType = {\r\n  getQuota(provider: string, modelName: string): Promise<ModelQuota | null>;\r\n  getTokenStats(provider: string, modelName: string): Promise<TokenStats>;\r\n  checkQuota(\r\n    provider: string,\r\n    modelName: string,\r\n    requestedTokens: number\r\n  ): Promise<QuotaCheckResult>;\r\n  safeRecordTokenUsage(\r\n    provider: string,\r\n    modelName: string,\r\n    usage: TokenUsageData\r\n  ): Promise<void>;\r\n  getUsageReport(\r\n    provider: string,\r\n    modelName: string\r\n  ): Promise<{\r\n    quota: ModelQuota | null;\r\n    currentStats: TokenStats;\r\n    quotaCheckResult: QuotaCheckResult;\r\n  }>;\r\n};","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\middleware\\tool-optimizing-middleware\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":47,"column":1,"nodeType":"Program","endLine":599,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Tool Optimizing Middleware\r\n * ----------------------------------\r\n * A LanguageModelV2 middleware that performs two orthogonal responsibilities before\r\n * a model invocation:\r\n *\r\n * 1. Tool Scanning / Registration\r\n *    Dynamically inspects the incoming `tools` collection (function & provider-defined\r\n *    tools) and registers any previously unseen tools into a central `ToolMap` used for\r\n *    analytics, availability logic, and downstream observability.\r\n *\r\n * 2. Message Optimization (Tool Summarization)\r\n *    Conditionally summarizes long chat histories using a tool‑aware summarizer to reduce\r\n *    token footprint while preserving semantic fidelity and tool invocation context.\r\n *\r\n * Design Goals:\r\n * - Backward compatibility with legacy middleware/tests expecting a `messages` array\r\n *   while the modern API uses `prompt` (array of LanguageModelV2 messages).\r\n * - Zero mutation / identity preservation where optimization is not applied.\r\n * - Defensive error handling: failures in scanning or optimization never surface to the\r\n *   caller; they are logged and original parameters pass through unchanged.\r\n * - Observability: rich OpenTelemetry counters & histograms describing frequency,\r\n *   latency, and discovery counts without leaking PII (user IDs are hashed).\r\n *\r\n * Heuristic Note:\r\n * When only a `prompt` array is provided (no explicit legacy `messages`) and the first\r\n * element lacks an `id` while the second has one, that first element is treated as a\r\n * transient / synthetic leading instruction. It is sliced out of the optimization input\r\n * only when either tool scanning was explicitly configured or the model was supplied as\r\n * a simple string. This mirrors historic test expectations around message subset\r\n * formation.\r\n *\r\n * Public API Surface:\r\n * - `createToolOptimizingMiddleware(config)` factory returning an extended middleware.\r\n * - `getToolOptimizingMiddlewareMetrics()` helper exposing metric instrument names for\r\n *   external telemetry systems.\r\n * - Re‑exports of `ToolMap` & `optimizeMessagesWithToolSummarization` for convenience.\r\n *\r\n * Non‑Goals:\r\n * - Does not enforce model selection, rate limiting, or caching policies.\r\n * - Does not mutate or re‑order tool definitions beyond scanning.\r\n *\r\n * Extensibility Points:\r\n * - Additional optimization strategies can wrap / replace `optimizeMessagesStep`.\r\n * - Alternate slicing heuristics can be introduced by adapting `buildOptimizerInput`.\r\n */\r\nimport type {\r\n  LanguageModelV2,\r\n  LanguageModelV2CallOptions,\r\n  LanguageModelV2FunctionTool,\r\n  LanguageModelV2Middleware,\r\n  LanguageModelV2ProviderDefinedTool,\r\n} from '@ai-sdk/provider';\r\n// UIMessage import removed historically; prompt format is canonical now.\r\nimport { LoggedError } from '@/lib/react-util';\r\nimport { ToolMap } from '@/lib/ai/services/model-stats/tool-map';\r\nimport { optimizeMessagesWithToolSummarization } from '@/lib/ai/chat/message-optimizer-tools';\r\nimport { log } from '@/lib/logger';\r\nimport { appMeters, hashUserId } from '@/lib/site-util/metrics';\r\n\r\n/**\r\n * Counter: Total invocations of the middleware's `transformParams` (successful or error paths).\r\n * Helps quantify adoption and load characteristics.\r\n */\r\nconst toolOptimizationCounter = appMeters.createCounter(\r\n  'ai_tool_optimization_middleware_total',\r\n  {\r\n    description: 'Total number of tool optimization middleware operations',\r\n    unit: '1',\r\n  },\r\n);\r\n\r\n/**\r\n * Counter: Number of tool scanning executions (only increments when scanning is enabled and attempted).\r\n */\r\nconst toolScanningCounter = appMeters.createCounter('ai_tool_scanning_total', {\r\n  description: 'Total number of tool scanning operations',\r\n  unit: '1',\r\n});\r\n\r\n/**\r\n * Histogram: Wall‑clock latency in milliseconds for a full middleware pass (excluding early returns).\r\n */\r\nconst toolOptimizationDurationHistogram = appMeters.createHistogram(\r\n  'ai_tool_optimization_middleware_duration_ms',\r\n  {\r\n    description: 'Duration of tool optimization middleware operations',\r\n    unit: 'ms',\r\n  },\r\n);\r\n\r\n/**\r\n * Histogram: Distribution of how many previously unknown tools were detected per scan invocation.\r\n */\r\nconst newToolsFoundHistogram = appMeters.createHistogram(\r\n  'ai_new_tools_found_count',\r\n  {\r\n    description: 'Distribution of new tools found during scanning',\r\n    unit: '1',\r\n  },\r\n);\r\n\r\n/**\r\n * Histogram (used as a counter semantic): Records each instance where message optimization was actually attempted/applied.\r\n */\r\nconst messageOptimizationHistogram = appMeters.createHistogram(\r\n  'ai_message_optimization_enabled_total',\r\n  {\r\n    description: 'Total number of times message optimization was enabled',\r\n    unit: '1',\r\n  },\r\n);\r\n\r\n/**\r\n * Configuration options for the tool optimizing middleware\r\n */\r\nexport interface ToolOptimizingMiddlewareConfig {\r\n  /** User ID for tracking and metrics */\r\n  userId?: string;\r\n  /** Chat history ID for context tracking */\r\n  chatHistoryId?: string;\r\n  /** Enable message optimization (tool summarization) - default true */\r\n  enableMessageOptimization?: boolean;\r\n  /** Minimum messages required before attempting optimization - default 10 */\r\n  optimizationThreshold?: number;\r\n  /** Enable scanning of tool definitions to register new tools - default true */\r\n  enableToolScanning?: boolean;\r\n}\r\n\r\n// Extended call options including legacy fields expected by existing tests/middleware chain\r\nexport interface ExtendedCallOptions extends LanguageModelV2CallOptions {\r\n  /** Legacy alias for prompt array retained for test expectations */\r\n  messages?: unknown[];\r\n  /** Execution trace of prior middleware names */\r\n  middlewareStack?: string[];\r\n  /** Passthrough contextual fields used by other middleware integration tests */\r\n  chatHistory?: unknown;\r\n  rateLimitInfo?: unknown;\r\n  telemetry?: unknown;\r\n}\r\n\r\n// Extended middleware signature permitting legacy operation identifiers\r\nexport interface ExtendedToolOptimizingMiddleware\r\n  extends Omit<LanguageModelV2Middleware, 'transformParams'> {\r\n  /** Accept legacy op types ('generateText' | 'streamText') in addition to canonical ones */\r\n  transformParams?: (options: {\r\n    type: 'generate' | 'stream' | 'generateText' | 'streamText';\r\n    params: ExtendedCallOptions;\r\n    model?: LanguageModelV2 | string;\r\n  }) => Promise<ExtendedCallOptions>;\r\n}\r\n\r\ninterface OptimizationResult {\r\n  result: ExtendedCallOptions;\r\n  applied: boolean;\r\n  earlyReturn: boolean; // indicates duration metric already not recorded in original design\r\n  sourceCount?: number;\r\n  optimizedCount?: number;\r\n}\r\n\r\n/**\r\n * Creates a middleware for tool optimization that handles tool scanning and message optimization.\r\n *\r\n * This middleware is responsible for:\r\n * - Scanning incoming tool definitions and adding new ones to the ToolMap\r\n * - Optimizing message history using tool summarization when configured\r\n * - Recording metrics for tool discovery and optimization operations\r\n * - Maintaining backward compatibility with existing middleware patterns\r\n *\r\n * The middleware uses the `transformParams` function to:\r\n * 1. Call ToolMap's `scanForTools` method to discover and register new tools\r\n * 2. Apply message optimization using `optimizeMessagesWithToolSummarization`\r\n * 3. Pass through all other parameters unchanged\r\n *\r\n * @param config - Configuration options for the middleware\r\n * @returns A middleware object implementing `LanguageModelV2Middleware`\r\n *\r\n * @example\r\n * ```typescript\r\n * import { createToolOptimizingMiddleware } from '@/lib/ai/middleware/tool-optimizing-middleware';\r\n *\r\n * const toolOptimizingMiddleware = createToolOptimizingMiddleware({\r\n *   userId: 'user-123',\r\n *   chatHistoryId: 'chat-456',\r\n *   enableMessageOptimization: true,\r\n *   optimizationThreshold: 15,\r\n * });\r\n *\r\n * // Use with your language model pipeline\r\n * const model = wrapModel(aiModelFactory('hifi'), [toolOptimizingMiddleware]);\r\n * ```\r\n */\r\nexport function createToolOptimizingMiddleware(\r\n  config: ToolOptimizingMiddlewareConfig = {},\r\n): ExtendedToolOptimizingMiddleware {\r\n  const {\r\n    userId,\r\n    chatHistoryId,\r\n    enableMessageOptimization = true,\r\n    optimizationThreshold = 10,\r\n    enableToolScanning = true,\r\n  } = config;\r\n  // Track whether enableToolScanning was explicitly provided (vs relying on default)\r\n  const enableToolScanningExplicit = Object.hasOwn(\r\n    config,\r\n    'enableToolScanning',\r\n  );\r\n\r\n  // Step 1 helper: tool scanning\r\n  /**\r\n   * Step 1: Perform tool scanning / registration.\r\n   *\r\n   * Reads the `tools` property from the call options (if present) and forwards them\r\n   * to the shared `ToolMap` singleton. Any newly observed tools are recorded so\r\n   * analytics & availability subsystems gain visibility without requiring explicit\r\n   * manual registration elsewhere.\r\n   *\r\n   * Failure Handling:\r\n   * - Exceptions are caught and logged via `LoggedError`.\r\n   * - Returns 0 on failure ensuring downstream logic remains stable.\r\n   *\r\n   * Metrics:\r\n   * - Increments `toolScanningCounter` when scanning occurs.\r\n   * - Records discovered count in `newToolsFoundHistogram`.\r\n   */\r\n  async function performToolScanning(\r\n    params: ExtendedCallOptions,\r\n    attributes: Record<string, string>,\r\n  ): Promise<number> {\r\n    if (!enableToolScanning || !params.tools) return 0;\r\n    let newToolsCount = 0;\r\n    const toolMap = await ToolMap.getInstance();\r\n    try {\r\n      newToolsCount = await toolMap.scanForTools(\r\n        params.tools as unknown as\r\n          | LanguageModelV2FunctionTool\r\n          | LanguageModelV2ProviderDefinedTool\r\n          | (\r\n              | LanguageModelV2FunctionTool\r\n              | LanguageModelV2ProviderDefinedTool\r\n            )[],\r\n      );\r\n      toolScanningCounter.add(1, {\r\n        ...attributes,\r\n        tools_provided: Array.isArray(params.tools) ? params.tools.length : 1,\r\n      });\r\n      newToolsFoundHistogram.record(newToolsCount, attributes);\r\n      log((l) =>\r\n        l.debug('Tool scanning completed', {\r\n          newToolsFound: newToolsCount,\r\n          totalToolsProvided: Array.isArray(params.tools)\r\n            ? params.tools.length\r\n            : 1,\r\n        }),\r\n      );\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'ToolOptimizingMiddleware.toolScanning',\r\n        message: 'Failed to scan tools',\r\n        data: {\r\n          userId,\r\n          chatHistoryId,\r\n          toolsCount: Array.isArray(params.tools) ? params.tools.length : 1,\r\n        },\r\n      });\r\n    }\r\n    return newToolsCount;\r\n  }\r\n\r\n  // Step 2 helper: message optimization & legacy handling\r\n\r\n  /**\r\n   * Extracts candidate message arrays from the incoming parameters while preserving\r\n   * legacy semantics:\r\n   * - If `messages` (legacy) is present & an array, it takes precedence.\r\n   * - Otherwise falls back to `prompt` when it is an array.\r\n   * - Also reports whether the legacy key existed (even if non-array) so callers can\r\n   *   decide how to re‑emit compatible shapes.\r\n   */\r\n  function selectSourceMessages(params: ExtendedCallOptions): {\r\n    hasLegacyMessagesKey: boolean;\r\n    legacyMessagesValue: unknown;\r\n    legacyArray?: unknown[];\r\n    promptArray?: unknown[];\r\n    sourceMessages?: unknown[];\r\n  } {\r\n    const hasLegacyMessagesKey = Object.prototype.hasOwnProperty.call(\r\n      params as unknown as Record<string, unknown>,\r\n      'messages',\r\n    );\r\n    const legacyMessagesValue = (params as { messages?: unknown }).messages;\r\n    const legacyArray = Array.isArray(legacyMessagesValue)\r\n      ? (legacyMessagesValue as unknown[])\r\n      : undefined;\r\n    const promptArray = Array.isArray(params.prompt)\r\n      ? (params.prompt as unknown[])\r\n      : undefined;\r\n    const sourceMessages = legacyArray ?? promptArray;\r\n    return {\r\n      hasLegacyMessagesKey,\r\n      legacyMessagesValue,\r\n      legacyArray,\r\n      promptArray,\r\n      sourceMessages,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Derives the exact message slice forwarded to the optimization routine.\r\n   *\r\n   * Heuristic: When no legacy array is present and the prompt's first element lacks\r\n   * an `id` but the second possesses one, treat the first as a synthetic leading\r\n   * instruction (e.g., a system bootstrap message) and drop it *iff* either:\r\n   * - Tool scanning was explicitly enabled/disabled (explicit config intent), OR\r\n   * - The model parameter was specified as a primitive string (common in tests &\r\n   *   simpler call sites lacking richer model metadata).\r\n   *\r\n   * Returns the modified or original array unchanged when conditions are not met.\r\n   */\r\n  function buildOptimizerInput(\r\n    legacyArray: unknown[] | undefined,\r\n    promptArray: unknown[] | undefined,\r\n    params: ExtendedCallOptions,\r\n  ): unknown[] | undefined {\r\n    if (!legacyArray && Array.isArray(promptArray) && promptArray.length > 0) {\r\n      const first = promptArray[0] as Record<string, unknown> | undefined;\r\n      const second = promptArray[1] as Record<string, unknown> | undefined;\r\n      if (!first?.id && second?.id) {\r\n        const paramModel = (params as unknown as { model?: unknown }).model;\r\n        const needsSlice =\r\n          enableToolScanningExplicit ||\r\n          typeof paramModel === 'string' ||\r\n          typeof paramModel === 'undefined';\r\n        if (needsSlice) return promptArray.slice(1) as unknown[];\r\n      }\r\n    }\r\n    return legacyArray ?? promptArray;\r\n  }\r\n\r\n  /**\r\n   * Step 2: Message Optimization & Legacy Reconciliation.\r\n   *\r\n   * Responsibilities:\r\n   * 1. Determine the canonical source message array (legacy `messages` vs. `prompt`).\r\n   * 2. Decide if optimization should occur (feature enabled, op type generate, meets\r\n   *    threshold).\r\n   * 3. Invoke the tool-aware summarization function, capturing metrics and falling\r\n   *    back gracefully on failure.\r\n   * 4. Reconstruct a return shape preserving (or reintroducing) the legacy `messages`\r\n   *    property when it existed on input so downstream middleware/tests remain stable.\r\n   *\r\n   * Optimization Decision Inputs:\r\n   * - `enableMessageOptimization`\r\n   * - Operation type (only for generate)\r\n   * - `optimizationThreshold` minimum count check\r\n   *\r\n   * Metrics:\r\n   * - Records success attempts in `messageOptimizationHistogram` with original &\r\n   *   optimized counts.\r\n   *\r\n   * Returns an `OptimizationResult` describing the final params and whether an\r\n   * optimization path was actually applied.\r\n   */\r\n  async function optimizeMessagesStep(\r\n    params: ExtendedCallOptions,\r\n    model: LanguageModelV2 | string | undefined,\r\n    opType: 'generate' | 'stream',\r\n    attributes: Record<string, string>,\r\n  ): Promise<OptimizationResult> {\r\n    const {\r\n      hasLegacyMessagesKey,\r\n      legacyMessagesValue,\r\n      legacyArray,\r\n      promptArray,\r\n      sourceMessages,\r\n    } = selectSourceMessages(params);\r\n\r\n    if (hasLegacyMessagesKey && !Array.isArray(legacyMessagesValue)) {\r\n      return {\r\n        result: {\r\n          ...(params as ExtendedCallOptions),\r\n          prompt: legacyMessagesValue as LanguageModelV2CallOptions['prompt'],\r\n          messages: legacyMessagesValue as unknown[],\r\n        },\r\n        applied: false,\r\n        earlyReturn: true,\r\n      };\r\n    }\r\n    if (!sourceMessages) {\r\n      return {\r\n        result: params as ExtendedCallOptions,\r\n        applied: false,\r\n        earlyReturn: true,\r\n      };\r\n    }\r\n\r\n    const optimizerInput = buildOptimizerInput(\r\n      legacyArray,\r\n      promptArray,\r\n      params,\r\n    ) as unknown[];\r\n\r\n    const shouldOptimize =\r\n      enableMessageOptimization &&\r\n      opType === 'generate' &&\r\n      Array.isArray(optimizerInput) &&\r\n      optimizerInput.length >= optimizationThreshold;\r\n\r\n    if (!shouldOptimize) {\r\n      if (!hasLegacyMessagesKey) {\r\n        return {\r\n          result: params as ExtendedCallOptions,\r\n          applied: false,\r\n          earlyReturn: false,\r\n          sourceCount: sourceMessages.length,\r\n        };\r\n      }\r\n      return {\r\n        result: {\r\n          ...(params as ExtendedCallOptions),\r\n          prompt: sourceMessages as LanguageModelV2CallOptions['prompt'],\r\n          messages: sourceMessages,\r\n        },\r\n        applied: false,\r\n        earlyReturn: false,\r\n        sourceCount: sourceMessages.length,\r\n      };\r\n    }\r\n\r\n    let optimizedMessages = sourceMessages;\r\n    try {\r\n      const modelId =\r\n        typeof model === 'string'\r\n          ? model\r\n          : (model as { modelId?: string } | undefined)?.modelId || 'unknown';\r\n      const optimizedCandidate = await optimizeMessagesWithToolSummarization(\r\n        optimizerInput as unknown as never,\r\n        modelId,\r\n        userId,\r\n        chatHistoryId,\r\n      );\r\n      optimizedMessages = optimizedCandidate as unknown[];\r\n      messageOptimizationHistogram.record(1, {\r\n        ...attributes,\r\n        model: modelId,\r\n        original_messages: sourceMessages.length,\r\n        optimized_messages: optimizedMessages.length,\r\n      });\r\n      log((l) =>\r\n        l.info('Message optimization applied', {\r\n          originalMessages: sourceMessages.length,\r\n          optimizedMessages: optimizedMessages.length,\r\n          modelId,\r\n          userId,\r\n          chatHistoryId,\r\n        }),\r\n      );\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'ToolOptimizingMiddleware.messageOptimization',\r\n        message: 'Failed to optimize messages',\r\n        data: {\r\n          userId,\r\n          chatHistoryId,\r\n          messageCount: sourceMessages.length,\r\n          modelId:\r\n            typeof model === 'string' ? model : model?.modelId || 'unknown',\r\n        },\r\n      });\r\n      // keep original messages on failure\r\n      optimizedMessages = sourceMessages;\r\n    }\r\n\r\n    const resultParams: ExtendedCallOptions = {\r\n      ...(params as ExtendedCallOptions),\r\n      prompt: optimizedMessages as LanguageModelV2CallOptions['prompt'],\r\n    };\r\n    if (hasLegacyMessagesKey) resultParams.messages = optimizedMessages;\r\n    return {\r\n      result: resultParams,\r\n      applied:\r\n        optimizedMessages !== sourceMessages ||\r\n        optimizerInput !== sourceMessages, // best-effort marker\r\n      earlyReturn: false,\r\n      sourceCount: sourceMessages.length,\r\n      optimizedCount: optimizedMessages.length,\r\n    };\r\n  }\r\n\r\n  const middleware: ExtendedToolOptimizingMiddleware = {\r\n    transformParams: async (options) => {\r\n      const { type, params, model } = options;\r\n      const opType: 'generate' | 'stream' =\r\n        type === 'stream' || type === 'streamText' ? 'stream' : 'generate';\r\n      const startTime = Date.now();\r\n      const attributes = {\r\n        user_id: userId ? hashUserId(userId) : 'anonymous',\r\n        chat_id: chatHistoryId || 'unknown',\r\n      };\r\n\r\n      try {\r\n        toolOptimizationCounter.add(1, attributes);\r\n        log((l) =>\r\n          l.debug('Tool optimizing middleware transformParams', {\r\n            enableToolScanning,\r\n            enableMessageOptimization,\r\n            userId,\r\n            chatHistoryId,\r\n          }),\r\n        );\r\n\r\n        // Step 1\r\n        const newToolsCount = await performToolScanning(\r\n          params as ExtendedCallOptions,\r\n          attributes,\r\n        );\r\n\r\n        // Step 2\r\n        const optimization = await optimizeMessagesStep(\r\n          params as ExtendedCallOptions,\r\n          model,\r\n          opType,\r\n          attributes,\r\n        );\r\n\r\n        if (!optimization.earlyReturn) {\r\n          const duration = Date.now() - startTime;\r\n          toolOptimizationDurationHistogram.record(duration, {\r\n            ...attributes,\r\n            optimization_applied: String(optimization.applied),\r\n            new_tools_found: newToolsCount,\r\n          });\r\n          log((l) =>\r\n            l.debug('Tool optimizing middleware completed', {\r\n              duration,\r\n              newToolsFound: newToolsCount,\r\n              optimizationApplied: optimization.applied,\r\n              originalMessageCount: optimization.sourceCount,\r\n              optimizedMessageCount: optimization.optimizedCount,\r\n            }),\r\n          );\r\n        }\r\n\r\n        return optimization.result;\r\n      } catch (error) {\r\n        const duration = Date.now() - startTime;\r\n        toolOptimizationDurationHistogram.record(duration, {\r\n          ...attributes,\r\n          status: 'error',\r\n        });\r\n        LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n          log: true,\r\n          source: 'ToolOptimizingMiddleware.transformParams',\r\n          message: 'Unexpected error in tool optimizing middleware',\r\n          data: { userId, chatHistoryId },\r\n        });\r\n        const legacyParams = params as unknown as {\r\n          messages?: unknown;\r\n          prompt?: unknown;\r\n        };\r\n        if (legacyParams.messages && !legacyParams.prompt) {\r\n          legacyParams.prompt = legacyParams.messages;\r\n        }\r\n        return params as ExtendedCallOptions;\r\n      }\r\n    },\r\n  };\r\n\r\n  return middleware;\r\n}\r\n\r\n/**\r\n * Export metrics collection for observability integration\r\n */\r\nexport const getToolOptimizingMiddlewareMetrics = () => {\r\n  return {\r\n    counters: {\r\n      tool_optimization_middleware_total:\r\n        'ai_tool_optimization_middleware_total',\r\n      tool_scanning_total: 'ai_tool_scanning_total',\r\n      message_optimization_enabled_total:\r\n        'ai_message_optimization_enabled_total',\r\n    },\r\n    histograms: {\r\n      tool_optimization_middleware_duration_ms:\r\n        'ai_tool_optimization_middleware_duration_ms',\r\n      new_tools_found_count: 'ai_new_tools_found_count',\r\n    },\r\n  };\r\n};\r\n\r\n/**\r\n * Re-export types and utilities for convenience\r\n */\r\nexport { ToolMap } from '@/lib/ai/services/model-stats/tool-map';\r\nexport { optimizeMessagesWithToolSummarization } from '@/lib/ai/chat/message-optimizer-tools';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\chat\\errors\\AbortChatMessageRequestError.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\chat\\errors\\MessageTooLargeForQueueError.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\chat\\errors\\abort-chat-message-request-error.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":55,"column":1,"nodeType":"Program","endLine":97,"endColumn":2}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview AbortChatMessageRequestError - Custom error for handling aborted chat message requests\r\n * \r\n * This module provides a specialized error class for scenarios where chat message requests\r\n * are intentionally aborted or cancelled. This is commonly used in AI chat applications\r\n * where users may cancel long-running requests or when the application needs to terminate\r\n * requests due to timeouts or other conditions.\r\n * \r\n * @module AbortChatMessageRequestError\r\n * @version 1.0.0\r\n * @since 1.0.0\r\n * \r\n * @example\r\n * ```typescript\r\n * import { AbortChatMessageRequestError } from './AbortChatMessageRequestError';\r\n * \r\n * // Throwing the error\r\n * throw new AbortChatMessageRequestError('req-123');\r\n * \r\n * // Catching and handling the error\r\n * try {\r\n *   await sendChatMessage(message);\r\n * } catch (error) {\r\n *   if (error instanceof AbortChatMessageRequestError) {\r\n *     console.log(`Request ${error.requestId} was cancelled`);\r\n *   }\r\n * }\r\n * ```\r\n */\r\n\r\n/**\r\n * Custom error thrown when a chat message request is aborted or cancelled.\r\n * \r\n * This error is typically thrown in the following scenarios:\r\n * - User manually cancels a chat request\r\n * - Request times out and is automatically aborted\r\n * - System cancels request due to resource constraints\r\n * - Request is superseded by a newer request\r\n * \r\n * @class AbortChatMessageRequestError\r\n * @extends Error\r\n * \r\n * @example\r\n * ```typescript\r\n * // Creating and throwing the error\r\n * const error = new AbortChatMessageRequestError('chat-req-456');\r\n * throw error;\r\n * \r\n * // Accessing error properties\r\n * console.log(error.name);        // 'AbortChatMessageRequestError'\r\n * console.log(error.message);     // 'Chat message request chat-req-456 was aborted'\r\n * console.log(error.requestId);   // 'chat-req-456'\r\n * ```\r\n */\r\nexport class AbortChatMessageRequestError extends Error {\r\n  /**\r\n   * The name of the error class, always set to 'AbortChatMessageRequestError'.\r\n   * This property is useful for error identification and logging.\r\n   * \r\n   * @readonly\r\n   * @type {string}\r\n   */\r\n  public readonly name = 'AbortChatMessageRequestError';\r\n\r\n  /**\r\n   * Creates a new AbortChatMessageRequestError instance.\r\n   * \r\n   * @param requestId - The unique identifier of the chat message request that was aborted.\r\n   *                   This should be a meaningful identifier that can be used for tracking\r\n   *                   and debugging purposes.\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // With a UUID-style request ID\r\n   * const error1 = new AbortChatMessageRequestError('550e8400-e29b-41d4-a716-446655440000');\r\n   * \r\n   * // With a custom request ID\r\n   * const error2 = new AbortChatMessageRequestError('chat-session-123-msg-456');\r\n   * \r\n   * // With a simple numeric ID\r\n   * const error3 = new AbortChatMessageRequestError('12345');\r\n   * ```\r\n   */\r\n  constructor(\r\n    /**\r\n     * The unique identifier of the aborted chat message request.\r\n     * This identifier should be meaningful for debugging and request tracking.\r\n     * \r\n     * @readonly\r\n     * @type {string}\r\n     */\r\n    public readonly requestId: string\r\n  ) {\r\n    super(`Chat message request ${requestId} was aborted`);\r\n    this.name = 'AbortChatMessageRequestError';\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\chat\\errors\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":5,"column":1,"nodeType":"Program","endLine":6,"endColumn":83}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Error classes for chat services\r\n */\r\n\r\nexport { MessageTooLargeForQueueError } from './message-too-large-for-queue-error';\r\nexport { AbortChatMessageRequestError } from './abort-chat-message-request-error';","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\chat\\errors\\message-too-large-for-queue-error.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":68,"column":1,"nodeType":"Program","endLine":131,"endColumn":2}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview MessageTooLargeForQueueError - Custom error for handling oversized chat messages\r\n * \r\n * This module provides a specialized error class for scenarios where chat messages exceed\r\n * the maximum token limits for AI language models. This is critical for managing costs,\r\n * preventing API failures, and ensuring optimal performance in AI chat applications.\r\n * \r\n * Different AI models have varying token limits:\r\n * - GPT-3.5-turbo: ~4,096 tokens\r\n * - GPT-4: ~8,192 tokens  \r\n * - GPT-4-turbo: ~128,000 tokens\r\n * - Claude-3: ~200,000 tokens\r\n * \r\n * @module MessageTooLargeForQueueError\r\n * @version 1.0.0\r\n * @since 1.0.0\r\n * \r\n * @example\r\n * ```typescript\r\n * import { MessageTooLargeForQueueError } from './MessageTooLargeForQueueError';\r\n * \r\n * // Throwing the error\r\n * throw new MessageTooLargeForQueueError(5000, 4096, 'gpt-3.5-turbo');\r\n * \r\n * // Catching and handling the error\r\n * try {\r\n *   await processMessage(largeMessage);\r\n * } catch (error) {\r\n *   if (error instanceof MessageTooLargeForQueueError) {\r\n *     console.log(`Message too large: ${error.tokenCount}/${error.maxTokens} tokens`);\r\n *     // Handle by chunking, summarizing, or rejecting\r\n *   }\r\n * }\r\n * ```\r\n */\r\n\r\n/**\r\n * Custom error thrown when a chat message exceeds the maximum token limit for a language model.\r\n * \r\n * This error provides detailed information about the size violation, including:\r\n * - The actual token count of the message\r\n * - The maximum allowed tokens for the model\r\n * - The specific model type that has the limit\r\n * \r\n * Common scenarios where this error occurs:\r\n * - User submits extremely long text input\r\n * - System attempts to process document that exceeds model capacity\r\n * - Conversation history grows beyond model's context window\r\n * - Prompt engineering results in oversized requests\r\n * \r\n * @class MessageTooLargeForQueueError\r\n * @extends Error\r\n * \r\n * @example\r\n * ```typescript\r\n * // Creating and throwing the error\r\n * const error = new MessageTooLargeForQueueError(10000, 8192, 'gpt-4');\r\n * throw error;\r\n * \r\n * // Accessing error properties\r\n * console.log(error.name);         // 'MessageTooLargeForQueueError'\r\n * console.log(error.tokenCount);   // 10000\r\n * console.log(error.maxTokens);    // 8192\r\n * console.log(error.modelType);    // 'gpt-4'\r\n * console.log(error.message);      // 'Message with 10000 tokens exceeds maximum allowed 8192 tokens for model gpt-4'\r\n * ```\r\n */\r\nexport class MessageTooLargeForQueueError extends Error {\r\n  /**\r\n   * The name of the error class, always set to 'MessageTooLargeForQueueError'.\r\n   * This property is useful for error identification, logging, and type guards.\r\n   * \r\n   * @readonly\r\n   * @type {string}\r\n   */\r\n  public readonly name = 'MessageTooLargeForQueueError';\r\n\r\n  /**\r\n   * Creates a new MessageTooLargeForQueueError instance.\r\n   * \r\n   * @param tokenCount - The actual number of tokens in the message that exceeded the limit.\r\n   *                    This count typically includes both input tokens and any system/context tokens.\r\n   * @param maxTokens - The maximum number of tokens allowed for the specified model.\r\n   *                   This limit is model-specific and may include both input and output token reserves.\r\n   * @param modelType - The identifier or name of the AI model that has the token limit.\r\n   *                   Should be a recognizable model name (e.g., 'gpt-4', 'claude-3-opus', 'gemini-pro').\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // For GPT-4 with standard limit\r\n   * const error1 = new MessageTooLargeForQueueError(10000, 8192, 'gpt-4');\r\n   * \r\n   * // For custom model with specific limits\r\n   * const error2 = new MessageTooLargeForQueueError(150000, 128000, 'gpt-4-turbo');\r\n   * \r\n   * // For enterprise model with higher limits\r\n   * const error3 = new MessageTooLargeForQueueError(250000, 200000, 'claude-3-opus');\r\n   * ```\r\n   */\r\n  constructor(\r\n    /**\r\n     * The actual number of tokens in the oversized message.\r\n     * This includes all tokens from the user input, system prompts, and conversation history.\r\n     * \r\n     * @readonly\r\n     * @type {number}\r\n     */\r\n    public readonly tokenCount: number,\r\n    \r\n    /**\r\n     * The maximum number of tokens allowed for the target model.\r\n     * This represents the hard limit imposed by the AI service or internal constraints.\r\n     * \r\n     * @readonly\r\n     * @type {number}\r\n     */\r\n    public readonly maxTokens: number,\r\n    \r\n    /**\r\n     * The identifier of the AI model that has the token limitation.\r\n     * Should be a clear, recognizable model name for debugging and routing purposes.\r\n     * \r\n     * @readonly\r\n     * @type {string}\r\n     */\r\n    public readonly modelType: string\r\n  ) {\r\n    super(`Message with ${tokenCount} tokens exceeds maximum allowed ${maxTokens} tokens for model ${modelType}`);\r\n    this.name = 'MessageTooLargeForQueueError';\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\chat\\errors\\model-resource-not-found-error.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\chat\\errors\\resource-not-found-error.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":4,"column":1,"nodeType":"Program","endLine":63,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Domain-specific error for missing model resources (provider or model).\r\n */\r\nimport { isError } from '@/lib/react-util/utility-methods';\r\n\r\n// Extendable union of resource categories that can be \"not found\" in AI services\r\nexport type ModelResourceType = 'provider' | 'model' | 'tool' | 'model-quota';\r\n\r\nexport interface ModelResourceNotFoundOptions {\r\n  /** The kind of resource missing */\r\n  resourceType: ModelResourceType;\r\n  /** Normalized value used for the lookup (e.g., provider name, providerId:modelName) */\r\n  normalized: unknown;\r\n  /** Raw, unnormalized input that led to the lookup */\r\n  inputRaw: unknown;\r\n  /** Short message describing the source of the failure */\r\n  message: string;\r\n  /** Optional inner error to preserve original exception */\r\n  cause?: unknown;\r\n}\r\n\r\nexport class ResourceNotFoundError extends Error {\r\n  readonly name = 'ResourceNotFoundError';\r\n  readonly resourceType: ModelResourceType;\r\n  readonly normalized: unknown;\r\n  readonly inputRaw: unknown;\r\n  readonly shortMessage: string;\r\n\r\n  constructor(options: ModelResourceNotFoundOptions) {\r\n    super(options.message, { cause: options.cause });\r\n    this.resourceType = options.resourceType;\r\n    this.normalized = options.normalized;\r\n    this.inputRaw = options.inputRaw;\r\n    this.shortMessage = options.message;\r\n  }\r\n}\r\n\r\n/**\r\n * Type guard for ResourceNotFoundError supporting instance and duck-typed detection.\r\n */\r\nexport function isResourceNotFoundError(\r\n  e: unknown,\r\n): e is ResourceNotFoundError {\r\n  if (!isError(e)) return false;\r\n  const anyErr = e as Partial<{\r\n    name: unknown;\r\n    resourceType: unknown;\r\n    normalized: unknown;\r\n    inputRaw: unknown;\r\n    shortMessage: unknown;\r\n  }>;\r\n  if (anyErr.name === 'ResourceNotFoundError') return true;\r\n  // Duck typing: check required properties\r\n  const rt = anyErr.resourceType;\r\n  const hasRT = rt === 'provider' || rt === 'model';\r\n  return (\r\n    hasRT &&\r\n    'normalized' in anyErr &&\r\n    'inputRaw' in anyErr &&\r\n    typeof anyErr.shortMessage === 'string'\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\chat\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":5,"column":1,"nodeType":"Program","endLine":6,"endColumn":46}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Chat services exports\r\n */\r\n\r\nexport { LanguageModelQueue } from './language-model-queue/queue';\r\nexport * from './language-model-queue/types';","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\chat\\language-model-queue\\queue.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":8,"column":1,"nodeType":"Program","endLine":837,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'request' is defined but never used.","line":603,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":603,"endColumn":34,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview FIFO rate-aware language model queue implementation\r\n *\r\n * This class provides a queue-based system for processing language model requests\r\n * while respecting rate limits and providing intelligent request scheduling.\r\n */\r\n\r\nimport { LanguageModelV2 } from '@ai-sdk/provider';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { getRedisClient } from '../../../middleware/cacheWithRedis/redis-client';\r\nimport { countTokens } from '../../../core/count-tokens';\r\nimport { auth } from '@/auth';\r\nimport { log } from '@/lib/logger';\r\nimport type {\r\n  LanguageModelQueueOptions,\r\n  QueuedRequest,\r\n  LanguageModelMethod,\r\n  ModelCapacity,\r\n  RateLimitInfo,\r\n  QueueMetrics,\r\n} from './types';\r\nimport { MessageTooLargeForQueueError } from '../errors';\r\nimport { ModelMap } from '../../model-stats/model-map';\r\n\r\nconst REDIS_PREFIX = 'language-model-queue';\r\nconst FIFO_CHATQUEUE_QUEUE_EXPIRATION_HOURS = 6;\r\nconst FIFO_CHATQUEUE_QUEUE_EXPIRATION_SECONDS =\r\n  FIFO_CHATQUEUE_QUEUE_EXPIRATION_HOURS * 60 * 60;\r\nconst FIFO_CHATQUEUE_MESSAGE_STALE_TIMEOUT = 5 * 60 * 1000;\r\nconst FIFO_CHATQUEUE_OUTPUT_TOKEN_BUFFER = 1500; // Reserved tokens for response\r\n\r\n/**\r\n * FIFO rate-aware language model queue\r\n *\r\n * Manages queued requests to language models with intelligent rate limiting,\r\n * FIFO processing with capacity-aware skipping, and comprehensive error handling.\r\n */\r\nexport class LanguageModelQueue {\r\n  private readonly model: LanguageModelV2;\r\n  private readonly maxConcurrentRequests: number;\r\n  private readonly _queueInstanceId: string;\r\n  private readonly modelType: string;\r\n  private processingInterval?: NodeJS.Timeout;\r\n  private abortControllers = new Map<string, AbortController>();\r\n\r\n  constructor(options: LanguageModelQueueOptions) {\r\n    this.model = options.model;\r\n    this.maxConcurrentRequests = options.maxConcurrentRequests;\r\n    this._queueInstanceId = uuidv4();\r\n    this.modelType = this.extractModelType(options.model);\r\n\r\n    log((l) =>\r\n      l.info('LanguageModelQueue initialized', {\r\n        modelType: this.modelType,\r\n        maxConcurrentRequests: this.maxConcurrentRequests,\r\n        queueInstanceId: this._queueInstanceId,\r\n      }),\r\n    );\r\n\r\n    // Start processing loop\r\n    this.startProcessing();\r\n  }\r\n\r\n  /**\r\n   * Get the readonly queue instance ID\r\n   */\r\n  get queueInstanceId(): string {\r\n    return this._queueInstanceId;\r\n  }\r\n\r\n  /**\r\n   * Extract model type from LanguageModel instance\r\n   */\r\n  private extractModelType(model: LanguageModelV2): string {\r\n    // Try to extract from the model's provider and model ID\r\n    if ('provider' in model && 'modelId' in model) {\r\n      const modelWithProps = model as { provider: string; modelId: string };\r\n      return `${modelWithProps.provider}:${modelWithProps.modelId}`;\r\n    }\r\n    // Fallback to a generic identifier\r\n    return 'unknown-model';\r\n  }\r\n\r\n  /**\r\n   * Generate Redis keys for queue operations\r\n   */\r\n  private getQueueKey(): string {\r\n    return `${REDIS_PREFIX}:queue:${this.modelType}`;\r\n  }\r\n\r\n  private getCapacityKey(): string {\r\n    return `${REDIS_PREFIX}:capacity:${this.modelType}`;\r\n  }\r\n\r\n  private getProcessingKey(): string {\r\n    return `${REDIS_PREFIX}:processing:${this.modelType}`;\r\n  }\r\n\r\n  /**\r\n   * Get current user ID from auth\r\n   */\r\n  private async getCurrentUserId(): Promise<string> {\r\n    try {\r\n      const session = await auth();\r\n      return session?.user?.id || 'anonymous';\r\n    } catch (error) {\r\n      log((l) => l.warn('Failed to get user ID from auth', { error }));\r\n      return 'anonymous';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get model token per minute limit from the models table\r\n   */\r\n  private async getModelTokenLimit(): Promise<number> {\r\n    try {\r\n      const quotaRecord = await (\r\n        await ModelMap.getInstance()\r\n      ).getModelFromLanguageModel(this.model);\r\n      // This would need to be implemented to query the models table\r\n      // For now, return a reasonable default\r\n      // TODO: Implement actual database query to get model limits\r\n      return quotaRecord?.quota?.maxTokensPerMinute || 50000; // Default limit\r\n    } catch (error) {\r\n      log((l) => l.warn('Failed to get model token limit', { error }));\r\n      return 10000; // Conservative fallback\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate that a message isn't too large for the queue\r\n   */\r\n  private async validateMessageSize(tokenCount: number): Promise<void> {\r\n    const maxTokensPerMinute = await this.getModelTokenLimit();\r\n    const maxAllowedTokens =\r\n      maxTokensPerMinute - FIFO_CHATQUEUE_OUTPUT_TOKEN_BUFFER;\r\n\r\n    if (tokenCount > maxAllowedTokens) {\r\n      throw new MessageTooLargeForQueueError(\r\n        tokenCount,\r\n        maxAllowedTokens,\r\n        this.modelType,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a queued request object\r\n   */\r\n  private async createQueuedRequest(\r\n    method: LanguageModelMethod,\r\n    params: unknown,\r\n    tokenCount: number,\r\n  ): Promise<QueuedRequest> {\r\n    const userId = await this.getCurrentUserId();\r\n\r\n    return {\r\n      id: uuidv4(),\r\n      modelType: this.modelType,\r\n      method,\r\n      params,\r\n      tokenCount,\r\n      userId,\r\n      status: 'pending',\r\n      queuedAt: new Date().toISOString(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Add a request to the Redis queue\r\n   */\r\n  private async enqueueRequest(request: QueuedRequest): Promise<void> {\r\n    const redis = await getRedisClient();\r\n    const queueKey = this.getQueueKey();\r\n\r\n    await redis\r\n      .multi()\r\n      .lPush(queueKey, JSON.stringify(request))\r\n      .expire(queueKey, FIFO_CHATQUEUE_QUEUE_EXPIRATION_SECONDS)\r\n      .exec();\r\n\r\n    log((l) =>\r\n      l.info('Request enqueued', {\r\n        requestId: request.id,\r\n        method: request.method,\r\n        tokenCount: request.tokenCount,\r\n        queueInstanceId: this._queueInstanceId,\r\n      }),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get the current model capacity from Redis\r\n   */\r\n  private async getModelCapacity(): Promise<ModelCapacity | null> {\r\n    try {\r\n      const redis = await getRedisClient();\r\n      const capacityKey = this.getCapacityKey();\r\n      const data = await redis.get(capacityKey);\r\n\r\n      if (!data) {\r\n        return null;\r\n      }\r\n\r\n      return JSON.parse(data) as ModelCapacity;\r\n    } catch (error) {\r\n      log((l) => l.warn('Failed to get model capacity', { error }));\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update model capacity in Redis\r\n   */\r\n  private async updateModelCapacity(capacity: ModelCapacity): Promise<void> {\r\n    try {\r\n      const redis = await getRedisClient();\r\n      const capacityKey = this.getCapacityKey();\r\n\r\n      await redis\r\n        .multi()\r\n        .set(capacityKey, JSON.stringify(capacity))\r\n        .expire(capacityKey, FIFO_CHATQUEUE_QUEUE_EXPIRATION_SECONDS)\r\n        .exec();\r\n    } catch (error) {\r\n      log((l) => l.warn('Failed to update model capacity', { error }));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract rate limit information from response headers\r\n   */\r\n  private extractRateLimitInfo(\r\n    headers: Record<string, string | string[]>,\r\n  ): RateLimitInfo {\r\n    const info: RateLimitInfo = {};\r\n\r\n    const remainingTokens = headers['x-ratelimit-remaining-tokens'];\r\n    if (remainingTokens) {\r\n      info.remainingTokens = parseInt(\r\n        Array.isArray(remainingTokens) ? remainingTokens[0] : remainingTokens,\r\n      );\r\n    }\r\n\r\n    const remainingRequests = headers['x-ratelimit-remaining-requests'];\r\n    if (remainingRequests) {\r\n      info.remainingRequests = parseInt(\r\n        Array.isArray(remainingRequests)\r\n          ? remainingRequests[0]\r\n          : remainingRequests,\r\n      );\r\n    }\r\n\r\n    const retryAfter = headers['x-retry-after'];\r\n    if (retryAfter) {\r\n      info.retryAfter = Array.isArray(retryAfter) ? retryAfter[0] : retryAfter;\r\n    }\r\n\r\n    return info;\r\n  }\r\n\r\n  /**\r\n   * Check if the model has capacity to process a request\r\n   */\r\n  private async hasCapacity(tokenCount: number): Promise<boolean> {\r\n    const capacity = await this.getModelCapacity();\r\n\r\n    if (!capacity) {\r\n      // No capacity data available, assume we have capacity\r\n      return true;\r\n    }\r\n\r\n    // Check if we're still in a rate limit period\r\n    if (capacity.resetAt) {\r\n      const resetTime = new Date(capacity.resetAt);\r\n      if (new Date() < resetTime) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // Check token capacity\r\n    const requiredTokens = tokenCount + FIFO_CHATQUEUE_OUTPUT_TOKEN_BUFFER;\r\n    return capacity.tokensPerMinute >= requiredTokens;\r\n  }\r\n\r\n  /**\r\n   * Generate text using the underlying model\r\n   */\r\n  async generateText(params: unknown, signal?: AbortSignal): Promise<unknown> {\r\n    return this.processRequest('generateText', params, signal);\r\n  }\r\n\r\n  /**\r\n   * Generate object using the underlying model\r\n   */\r\n  async generateObject(\r\n    params: unknown,\r\n    signal?: AbortSignal,\r\n  ): Promise<unknown> {\r\n    return this.processRequest('generateObject', params, signal);\r\n  }\r\n\r\n  /**\r\n   * Stream text using the underlying model\r\n   */\r\n  async streamText(params: unknown, signal?: AbortSignal): Promise<unknown> {\r\n    return this.processRequest('streamText', params, signal);\r\n  }\r\n\r\n  /**\r\n   * Stream object using the underlying model\r\n   */\r\n  async streamObject(params: unknown, signal?: AbortSignal): Promise<unknown> {\r\n    return this.processRequest('streamObject', params, signal);\r\n  }\r\n\r\n  /**\r\n   * Process a request by adding it to the queue and waiting for completion\r\n   */\r\n  private async processRequest(\r\n    method: LanguageModelMethod,\r\n    params: unknown,\r\n    signal?: AbortSignal,\r\n  ): Promise<unknown> {\r\n    // Count tokens in the request\r\n    const tokenCount = this.estimateTokenCount(params);\r\n\r\n    // Validate message size\r\n    await this.validateMessageSize(tokenCount);\r\n\r\n    // Create queued request\r\n    const queuedRequest = await this.createQueuedRequest(\r\n      method,\r\n      params,\r\n      tokenCount,\r\n    );\r\n\r\n    // Set up abort handling\r\n    if (signal) {\r\n      this.abortControllers.set(queuedRequest.id, new AbortController());\r\n\r\n      signal.addEventListener('abort', () => {\r\n        this.handleAbort(queuedRequest.id);\r\n      });\r\n    }\r\n\r\n    // Enqueue the request\r\n    await this.enqueueRequest(queuedRequest);\r\n\r\n    // Return a promise that resolves when the request is processed\r\n    return new Promise((resolve, reject) => {\r\n      this.waitForRequestCompletion(queuedRequest.id, resolve, reject);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Estimate token count for request parameters\r\n   */\r\n  private estimateTokenCount(params: unknown): number {\r\n    try {\r\n      // Try to extract messages from params for token counting\r\n      if (params && typeof params === 'object' && 'messages' in params) {\r\n        const messages = (params as { messages: unknown }).messages;\r\n        if (Array.isArray(messages)) {\r\n          return countTokens({ prompt: messages });\r\n        }\r\n      }\r\n\r\n      // Fallback estimation based on string length\r\n      const str = JSON.stringify(params);\r\n      return Math.ceil(str.length / 4); // Rough estimation: 4 chars per token\r\n    } catch (error) {\r\n      log((l) => l.warn('Failed to count tokens, using fallback', { error }));\r\n      return 1000; // Conservative fallback\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle request abortion\r\n   */\r\n  private async handleAbort(requestId: string): Promise<void> {\r\n    try {\r\n      const redis = await getRedisClient();\r\n      const queueKey = this.getQueueKey();\r\n\r\n      // Remove the request from the queue\r\n      const requests = await redis.lRange(queueKey, 0, -1);\r\n      const filteredRequests = requests.filter((req) => {\r\n        try {\r\n          const parsed = JSON.parse(req) as QueuedRequest;\r\n          return parsed.id !== requestId;\r\n        } catch {\r\n          return true; // Keep unparseable requests\r\n        }\r\n      });\r\n\r\n      // Update the queue\r\n      await redis.del(queueKey);\r\n      if (filteredRequests.length > 0) {\r\n        await redis.lPush(queueKey, filteredRequests);\r\n        await redis.expire(queueKey, FIFO_CHATQUEUE_QUEUE_EXPIRATION_SECONDS);\r\n      }\r\n\r\n      // Clean up abort controller\r\n      this.abortControllers.delete(requestId);\r\n\r\n      log((l) => l.info('Request aborted', { requestId }));\r\n    } catch (error) {\r\n      log((l) => l.warn('Failed to handle abort', { requestId, error }));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Wait for a request to complete processing\r\n   */\r\n  private async waitForRequestCompletion(\r\n    requestId: string,\r\n    resolve: (value: unknown) => void,\r\n    reject: (reason: unknown) => void,\r\n  ): Promise<void> {\r\n    // This would be implemented to poll for completion or use pub/sub\r\n    // For now, this is a placeholder\r\n    setTimeout(() => {\r\n      reject(\r\n        new Error(\r\n          `Request processing not yet implemented for request ${requestId}`,\r\n        ),\r\n      );\r\n    }, 1000);\r\n  }\r\n\r\n  /**\r\n   * Start the processing loop\r\n   */\r\n  private startProcessing(): void {\r\n    this.processingInterval = setInterval(() => {\r\n      this.processQueue().catch((error) => {\r\n        log((l) => l.error('Error in processing loop', { error }));\r\n      });\r\n    }, 1000); // Process every second\r\n  }\r\n\r\n  /**\r\n   * Main queue processing logic\r\n   */\r\n  private async processQueue(): Promise<void> {\r\n    try {\r\n      // Get current queue state\r\n      const redis = await getRedisClient();\r\n      const queueKey = this.getQueueKey();\r\n      const requests = await redis.lRange(queueKey, 0, -1);\r\n\r\n      if (requests.length === 0) {\r\n        return; // Nothing to process\r\n      }\r\n\r\n      // Parse requests\r\n      const parsedRequests = requests\r\n        .map((req) => {\r\n          try {\r\n            return JSON.parse(req) as QueuedRequest;\r\n          } catch {\r\n            return null;\r\n          }\r\n        })\r\n        .filter((req) => req !== null) as QueuedRequest[];\r\n\r\n      // Filter to pending requests only\r\n      const pendingRequests = parsedRequests.filter(\r\n        (req) => req.status === 'pending',\r\n      );\r\n\r\n      if (pendingRequests.length === 0) {\r\n        return;\r\n      }\r\n\r\n      // Check how many are currently processing\r\n      const processingCount = parsedRequests.filter(\r\n        (req) => req.status === 'processing',\r\n      ).length;\r\n      const availableSlots = this.maxConcurrentRequests - processingCount;\r\n\r\n      if (availableSlots <= 0) {\r\n        return; // No available processing slots\r\n      }\r\n\r\n      // Process requests with FIFO + capacity-aware logic\r\n      await this.selectAndProcessRequests(pendingRequests, availableSlots);\r\n    } catch (error) {\r\n      log((l) => l.error('Error processing queue', { error }));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Select and process requests using FIFO with capacity-aware skipping\r\n   */\r\n  private async selectAndProcessRequests(\r\n    pendingRequests: QueuedRequest[],\r\n    availableSlots: number,\r\n  ): Promise<void> {\r\n    const requestsToProcess: QueuedRequest[] = [];\r\n    const now = new Date();\r\n\r\n    for (const request of pendingRequests) {\r\n      if (requestsToProcess.length >= availableSlots) {\r\n        break;\r\n      }\r\n\r\n      const hasCapacityForRequest = await this.hasCapacity(request.tokenCount);\r\n\r\n      if (hasCapacityForRequest) {\r\n        requestsToProcess.push(request);\r\n      } else {\r\n        // Check if we should wait for capacity to process this request due to the stale-message rule\r\n        const queuedTime = new Date(request.queuedAt);\r\n        const timeDiff = now.getTime() - queuedTime.getTime();\r\n\r\n        if (timeDiff > FIFO_CHATQUEUE_MESSAGE_STALE_TIMEOUT) {\r\n          // Don't skip requests older than 5 minutes\r\n          requestsToProcess.push(request);\r\n        }\r\n        // Otherwise skip this request and continue to the next\r\n      }\r\n    }\r\n\r\n    // Process selected requests\r\n    for (const request of requestsToProcess) {\r\n      await this.executeRequest(request);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute a single request\r\n   */\r\n  private async executeRequest(request: QueuedRequest): Promise<void> {\r\n    try {\r\n      // Mark as processing\r\n      await this.markRequestAsProcessing(request);\r\n\r\n      // Execute the actual model call\r\n      const result = await this.callModel(request);\r\n\r\n      // Handle successful completion\r\n      await this.handleRequestSuccess(request, result);\r\n    } catch (error) {\r\n      // Handle errors\r\n      await this.handleRequestError(request, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mark a request as processing\r\n   */\r\n  private async markRequestAsProcessing(request: QueuedRequest): Promise<void> {\r\n    const updatedRequest: QueuedRequest = {\r\n      ...request,\r\n      status: 'processing',\r\n      processingStartedAt: new Date().toISOString(),\r\n      processingQueueInstanceId: this._queueInstanceId,\r\n    };\r\n\r\n    await this.updateRequestInQueue(request.id, updatedRequest);\r\n  }\r\n\r\n  /**\r\n   * Update a request in the queue\r\n   */\r\n  private async updateRequestInQueue(\r\n    requestId: string,\r\n    updatedRequest: QueuedRequest,\r\n  ): Promise<void> {\r\n    const redis = await getRedisClient();\r\n    const queueKey = this.getQueueKey();\r\n\r\n    // Get all requests\r\n    const requests = await redis.lRange(queueKey, 0, -1);\r\n\r\n    // Update the specific request\r\n    const updatedRequests = requests.map((req) => {\r\n      try {\r\n        const parsed = JSON.parse(req) as QueuedRequest;\r\n        if (parsed.id === requestId) {\r\n          return JSON.stringify(updatedRequest);\r\n        }\r\n        return req;\r\n      } catch {\r\n        return req;\r\n      }\r\n    });\r\n\r\n    // Replace the queue\r\n    await redis.del(queueKey);\r\n    if (updatedRequests.length > 0) {\r\n      await redis.lPush(queueKey, updatedRequests);\r\n      await redis.expire(queueKey, FIFO_CHATQUEUE_QUEUE_EXPIRATION_SECONDS);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Call the underlying language model\r\n   */\r\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n  private async callModel(request: QueuedRequest): Promise<unknown> {\r\n    // This would implement the actual model calls\r\n    // For now, this is a placeholder\r\n    throw new Error('Model calling not yet implemented');\r\n  }\r\n\r\n  /**\r\n   * Handle successful request completion\r\n   */\r\n  private async handleRequestSuccess(\r\n    request: QueuedRequest,\r\n    result: unknown,\r\n  ): Promise<void> {\r\n    // Remove from queue\r\n    await this.removeRequestFromQueue(request.id);\r\n\r\n    // Update capacity based on response headers if available\r\n    if (result && typeof result === 'object' && 'rawResponse' in result) {\r\n      const rawResponse = (\r\n        result as {\r\n          rawResponse?: { headers?: Record<string, string | string[]> };\r\n        }\r\n      ).rawResponse;\r\n      if (rawResponse && rawResponse.headers) {\r\n        await this.updateCapacityFromHeaders(rawResponse.headers);\r\n      }\r\n    }\r\n\r\n    // Report metrics\r\n    await this.reportMetrics();\r\n\r\n    log((l) =>\r\n      l.info('Request completed successfully', { requestId: request.id }),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Handle request errors\r\n   */\r\n  private async handleRequestError(\r\n    request: QueuedRequest,\r\n    error: unknown,\r\n  ): Promise<void> {\r\n    const isRateLimitError = this.isRateLimitError(error);\r\n\r\n    if (isRateLimitError) {\r\n      // Reset request to pending and update capacity\r\n      const resetRequest: QueuedRequest = {\r\n        ...request,\r\n        status: 'pending',\r\n        processingStartedAt: undefined,\r\n        processingQueueInstanceId: undefined,\r\n      };\r\n\r\n      await this.updateRequestInQueue(request.id, resetRequest);\r\n      await this.handleRateLimitError(error);\r\n    } else {\r\n      // Remove from queue for non-rate-limit errors\r\n      await this.removeRequestFromQueue(request.id);\r\n    }\r\n\r\n    log((l) =>\r\n      l.error('Request failed', {\r\n        requestId: request.id,\r\n        error,\r\n        isRateLimitError,\r\n      }),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Remove a request from the queue\r\n   */\r\n  private async removeRequestFromQueue(requestId: string): Promise<void> {\r\n    const redis = await getRedisClient();\r\n    const queueKey = this.getQueueKey();\r\n\r\n    const requests = await redis.lRange(queueKey, 0, -1);\r\n    const filteredRequests = requests.filter((req) => {\r\n      try {\r\n        const parsed = JSON.parse(req) as QueuedRequest;\r\n        return parsed.id !== requestId;\r\n      } catch {\r\n        return true;\r\n      }\r\n    });\r\n\r\n    await redis.del(queueKey);\r\n    if (filteredRequests.length > 0) {\r\n      await redis.lPush(queueKey, filteredRequests);\r\n      await redis.expire(queueKey, FIFO_CHATQUEUE_QUEUE_EXPIRATION_SECONDS);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if an error is a rate limit error\r\n   */\r\n  private isRateLimitError(error: unknown): boolean {\r\n    if (error && typeof error === 'object') {\r\n      const errorObj = error as {\r\n        code?: string;\r\n        status?: number;\r\n        message?: string;\r\n        headers?: Record<string, string | string[]>;\r\n      };\r\n\r\n      // Check for common rate limit indicators\r\n      if (\r\n        errorObj.code === 'rate_limit_exceeded' ||\r\n        errorObj.status === 429 ||\r\n        (errorObj.message && errorObj.message.includes('rate limit'))\r\n      ) {\r\n        return true;\r\n      }\r\n\r\n      // Check for x-retry-after header presence\r\n      if (errorObj.headers && errorObj.headers['x-retry-after']) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Handle rate limit errors\r\n   */\r\n  private async handleRateLimitError(error: unknown): Promise<void> {\r\n    // Extract retry-after information\r\n    let retryAfter: string | undefined;\r\n\r\n    if (error && typeof error === 'object') {\r\n      const errorObj = error as { headers?: Record<string, string | string[]> };\r\n      if (errorObj.headers && errorObj.headers['x-retry-after']) {\r\n        retryAfter = Array.isArray(errorObj.headers['x-retry-after'])\r\n          ? errorObj.headers['x-retry-after'][0]\r\n          : errorObj.headers['x-retry-after'];\r\n      }\r\n    }\r\n\r\n    // Update capacity to indicate no tokens available\r\n    const capacity: ModelCapacity = {\r\n      tokensPerMinute: 0,\r\n      lastUpdated: new Date().toISOString(),\r\n      resetAt: retryAfter || new Date(Date.now() + 60000).toISOString(), // Default 1 minute\r\n    };\r\n\r\n    await this.updateModelCapacity(capacity);\r\n  }\r\n\r\n  /**\r\n   * Update capacity from response headers\r\n   */\r\n  private async updateCapacityFromHeaders(\r\n    headers: Record<string, string | string[]>,\r\n  ): Promise<void> {\r\n    const rateLimitInfo = this.extractRateLimitInfo(headers);\r\n\r\n    if (rateLimitInfo.remainingTokens !== undefined) {\r\n      const capacity: ModelCapacity = {\r\n        tokensPerMinute: rateLimitInfo.remainingTokens,\r\n        requestsPerMinute: rateLimitInfo.remainingRequests,\r\n        lastUpdated: new Date().toISOString(),\r\n        resetAt: rateLimitInfo.retryAfter,\r\n      };\r\n\r\n      await this.updateModelCapacity(capacity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Report metrics to Application Insights\r\n   */\r\n  private async reportMetrics(): Promise<void> {\r\n    try {\r\n      const redis = await getRedisClient();\r\n      const queueKey = this.getQueueKey();\r\n      const requests = await redis.lRange(queueKey, 0, -1);\r\n\r\n      const parsedRequests = requests\r\n        .map((req) => {\r\n          try {\r\n            return JSON.parse(req) as QueuedRequest;\r\n          } catch {\r\n            return null;\r\n          }\r\n        })\r\n        .filter((req) => req !== null) as QueuedRequest[];\r\n\r\n      const activeRequests = parsedRequests.filter(\r\n        (req) => req.status === 'processing',\r\n      ).length;\r\n      const queueSize = parsedRequests.length;\r\n\r\n      const capacity = await this.getModelCapacity();\r\n      const availableTokens = capacity?.tokensPerMinute || 0;\r\n\r\n      const metrics: QueueMetrics = {\r\n        activeRequests,\r\n        queueSize,\r\n        availableTokens,\r\n        queueInstanceId: this._queueInstanceId,\r\n        modelType: this.modelType,\r\n      };\r\n\r\n      // Report to Application Insights\r\n      log((l) => l.info('Queue metrics', metrics));\r\n    } catch (error) {\r\n      log((l) => l.warn('Failed to report metrics', { error }));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up resources\r\n   */\r\n  dispose(): void {\r\n    if (this.processingInterval) {\r\n      clearInterval(this.processingInterval);\r\n      this.processingInterval = undefined;\r\n    }\r\n\r\n    // Abort any pending requests\r\n    this.abortControllers.forEach((controller) => {\r\n      controller.abort();\r\n    });\r\n    this.abortControllers.clear();\r\n\r\n    log((l) =>\r\n      l.info('LanguageModelQueue disposed', {\r\n        queueInstanceId: this._queueInstanceId,\r\n      }),\r\n    );\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\chat\\language-model-queue\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":5,"column":1,"nodeType":"Program","endLine":98,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Types and error classes for the FIFO rate-aware model queue system\r\n */\r\n\r\nimport { LanguageModelV2 } from '@ai-sdk/provider';\r\n\r\n/**\r\n * Status of a queued request\r\n */\r\nexport type QueuedRequestStatus = 'pending' | 'processing';\r\n\r\n/**\r\n * Method type for language model operations\r\n */\r\nexport type LanguageModelMethod =\r\n  | 'generateText'\r\n  | 'generateObject'\r\n  | 'streamText'\r\n  | 'streamObject';\r\n\r\n/**\r\n * Configuration options for LanguageModelQueue constructor\r\n */\r\nexport interface LanguageModelQueueOptions {\r\n  /** The language model the queue is attached to */\r\n  model: LanguageModelV2;\r\n  /** Maximum number of concurrent requests the queue will run */\r\n  maxConcurrentRequests: number;\r\n}\r\n\r\n/**\r\n * A queued request record stored in Redis\r\n */\r\nexport interface QueuedRequest {\r\n  /** Unique request identifier */\r\n  id: string;\r\n  /** Model type from the LanguageModelV2 */\r\n  modelType: string;\r\n  /** Method used to queue the request */\r\n  method: LanguageModelMethod;\r\n  /** Request parameters */\r\n  params: unknown;\r\n  /** Number of tokens needed to process the request */\r\n  tokenCount: number;\r\n  /** User ID making the request */\r\n  userId: string;\r\n  /** Status of the request */\r\n  status: QueuedRequestStatus;\r\n  /** Datetime the request was added to the queue */\r\n  queuedAt: string;\r\n  /** Datetime processing began (only set when status is 'processing') */\r\n  processingStartedAt?: string;\r\n  /** Queue instance ID of the queue processing the request */\r\n  processingQueueInstanceId?: string;\r\n}\r\n\r\n/**\r\n * Model capacity tracking information\r\n */\r\nexport interface ModelCapacity {\r\n  /** Available tokens per minute */\r\n  tokensPerMinute: number;\r\n  /** Available requests per minute */\r\n  requestsPerMinute?: number;\r\n  /** Timestamp when capacity was last updated */\r\n  lastUpdated: string;\r\n  /** Timestamp when capacity will reset (for rate limit scenarios) */\r\n  resetAt?: string;\r\n}\r\n\r\n/**\r\n * Rate limit information from response headers\r\n */\r\nexport interface RateLimitInfo {\r\n  /** Remaining tokens from x-ratelimit-remaining-tokens header */\r\n  remainingTokens?: number;\r\n  /** Remaining requests from x-ratelimit-remaining-requests header */\r\n  remainingRequests?: number;\r\n  /** Retry after datetime from x-retry-after header */\r\n  retryAfter?: string;\r\n}\r\n\r\n/**\r\n * Queue processing metrics for Application Insights\r\n */\r\nexport interface QueueMetrics {\r\n  /** Number of requests currently being processed */\r\n  activeRequests: number;\r\n  /** Total number of requests in the queue */\r\n  queueSize: number;\r\n  /** Available model token capacity */\r\n  availableTokens: number;\r\n  /** Queue instance ID */\r\n  queueInstanceId: string;\r\n  /** Model type */\r\n  modelType: string;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\embedding\\EmbeddingService.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":59,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { EmbeddingModelV2 } from '@ai-sdk/provider';\r\nimport { createEmbeddingModel } from '../../aiModelFactory';\r\nimport { embed } from 'ai';\r\nimport { IEmbeddingService } from './types';\r\n\r\nexport class EmbeddingService implements IEmbeddingService {\r\n  /**\r\n   * Global embedding model stored in a Symbol-backed registry to avoid\r\n   * duplication across HMR/SSR/multi-bundle environments.\r\n   */\r\n  private static get globalEmbeddingModel(): EmbeddingModelV2<string> {\r\n    const GLOBAL_KEY = Symbol.for('@noeducation/embedding:Model');\r\n    const registry = globalThis as unknown as {\r\n      [key: symbol]: EmbeddingModelV2<string> | undefined;\r\n    };\r\n    if (!registry[GLOBAL_KEY]) {\r\n      registry[GLOBAL_KEY] = createEmbeddingModel();\r\n    }\r\n    return registry[GLOBAL_KEY]!;\r\n  }\r\n  private static set globalEmbeddingModel(model: EmbeddingModelV2<string>) {\r\n    const GLOBAL_KEY = Symbol.for('@noeducation/embedding:Model');\r\n    const registry = globalThis as unknown as {\r\n      [key: symbol]: EmbeddingModelV2<string> | undefined;\r\n    };\r\n    registry[GLOBAL_KEY] = model;\r\n  }\r\n\r\n  private openAiClient: EmbeddingModelV2<string>;\r\n  private cacheEmbeddings = true;\r\n  private embeddingCache: Map<string, number[]> = new Map();\r\n\r\n  constructor(openAiClient?: EmbeddingModelV2<string>) {\r\n    this.openAiClient = openAiClient ?? EmbeddingService.globalEmbeddingModel;\r\n  }\r\n\r\n  public setCacheEmbeddings(cache: boolean): this {\r\n    this.cacheEmbeddings = cache;\r\n    return this;\r\n  }\r\n\r\n  private async getEmbedding(query: string): Promise<number[]> {\r\n    const ret = await embed({\r\n      model: this.openAiClient,\r\n      value: query,\r\n    });\r\n    return ret.embedding;\r\n  }\r\n\r\n  public async embed(query: string): Promise<number[]> {\r\n    if (this.cacheEmbeddings && this.embeddingCache.has(query)) {\r\n      return this.embeddingCache.get(query)!;\r\n    }\r\n    const vector = await this.getEmbedding(query);\r\n    this.embeddingCache.set(query, vector);\r\n    return vector;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\embedding\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\embedding\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":5,"column":1,"nodeType":"Program","endLine":8,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * A very thin embedding-service interface. Your real service\r\n * must implement .embed(text): Promise<number[]>\r\n */\r\nexport interface IEmbeddingService {\r\n  embed(text: string): Promise<number[]>;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\model-stats\\model-map.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":1010,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ResourceNotFoundError } from '@/lib/ai/services/chat/errors/resource-not-found-error';\r\n/**\r\n * @module lib/ai/services/model-stats/model-map\r\n * @fileoverview\r\n * ModelMap provides centralized management of model configurations, quotas, and metadata.\r\n * It follows the singleton pattern with local caching and database persistence.\r\n * Supports normalization of provider/model names and direct lookup from LanguageModelV1 instances.\r\n *\r\n * @author NoEducation Team\r\n * @version 1.0.0\r\n * @since 2025-08-23\r\n */\r\n\r\nimport { drizDbWithInit, type DbDatabaseType } from '@/lib/drizzle-db';\r\nimport { schema } from '@/lib/drizzle-db/schema';\r\nimport { eq, and } from 'drizzle-orm';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport {\r\n  ProviderMap,\r\n  ProviderPrimaryNameType,\r\n  ProviderPrimaryNameTypeValues,\r\n} from './provider-map';\r\nimport { log } from '@/lib/logger';\r\nimport { LanguageModel } from 'ai';\r\nimport { ModelClassification } from '../../middleware/key-rate-limiter/types';\r\nimport { isKeyOf, newUuid } from '@/lib/typescript';\r\n\r\n/**\r\n * Type representing a complete model record with provider information.\r\n */\r\nexport type ModelRecord = {\r\n  id: string;\r\n  providerId: string;\r\n  providerName?: string;\r\n  modelName: string;\r\n  displayName?: string;\r\n  description?: string;\r\n  isActive: boolean;\r\n  createdAt: string;\r\n  updatedAt: string;\r\n};\r\n\r\n/**\r\n * Type representing optional fields when creating or updating a model quota.\r\n */\r\ntype UpdateOptionalQuotaFields = 'id' | 'createdAt' | 'updatedAt' | 'isActive';\r\n\r\n/**\r\n * Type representing a model quota configuration.\r\n */\r\nexport type ModelQuotaRecord = {\r\n  id: string;\r\n  modelId: string;\r\n  maxTokensPerMessage?: number;\r\n  maxTokensPerMinute?: number;\r\n  maxTokensPerDay?: number;\r\n  isActive: boolean;\r\n  createdAt: string | null;\r\n  updatedAt: string | null;\r\n};\r\n\r\n/**\r\n * Type representing a complete model with its quota configuration.\r\n */\r\nexport type ModelWithQuota = ModelRecord & {\r\n  quota?: ModelQuotaRecord;\r\n};\r\n\r\n/**\r\n * Type for provider/model name normalization results.\r\n */\r\nexport type ProviderModelNormalization = {\r\n  provider: string;\r\n  modelName: string;\r\n  modelId: string;\r\n  providerId: string;\r\n  rethrow: () => void;\r\n  get classification(): ModelClassification;\r\n};\r\n\r\n/**\r\n * List of aliased model names.\r\n */\r\nexport const ModelAliasNameValues = ['hifi', 'lofi', 'embedding'] as const;\r\n\r\nexport type ModelAliasNameType = (typeof ModelAliasNameValues)[number];\r\n\r\n/**\r\n * Maps alias names to environment variables per provider.\r\n */\r\nexport const EnvironmentAliasMap: Record<\r\n  ProviderPrimaryNameType,\r\n  Record<ModelAliasNameType, string>\r\n> = {\r\n  azure: {\r\n    hifi: 'AZURE_OPENAI_DEPLOYMENT_HIFI',\r\n    lofi: 'AZURE_OPENAI_DEPLOYMENT_LOFI',\r\n    embedding: 'AZURE_OPENAI_DEPLOYMENT_EMBEDDING',\r\n  },\r\n  google: {\r\n    hifi: 'GOOGLE_GENERATIVE_HIFI',\r\n    lofi: 'GOOGLE_GENERATIVE_LOFI',\r\n    embedding: 'GOOGLE_GENERATIVE_EMBEDDING',\r\n  },\r\n  openai: {\r\n    hifi: 'OPENAI_HIFI',\r\n    lofi: 'OPENAI_LOFI',\r\n    embedding: 'OPENAI_EMBEDDING',\r\n  },\r\n} as const;\r\n\r\n/**\r\n * Apparently I was just waiting for typescript to catch up?\r\n * keeping around in case we wind up needing it\r\ntype ModelRowExt = {\r\n  modelId: string;\r\n  providerId: string;\r\n  modelName: string;\r\n  displayName: string;\r\n  description: string;\r\n  isActive: string;\r\n  createdAt: string;\r\n  updatedAt: string;\r\n  providerName: string;\r\n};\r\n */\r\n\r\n/**\r\n * ModelMap provides centralized management of AI model configurations and quotas.\r\n * Uses singleton pattern with local caching and database persistence.\r\n *\r\n * Key features:\r\n * - Singleton instance with lazy initialization\r\n * - Local caching with TTL for performance\r\n * - Provider/model name normalization\r\n * - Direct lookup from LanguageModelV1 instances\r\n * - Comprehensive quota management\r\n *\r\n * @example\r\n * ```typescript\r\n * const modelMap = await ModelMap.getInstance();\r\n * const model = await modelMap.getModelByProviderAndName('azure-openai.chat', 'gpt-4');\r\n * const quota = await modelMap.getQuotaByModel(model);\r\n * ```\r\n */\r\nexport class ModelMap {\r\n  /** Global symbol key to access init resolvers across module copies/HMR. */\r\n  static readonly #INIT_KEY = Symbol.for(\r\n    '@noeducation/model-stats:ModelMap:init',\r\n  );\r\n  /** Symbol-based global registry key for ModelMap singleton. */\r\n  static readonly #REGISTRY_KEY = Symbol.for(\r\n    '@noeducation/model-stats:ModelMap',\r\n  );\r\n  /** Local cached reference to the global singleton via global symbol registry. */\r\n  static get #instance(): ModelMap | undefined {\r\n    type GlobalReg = { [k: symbol]: ModelMap | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    return g[this.#REGISTRY_KEY];\r\n  }\r\n  static set #instance(value: ModelMap | undefined) {\r\n    type GlobalReg = { [k: symbol]: ModelMap | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    g[this.#REGISTRY_KEY] = value;\r\n  }\r\n\r\n  /** In-memory cache for model records, keyed by `${providerId}:${modelName}`. */\r\n  readonly #providerModelToRecord: Map<string, ModelRecord>;\r\n\r\n  /** In-memory cache for model records, keyed by model ID. */\r\n  readonly #idToRecord: Map<string, ModelRecord>;\r\n\r\n  /** In-memory cache for quota records, keyed by model ID. */\r\n  readonly #modelIdToQuota: Map<string, ModelQuotaRecord>;\r\n\r\n  /** Promise that resolves when the instance is initialized. */\r\n  #whenInitialized: PromiseWithResolvers<boolean>;\r\n\r\n  /** Whether the instance has been initialized. */\r\n  #initialized: boolean = false;\r\n\r\n  /** Timestamp of last cache update (ms since epoch). */\r\n  #lastCacheUpdate = 0;\r\n\r\n  /** Cache time-to-live in milliseconds (default: 5 minutes). */\r\n  readonly #CACHE_TTL = 5 * 60 * 1000;\r\n\r\n  /**\r\n   * Private constructor for singleton pattern.\r\n   * @param {(readonly [string, ModelRecord])[] | DbDatabaseType} [modelsOrDb] - Initial models or database instance.\r\n   */\r\n  private constructor(\r\n    modelsOrDb?: (readonly [string, ModelRecord])[] | DbDatabaseType,\r\n  ) {\r\n    this.#providerModelToRecord = new Map();\r\n    this.#idToRecord = new Map();\r\n    this.#modelIdToQuota = new Map();\r\n    this.#initialized = false;\r\n    this.#whenInitialized = Promise.withResolvers<boolean>();\r\n    (this as unknown as Record<symbol, PromiseWithResolvers<boolean>>)[\r\n      ModelMap.#INIT_KEY\r\n    ] = this.#whenInitialized;\r\n    if (Array.isArray(modelsOrDb)) {\r\n      for (const [key, record] of modelsOrDb) {\r\n        this.#providerModelToRecord.set(key, record);\r\n        this.#idToRecord.set(record.id, record);\r\n      }\r\n      this.#initialized = true;\r\n      this.#lastCacheUpdate = Date.now();\r\n      this.#whenInitialized.resolve(true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the singleton instance of ModelMap.\r\n   * @returns {ModelMap} The singleton instance.\r\n   */\r\n  static get Instance(): ModelMap {\r\n    type GlobalReg = { [k: symbol]: ModelMap | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    if (!g[this.#REGISTRY_KEY]) {\r\n      // Create without DB here; callers who need DB-backed init should call getInstance(db)\r\n      g[this.#REGISTRY_KEY] = new ModelMap();\r\n    }\r\n    this.#instance = g[this.#REGISTRY_KEY]!;\r\n    return this.#instance;\r\n  }\r\n\r\n  /**\r\n   * Get the singleton instance with initialization guarantee.\r\n   * @param {DbDatabaseType} [db] - Optional database instance.\r\n   * @returns {Promise<ModelMap>} Promise that resolves to the initialized instance.\r\n   */\r\n  static async getInstance(db?: DbDatabaseType): Promise<ModelMap> {\r\n    type GlobalReg = { [k: symbol]: ModelMap | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    let inst = g[this.#REGISTRY_KEY];\r\n    if (!inst) {\r\n      inst = new ModelMap(db);\r\n      g[this.#REGISTRY_KEY] = inst;\r\n      this.#instance = inst;\r\n      const init = (\r\n        inst as unknown as Record<\r\n          symbol,\r\n          PromiseWithResolvers<boolean> | undefined\r\n        >\r\n      )[ModelMap.#INIT_KEY];\r\n      const p = (init?.promise ?? Promise.resolve(true))\r\n        .then((x) => {\r\n          log((l) => l.silly('ModelMap initialized successfully'));\r\n          return x;\r\n        })\r\n        .catch((e) => {\r\n          this.#instance = undefined;\r\n          g[this.#REGISTRY_KEY] = undefined;\r\n          LoggedError.isTurtlesAllTheWayDownBaby(e, {\r\n            log: true,\r\n            message: 'Uncaught error during ModelMap initialization',\r\n            source: 'ModelMap.Instance',\r\n          });\r\n        });\r\n      inst.refresh(db);\r\n      await p;\r\n      return inst;\r\n    }\r\n    this.#instance = inst;\r\n    const init2 = (\r\n      inst as unknown as Record<\r\n        symbol,\r\n        PromiseWithResolvers<boolean> | undefined\r\n      >\r\n    )[ModelMap.#INIT_KEY];\r\n    await (init2?.promise ?? Promise.resolve(true)).catch(() => {});\r\n    return inst;\r\n  }\r\n\r\n  /**\r\n   * Setup a mock instance of ModelMap for testing.\r\n   * @param records - The model records to initialize the map with.\r\n   * @returns The initialized ModelMap instance.\r\n   */\r\n  static setupMockInstance(\r\n    records: (readonly [string, ModelRecord])[],\r\n    quotas: (readonly [string, ModelQuotaRecord])[],\r\n  ): ModelMap {\r\n    type GlobalReg = { [k: symbol]: ModelMap | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    g[this.#REGISTRY_KEY] = new ModelMap(records);\r\n    this.#instance = g[this.#REGISTRY_KEY]!;\r\n    for (const [key, record] of quotas) {\r\n      this.#instance.#modelIdToQuota.set(key, record);\r\n    }\r\n    return this.#instance;\r\n  }\r\n\r\n  /**\r\n   * Reset the singleton instance (for testing or reinitialization).\r\n   */\r\n  static reset(): void {\r\n    type GlobalReg = { [k: symbol]: ModelMap | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    g[this.#REGISTRY_KEY] = undefined;\r\n    ModelMap.#instance = undefined;\r\n  }\r\n\r\n  /**\r\n   * Refresh the model and quota data from the database.\r\n   *\r\n   * @param {DbDatabaseType} [db] - Optional database instance.\r\n   * @returns {Promise<boolean>} Promise that resolves to true when refresh is complete.\r\n   */\r\n  async refresh(db?: DbDatabaseType): Promise<boolean> {\r\n    this.#providerModelToRecord.clear();\r\n    this.#idToRecord.clear();\r\n    this.#modelIdToQuota.clear();\r\n    if (this.#initialized) {\r\n      this.#initialized = false;\r\n      this.#whenInitialized = Promise.withResolvers<boolean>();\r\n    }\r\n\r\n    try {\r\n      const database = db || (await drizDbWithInit());\r\n      // Load models with provider information\r\n      const modelsWithProviders = database\r\n        .select({\r\n          modelId: schema.models.id,\r\n          providerId: schema.models.providerId,\r\n          modelName: schema.models.modelName,\r\n          displayName: schema.models.displayName,\r\n          description: schema.models.description,\r\n          isActive: schema.models.isActive,\r\n          createdAt: schema.models.createdAt,\r\n          updatedAt: schema.models.updatedAt,\r\n          providerName: schema.providers.name,\r\n        })\r\n        .from(schema.models)\r\n        .innerJoin(\r\n          schema.providers,\r\n          eq(schema.models.providerId, schema.providers.id),\r\n        )\r\n        .where(eq(schema.models.isActive, true))\r\n        .execute();\r\n\r\n      // Load all quotas\r\n      const quotas = database\r\n        .select()\r\n        .from(schema.modelQuotas)\r\n        .where(eq(schema.modelQuotas.isActive, true))\r\n        .execute();\r\n\r\n      // Populate model caches - ensure we have an array to iterate over\r\n      const now = new Date(Date.now());\r\n      Array.from((await modelsWithProviders) ?? []).forEach((row) => {\r\n        const record: ModelRecord = {\r\n          id: row.modelId,\r\n          providerId: row.providerId,\r\n          providerName: row.providerName,\r\n          modelName: row.modelName,\r\n          displayName: row.displayName || undefined,\r\n          description: row.description || undefined,\r\n          isActive: row.isActive,\r\n          createdAt: row.createdAt ?? now.toISOString(),\r\n          updatedAt: row.updatedAt ?? now.toISOString(),\r\n        };\r\n        this.#providerModelToRecord.set(\r\n          `${row.providerId}:${row.modelName}`,\r\n          record,\r\n        );\r\n        this.#idToRecord.set(row.modelId, record);\r\n      });\r\n\r\n      // Populate quota cache - ensure we have an array to iterate over\r\n      Array.from((await quotas) ?? []).forEach((quota) => {\r\n        const quotaRecord: ModelQuotaRecord = {\r\n          id: quota.id,\r\n          modelId: quota.modelId,\r\n          maxTokensPerMessage: quota.maxTokensPerMessage || undefined,\r\n          maxTokensPerMinute: quota.maxTokensPerMinute || undefined,\r\n          maxTokensPerDay: quota.maxTokensPerDay || undefined,\r\n          isActive: quota.isActive,\r\n          createdAt: quota.createdAt ?? now.toISOString(),\r\n          updatedAt: quota.updatedAt ?? now.toISOString(),\r\n        };\r\n        this.#modelIdToQuota.set(quota.modelId, quotaRecord);\r\n      });\r\n      this.#initialized = true;\r\n      this.#lastCacheUpdate = Date.now();\r\n      this.#whenInitialized.resolve(true);\r\n      return true;\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        message: 'Failed to refresh ModelMap from database',\r\n        source: 'ModelMap.refresh',\r\n      });\r\n      this.#whenInitialized.reject(error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all model records as an iterable.\r\n   * @returns {IterableIterator<[string, ModelRecord]>} Iterator over provider:model key-value pairs.\r\n   */\r\n  get entries(): IterableIterator<[string, ModelRecord]> {\r\n    return this.#providerModelToRecord.entries();\r\n  }\r\n\r\n  /**\r\n   * Get all model IDs.\r\n   * @returns {string[]} Array of all model IDs.\r\n   */\r\n  get allIds(): string[] {\r\n    return Array.from(this.#idToRecord.keys());\r\n  }\r\n\r\n  /**\r\n   * Get all provider:model keys.\r\n   * @returns {string[]} Array of all provider:model combinations.\r\n   */\r\n  get allProviderModelKeys(): string[] {\r\n    return Array.from(this.#providerModelToRecord.keys());\r\n  }\r\n\r\n  /**\r\n   * Check if the instance is initialized.\r\n   * @returns {boolean} True if initialized.\r\n   */\r\n  get initialized(): boolean {\r\n    return this.#initialized;\r\n  }\r\n\r\n  /**\r\n   * Get a promise that resolves when the instance is initialized.\r\n   * @returns {Promise<boolean>} Promise that resolves to true when initialized.\r\n   */\r\n  get whenInitialized(): Promise<boolean> {\r\n    return this.#whenInitialized.promise;\r\n  }\r\n\r\n  /**\r\n   * Normalize provider and model names for consistent storage and lookup.\r\n   * Handles both separate and 'provider:model' formats.\r\n   *\r\n   * @param {string} providerOrModel - Provider name or 'provider:model' string.\r\n   * @param {string} [modelName] - Optional model name.\r\n   * @returns {Promise<ProviderModelNormalization>} Normalized provider and model information.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const norm1 = await modelMap.normalizeProviderModel('azure-openai.chat', 'gpt-4');\r\n   * const norm2 = await modelMap.normalizeProviderModel('azure-openai.chat:gpt-4');\r\n   * ```\r\n   */\r\n  async normalizeProviderModel(\r\n    providerOrModel: LanguageModel,\r\n    modelName?: string,\r\n  ): Promise<ProviderModelNormalization> {\r\n    if (typeof providerOrModel === 'object' && providerOrModel) {\r\n      return await this.normalizeProviderModel(\r\n        providerOrModel.provider,\r\n        providerOrModel.modelId,\r\n      );\r\n    }\r\n    // Parse provider:model format if present\r\n    let provider: string;\r\n    let parsedModelName: string;\r\n\r\n    if (providerOrModel.includes(':')) {\r\n      const [providerPart, modelPart] = providerOrModel.split(':', 2);\r\n      provider = providerPart.trim();\r\n      parsedModelName = modelPart.trim() || (modelName?.trim() ?? '');\r\n    } else {\r\n      provider = providerOrModel?.trim() ?? '';\r\n      parsedModelName = modelName?.trim() ?? '';\r\n      if (!parsedModelName) {\r\n        // Sometimes we get the model name and only the model name - usually when dealing with an alias (eg 'hifi') or unique model name.\r\n        // Apply common-sense provider detection rules to try and flesh this out.\r\n        // If it has 'gemini' or 'google' as a prefix it's a google model\r\n        if (\r\n          ['gemini-', 'google-'].some((prefix) => provider.startsWith(prefix))\r\n        ) {\r\n          parsedModelName = provider;\r\n          provider = 'google';\r\n        } else {\r\n          // Everything else defaults to azure\r\n          parsedModelName = provider;\r\n          provider = 'azure';\r\n        }\r\n      }\r\n    }\r\n    // Get provider ID from ProviderMap\r\n    try {\r\n      // Give maps a chance to finish initialization\r\n      const [providerMap] = await Promise.all([\r\n        ProviderMap.getInstance(),\r\n        this.whenInitialized,\r\n      ]);\r\n      // Get provider ID from ProviderMap - note providermap.id is a synchronous function, so no await is necessary.\r\n      const providerId = providerMap.id(provider);\r\n      const providerCanonicalName = providerId\r\n        ? isKeyOf(provider, ProviderPrimaryNameTypeValues)\r\n          ? provider\r\n          : providerMap.name(providerId)!\r\n        : undefined;\r\n      // If provider ID was found then use it pull the model, otherwise set id to undefined\r\n      const record = providerId\r\n        ? this.#providerModelToRecord.get(`${providerId}:${parsedModelName}`)\r\n        : undefined;\r\n      const modelId = record?.id;\r\n      // Return normalized results with an error rethrow callback\r\n      return {\r\n        provider: providerCanonicalName!,\r\n        modelName: parsedModelName,\r\n        modelId: modelId!,\r\n        providerId: providerId!,\r\n        get classification(): ModelClassification {\r\n          if (!modelId) {\r\n            // HACK: undefined does not a modelclassification make,\r\n            // however I should never have a null /undefined modelId\r\n            // either, so good for the goose good for the gander.\r\n            return undefined as unknown as ModelClassification;\r\n          }\r\n          if (\r\n            modelId.includes('hifi') ||\r\n            modelId.includes('gpt-4') ||\r\n            (modelId.includes('gemini') && modelId.includes('pro'))\r\n          ) {\r\n            return 'hifi';\r\n          }\r\n          if (\r\n            modelId.includes('lofi') ||\r\n            modelId.includes('gpt-3.5') ||\r\n            (modelId.includes('gemini') && modelId.includes('flash'))\r\n          ) {\r\n            return 'lofi';\r\n          }\r\n          if (modelId.includes('embedding')) {\r\n            return 'embedding';\r\n          }\r\n          if (modelId.includes('completions')) {\r\n            return 'completions';\r\n          }\r\n\r\n          return 'hifi'; // default fallback\r\n        },\r\n        rethrow: () => {\r\n          if (!providerId) {\r\n            throw new ResourceNotFoundError({\r\n              resourceType: 'provider',\r\n              normalized: provider,\r\n              inputRaw: providerOrModel,\r\n              message: `Provider not found: ${provider}`,\r\n            });\r\n          }\r\n          if (!modelId) {\r\n            throw new ResourceNotFoundError({\r\n              resourceType: 'model',\r\n              normalized: `${providerId}:${parsedModelName}`,\r\n              inputRaw: { providerOrModel, modelName },\r\n              message: `Model not found for provider ${provider}: ${parsedModelName}`,\r\n            });\r\n          }\r\n        },\r\n      };\r\n    } catch (error) {\r\n      // Log the failure\r\n      const loggedError = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        message: 'Error normalizing provider/model',\r\n        extra: { providerOrModel, modelName },\r\n        source: 'ModelMap.normalizeProviderModel',\r\n      });\r\n      // Yeah, i know...undefined as unknown as string is evil...but thats\r\n      // what the rethrow callback is for ;)\r\n      return {\r\n        provider,\r\n        modelId: undefined as unknown as string,\r\n        modelName: parsedModelName,\r\n        providerId: undefined as unknown as string,\r\n        classification: undefined as unknown as ModelClassification,\r\n        rethrow: () => {\r\n          throw loggedError;\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /** Helper that throws ResourceNotFoundError when provider/model can’t be normalized */\r\n  async normalizeProviderModelOrThrow(\r\n    providerOrModel: string,\r\n    modelName?: string,\r\n  ): Promise<\r\n    Required<\r\n      Pick<\r\n        ProviderModelNormalization,\r\n        'provider' | 'modelName' | 'providerId' | 'modelId'\r\n      >\r\n    >\r\n  > {\r\n    const norm = await this.normalizeProviderModel(providerOrModel, modelName);\r\n    norm.rethrow();\r\n    return {\r\n      provider: norm.provider,\r\n      modelName: norm.modelName,\r\n      providerId: norm.providerId!,\r\n      modelId: norm.modelId!,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get a model record by provider and model name.\r\n   *\r\n   * @param {string} provider - Provider name or ID.\r\n   * @param {string} modelName - Model name.\r\n   * @returns {Promise<ModelRecord | null>} Model record or null if not found.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const model = await modelMap.getModelByProviderAndName('azure-openai.chat', 'gpt-4');\r\n   * ```\r\n   */\r\n  async getModelByProviderAndName(\r\n    provider: LanguageModel,\r\n    modelName: string,\r\n  ): Promise<ModelRecord | null> {\r\n    await this.#ensureFreshCache();\r\n\r\n    const {\r\n      modelName: normalizedModelName,\r\n      rethrow,\r\n      providerId: normalizedProviderId,\r\n    } = await this.normalizeProviderModel(provider, modelName);\r\n\r\n    try {\r\n      rethrow();\r\n      const key = `${normalizedProviderId}:${normalizedModelName}`;\r\n      return this.#providerModelToRecord.get(key) || null;\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        message: 'Error getting model by provider and name',\r\n        extra: { provider, modelName },\r\n        source: 'ModelMap.getModelByProviderAndName',\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a model record by model ID.\r\n   *\r\n   * @param {string} modelId - Model ID.\r\n   * @returns {Promise<ModelRecord | null>} Model record or null if not found.\r\n   */\r\n  async getModelById(modelId: string): Promise<ModelRecord | null> {\r\n    await this.#ensureFreshCache();\r\n    return this.#idToRecord.get(modelId) || null;\r\n  }\r\n\r\n  /**\r\n   * Get a quota record by model ID.\r\n   *\r\n   * @param {string} modelId - Model ID.\r\n   * @returns {Promise<ModelQuotaRecord | null>} Quota record or null if not found.\r\n   */\r\n  async getQuotaByModelId(modelId: string): Promise<ModelQuotaRecord | null> {\r\n    await this.#ensureFreshCache();\r\n    return this.#modelIdToQuota.get(modelId) || null;\r\n  }\r\n  /**\r\n   * Get a quota record by model ID.\r\n   *\r\n   * @param {string} modelId - Model ID.\r\n   * @returns {Promise<ModelQuotaRecord | null>} Quota record or null if not found.\r\n   */\r\n  async addQuotaToModel(\r\n    record: Omit<ModelQuotaRecord, UpdateOptionalQuotaFields> &\r\n      Partial<Pick<ModelQuotaRecord, UpdateOptionalQuotaFields>>,\r\n  ): Promise<ModelQuotaRecord> {\r\n    if (!record.modelId) {\r\n      throw new TypeError('modelId is required when adding a quota record.');\r\n    }\r\n    await this.#ensureFreshCache();\r\n    let current = this.#modelIdToQuota.get(record.modelId);\r\n    const now = new Date().toISOString();\r\n    if (current) {\r\n      current.maxTokensPerDay = record.maxTokensPerDay;\r\n      current.maxTokensPerMinute = record.maxTokensPerMinute;\r\n      current.maxTokensPerMessage = record.maxTokensPerMessage;\r\n      current.isActive = record.isActive ?? true;\r\n      current.updatedAt = now;\r\n    } else {\r\n      current = {\r\n        ...record,\r\n        id: record.id ?? newUuid(),\r\n        createdAt: now,\r\n        updatedAt: now,\r\n        isActive: record.isActive ?? true,\r\n      };\r\n    }\r\n    this.#modelIdToQuota.set(record.modelId, current);\r\n    return current;\r\n  }\r\n\r\n  /**\r\n   * Get a quota record by model record.\r\n   *\r\n   * @param {ModelRecord} model - Model record.\r\n   * @returns {Promise<ModelQuotaRecord | null>} Quota record or null if not found.\r\n   */\r\n  async getQuotaByModel(model: ModelRecord): Promise<ModelQuotaRecord | null> {\r\n    return this.getQuotaByModelId(model.id);\r\n  }\r\n\r\n  /**\r\n   * Get a complete model with quota by provider and model name.\r\n   *\r\n   * @param {string} provider - Provider name or ID.\r\n   * @param {string} modelName - Model name.\r\n   * @returns {Promise<ModelWithQuota | null>} Model with quota or null if not found.\r\n   */\r\n  async getModelWithQuota(\r\n    provider: string,\r\n    modelName: string,\r\n  ): Promise<ModelWithQuota | null> {\r\n    const model = await this.getModelByProviderAndName(provider, modelName);\r\n    if (!model) return null;\r\n\r\n    const quota = await this.getQuotaByModelId(model.id);\r\n    return {\r\n      ...model,\r\n      quota: quota || undefined,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get model and quota information from a LanguageModelV1 instance.\r\n   * This method extracts provider and model information from the model's metadata\r\n   * and performs a lookup in the ModelMap.\r\n   *\r\n   * @param {LanguageModelV1} languageModel - The LanguageModelV1 instance.\r\n   * @returns {Promise<ModelWithQuota | null>} Model with quota or null if not found.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const model = aiModelFactory('hifi');\r\n   * const modelInfo = await modelMap.getModelFromLanguageModelV1(model);\r\n   * ```\r\n   */\r\n  async getModelFromLanguageModel(\r\n    languageModel: LanguageModel,\r\n  ): Promise<ModelWithQuota | null> {\r\n    try {\r\n      // Extract provider and model information from the LanguageModelV1 instance\r\n      // LanguageModelV1 instances have provider and modelId properties\r\n      const provider = (languageModel as { provider?: string }).provider;\r\n      const modelId = (languageModel as { modelId?: string }).modelId;\r\n\r\n      if (!provider || !modelId) {\r\n        LoggedError.isTurtlesAllTheWayDownBaby(\r\n          new Error('Missing provider or modelId in LanguageModelV1 instance'),\r\n          {\r\n            log: true,\r\n            message: 'Unable to extract provider/model from LanguageModelV1',\r\n            extra: {\r\n              hasProvider: !!provider,\r\n              hasModelId: !!modelId,\r\n              keys: Object.keys(languageModel),\r\n            },\r\n            source: 'ModelMap.getModelFromLanguageModelV1',\r\n          },\r\n        );\r\n        return null;\r\n      }\r\n\r\n      // Some models may have provider prefixes in the modelId, normalize them\r\n      let normalizedModelName = modelId;\r\n\r\n      // Handle Azure OpenAI format (e.g., \"gpt-4\" or \"azure:gpt-4\")\r\n      if (provider.includes('azure') && normalizedModelName.includes(':')) {\r\n        normalizedModelName =\r\n          normalizedModelName.split(':').pop() || normalizedModelName;\r\n      }\r\n\r\n      // Handle Google format (e.g., \"models/gemini-pro\")\r\n      if (\r\n        provider.includes('google') &&\r\n        normalizedModelName.startsWith('models/')\r\n      ) {\r\n        normalizedModelName = normalizedModelName.replace('models/', '');\r\n      }\r\n\r\n      return await this.getModelWithQuota(provider, normalizedModelName);\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        message: 'Error getting model from LanguageModelV1',\r\n        extra: {\r\n          languageModelType: typeof languageModel,\r\n          languageModelKeys: Object.keys(languageModel || {}),\r\n        },\r\n        source: 'ModelMap.getModelFromLanguageModelV1',\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load quota configuration from PostgreSQL database.\r\n   * This method is extracted from TokenStatsService to centralize model/quota management.\r\n   *\r\n   * @param {string} provider - Provider ID.\r\n   * @param {string} modelName - Model name.\r\n   * @returns {Promise<ModelQuotaRecord | null>} Quota configuration or null if not found.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const quota = await modelMap.loadQuotaFromDatabase('azure-provider-id', 'gpt-4');\r\n   * ```\r\n   */\r\n  async loadQuotaFromDatabase(\r\n    provider: string,\r\n    modelName: string,\r\n  ): Promise<ModelQuotaRecord | null> {\r\n    try {\r\n      return await drizDbWithInit(async (db) => {\r\n        const row = await db\r\n          .select({\r\n            id: schema.modelQuotas.id,\r\n            modelId: schema.modelQuotas.modelId,\r\n            maxTokensPerMessage: schema.modelQuotas.maxTokensPerMessage,\r\n            maxTokensPerMinute: schema.modelQuotas.maxTokensPerMinute,\r\n            maxTokensPerDay: schema.modelQuotas.maxTokensPerDay,\r\n            isActive: schema.modelQuotas.isActive,\r\n            createdAt: schema.modelQuotas.createdAt,\r\n            updatedAt: schema.modelQuotas.updatedAt,\r\n          })\r\n          .from(schema.modelQuotas)\r\n          .innerJoin(\r\n            schema.models,\r\n            eq(schema.modelQuotas.modelId, schema.models.id),\r\n          )\r\n          .where(\r\n            and(\r\n              eq(schema.models.providerId, provider),\r\n              eq(schema.models.modelName, modelName),\r\n              eq(schema.modelQuotas.isActive, true),\r\n            ),\r\n          )\r\n          .limit(1)\r\n          .execute()\r\n          .then((r) => r.at(0));\r\n\r\n        if (!row) {\r\n          return null;\r\n        }\r\n        const now =\r\n          row.createdAt ?? row.updatedAt ?? new Date(Date.now()).toISOString();\r\n        return {\r\n          id: row.id,\r\n          modelId: row.modelId,\r\n          maxTokensPerMessage: row.maxTokensPerMessage || undefined,\r\n          maxTokensPerMinute: row.maxTokensPerMinute || undefined,\r\n          maxTokensPerDay: row.maxTokensPerDay || undefined,\r\n          isActive: row.isActive,\r\n          createdAt: now,\r\n          updatedAt: now,\r\n        };\r\n      });\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        message: 'Error loading quota from database',\r\n        extra: { provider, modelName },\r\n        source: 'ModelMap.loadQuotaFromDatabase',\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if the cache needs to be refreshed and refresh if necessary.\r\n   * @private\r\n   */\r\n  async #ensureFreshCache(): Promise<void> {\r\n    if (\r\n      !this.#initialized ||\r\n      Date.now() - this.#lastCacheUpdate > this.#CACHE_TTL\r\n    ) {\r\n      await this.refresh();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the model ID for a given provider and model name.\r\n   * Similar to ProviderMap.id() but requires both provider and model name.\r\n   *\r\n   * @param {string} provider - Provider name or ID.\r\n   * @param {string} modelName - Model name.\r\n   * @returns {Promise<string | undefined>} Model ID or undefined if not found.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const modelId = await modelMap.id('azure-openai.chat', 'gpt-4');\r\n   * ```\r\n   */\r\n  async id(provider: string, modelName: string): Promise<string | undefined> {\r\n    const model = await this.getModelByProviderAndName(provider, modelName);\r\n    return model?.id;\r\n  }\r\n\r\n  /**\r\n   * Get the model name for a given model ID.\r\n   *\r\n   * @param {string} modelId - Model ID.\r\n   * @returns {Promise<string | undefined>} Model name or undefined if not found.\r\n   */\r\n  async modelName(modelId: string): Promise<string | undefined> {\r\n    const model = await this.getModelById(modelId);\r\n    return model?.modelName;\r\n  }\r\n\r\n  /**\r\n   * Get the provider ID for a given model ID.\r\n   *\r\n   * @param {string} modelId - Model ID.\r\n   * @returns {Promise<string | undefined>} Provider ID or undefined if not found.\r\n   */\r\n  async providerId(modelId: string): Promise<string | undefined> {\r\n    const model = await this.getModelById(modelId);\r\n    return model?.providerId;\r\n  }\r\n\r\n  /**\r\n   * Get the provider name for a given model ID.\r\n   *\r\n   * @param {string} modelId - Model ID.\r\n   * @returns {Promise<string | undefined>} Provider name or undefined if not found.\r\n   */\r\n  async providerName(modelId: string): Promise<string | undefined> {\r\n    const model = await this.getModelById(modelId);\r\n    return model?.providerName;\r\n  }\r\n\r\n  /**\r\n   * Get a model record by provider and model name or IDs.\r\n   * Similar to ProviderMap.record() but requires both provider and model identifiers.\r\n   *\r\n   * @param {string} provider - Provider name or ID.\r\n   * @param {string} modelName - Model name or ID.\r\n   * @returns {Promise<ModelRecord | undefined>} Model record or undefined if not found.\r\n   */\r\n  async record(\r\n    provider: string,\r\n    modelName: string,\r\n  ): Promise<ModelRecord | undefined> {\r\n    const model = await this.getModelByProviderAndName(provider, modelName);\r\n    return model || undefined;\r\n  }\r\n\r\n  /**\r\n   * Check if the ModelMap contains a model with the given provider and name.\r\n   *\r\n   * @param {string} provider - Provider name or ID.\r\n   * @param {string} modelName - Model name.\r\n   * @returns {Promise<boolean>} True if the model exists.\r\n   */\r\n  async contains(provider: string, modelName: string): Promise<boolean> {\r\n    const model = await this.getModelByProviderAndName(provider, modelName);\r\n    return model !== null;\r\n  }\r\n\r\n  /**\r\n   * Get all active models for a specific provider.\r\n   *\r\n   * @param {string} provider - Provider name or ID.\r\n   * @returns {Promise<ModelRecord[]>} Array of model records for the provider.\r\n   */\r\n  async getModelsForProvider(provider: string): Promise<ModelRecord[]> {\r\n    await this.#ensureFreshCache();\r\n\r\n    const { providerId, rethrow } = await this.normalizeProviderModel(\r\n      provider,\r\n      '',\r\n    );\r\n\r\n    try {\r\n      rethrow();\r\n      const models: ModelRecord[] = [];\r\n\r\n      for (const [key, record] of this.#providerModelToRecord.entries()) {\r\n        if (key.startsWith(`${providerId}:`)) {\r\n          models.push(record);\r\n        }\r\n      }\r\n\r\n      return models;\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        message: 'Error getting models for provider',\r\n        extra: { provider },\r\n        source: 'ModelMap.getModelsForProvider',\r\n      });\r\n      return [];\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\model-stats\\provider-map.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":16,"column":1,"nodeType":"Program","endLine":438,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module lib/ai/services/model-stats/provider-map\r\n *\r\n * ProviderMap manages provider metadata (IDs, names, aliases) used throughout\r\n * the model/quotas subsystem. It exposes a singleton instance which can be\r\n * initialized from the database or seeded with a mock set for tests.\r\n *\r\n * Responsibilities:\r\n * - Load and cache provider rows from the DB (id, name, displayName, aliases).\r\n * - Provide stable lookup helpers (by id or by name/alias).\r\n * - Offer defensive helpers that throw typed errors when lookups fail.\r\n *\r\n * The module exports small typed constants and guards to make provider names\r\n * ergonomic and well-typed across the codebase.\r\n */\r\nimport {\r\n  drizDbWithInit,\r\n  type ProvidersType,\r\n  type DbDatabaseType,\r\n  schema,\r\n} from '@/lib/drizzle-db';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { ResourceNotFoundError } from '@/lib/ai/services/chat/errors/resource-not-found-error';\r\nimport { isKeyOf } from '@/lib/typescript';\r\nimport { log } from '@/lib/logger';\r\n\r\n/**\r\n * Primary provider canonical names.\r\n *\r\n * These are the short, canonical names used internally to represent the\r\n * capabilities of a provider.\r\n */\r\nexport const ProviderPrimaryNameTypeValues = [\r\n  'azure',\r\n  'google',\r\n  'openai',\r\n] as const;\r\n\r\n/**\r\n * Common provider alias values used by external libraries or legacy configs.\r\n *\r\n * Aliases are additional names that should be treated as equivalent to the\r\n * canonical provider name when normalizing provider inputs.\r\n */\r\nexport const ProviderAliasTypeValues = [\r\n  'google.generative-ai',\r\n  'azure.chat',\r\n  'azure-openai.chat',\r\n] as const;\r\n\r\n/**\r\n * Type representing a primary provider name (one of the canonical names).\r\n */\r\nexport type ProviderPrimaryNameType =\r\n  (typeof ProviderPrimaryNameTypeValues)[number];\r\n\r\n/**\r\n * Type representing a provider alias name.\r\n */\r\nexport type ProviderAliasType = (typeof ProviderAliasTypeValues)[number];\r\n\r\n/**\r\n * Union of all supported provider name variants (primary and aliases).\r\n */\r\nexport type ProviderNameType = ProviderPrimaryNameType | ProviderAliasType;\r\n\r\n/**\r\n * Type guard that returns `true` when the provided value is a known provider\r\n * name or alias. Useful when accepting free-form input (config, tests,\r\n * runtime) and wanting a narrow `ProviderNameType`.\r\n *\r\n * @param value - Candidate value to test.\r\n * @returns `true` if `value` is one of the known provider names or aliases.\r\n */\r\nexport const isProviderName = (value: unknown): value is ProviderNameType =>\r\n  isKeyOf(value, ProviderPrimaryNameTypeValues) ||\r\n  isKeyOf(value, ProviderAliasTypeValues);\r\n\r\n/**\r\n * Shape of a provider record stored in the in-memory provider map.\r\n *\r\n * It mirrors the database `ProvidersType` row but omits DB-managed columns\r\n * (`id`, `createdAt`, `updatedAt`) because the map stores the row indexed by\r\n * `id` and the timestamps are not required for lookups.\r\n */\r\nexport type ProviderMapEntry = Omit<\r\n  ProvidersType,\r\n  'id' | 'createdAt' | 'updatedAt'\r\n>;\r\ntype ProviderMapEntryNameKey = 'name';\r\ntype ProviderMapEntryAliasesKey = 'aliases';\r\ntype ProviderMapEntryIdKey = 'id';\r\ntype ProviderIdType = ProvidersType[ProviderMapEntryIdKey];\r\ntype ProviderNameOrIdType = ProviderIdType | ProviderNameType;\r\n\r\n/**\r\n * ProviderMap\r\n *\r\n * Singleton that manages provider metadata used by the ModelMap and other\r\n * services. It caches provider rows (id, name, aliases, displayName, etc.) and\r\n * provides convenient lookup helpers by id, name or alias. The class is\r\n * designed to be initialized once and reused; it supports seeding with an\r\n * in-memory record set for tests via `setupMockInstance` and can refresh its\r\n * cache from the database via `refresh`.\r\n *\r\n * Lifecycle & thread-safety:\r\n * - Use `ProviderMap.getInstance(db?)` to obtain the singleton asynchronously.\r\n * - Callers may also use the sync `ProviderMap.Instance` getter after the\r\n *   instance has been initialized.\r\n * - `refresh` will re-populate caches and resolve the internal initialization\r\n *   promise; failures are logged and cause the initialization promise to reject.\r\n *\r\n * Example:\r\n * ```ts\r\n * const map = await ProviderMap.getInstance();\r\n * const providerId = map.idOrThrow('azure');\r\n * ```\r\n */\r\nexport class ProviderMap {\r\n  // Global symbol key to expose init resolvers across module copies/HMR boundaries\r\n  static readonly #INIT_KEY = Symbol.for(\r\n    '@noeducation/model-stats:ProviderMap:init',\r\n  );\r\n  // Symbol-based global registry key to ensure singleton across module reloads/bundles\r\n  static readonly #REGISTRY_KEY = Symbol.for(\r\n    '@noeducation/model-stats:ProviderMap',\r\n  );\r\n  static get #instance(): ProviderMap | undefined {\r\n    type GlobalReg = { [k: symbol]: ProviderMap | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    return g[this.#REGISTRY_KEY];\r\n  }\r\n  static set #instance(value: ProviderMap | undefined) {\r\n    type GlobalReg = { [k: symbol]: ProviderMap | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    g[this.#REGISTRY_KEY] = value;\r\n  }\r\n  static readonly #ProviderNameKey: ProviderMapEntryNameKey = 'name' as const;\r\n  static readonly #ProviderAliasesKey: ProviderMapEntryAliasesKey =\r\n    'aliases' as const;\r\n\r\n  static get Instance(): ProviderMap {\r\n    type GlobalReg = { [k: symbol]: ProviderMap | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    if (!g[this.#REGISTRY_KEY]) {\r\n      g[this.#REGISTRY_KEY] = new ProviderMap();\r\n    }\r\n    this.#instance = g[this.#REGISTRY_KEY]!;\r\n    return this.#instance;\r\n  }\r\n  /**\r\n   * Return the singleton `ProviderMap` instance, asynchronously initializing it\r\n   * if necessary. If a `db` is supplied it will be used for initialization.\r\n   *\r\n   * @param db - Optional database handle used for initialization.\r\n   * @returns Promise that resolves to the initialized ProviderMap.\r\n   */\r\n  static getInstance(db?: DbDatabaseType): Promise<ProviderMap> {\r\n    type GlobalReg = { [k: symbol]: ProviderMap | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    if (!g[this.#REGISTRY_KEY]) {\r\n      g[this.#REGISTRY_KEY] = new ProviderMap(db);\r\n    }\r\n    this.#instance = g[this.#REGISTRY_KEY]!;\r\n    const inst = this.#instance;\r\n    const init = (\r\n      inst as unknown as Record<\r\n        symbol,\r\n        PromiseWithResolvers<boolean> | undefined\r\n      >\r\n    )[ProviderMap.#INIT_KEY];\r\n    const p: Promise<boolean> =\r\n      init?.promise ?? inst.whenInitialized ?? Promise.resolve(true);\r\n    return p.then(() => this.#instance!);\r\n  }\r\n  /**\r\n   * Create a mock ProviderMap instance seeded with in-memory records. Useful\r\n   * for unit tests that need deterministic provider lookups without touching\r\n   * the database.\r\n   *\r\n   * @param records - Array of `[id, ProviderMapEntry]` tuples to seed the map.\r\n   * @returns The initialized ProviderMap singleton.\r\n   */\r\n  static setupMockInstance(\r\n    records: (readonly [ProviderIdType, ProviderMapEntry])[],\r\n  ): ProviderMap {\r\n    type GlobalReg = { [k: symbol]: ProviderMap | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    g[this.#REGISTRY_KEY] = new ProviderMap(records);\r\n    this.#instance = g[this.#REGISTRY_KEY]!;\r\n    return this.#instance;\r\n  }\r\n\r\n  readonly #idToRecord: Map<ProviderIdType, ProviderMapEntry>;\r\n  readonly #nameToId: Map<ProviderNameType, ProviderIdType>;\r\n  #whenInitialized: PromiseWithResolvers<boolean>;\r\n  #initialized: boolean = false;\r\n\r\n  constructor(\r\n    entriesOrDb?:\r\n      | (readonly [ProviderIdType, ProviderMapEntry])[]\r\n      | DbDatabaseType,\r\n  ) {\r\n    this.#nameToId = new Map();\r\n    this.#initialized = false;\r\n    this.#whenInitialized = Promise.withResolvers<boolean>();\r\n    // Expose init resolvers via a symbol to avoid private brand checks across module copies\r\n    (this as unknown as Record<symbol, PromiseWithResolvers<boolean>>)[\r\n      ProviderMap.#INIT_KEY\r\n    ] = this.#whenInitialized;\r\n    if (Array.isArray(entriesOrDb)) {\r\n      this.#idToRecord = new Map(entriesOrDb);\r\n      this.#initializeNameToIdMap();\r\n    } else {\r\n      this.#idToRecord = new Map();\r\n      this.refresh(entriesOrDb);\r\n    }\r\n  }\r\n  get entries(): IterableIterator<[ProviderIdType, ProviderMapEntry]> {\r\n    return this.#idToRecord.entries();\r\n  }\r\n  /**\r\n   * Iterate over stored provider entries as `[id, ProviderMapEntry]` tuples.\r\n   */\r\n  get allIds(): ProviderIdType[] {\r\n    return Array.from(this.#idToRecord.keys());\r\n  }\r\n  /**\r\n   * Return all provider IDs currently stored in the map.\r\n   */\r\n  get allNames(): ProviderNameType[] {\r\n    return Array.from(this.#nameToId.keys());\r\n  }\r\n  /**\r\n   * Return all recognized provider names (canonical or aliases) currently\r\n   * mapped to IDs.\r\n   */\r\n  get initialized(): boolean {\r\n    return this.#initialized;\r\n  }\r\n  /**\r\n   * Promise that resolves when the map is fully initialized (either from DB or\r\n   * by a mock seed).\r\n   */\r\n  get whenInitialized(): Promise<boolean> {\r\n    return this.#whenInitialized.promise;\r\n  }\r\n  /**\r\n   * Lookup a provider record by id or name (name or alias).\r\n   *\r\n   * @param idOrName - Provider id (UUID) or a recognized provider name/alias.\r\n   * @returns The provider entry or `undefined` if not found.\r\n   */\r\n  record(idOrName: ProviderNameOrIdType): ProviderMapEntry | undefined {\r\n    let id: string;\r\n    if (isProviderName(idOrName)) {\r\n      const check = this.#nameToId.get(idOrName);\r\n      if (!check) {\r\n        return undefined;\r\n      }\r\n      id = check;\r\n    } else {\r\n      id = idOrName;\r\n    }\r\n    return this.#idToRecord.get(id);\r\n  }\r\n  /**\r\n   * Lookup a provider record by id or name and throw `ResourceNotFoundError`\r\n   * when it cannot be found. Useful in code paths where a missing provider\r\n   * should be treated as an exceptional condition.\r\n   *\r\n   * @param idOrName - Provider id (UUID) or a recognized provider name/alias.\r\n   * @throws {ResourceNotFoundError} When the provider cannot be found.\r\n   * @returns The provider entry when found.\r\n   */\r\n  recordOrThrow(idOrName: ProviderNameOrIdType): ProviderMapEntry {\r\n    const rec = this.record(idOrName);\r\n    if (rec) return rec;\r\n    throw new ResourceNotFoundError({\r\n      resourceType: 'provider',\r\n      normalized: idOrName,\r\n      inputRaw: idOrName,\r\n      message: `Provider not found: ${String(idOrName)}`,\r\n    });\r\n  }\r\n  /**\r\n   * Return the canonical provider name for the given id or name/alias.\r\n   *\r\n   * @param id - Provider id (UUID) or a recognized provider name/alias.\r\n   * @returns The canonical provider name or `undefined` when not found.\r\n   */\r\n  name(id: ProviderNameOrIdType): ProviderNameType | undefined {\r\n    const record = this.record(id);\r\n    return record?.[ProviderMap.#ProviderNameKey] as\r\n      | ProviderNameType\r\n      | undefined;\r\n  }\r\n\r\n  /**\r\n   * Like `name()` but throws when the provider cannot be found.\r\n   *\r\n   * @throws {ResourceNotFoundError} When the provider name is not found.\r\n   */\r\n  nameOrThrow(id: ProviderNameOrIdType): ProviderNameType {\r\n    const name = this.name(id);\r\n    if (name) return name;\r\n    throw new ResourceNotFoundError({\r\n      resourceType: 'provider',\r\n      normalized: id,\r\n      inputRaw: id,\r\n      message: `Provider name not found for: ${String(id)}`,\r\n    });\r\n  }\r\n  /**\r\n   * Return the provider id for a provider name or id. If the input is already\r\n   * an id it will be returned when present in the cache.\r\n   *\r\n   * @param idOrName - Provider id (UUID) or a recognized provider name/alias.\r\n   * @returns Provider id or `undefined` when not found.\r\n   */\r\n  id(idOrName: ProviderNameOrIdType): ProviderIdType | undefined {\r\n    const name = this.name(idOrName);\r\n\r\n    return name ? this.#nameToId.get(name) : undefined;\r\n  }\r\n\r\n  /**\r\n   * Like `id()` but throws when the provider id cannot be resolved.\r\n   *\r\n   * @throws {ResourceNotFoundError}\r\n   */\r\n  idOrThrow(idOrName: ProviderNameOrIdType): ProviderIdType {\r\n    const val = this.id(idOrName);\r\n    if (val) return val;\r\n    throw new ResourceNotFoundError({\r\n      resourceType: 'provider',\r\n      normalized: idOrName,\r\n      inputRaw: idOrName,\r\n      message: `Provider id not found: ${String(idOrName)}`,\r\n    });\r\n  }\r\n  /**\r\n   * Return true when the provider map contains a provider for the given id or name.\r\n   */\r\n  contains(idOrName: ProviderNameOrIdType): boolean {\r\n    return !!this.record(idOrName);\r\n  }\r\n  /**\r\n   * Refresh the provider map from the database. This will clear current\r\n   * in-memory caches and repopulate them from the `providers` table.\r\n   *\r\n   * The call returns a promise that resolves when initialization completes.\r\n   * Failures are logged and the initialization promise is rejected.\r\n   *\r\n   * @param db - Optional database handle to use for loading providers.\r\n   * @returns Promise that resolves to true when refresh completes.\r\n   */\r\n  refresh(db?: DbDatabaseType): Promise<boolean> {\r\n    this.#idToRecord.clear();\r\n    this.#initialized = false;\r\n    this.#whenInitialized = Promise.withResolvers<boolean>();\r\n    (this as unknown as Record<symbol, PromiseWithResolvers<boolean>>)[\r\n      ProviderMap.#INIT_KEY\r\n    ] = this.#whenInitialized;\r\n\r\n    const initDb = (!!db ? Promise.resolve(db) : drizDbWithInit())\r\n      .then((db) => {\r\n        return db.select().from(schema.providers);\r\n      })\r\n      .then((rows) => {\r\n        (rows as ProvidersType[]).forEach(\r\n          ({\r\n            id,\r\n            name,\r\n            displayName,\r\n            description,\r\n            baseUrl,\r\n            isActive,\r\n            aliases,\r\n          }) => {\r\n            this.#idToRecord.set(id, {\r\n              name,\r\n              displayName,\r\n              description,\r\n              baseUrl,\r\n              isActive,\r\n              aliases,\r\n            });\r\n          },\r\n        );\r\n        return Promise.resolve();\r\n      })\r\n      .then(() => this.#initializeNameToIdMap());\r\n    // Log and suppress failure\r\n    initDb.catch((err: unknown) => {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(err, {\r\n        log: true,\r\n        message: 'Failed to load provider map from database',\r\n      });\r\n      this.#whenInitialized.reject();\r\n    });\r\n    return this.#whenInitialized.promise;\r\n  }\r\n\r\n  #initializeNameToIdMap(): Promise<boolean> {\r\n    this.#nameToId.clear();\r\n    this.#idToRecord.forEach((rec, id) => {\r\n      const thisName = rec[ProviderMap.#ProviderNameKey];\r\n      if (isProviderName(thisName)) {\r\n        this.#nameToId.set(thisName, id);\r\n      } else {\r\n        log((l) => l.warn(`Invalid provider name for id ${id}: ${thisName}`));\r\n        // Force it, but keep in mind it probably won't work very well until we\r\n        // the the code updated...\r\n        this.#nameToId.set(thisName as ProviderNameType, id);\r\n      }\r\n      const aliases = rec[ProviderMap.#ProviderAliasesKey] || [];\r\n      aliases.forEach((alias) => {\r\n        if (isProviderName(alias)) {\r\n          this.#nameToId.set(alias, id);\r\n        } else {\r\n          log((l) =>\r\n            l.warn(\r\n              `Invalid provider alias for provider ${thisName} (${id}): ${alias}`,\r\n            ),\r\n          );\r\n          // Force it, but keep in mind it probably won't work very well until we\r\n          // the the code updated...\r\n          this.#nameToId.set(alias as ProviderNameType, id);\r\n        }\r\n      });\r\n    });\r\n    this.#initialized = true;\r\n    this.#whenInitialized.resolve(true);\r\n    return this.#whenInitialized.promise;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\model-stats\\token-stats-service.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":13,"column":1,"nodeType":"Program","endLine":596,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module lib/ai/middleware/tokenStatsTracking/tokenStatsService\r\n * @fileoverview\r\n * TokenStatsService provides centralized logic for tracking AI token consumption, enforcing quotas, and reporting usage statistics.\r\n * It integrates Redis for fast, sliding-window statistics and PostgreSQL for persistent system-of-record storage.\r\n * This module is used by AI middleware, model factories, and quota enforcement logic throughout the application.\r\n *\r\n * @author NoEducation Team\r\n * @version 1.0.0\r\n * @since 2025-01-01\r\n */\r\n\r\nimport { getRedisClient } from '@/lib/ai/middleware/cacheWithRedis/redis-client';\r\nimport { drizDbWithInit, schema, sql } from '@/lib/drizzle-db';\r\nimport { log } from '@/lib/logger';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport {\r\n  ModelQuota,\r\n  QuotaCheckResult,\r\n  TokenStats,\r\n  TokenStatsServiceType,\r\n  TokenUsageData,\r\n} from '../../middleware/tokenStatsTracking/types';\r\nimport { ModelMap } from './model-map';\r\n\r\n/**\r\n * Service for tracking token consumption statistics and enforcing quotas.\r\n * Uses Redis for fast access and PostgreSQL as system of record.\r\n *\r\n * @implements {TokenStatsServiceType}\r\n */\r\nclass TokenStatsService implements TokenStatsServiceType {\r\n  /** Symbol-based global registry key for TokenStatsService singleton. */\r\n  static readonly #REGISTRY_KEY = Symbol.for(\r\n    '@noeducation/model-stats:TokenStatsService',\r\n  );\r\n\r\n  /** Global singleton instance via symbol registry. */\r\n  private static get instance(): TokenStatsService | undefined {\r\n    type GlobalReg = { [k: symbol]: TokenStatsService | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    return g[this.#REGISTRY_KEY];\r\n  }\r\n  private static set instance(value: TokenStatsService | undefined) {\r\n    type GlobalReg = { [k: symbol]: TokenStatsService | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    g[this.#REGISTRY_KEY] = value;\r\n  }\r\n\r\n  /** Quota cache time-to-live in milliseconds (default: 5 minutes). */\r\n  private readonly QUOTA_CACHE_TTL = 5 * 60 * 1000;\r\n\r\n  /** Private constructor for singleton pattern. */\r\n  private constructor() {}\r\n\r\n  /**\r\n   * Reset the singleton instance (for testing or reinitialization).\r\n   * @function\r\n   */\r\n  static reset(): void {\r\n    this.instance = undefined;\r\n  }\r\n\r\n  /**\r\n   * Get the singleton instance of TokenStatsService.\r\n   * @returns {TokenStatsService} The singleton instance.\r\n   * @function\r\n   */\r\n  static get Instance(): TokenStatsService {\r\n    if (!TokenStatsService.instance) {\r\n      TokenStatsService.instance = new TokenStatsService();\r\n    }\r\n    return TokenStatsService.instance;\r\n  }\r\n\r\n  /**\r\n   * Get the Redis key for token statistics for a given provider/model and window type.\r\n   * @param {string} provider - Provider ID (e.g., 'azure-openai.chat').\r\n   * @param {string} modelName - Model name (e.g., 'gpt-4').\r\n   * @param {string} windowType - Time window ('minute', 'hour', 'day').\r\n   * @returns {string} Redis key for token stats.\r\n   * @private\r\n   */\r\n  private getRedisStatsKey(\r\n    provider: string,\r\n    modelName: string,\r\n    windowType: string,\r\n  ): string {\r\n    return `token_stats:${provider}:${modelName}:${windowType}`;\r\n  }\r\n\r\n  /**\r\n   * Get quota configuration for a provider/model from cache, Redis, or database.\r\n   * @param {string} provider - Provider name or ID.\r\n   * @param {string} modelName - Model name.\r\n   * @returns {Promise<ModelQuota|null>} Quota configuration or null if not found.\r\n   */\r\n  async getQuota(\r\n    provider: string,\r\n    modelName: string,\r\n  ): Promise<ModelQuota | null> {\r\n    const {\r\n      providerId: normalizedProvider,\r\n      modelName: normalizedModel,\r\n      modelId: normalizedModelId,\r\n      rethrow,\r\n    } = await ModelMap.getInstance().then((x) =>\r\n      x.normalizeProviderModel(provider, modelName),\r\n    );\r\n    try {\r\n      rethrow();\r\n      let quotaFromMap = await ModelMap.getInstance().then((x) =>\r\n        x.getQuotaByModelId(normalizedModelId!),\r\n      );\r\n      if (!quotaFromMap) {\r\n        quotaFromMap = await ModelMap.Instance.addQuotaToModel({\r\n          modelId: normalizedModelId!,\r\n          maxTokensPerMessage: undefined,\r\n          maxTokensPerMinute: undefined,\r\n          maxTokensPerDay: undefined,\r\n        });\r\n      }\r\n      return {\r\n        ...quotaFromMap,\r\n        provider: normalizedProvider!,\r\n        modelName: normalizedModel,\r\n      };\r\n    } catch (error) {\r\n      log((l) =>\r\n        l.error('Error getting quota', {\r\n          provider: provider,\r\n          modelName: normalizedModel,\r\n          error,\r\n        }),\r\n      );\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current token usage statistics for a provider/model from Redis.\r\n   * @param {string} provider - Provider name or ID.\r\n   * @param {string} modelName - Model name.\r\n   * @returns {Promise<TokenStats>} Aggregated token usage statistics.\r\n   */\r\n  async getTokenStats(\r\n    provider: string,\r\n    modelName: string,\r\n  ): Promise<TokenStats> {\r\n    const {\r\n      providerId: normalizedProvider,\r\n      modelName: normalizedModel,\r\n      rethrow,\r\n    } = await ModelMap.getInstance().then((x) =>\r\n      x.normalizeProviderModel(provider, modelName),\r\n    );\r\n    try {\r\n      rethrow();\r\n\r\n      const redis = await getRedisClient();\r\n\r\n      // Get current stats from Redis sliding windows\r\n      const currentMinuteKey = this.getRedisStatsKey(\r\n        normalizedProvider,\r\n        normalizedModel,\r\n        'minute',\r\n      );\r\n      const lastHourKey = this.getRedisStatsKey(\r\n        normalizedProvider,\r\n        normalizedModel,\r\n        'hour',\r\n      );\r\n      const last24HoursKey = this.getRedisStatsKey(\r\n        normalizedProvider,\r\n        normalizedModel,\r\n        'day',\r\n      );\r\n\r\n      const [minuteData, hourData, dayData] = await Promise.all([\r\n        redis.get(currentMinuteKey),\r\n        redis.get(lastHourKey),\r\n        redis.get(last24HoursKey),\r\n      ]);\r\n\r\n      return {\r\n        currentMinuteTokens: minuteData\r\n          ? JSON.parse(minuteData).totalTokens || 0\r\n          : 0,\r\n        lastHourTokens: hourData ? JSON.parse(hourData).totalTokens || 0 : 0,\r\n        last24HoursTokens: dayData ? JSON.parse(dayData).totalTokens || 0 : 0,\r\n        requestCount: minuteData ? JSON.parse(minuteData).requestCount || 0 : 0,\r\n      };\r\n    } catch (error) {\r\n      log((l) =>\r\n        l.error('Error getting token stats', {\r\n          provider: normalizedProvider,\r\n          modelName: normalizedModel,\r\n          error,\r\n        }),\r\n      );\r\n      return {\r\n        currentMinuteTokens: 0,\r\n        lastHourTokens: 0,\r\n        last24HoursTokens: 0,\r\n        requestCount: 0,\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a token usage request would exceed quotas for a provider/model.\r\n   * Returns a result indicating allowance, reason, and current usage.\r\n   * @param {string} provider - Provider name or ID.\r\n   * @param {string} modelName - Model name.\r\n   * @param {number} requestedTokens - Number of tokens requested.\r\n   * @returns {Promise<QuotaCheckResult>} Quota check result.\r\n   */\r\n  async checkQuota(\r\n    provider: string,\r\n    modelName: string,\r\n    requestedTokens: number,\r\n  ): Promise<QuotaCheckResult> {\r\n    const {\r\n      providerId: normalizedProvider,\r\n      modelName: normalizedModel,\r\n      rethrow,\r\n    } = await ModelMap.getInstance().then((x) =>\r\n      x.normalizeProviderModel(provider, modelName),\r\n    );\r\n\r\n    try {\r\n      rethrow();\r\n      const [quota, currentStats] = await Promise.all([\r\n        this.getQuota(normalizedProvider, normalizedModel),\r\n        this.getTokenStats(normalizedProvider, normalizedModel),\r\n      ]);\r\n\r\n      // If no quota is configured, allow the request\r\n      if (!quota) {\r\n        return { allowed: true, currentUsage: currentStats };\r\n      }\r\n\r\n      // Check per-message limit\r\n      if (\r\n        quota.maxTokensPerMessage &&\r\n        requestedTokens > quota.maxTokensPerMessage\r\n      ) {\r\n        return {\r\n          allowed: false,\r\n          reason: `Request tokens (${requestedTokens}) exceed per-message limit (${quota.maxTokensPerMessage})`,\r\n          currentUsage: currentStats,\r\n          quota,\r\n        };\r\n      }\r\n\r\n      // Check per-minute limit\r\n      if (\r\n        quota.maxTokensPerMinute &&\r\n        currentStats.currentMinuteTokens + requestedTokens >\r\n          quota.maxTokensPerMinute\r\n      ) {\r\n        return {\r\n          allowed: false,\r\n          reason: `Request would exceed per-minute limit (${quota.maxTokensPerMinute})`,\r\n          currentUsage: currentStats,\r\n          quota,\r\n        };\r\n      }\r\n\r\n      // Check daily limit\r\n      if (\r\n        quota.maxTokensPerDay &&\r\n        currentStats.last24HoursTokens + requestedTokens > quota.maxTokensPerDay\r\n      ) {\r\n        return {\r\n          allowed: false,\r\n          reason: `Request would exceed daily limit (${quota.maxTokensPerDay})`,\r\n          currentUsage: currentStats,\r\n          quota,\r\n        };\r\n      }\r\n\r\n      return { allowed: true, currentUsage: currentStats, quota };\r\n    } catch (error) {\r\n      log((l) =>\r\n        l.error('Error checking quota', {\r\n          provider: normalizedProvider,\r\n          modelName: normalizedModel,\r\n          error,\r\n        }),\r\n      );\r\n      // On error, allow the request to avoid blocking legitimate usage\r\n      return { allowed: true };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Safely record token usage for a provider/model.\r\n   * Updates both Redis and PostgreSQL with sliding window statistics.\r\n   * This method is guaranteed not to reject and can be safely ignored.\r\n   *\r\n   * @param {string} provider - Provider ID (e.g., 'azure-openai.chat').\r\n   * @param {string} modelName - Model name (e.g., 'gpt-4').\r\n   * @param {TokenUsageData} usage - Token usage data to record.\r\n   * @returns {Promise<void>} Resolves when usage is recorded.\r\n   * @throws Never - errors are handled internally.\r\n   *\r\n   * @example\r\n   * await tokenStatsService.safeRecordTokenUsage('azure-openai.chat', 'gpt-4', {\r\n   *   promptTokens: 100,\r\n   *   completionTokens: 200,\r\n   *   totalTokens: 300\r\n   * });\r\n   */\r\n  async safeRecordTokenUsage(\r\n    provider: string,\r\n    modelName: string,\r\n    usage: TokenUsageData,\r\n  ): Promise<void> {\r\n    const {\r\n      providerId: normalizedProvider,\r\n      modelName: normalizedModel,\r\n      rethrow,\r\n    } = await ModelMap.getInstance().then((x) =>\r\n      x.normalizeProviderModel(provider, modelName),\r\n    );\r\n\r\n    try {\r\n      rethrow();\r\n      await Promise.all([\r\n        this.updateRedisStats(normalizedProvider, normalizedModel, usage),\r\n        this.updateDatabaseStats(normalizedProvider, normalizedModel, usage),\r\n      ]);\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        message: 'Error recording token usage',\r\n        extra: {\r\n          provider: normalizedProvider,\r\n          modelName: normalizedModel,\r\n          usage,\r\n        },\r\n        source: 'TokenStatsService.safeRecordTokenUsage',\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update Redis statistics for a provider/model with sliding windows.\r\n   * @param {string} provider - Provider ID.\r\n   * @param {string} modelName - Model name.\r\n   * @param {TokenUsageData} usage - Token usage data.\r\n   * @returns {Promise<void>} Resolves when Redis stats are updated.\r\n   * @private\r\n   */\r\n  private async updateRedisStats(\r\n    provider: string,\r\n    modelName: string,\r\n    usage: TokenUsageData,\r\n  ): Promise<void> {\r\n    const {\r\n      providerId: normalizedProvider,\r\n      modelName: normalizedModel,\r\n      rethrow,\r\n    } = await ModelMap.getInstance().then((x) =>\r\n      x.normalizeProviderModel(provider, modelName),\r\n    );\r\n    try {\r\n      rethrow();\r\n      const redis = await getRedisClient();\r\n      const now = new Date();\r\n\r\n      // Update each time window\r\n      const windows = [\r\n        {\r\n          type: 'minute',\r\n          duration: 60,\r\n          start: new Date(Math.floor(now.getTime() / 60000) * 60000),\r\n        },\r\n        {\r\n          type: 'hour',\r\n          duration: 3600,\r\n          start: new Date(Math.floor(now.getTime() / 3600000) * 3600000),\r\n        },\r\n        {\r\n          type: 'day',\r\n          duration: 86400,\r\n          start: new Date(Math.floor(now.getTime() / 86400000) * 86400000),\r\n        },\r\n      ];\r\n      // Use a Lua EVAL script to atomically read-modify-write and set TTL\r\n      const lua = `\r\n        local raw = redis.call('GET', KEYS[1])\r\n        local obj = nil\r\n        if raw then\r\n          local ok, parsed = pcall(cjson.decode, raw)\r\n          if ok and parsed then\r\n            obj = parsed\r\n          else\r\n            obj = {promptTokens=0, completionTokens=0, totalTokens=0, requestCount=0, windowStart=ARGV[5]}\r\n          end\r\n        else\r\n          obj = {promptTokens=0, completionTokens=0, totalTokens=0, requestCount=0, windowStart=ARGV[5]}\r\n        end\r\n\r\n        obj['promptTokens'] = (obj['promptTokens'] or 0) + tonumber(ARGV[1])\r\n        obj['completionTokens'] = (obj['completionTokens'] or 0) + tonumber(ARGV[2])\r\n        obj['totalTokens'] = (obj['totalTokens'] or 0) + tonumber(ARGV[3])\r\n        obj['requestCount'] = (obj['requestCount'] or 0) + tonumber(ARGV[4])\r\n        obj['windowStart'] = ARGV[5]\r\n        obj['lastUpdated'] = ARGV[7]\r\n\r\n        redis.call('SETEX', KEYS[1], tonumber(ARGV[6]), cjson.encode(obj))\r\n        return cjson.encode(obj)\r\n      `;\r\n\r\n      for (const window of windows) {\r\n        const key = this.getRedisStatsKey(\r\n          normalizedProvider,\r\n          normalizedModel,\r\n          window.type,\r\n        );\r\n\r\n        // Execute Lua script to atomically update the JSON blob and set TTL.\r\n        // ARGV: promptDelta, completionDelta, totalDelta, requestDelta, windowStart, ttl, nowIso\r\n        await redis.eval(lua, {\r\n          keys: [key],\r\n          arguments: [\r\n            String(usage.promptTokens),\r\n            String(usage.completionTokens),\r\n            String(usage.totalTokens),\r\n            '1',\r\n            window.start.toISOString(),\r\n            String(window.duration + 300),\r\n            now.toISOString(),\r\n          ],\r\n        });\r\n      }\r\n    } catch (error) {\r\n      throw LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        message: 'Failed to update Redis stats',\r\n        extra: {\r\n          provider: normalizedProvider,\r\n          modelName: normalizedModel,\r\n          usage,\r\n        },\r\n        source: 'TokenStatsService.updateRedisStats',\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update PostgreSQL statistics for a provider/model for persistence.\r\n   * @param {string} provider - Provider ID.\r\n   * @param {string} modelName - Model name.\r\n   * @param {TokenUsageData} usage - Token usage data.\r\n   * @returns {Promise<void>} Resolves when database stats are updated.\r\n   * @private\r\n   */\r\n  private async updateDatabaseStats(\r\n    provider: string,\r\n    modelName: string,\r\n    usage: TokenUsageData,\r\n  ): Promise<void> {\r\n    try {\r\n      const model = await ModelMap.Instance.getModelByProviderAndName(\r\n        provider,\r\n        modelName,\r\n      );\r\n      if (!model) {\r\n        throw new Error(`Model not found: ${provider}:${modelName}`);\r\n      }\r\n      await drizDbWithInit(async (db) => {\r\n        const now = new Date();\r\n        // Update each time window in the database\r\n        const windows = [\r\n          {\r\n            type: 'minute',\r\n            start: new Date(Math.floor(now.getTime() / 60000) * 60000),\r\n          },\r\n          {\r\n            type: 'hour',\r\n            start: new Date(Math.floor(now.getTime() / 3600000) * 3600000),\r\n          },\r\n          {\r\n            type: 'day',\r\n            start: new Date(Math.floor(now.getTime() / 86400000) * 86400000),\r\n          },\r\n        ];\r\n\r\n        for (const window of windows) {\r\n          const windowEnd = new Date(window.start.getTime());\r\n          if (window.type === 'minute')\r\n            windowEnd.setMinutes(windowEnd.getMinutes() + 1);\r\n          else if (window.type === 'hour')\r\n            windowEnd.setHours(windowEnd.getHours() + 1);\r\n          else windowEnd.setDate(windowEnd.getDate() + 1);\r\n\r\n          const conflictTarget = [\r\n            schema.tokenConsumptionStats.modelId,\r\n            schema.tokenConsumptionStats.windowStart,\r\n            schema.tokenConsumptionStats.windowType,\r\n          ];\r\n\r\n          // Use upsert to update or insert stats\r\n          await db\r\n            .insert(schema.tokenConsumptionStats)\r\n            .values({\r\n              modelId: model.id,\r\n              windowStart: window.start.toISOString(),\r\n              windowEnd: windowEnd.toISOString(),\r\n              windowType: window.type,\r\n              promptTokens: usage.promptTokens,\r\n              completionTokens: usage.completionTokens,\r\n              totalTokens: usage.totalTokens,\r\n              requestCount: 1,\r\n            })\r\n            .onConflictDoUpdate({\r\n              target: conflictTarget,\r\n              set: {\r\n                promptTokens: sql`${schema.tokenConsumptionStats.promptTokens} + ${usage.promptTokens}`,\r\n                completionTokens: sql`${schema.tokenConsumptionStats.completionTokens} + ${usage.completionTokens}`,\r\n                totalTokens: sql`${schema.tokenConsumptionStats.totalTokens} + ${usage.totalTokens}`,\r\n                requestCount: sql`${schema.tokenConsumptionStats.requestCount} + 1`,\r\n                lastUpdated: new Date().toISOString(),\r\n              },\r\n            });\r\n        }\r\n      });\r\n    } catch (error) {\r\n      throw LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        message: 'Failed to update database stats.',\r\n        data: { provider, modelName, usage },\r\n        source: 'TokenStatsService.updateDatabaseStats',\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a comprehensive token usage report for a provider/model.\r\n   * Includes quota, current stats, and quota check result.\r\n   * @param {string} provider - Provider name or ID.\r\n   * @param {string} modelName - Model name.\r\n   * @returns {Promise<{quota: ModelQuota|null, currentStats: TokenStats, quotaCheckResult: QuotaCheckResult}>}\r\n   *   Usage report object.\r\n   */\r\n  async getUsageReport(\r\n    provider: string,\r\n    modelName: string,\r\n  ): Promise<{\r\n    quota: ModelQuota | null;\r\n    currentStats: TokenStats;\r\n    quotaCheckResult: QuotaCheckResult;\r\n  }> {\r\n    const {\r\n      providerId: normalizedProvider,\r\n      modelName: normalizedModel,\r\n      rethrow,\r\n    } = await ModelMap.getInstance().then((x) =>\r\n      x.normalizeProviderModel(provider, modelName),\r\n    );\r\n    try {\r\n      rethrow();\r\n      const [quota, currentStats] = await Promise.all([\r\n        this.getQuota(normalizedProvider, normalizedModel),\r\n        this.getTokenStats(normalizedProvider, normalizedModel),\r\n      ]);\r\n\r\n      const quotaCheckResult = await this.checkQuota(\r\n        normalizedProvider,\r\n        normalizedModel,\r\n        0,\r\n      );\r\n\r\n      return { quota, currentStats, quotaCheckResult };\r\n    } catch (error) {\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get the singleton instance of TokenStatsService as TokenStatsServiceType.\r\n * @returns {TokenStatsServiceType} The singleton instance.\r\n */\r\nexport const getInstance = (): TokenStatsServiceType =>\r\n  TokenStatsService.Instance;\r\n\r\n/**\r\n * Reset the singleton instance of TokenStatsService.\r\n * @returns {void}\r\n */\r\nexport const reset = (): void => TokenStatsService.reset();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\model-stats\\tool-map.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":348,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { drizDbWithInit, type DbDatabaseType, schema } from '@/lib/drizzle-db';\r\nimport type { ChatToolType } from '@/lib/drizzle-db/drizzle-types';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { ResourceNotFoundError } from '@/lib/ai/services/chat/errors/resource-not-found-error';\r\nimport { log } from '@/lib/logger';\r\nimport type {\r\n  LanguageModelV2ProviderDefinedTool,\r\n  LanguageModelV2FunctionTool,\r\n} from '@ai-sdk/provider';\r\n\r\ntype ToolMapEntry = ChatToolType;\r\ntype ToolIdType = ChatToolType['chatToolId'];\r\ntype ToolNameType = ChatToolType['toolName'];\r\ntype ToolNameOrIdType = ToolIdType | ToolNameType;\r\n\r\n/**\r\n * ToolMap manages chat tool metadata from the `chat_tool` table.\r\n * It mirrors ProviderMap's lifecycle and lookup utilities.\r\n */\r\nexport class ToolMap {\r\n  /** Global symbol key to access the init resolvers across module copies */\r\n  static readonly #INIT_KEY = Symbol.for(\r\n    '@noeducation/model-stats:ToolMap:init',\r\n  );\r\n  /** Symbol-based global registry key for singleton ToolMap. */\r\n  static readonly #REGISTRY_KEY = Symbol.for(\r\n    '@noeducation/model-stats:ToolMap',\r\n  );\r\n  /** Local cached reference to the global singleton via global symbol registry. */\r\n  static get #instance(): ToolMap | undefined {\r\n    type GlobalReg = { [k: symbol]: ToolMap | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    return g[this.#REGISTRY_KEY];\r\n  }\r\n  static set #instance(value: ToolMap | undefined) {\r\n    type GlobalReg = { [k: symbol]: ToolMap | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    g[this.#REGISTRY_KEY] = value;\r\n  }\r\n\r\n  /** In-memory cache for tool records, keyed by record ID. */\r\n  readonly #idToRecord: Map<ToolIdType, ToolMapEntry>;\r\n\r\n  /** In-memory mapping of tool name to record ID. */\r\n  readonly #nameToId: Map<ToolNameType, ToolIdType>;\r\n\r\n  /** Promise that resolves when the instance is initialized. */\r\n  #whenInitialized: PromiseWithResolvers<boolean>;\r\n\r\n  /** Whether the instance has been initialized. */\r\n  #initialized: boolean = false;\r\n\r\n  constructor(\r\n    entriesOrDb?: (readonly [ToolIdType, ToolMapEntry])[] | DbDatabaseType,\r\n  ) {\r\n    this.#idToRecord = new Map();\r\n    this.#nameToId = new Map();\r\n    this.#whenInitialized = Promise.withResolvers<boolean>();\r\n    // Expose init resolvers via a global symbol so static methods don't touch private slots\r\n    (this as unknown as Record<symbol, PromiseWithResolvers<boolean>>)[\r\n      ToolMap.#INIT_KEY\r\n    ] = this.#whenInitialized;\r\n    this.#initialized = false;\r\n\r\n    if (Array.isArray(entriesOrDb)) {\r\n      for (const [id, record] of entriesOrDb) {\r\n        this.#idToRecord.set(id, record);\r\n      }\r\n      this.#initializeNameToIdMap();\r\n    } else {\r\n      this.refresh(entriesOrDb);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Synchronous singleton getter. Prefer getInstance() in async flows.\r\n   */\r\n  static get Instance(): ToolMap {\r\n    type GlobalReg = { [k: symbol]: ToolMap | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    if (!g[this.#REGISTRY_KEY]) {\r\n      g[this.#REGISTRY_KEY] = new ToolMap();\r\n    }\r\n    this.#instance = g[this.#REGISTRY_KEY]!;\r\n    return this.#instance;\r\n  }\r\n\r\n  /**\r\n   * Return the singleton ToolMap instance, initializing from DB if needed.\r\n   */\r\n  static getInstance(db?: DbDatabaseType): Promise<ToolMap> {\r\n    type GlobalReg = { [k: symbol]: ToolMap | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    if (!g[this.#REGISTRY_KEY]) {\r\n      g[this.#REGISTRY_KEY] = new ToolMap(db);\r\n    }\r\n    this.#instance = g[this.#REGISTRY_KEY]!;\r\n    const init = (\r\n      this.#instance as unknown as Record<\r\n        symbol,\r\n        PromiseWithResolvers<boolean> | undefined\r\n      >\r\n    )[ToolMap.#INIT_KEY];\r\n    const promise =\r\n      init?.promise ??\r\n      (this.#instance.initialized\r\n        ? Promise.resolve(true)\r\n        : Promise.resolve(true));\r\n    return promise.then(() => this.#instance!);\r\n  }\r\n\r\n  /** Setup a mock instance for tests using in-memory entries. */\r\n  static setupMockInstance(\r\n    records: (readonly [ToolIdType, ToolMapEntry])[],\r\n  ): ToolMap {\r\n    type GlobalReg = { [k: symbol]: ToolMap | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    g[this.#REGISTRY_KEY] = new ToolMap(records);\r\n    this.#instance = g[this.#REGISTRY_KEY]!;\r\n    return this.#instance;\r\n  }\r\n\r\n  /** Reset the singleton (tests/reinit). */\r\n  static reset(): void {\r\n    type GlobalReg = { [k: symbol]: ToolMap | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    g[this.#REGISTRY_KEY] = undefined;\r\n    ToolMap.#instance = undefined;\r\n  }\r\n\r\n  /** Whether initialized. */\r\n  get initialized(): boolean {\r\n    return this.#initialized;\r\n  }\r\n\r\n  /** Promise that resolves when initialized. */\r\n  get whenInitialized(): Promise<boolean> {\r\n    return this.#whenInitialized.promise;\r\n  }\r\n\r\n  /** Iterate entries as [id, record]. */\r\n  get entries(): IterableIterator<[ToolIdType, ToolMapEntry]> {\r\n    return this.#idToRecord.entries();\r\n  }\r\n\r\n  /** Return all tool IDs. */\r\n  get allIds(): ToolIdType[] {\r\n    return Array.from(this.#idToRecord.keys());\r\n  }\r\n\r\n  /** Return all tool names. */\r\n  get allNames(): ToolNameType[] {\r\n    return Array.from(this.#nameToId.keys());\r\n  }\r\n\r\n  /** Lookup a tool record by id or name. */\r\n  record(idOrName: ToolNameOrIdType): ToolMapEntry | undefined {\r\n    // First, try by id\r\n    if (this.#idToRecord.has(idOrName as ToolIdType)) {\r\n      return this.#idToRecord.get(idOrName as ToolIdType);\r\n    }\r\n    // Then, try by name\r\n    const id = this.#nameToId.get(idOrName as ToolNameType);\r\n    return id ? this.#idToRecord.get(id) : undefined;\r\n  }\r\n\r\n  /** Lookup a tool record or throw when missing. */\r\n  recordOrThrow(idOrName: ToolNameOrIdType): ToolMapEntry {\r\n    const rec = this.record(idOrName);\r\n    if (rec) return rec;\r\n    throw new ResourceNotFoundError({\r\n      resourceType: 'tool',\r\n      normalized: idOrName,\r\n      inputRaw: idOrName,\r\n      message: `Tool not found: ${String(idOrName)}`,\r\n    });\r\n  }\r\n\r\n  /** Return the tool name for an id or name. */\r\n  name(idOrName: ToolNameOrIdType): ToolNameType | undefined {\r\n    const rec = this.record(idOrName);\r\n    return rec?.toolName;\r\n  }\r\n\r\n  /** Like name(), but throws if missing. */\r\n  nameOrThrow(idOrName: ToolNameOrIdType): ToolNameType {\r\n    const n = this.name(idOrName);\r\n    if (n) return n;\r\n    throw new ResourceNotFoundError({\r\n      resourceType: 'tool',\r\n      normalized: idOrName,\r\n      inputRaw: idOrName,\r\n      message: `Tool name not found for: ${String(idOrName)}`,\r\n    });\r\n  }\r\n\r\n  /** Return the tool id for an id or name. */\r\n  id(idOrName: ToolNameOrIdType): ToolIdType | undefined {\r\n    if (this.#idToRecord.has(idOrName as ToolIdType)) {\r\n      return idOrName as ToolIdType;\r\n    }\r\n    const name = idOrName as ToolNameType;\r\n    return this.#nameToId.get(name);\r\n  }\r\n\r\n  /** Like id(), but throws if missing. */\r\n  idOrThrow(idOrName: ToolNameOrIdType): ToolIdType {\r\n    const val = this.id(idOrName);\r\n    if (val) return val;\r\n    throw new ResourceNotFoundError({\r\n      resourceType: 'tool',\r\n      normalized: idOrName,\r\n      inputRaw: idOrName,\r\n      message: `Tool id not found: ${String(idOrName)}`,\r\n    });\r\n  }\r\n\r\n  /** Whether a tool exists for id or name. */\r\n  contains(idOrName: ToolNameOrIdType): boolean {\r\n    return !!this.record(idOrName);\r\n  }\r\n\r\n  async scanForTools(\r\n    tools:\r\n      | Array<LanguageModelV2FunctionTool | LanguageModelV2ProviderDefinedTool>\r\n      | (LanguageModelV2FunctionTool | LanguageModelV2ProviderDefinedTool),\r\n  ): Promise<number> {\r\n    if (!Array.isArray(tools)) {\r\n      tools = [tools];\r\n    }\r\n    const newEntries = tools\r\n      .filter((tool) => {\r\n        try {\r\n          const id = tool && tool.name && this.name(tool.name);\r\n          return !id;\r\n        } catch (error) {\r\n          LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n            log: true,\r\n            message: 'Error checking tool existence in ToolMap',\r\n          });\r\n          return false;\r\n        }\r\n      })\r\n      .map((tool) => {\r\n        let chatTool: ChatToolType | null = null;\r\n        switch (tool.type) {\r\n          case 'function':\r\n            chatTool = {\r\n              chatToolId: crypto.randomUUID(),\r\n              toolName: tool.name,\r\n              inputSchema: JSON.stringify(\r\n                tool.inputSchema || { type: 'object' },\r\n              ),\r\n              outputSchema: null,\r\n              providerOptions: tool.providerOptions\r\n                ? JSON.stringify(tool.providerOptions)\r\n                : null,\r\n              description: tool.description || '',\r\n            };\r\n            break;\r\n          case 'provider-defined':\r\n            chatTool = {\r\n              chatToolId: crypto.randomUUID(),\r\n              toolName: tool.name,\r\n              inputSchema: JSON.stringify(tool.args ?? { type: 'object' }),\r\n              outputSchema: null,\r\n              providerOptions: null,\r\n              description: `provider-defined tool: ${tool.id || ''}`,\r\n            };\r\n            break;\r\n          default:\r\n            log((l) =>\r\n              l.warn(\r\n                `Unknown tool type in scanForTools: ${(tool as { type: string })?.type}`,\r\n              ),\r\n            );\r\n        }\r\n        return chatTool;\r\n      })\r\n      .filter(Boolean);\r\n    if (newEntries.length === 0) {\r\n      return 0;\r\n    }\r\n    const db = await drizDbWithInit();\r\n    let processed = 0;\r\n    for (const entry of newEntries) {\r\n      try {\r\n        await db.insert(schema.chatTool).values(entry!).execute();\r\n        this.#idToRecord.set(entry!.chatToolId, entry!);\r\n        this.#nameToId.set(entry!.toolName, entry!.chatToolId);\r\n        processed++;\r\n      } catch (error) {\r\n        LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n          log: true,\r\n          message: 'Error inserting new tool in scanForTools',\r\n          data: { toolName: entry!.toolName },\r\n        });\r\n      }\r\n    }\r\n    return processed;\r\n  }\r\n\r\n  /** Refresh caches from database. */\r\n  refresh(db?: DbDatabaseType): Promise<boolean> {\r\n    this.#idToRecord.clear();\r\n    this.#nameToId.clear();\r\n    this.#initialized = false;\r\n    this.#whenInitialized = Promise.withResolvers<boolean>();\r\n    // Re-expose fresh resolvers under the global INIT symbol\r\n    (this as unknown as Record<symbol, PromiseWithResolvers<boolean>>)[\r\n      ToolMap.#INIT_KEY\r\n    ] = this.#whenInitialized;\r\n\r\n    const initDb = (!!db ? Promise.resolve(db) : drizDbWithInit())\r\n      .then((database) => database.select().from(schema.chatTool))\r\n      .then((rows) => {\r\n        (rows as ToolMapEntry[]).forEach((row) => {\r\n          this.#idToRecord.set(row.chatToolId, row);\r\n        });\r\n      })\r\n      .then(() => this.#initializeNameToIdMap());\r\n\r\n    initDb.catch((err: unknown) => {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(err, {\r\n        log: true,\r\n        message: 'Failed to load tool map from database',\r\n      });\r\n      this.#whenInitialized.reject();\r\n    });\r\n\r\n    return this.#whenInitialized.promise;\r\n  }\r\n\r\n  #initializeNameToIdMap(): Promise<boolean> {\r\n    this.#nameToId.clear();\r\n    this.#idToRecord.forEach((rec, id) => {\r\n      if (!rec.toolName) {\r\n        log((l) => l.warn(`Invalid tool name for id ${id}`));\r\n        return;\r\n      }\r\n      this.#nameToId.set(rec.toolName, id);\r\n    });\r\n    this.#initialized = true;\r\n    this.#whenInitialized.resolve(true);\r\n    return this.#whenInitialized.promise;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\search\\HybridDocumentSearch.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":129,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { env } from '@/lib/site-util/env';\r\nimport { CaseFileSearchOptions } from '../../tools/types';\r\nimport { CaseFileSearchScopeType } from '../../tools/unions';\r\nimport { HybridSearchClient } from './HybridSearchBase';\r\nimport { HybridSearchPayload } from './types';\r\nimport { IEmbeddingService } from '../embedding';\r\n\r\n/**\r\n * Concrete hybrid search client specializing in case file (email + attachment + derived\r\n * document unit) content. Provides filtering semantics for different logical document\r\n * types as well as cross‑document relational identifiers (threads, replies, relationships).\r\n */\r\nexport class HybridDocumentSearch extends HybridSearchClient<CaseFileSearchOptions> {\r\n  /**\r\n   * Index name for document corpus (emails, attachments, key points, CTAs, etc.).\r\n   * Derived from environment so deployments can swap indexes without code changes.\r\n   */\r\n  protected getSearchIndexName(): string {\r\n    return env('AZURE_AISEARCH_DOCUMENTS_INDEX_NAME');\r\n  }\r\n\r\n  /**\r\n   * Applies domain specific filters based on provided {@link CaseFileSearchOptions}.\r\n   *\r\n   * Supported filter dimensions:\r\n   *  - scope: Accepts singular or array of logical types which are mapped to concrete\r\n   *           `document_type` values stored in metadata attributes.\r\n   *  - emailId, threadId, attachmentId, documentId: Direct entity scoping.\r\n   *  - replyToDocumentId: Parent / reply chain scoping.\r\n   *  - relatedToDocumentId: Custom relation tag (stored as composite key in metadata).\r\n   *\r\n   * Filtering Strategy:\r\n   *  - Each dimension becomes an OData filter snippet targeting the `metadata/attributes`\r\n   *    collection using `any()` semantics to match the desired attribute key/value pair.\r\n   *  - Multiple dimensions are AND‑combined; multiple document types inside `scope` are OR‑combined.\r\n   *\r\n   * NOTE: This mutation is additive – existing payload properties are preserved.\r\n   */\r\n  protected appendScopeFilter(\r\n    payload: HybridSearchPayload,\r\n    options: CaseFileSearchOptions,\r\n  ): void {\r\n    const {\r\n      scope: policyType,\r\n      emailId,\r\n      threadId,\r\n      attachmentId,\r\n      documentId,\r\n      replyToDocumentId,\r\n      relatedToDocumentId,\r\n    } = options ?? {};\r\n    let filterValues: string[] = [];\r\n    const validTypes: Record<CaseFileSearchScopeType, Array<string>> = {\r\n      email: ['email'],\r\n      attachment: ['attachment'],\r\n      'key-point': ['key_point'],\r\n      'call-to-action': ['cta'],\r\n      'responsive-action': ['cta_response'],\r\n      note: ['note'],\r\n      'core-document': ['email', 'attachment'],\r\n    };\r\n    const filters: Array<string> = [];\r\n\r\n    if (Array.isArray(policyType)) {\r\n      filterValues = policyType\r\n        .flatMap((type) => validTypes[type])\r\n        .filter(Boolean);\r\n    } else if (typeof policyType === 'string') {\r\n      const mapped = validTypes[policyType];\r\n      if (mapped) {\r\n        filterValues = [mapped];\r\n      }\r\n    }\r\n\r\n    if (filterValues.length > 0) {\r\n      const orFilters = filterValues\r\n        .map(\r\n          (val) =>\r\n            `metadata/attributes/any(a: a/key eq 'document_type' and a/value eq '${val}')`,\r\n        )\r\n        .join(' or ');\r\n      filters.push(`(${orFilters})`);\r\n    }\r\n\r\n    if (emailId) {\r\n      filters.push(\r\n        `metadata/attributes/any(a: a/key eq 'email_id' and a/value eq '${emailId}')`,\r\n      );\r\n    }\r\n    if (threadId) {\r\n      filters.push(\r\n        `metadata/attributes/any(a: a/key eq 'thread_id' and a/value eq '${threadId}')`,\r\n      );\r\n    }\r\n    if (attachmentId) {\r\n      filters.push(\r\n        `metadata/attributes/any(a: a/key eq 'attachment_id' and a/value eq '${attachmentId}')`,\r\n      );\r\n    }\r\n    if (documentId) {\r\n      filters.push(\r\n        `metadata/attributes/any(a: a/key eq 'id' and a/value eq '${documentId}')`,\r\n      );\r\n    }\r\n    if (replyToDocumentId) {\r\n      filters.push(\r\n        `metadata/attributes/any(a: a/key eq 'parent_email_id' and a/value eq '${replyToDocumentId}')`,\r\n      );\r\n    }\r\n    if (relatedToDocumentId) {\r\n      filters.push(\r\n        `metadata/attributes/any(a: a/key eq 'relatedEmailId:${relatedToDocumentId}')`,\r\n      );\r\n    }\r\n    if (filters.length > 0) {\r\n      payload.filter = filters.join(' and ');\r\n    }\r\n  }\r\n}\r\n/**\r\n * Factory helper for creating a {@link HybridDocumentSearch} instance while optionally\r\n * injecting a custom embedding service (for testing or alternate vector providers).\r\n *\r\n * @param options Optional configuration containing an `embeddingService` override.\r\n */\r\nexport const hybridDocumentSearchFactory = (options?: {\r\n  embeddingService?: IEmbeddingService;\r\n}) => new HybridDocumentSearch(options);\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\search\\HybridPolicySearch.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":73,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { env } from '@/lib/site-util/env';\r\nimport type { PolicySearchOptions } from '../../tools/types';\r\nimport type { PolicySearchScopeType } from '../../tools/unions';\r\nimport { HybridSearchClient } from './HybridSearchBase';\r\nimport type { HybridSearchPayload } from './types';\r\nimport type { IEmbeddingService } from '../embedding';\r\n\r\n/**\r\n * Hybrid search client targeted at policy corpus (district / state / federal). Encapsulates\r\n * the mapping of high level scope types into concrete `document_type` attribute values\r\n * persisted inside the search index.\r\n */\r\nexport class HybridPolicySearch extends HybridSearchClient<PolicySearchOptions> {\r\n  /** Returns the policy index name (environment sourced). */\r\n  protected getSearchIndexName(): string {\r\n    return env('AZURE_AISEARCH_POLICY_INDEX_NAME');\r\n  }\r\n\r\n  /**\r\n   * Appends policy scope filters to the outgoing payload by translating logical scope values\r\n   * (e.g. 'state') into one or more underlying document type identifiers.\r\n   *\r\n   * The resulting filter is an OR chain across selected types, applied directly as the payload's\r\n   * `filter` property (overwriting any previous value – acceptable because this subclass owns\r\n   * its filter semantics).\r\n   */\r\n  protected appendScopeFilter(\r\n    payload: HybridSearchPayload,\r\n    options: PolicySearchOptions,\r\n  ): void {\r\n    // Example: apply a filter based on a \"scopeType\" property in options.metadata\r\n    // (You may need to adjust this logic based on your actual requirements)\r\n    const policyType = options?.scope;\r\n    let filterValues: string[] = [];\r\n\r\n    // Update these cases to reflect only valid/allowed values for your application\r\n    const validTypes: Record<PolicySearchScopeType, Array<string>> = {\r\n      'school-district': ['1'],\r\n      state: ['2'],\r\n      federal: ['3'],\r\n    };\r\n\r\n    if (Array.isArray(policyType)) {\r\n      filterValues = policyType\r\n        .flatMap((type) => validTypes[type])\r\n        .filter(Boolean);\r\n    } else if (typeof policyType === 'string') {\r\n      const mapped = validTypes[policyType];\r\n      if (mapped) {\r\n        filterValues = [mapped];\r\n      }\r\n    }\r\n\r\n    if (filterValues.length > 0) {\r\n      const orFilters = filterValues\r\n        .map(\r\n          (val) =>\r\n            `metadata/attributes/any(a: a/key eq 'document_type' and a/value eq '${val}')`,\r\n        )\r\n        .join(' or ');\r\n      payload.filter = orFilters;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Factory helper for creating a {@link HybridPolicySearch} with optional embedding service injection.\r\n * @param options Optional configuration with embeddingService override.\r\n */\r\nexport const hybridPolicySearchFactory = (options?: {\r\n  embeddingService?: IEmbeddingService;\r\n}) => new HybridPolicySearch(options);\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\search\\HybridSearchBase.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":3,"column":1,"nodeType":"Program","endLine":378,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// AzureBaseSearchClient.ts\r\n\r\nimport { env } from '@/lib/site-util/env';\r\nimport { type IEmbeddingService, EmbeddingService } from '../embedding';\r\nimport type {\r\n  HybridSearchOptions,\r\n  VectorBlock,\r\n  AiSearchResult,\r\n  HybridSearchPayload,\r\n  AiSearchResultEnvelope,\r\n} from './types';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { fetch } from '@/lib/nextjs-util/fetch';\r\nimport { log, logEvent } from '@/lib/logger';\r\nimport { performance } from 'perf_hooks';\r\n\r\n/**\r\n * Raw metadata structure returned by Azure AI Search (or compatible hybrid search endpoint)\r\n * for each individual hit. It is composed of an array of key/value pairs instead of a flat\r\n * object so that multiple instances of the same logical key (e.g. multi‑value tags) can be\r\n * preserved and later reconstructed into arrays.\r\n */\r\ntype SearchMeta = {\r\n  attributes: Array<{ key: string; value: unknown }>;\r\n};\r\n\r\n/**\r\n * Abstract base class, parameterized by your scope‐type (e.g. policyTypeId).\r\n */\r\nexport abstract class HybridSearchClient<TOptions extends HybridSearchOptions> {\r\n  /**\r\n   * Extracts the canonical document identifier from a metadata bag.\r\n   *\r\n   * The Azure index stores scalar metadata in the attributes collection. We look for an\r\n   * attribute with key 'id' and coerce its value to a string. If not present, the caller\r\n   * can fall back to the root level document's own `id` field.\r\n   *\r\n   * @param metadata Raw metadata attribute set for a single hit.\r\n   * @returns Identifier string if present; otherwise undefined.\r\n   */\r\n  protected static readonly parseId = (\r\n    metadata: SearchMeta,\r\n  ): string | undefined => {\r\n    const found = metadata?.attributes?.find((m) => m.key === 'id')?.value;\r\n    return found ? String(found) : undefined;\r\n  };\r\n  /**\r\n   * Normalizes raw attribute key/value pairs into a flat record with arrays for repeated\r\n   * logical keys. Keys that end with a trailing number (e.g. `tag1`, `tag2`) are treated as\r\n   * a single logical key (`tag`) whose value becomes an array preserving insertion order.\r\n   *\r\n   * @example\r\n   * Input attributes: [{ key: 'tag1', value: 'a' }, { key: 'tag2', value: 'b' }]\r\n   * Output record: { tag: ['a','b'] }\r\n   *\r\n   * Non‑numeric‑suffixed keys map directly to a scalar value. If a non‑numeric key repeats\r\n   * it is automatically promoted to an array of values.\r\n   *\r\n   * @param metadata Raw metadata attribute set for a single hit.\r\n   * @returns Flattened, consumer‑friendly metadata object.\r\n   */\r\n  protected static readonly parseMetadata = (\r\n    metadata: SearchMeta,\r\n  ): Record<string, unknown> => {\r\n    const result: Record<string, unknown> = {};\r\n    const processExisting = (\r\n      key: string,\r\n      attr: { value: unknown },\r\n      arrayByDefault = false,\r\n    ) => {\r\n      const existing = result[key];\r\n      if (Array.isArray(existing)) {\r\n        existing.push(attr.value);\r\n      } else if (existing !== undefined) {\r\n        result[key] = [existing, attr.value];\r\n      } else {\r\n        result[key] = arrayByDefault ? [attr.value] : attr.value;\r\n      }\r\n    };\r\n    metadata?.attributes?.forEach((attr) => {\r\n      if (!attr.value) return;\r\n      const key = attr.key;\r\n      const m = key.match(/^(.+?)(\\d+)$/);\r\n      if (m && m.at(1)) {\r\n        processExisting(m[1], attr, true);\r\n      } else {\r\n        processExisting(key, attr);\r\n      }\r\n    });\r\n    return result;\r\n  };\r\n  /**\r\n   * INTERNAL: Converts a raw Azure Search JSON response into the strongly typed\r\n   * {@link AiSearchResultEnvelope} consumed by higher layers.\r\n   *\r\n   * Responsibilities:\r\n   *  - Detect and surface service level errors (throws with contextual details)\r\n   *  - Gracefully handle empty / missing result sets\r\n   *  - Map each hit into a normalized structure (id, content, metadata, score)\r\n   *  - Extract optional total counts and continuation tokens\r\n   *\r\n   * The method is static and pure: it performs no logging unless an error occurs\r\n   * while mapping an individual hit, in which case a LoggedError is emitted and\r\n   * the offending hit is omitted from the final result list.\r\n   *\r\n   * @param json Raw JSON body from the search API.\r\n   * @param query Original natural language query string provided by caller.\r\n   * @param options Options used during the search (forwarded for context in errors/warnings).\r\n   * @throws Error when the service reports an error block.\r\n   */\r\n  protected static readonly parseResponse = <TOptions>(\r\n    json: {\r\n      error?: { code?: string; message?: string };\r\n      value?: Record<string, unknown>[];\r\n      '@odata.count'?: number;\r\n      '@odata.nextLink'?: string;\r\n    },\r\n    query: string,\r\n    options: TOptions,\r\n  ): AiSearchResultEnvelope => {\r\n    if (json.error) {\r\n      const { code, message } = json.error;\r\n      throw new Error(\r\n        `Error in search response: ${message || '[no message]'}` +\r\n          ` (code: ${code || '[no code]'})\\nRaw: ${JSON.stringify(json)}`,\r\n      );\r\n    }\r\n\r\n    if (!Array.isArray(json.value)) {\r\n      log((l) =>\r\n        l.warn({\r\n          message: `No 'value' array in response. query=${query} options=${JSON.stringify(options)}`,\r\n          data: {\r\n            options,\r\n            query,\r\n          },\r\n        }),\r\n      );\r\n      return { results: [] };\r\n    }\r\n\r\n    if (json.value.length === 0) {\r\n      log((l) =>\r\n        l.warn({\r\n          message: `No results for query=${query} options=${JSON.stringify(options)}`,\r\n          data: { options, query },\r\n        }),\r\n      );\r\n      return { results: [] };\r\n    }\r\n\r\n    return {\r\n      results: json.value\r\n        .map((doc: Record<string, unknown>, idx: number) => {\r\n          try {\r\n            return {\r\n              id:\r\n                HybridSearchClient.parseId(doc.metadata as SearchMeta) ??\r\n                doc.id,\r\n              content: doc.content,\r\n              metadata:\r\n                HybridSearchClient.parseMetadata(doc.metadata as SearchMeta) ??\r\n                doc.metadata,\r\n              score: doc['@search.rerankerScore'] ?? doc['@search.score'] ?? 0,\r\n            } as AiSearchResult;\r\n          } catch (e) {\r\n            LoggedError.isTurtlesAllTheWayDownBaby(e, {\r\n              log: true,\r\n              message: `Error parsing hit #${idx}`,\r\n              data: {\r\n                query,\r\n                options,\r\n              },\r\n            });\r\n            return null;\r\n          }\r\n        })\r\n        .filter((r: AiSearchResult | null): r is AiSearchResult => !!r),\r\n      ...({\r\n        total: json['@odata.count'] ? Number(json['@odata.count']) : undefined,\r\n        continuationToken: json['@odata.nextLink'] ?? undefined,\r\n      } as Partial<AiSearchResultEnvelope>),\r\n    };\r\n  };\r\n  /**\r\n   * Underlying embedding service responsible for turning the natural query into\r\n   * a numeric vector suitable for vector portion of the hybrid search.\r\n   */\r\n  protected readonly embeddingService: IEmbeddingService;\r\n\r\n  /**\r\n   * Creates a new HybridSearchClient.\r\n   *\r\n   * Accepts either:\r\n   *  1. An {@link IEmbeddingService} implementation (used directly), or\r\n   *  2. An options object with optional `embeddingService` property, or\r\n   *  3. Nothing – in which case a new default {@link EmbeddingService} is provisioned.\r\n   *\r\n   * @param embeddingServiceOrOptions Optional embedding service instance or configuration wrapper.\r\n   * @throws Error if the argument is neither an embedding service nor an options object.\r\n   */\r\n  constructor(\r\n    embeddingServiceOrOptions?:\r\n      | IEmbeddingService\r\n      | {\r\n          embeddingService?: IEmbeddingService;\r\n        },\r\n  ) {\r\n    if (!embeddingServiceOrOptions) {\r\n      this.embeddingService = new EmbeddingService();\r\n    } else {\r\n      if ('embeddingService' in embeddingServiceOrOptions) {\r\n        this.embeddingService =\r\n          embeddingServiceOrOptions.embeddingService ?? new EmbeddingService();\r\n      } else if ('embed' in embeddingServiceOrOptions) {\r\n        this.embeddingService = embeddingServiceOrOptions;\r\n      } else {\r\n        throw new Error(\r\n          'Invalid argument: expected an IEmbeddingService or an object with embeddingService property',\r\n          { cause: embeddingServiceOrOptions },\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Implemented by concrete subclasses to return the Azure AI Search index name\r\n   * to target (e.g. documents vs policies). Should be stable and usually sourced\r\n   * from configuration / environment variables.\r\n   */\r\n  protected abstract getSearchIndexName(): string;\r\n\r\n  /**\r\n   * Gives subclasses a chance to mutate the outgoing payload with filter logic\r\n   * derived from user / domain specific options (e.g. restricting by document\r\n   * type, policy jurisdiction, ownership, etc.).\r\n   *\r\n   * Implementations SHOULD be pure (no side effects beyond the provided payload) and\r\n   * SHOULD NOT remove existing required properties.\r\n   *\r\n   * @param payload Mutable payload object that will be serialized for the search request.\r\n   * @param options User supplied search options.\r\n   */\r\n  protected abstract appendScopeFilter(\r\n    payload: HybridSearchPayload,\r\n    options: TOptions,\r\n  ): void;\r\n\r\n  /**\r\n   * Returns the Azure Search service API version in use. Centralized here to\r\n   * simplify coordinated upgrades.\r\n   */\r\n  protected getSearchApiVersion(): string {\r\n    return '2025-05-01-preview';\r\n  }\r\n\r\n  /**\r\n   * Builds the fully qualified search endpoint URL including index path and API version.\r\n   */\r\n  protected getServiceUrl(): string {\r\n    return (\r\n      `${env('AZURE_AISEARCH_ENDPOINT')}` +\r\n      `/indexes/${this.getSearchIndexName()}` +\r\n      `/docs/search?api-version=${this.getSearchApiVersion()}`\r\n    );\r\n  }\r\n\r\n  public async hybridSearch(\r\n    naturalQuery: string,\r\n    options?: TOptions,\r\n  ): Promise<AiSearchResultEnvelope> {\r\n    /**\r\n     * Executes a hybrid (semantic + vector) search against the configured index.\r\n     *\r\n     * Workflow:\r\n     *  1. Generate / fetch an embedding for the natural language query.\r\n     *  2. Construct a vector query block (k expanded to at least 50 for richer recall).\r\n     *  3. Build the hybrid payload (semantic configuration, paging, selection, filters).\r\n     *  4. POST to the Azure AI Search endpoint with API key authentication.\r\n     *  5. Parse, normalize, and return results via {@link HybridSearchClient.parseResponse}.\r\n     *\r\n     * Error Handling:\r\n     *  - Network / fetch errors are wrapped in a {@link LoggedError} with contextual metadata.\r\n     *  - Service reported errors (embedded in JSON) throw early inside parseResponse.\r\n     *\r\n     * @param naturalQuery User provided freeform text query.\r\n     * @param options Domain specific hybrid search options (paging, filters, counts, etc.).\r\n     * @returns Envelope containing normalized results plus optional total/continuation data.\r\n     */\r\n    const {\r\n      hitsPerPage: topK = 5, // default to 15 results\r\n      page = 1, // default to first page\r\n      exhaustive = false,\r\n    } = options ?? {};\r\n    const url = this.getServiceUrl();\r\n\r\n    // 1) ensure we have an embedding\r\n    const embeddingVector = await this.embeddingService.embed(naturalQuery);\r\n    // 2) build our vector‐query block\r\n\r\n    const vectorBlock: VectorBlock = {\r\n      vector: embeddingVector,\r\n      kind: 'vector',\r\n      fields: 'content_vector',\r\n      k: Math.max(50, topK),\r\n      exhaustive,\r\n    };\r\n\r\n    const payload: HybridSearchPayload = {\r\n      search: naturalQuery,\r\n      vectorQueries: [vectorBlock],\r\n      top: topK,\r\n      queryType: 'semantic',\r\n      semanticConfiguration: 'semantic-search-config',\r\n      select: 'content,id,metadata',\r\n      ...(options?.count ? { count: true } : {}),\r\n      ...(page > 1 ? { skip: (page - 1) * topK } : {}),\r\n    };\r\n    this.appendScopeFilter(payload, options ?? ({} as TOptions));\r\n\r\n    try {\r\n      const timer = performance.now();\r\n      const res = await fetch(url, {\r\n        method: 'POST',\r\n        headers: {\r\n          'x-ms-azs-return-searchid': 'true',\r\n          'Access-Control-Expose-Headers': 'x-ms-azs-searchid',\r\n          'Content-Type': 'application/json',\r\n          'api-key': env('AZURE_AISEARCH_KEY') ?? '',\r\n        },\r\n        body: JSON.stringify(payload),\r\n      });\r\n      const body = await res.json();\r\n      const elapsed = performance.now() - timer;\r\n      const ret = HybridSearchClient.parseResponse(\r\n        body,\r\n        naturalQuery,\r\n        options ?? ({} as TOptions),\r\n      );\r\n      const searchId = res.headers?.get('x-ms-azs-searchid');\r\n      if (searchId) {\r\n        ret.searchId = searchId;\r\n        logEvent('Search', {\r\n          SearchServiceName: 'schoollawsearch',\r\n          SearchId: searchId,\r\n          IndexName: this.getSearchIndexName(),\r\n          QueryTerms: naturalQuery,\r\n          Latency: elapsed,\r\n          ResultCount: ret.results?.length ?? 0,\r\n          TopThreeById: ret.results\r\n            ?.slice(0, 3)\r\n            .map((r) => r.id)\r\n            .join(','),\r\n          ScoringProfile: 'Hybrid',\r\n        });\r\n      }\r\n      return ret;\r\n    } catch (err) {\r\n      const le = LoggedError.isTurtlesAllTheWayDownBaby(err, {\r\n        log: true,\r\n        message: 'Error performing hybrid search',\r\n        source: 'HybridSearchClient.hybridSearch',\r\n        data: {\r\n          naturalQuery,\r\n          options,\r\n          payload,\r\n        },\r\n      });\r\n      logEvent('error', 'SearchError', {\r\n        SearchServiceName: 'schoollawsearch',\r\n        QueryTerms: naturalQuery,\r\n        ErrorMessage: le.toString(),\r\n      });\r\n      throw le;\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\search\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\services\\search\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":12,"column":1,"nodeType":"Program","endLine":182,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Options for configuring a hybrid search operation.\r\n *\r\n * @property hitsPerPage - Optional. The number of results to return per page.\r\n * @property page - Optional. The page number to retrieve (for pagination).\r\n * @property metadata - Optional. Additional metadata to include with the search, represented as key-value pairs.\r\n * @property count - Optional. If true, the total number of results will be returned in the response.\r\n * @property continuationToken - Optional. A token for pagination, allowing retrieval of the next set of results.\r\n *            This is useful for large result sets where you want to fetch results in chunks.\r\n *            If set, hitsPerPage and page are ignored, and the search will return the next set of results based on the token.\r\n */\r\nexport type HybridSearchOptions = {\r\n  /**\r\n   * Optional. The number of results to return per page.\r\n   */\r\n  hitsPerPage?: number;\r\n  /**\r\n   * Optional. The page number to retrieve (for pagination).\r\n   */\r\n  page?: number;\r\n  /**\r\n   * Optional. Additional metadata to include with the search, represented as key-value pairs.\r\n   */\r\n  metadata?: Record<string, string>;\r\n  /**\r\n   * Optional. If true, the total number of results will be returned in the response.\r\n   * This is useful for understanding the scope of the search results.\r\n   */\r\n  count?: boolean;\r\n  /**\r\n   * Optional. A token for pagination, allowing retrieval of the next set of results.\r\n   * This is useful for large result sets where you want to fetch results in chunks.\r\n   * If set, hitsPerPage and page are ignored, and the search will return the next set of results based on the token.\r\n   */\r\n  continuationToken?: string;\r\n  /***\r\n   * When true, triggers an exhaustive k-nearest neighbor search across all vectors within the vector index.\r\n   * Useful for scenarios where exact matches are critical, such as determining ground truth values.  Default is false.\r\n   */\r\n  exhaustive?: boolean;\r\n};\r\n\r\n/**\r\n * Shape of the search-result model.\r\n */\r\nexport interface AiSearchResult {\r\n  /**\r\n   * Optional. Unique identifier for this search result.\r\n   * This can be used to reference the result in subsequent operations.\r\n   */\r\n  id?: string;\r\n  /**\r\n   * The main content of the search result.\r\n   * This is typically the text or data that matches the search query.\r\n   */\r\n  content: string;\r\n  /**\r\n   * Optional. Additional metadata describing the search result, represented as key-value pairs.\r\n   * This can include information such as source, timestamp, or any other relevant details.\r\n   */\r\n  metadata?: Record<string, unknown>;\r\n  /**\r\n   * The relevance score of the search result.\r\n   * This is typically a numeric value indicating how well the result matches the search query.\r\n   */\r\n  score: number;\r\n}\r\n\r\n/**\r\n * Represents the envelope for AI search results, including the list of results,\r\n * the total number of results available, and an optional continuation token for pagination.\r\n *\r\n * @property results - An array of AI search result items.\r\n * @property total - (Optional) The total number of results matching the search criteria.  This is only returned when the `count` options is true.\r\n * @property continuationToken - (Optional) A token used to retrieve the next set of results for pagination.\r\n */\r\nexport type AiSearchResultEnvelope = {\r\n  /**\r\n   * Optional unique identifier assigned by the search service for this specific search operation.\r\n   */\r\n  searchId?: string;\r\n  /**\r\n   * An array of AI search results.\r\n   */\r\n  results: AiSearchResult[];\r\n  /**\r\n   * The total number of results available for the search query.\r\n   * This is useful for understanding the scope of the search results.\r\n   * It is only returned when the count option is set to true in the search request.\r\n   */\r\n  total?: number;\r\n  /**\r\n   * A token for pagination, allowing retrieval of the next set of results.\r\n   * This is useful for large result sets where you want to fetch results in chunks.\r\n   */\r\n  continuationToken?: string;\r\n};\r\n\r\n/**\r\n * Represents a block of vector search parameters.\r\n *\r\n * @property vector - The numerical vector used for searching.\r\n * @property kind - The type of block, always set to 'vector'.\r\n * @property fields - The fields to be searched or indexed.\r\n * @property k - The number of nearest neighbors to retrieve.\r\n * @property exhaustive - Whether to perform an exhaustive search.\r\n */\r\nexport type VectorBlock = {\r\n  /**\r\n   * The numerical vector used for searching.\r\n   */\r\n  vector: number[];\r\n  /**\r\n   * The type of block, always set to 'vector'.\r\n   */\r\n  kind: 'vector';\r\n  /**\r\n   * The fields to be searched or indexed.\r\n   */\r\n  fields: string;\r\n  /**\r\n   * The number of nearest neighbors to retrieve.\r\n   */\r\n  k: number;\r\n  /**\r\n   * Whether to perform an exhaustive search.\r\n   */\r\n  exhaustive: boolean;\r\n};\r\n\r\n/**\r\n * Represents the payload for performing a hybrid search operation.\r\n *\r\n * @property search - The search query string.\r\n * @property filter - Optional filter expression to refine search results.\r\n * @property vectorQueries - An array of vector-based search queries.\r\n * @property top - The maximum number of results to return.\r\n * @property queryType - The type of query to execute.\r\n * @property semanticConfiguration - The semantic configuration to use for the search.\r\n * @property select - Comma-separated list of fields to include in the result.\r\n * @property count - Optional flag to include the total count of results.\r\n * @property skip - Optional number of results to skip (for pagination).\r\n */\r\nexport type HybridSearchPayload = {\r\n  /**\r\n   * The search query string.\r\n   */\r\n  search: string;\r\n  /**\r\n   * Optional filter expression to refine search results.\r\n   */\r\n  filter?: string;\r\n  /**\r\n   * An array of vector-based search queries.\r\n   */\r\n  vectorQueries: VectorBlock[];\r\n  /**\r\n   * The maximum number of results to return.\r\n   */\r\n  top: number;\r\n  /**\r\n   * The type of query to execute.\r\n   */\r\n  queryType: string;\r\n  /**\r\n   * The semantic configuration to use for the search.\r\n   */\r\n  semanticConfiguration: string;\r\n  /**\r\n   * Comma-separated list of fields to include in the result.\r\n   */\r\n  select: string;\r\n  /**\r\n   * Optional flag to include the total count of results.\r\n   */\r\n  count?: boolean;\r\n  /**\r\n   * Optional number of results to skip (for pagination).\r\n   */\r\n  skip?: number;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\amendCaseRecord.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":802,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport {\r\n  Amendment,\r\n  AmendmentResult,\r\n  CaseFileAmendment,\r\n  ResponsiveActionAssociation,\r\n  ToolCallbackResult,\r\n} from './types';\r\nimport {\r\n  resolveCaseFileId,\r\n  toolCallbackArrayResultSchemaFactory,\r\n} from './utility';\r\nimport {\r\n  callToActionDetails,\r\n  callToActionDetailsCallToActionResponse,\r\n  callToActionResponseDetails,\r\n  documentProperty,\r\n  documentUnits,\r\n  keyPointsDetails,\r\n  violationDetails,\r\n} from '@/drizzle/schema';\r\nimport { eq } from 'drizzle-orm';\r\nimport { log } from '@/lib/logger';\r\nimport { toolCallbackResultFactory } from './utility';\r\nimport { newUuid } from '@/lib/typescript';\r\nimport { EmailPropertyTypeTypeId } from '@/data-models/api/email-properties/property-type';\r\nimport {\r\n  drizDb,\r\n  CallToActionResponsiveActionLinkType,\r\n  DbTransactionType,\r\n  addDocumentRelations,\r\n  addNotesToDocument,\r\n} from '@/lib/drizzle-db';\r\nimport { appMeters } from '@/lib/site-util/metrics';\r\nimport { CaseFileAmendmentShape } from './schemas/caseFileAmendmentShape';\r\nimport { AmendmentResultShape } from './schemas/amendment-result-schema';\r\n\r\n// OpenTelemetry Metrics for AmendCaseRecord Tool\r\nconst amendCaseRecordCounter = appMeters.createCounter(\r\n  'ai_tool_amend_case_record_total',\r\n  {\r\n    description: 'Total number of case record amendment operations',\r\n    unit: '1',\r\n  },\r\n);\r\n\r\nconst amendCaseRecordDurationHistogram = appMeters.createHistogram(\r\n  'ai_tool_amend_case_record_duration_ms',\r\n  {\r\n    description: 'Duration of case record amendment operations',\r\n    unit: 'ms',\r\n  },\r\n);\r\n\r\nconst amendmentRecordsHistogram = appMeters.createHistogram(\r\n  'ai_tool_amendment_records_count',\r\n  {\r\n    description: 'Number of records updated/inserted per amendment operation',\r\n    unit: '1',\r\n  },\r\n);\r\n\r\nconst amendmentErrorCounter = appMeters.createCounter(\r\n  'ai_tool_amend_case_record_errors_total',\r\n  {\r\n    description: 'Total number of case record amendment errors',\r\n    unit: '1',\r\n  },\r\n);\r\n\r\n/**\r\n * Updates the main record in the database based on the provided document type and amendment details.\r\n *\r\n * @param tx - The database transaction object.\r\n * @param du - The document unit containing the document type and property ID.\r\n * @param details - The amendment details including ratings, reasons, and arrays for updated and failed records.\r\n * @returns A promise that resolves when the update is complete.\r\n * @example\r\n * await updateMainRecord(tx, { documentType: 'cta', documentPropertyId: '123' }, {\r\n *   severityRating: 5,\r\n *   updated: [],\r\n *   failed: []\r\n * });\r\n */\r\nconst updateMainRecord = async (\r\n  tx: DbTransactionType,\r\n  du: { documentPropertyId: string | null; documentType: string | null },\r\n  {\r\n    severityRating,\r\n    severityReasons,\r\n    complianceRating,\r\n    complianceReasons,\r\n    completionRating,\r\n    completionReasons,\r\n    sentimentRating,\r\n    sentimentReasons,\r\n    chapter13Rating,\r\n    chapter13Reasons,\r\n    titleIXRating,\r\n    titleIXReasons,\r\n    updated,\r\n    failed,\r\n  }: Partial<CaseFileAmendment> & {\r\n    updated: Array<Amendment>;\r\n    failed: Array<Amendment & { error: string }>;\r\n  },\r\n): Promise<void> => {\r\n  if (\r\n    !(\r\n      severityRating ??\r\n      severityReasons?.length ??\r\n      complianceRating ??\r\n      complianceReasons?.length ??\r\n      completionRating ??\r\n      completionReasons?.length ??\r\n      sentimentRating ??\r\n      sentimentReasons?.length ??\r\n      chapter13Rating ??\r\n      chapter13Reasons?.length ??\r\n      titleIXRating ??\r\n      titleIXReasons?.length\r\n    )\r\n  ) {\r\n    // nothing to do\r\n    return;\r\n  }\r\n\r\n  switch (du.documentType) {\r\n    case 'cta':\r\n      await tx\r\n        .update(callToActionDetails)\r\n        .set({\r\n          ...(severityRating !== undefined ? { severity: severityRating } : {}),\r\n          ...(severityReasons !== undefined\r\n            ? { severityReason: severityReasons }\r\n            : {}),\r\n          ...(sentimentRating !== undefined\r\n            ? { sentiment: sentimentRating }\r\n            : {}),\r\n          ...(sentimentReasons !== undefined ? { sentimentReasons } : {}),\r\n          ...(complianceRating !== undefined ? { complianceRating } : {}),\r\n          ...(complianceReasons !== undefined\r\n            ? { complianceRatingReasons: complianceReasons }\r\n            : {}),\r\n        })\r\n        .where(eq(callToActionDetails.propertyId, du.documentPropertyId!))\r\n        .execute();\r\n      break;\r\n    case 'cta_response':\r\n      await tx\r\n        .update(callToActionResponseDetails)\r\n        .set({\r\n          ...(complianceRating ? { complianceRating } : {}),\r\n          ...(severityRating ? { severity: severityRating } : {}),\r\n          ...(severityReasons?.length\r\n            ? { severityReason: severityReasons }\r\n            : {}),\r\n          ...(sentimentRating ? { sentiment: sentimentRating } : {}),\r\n          ...(sentimentReasons?.length ? { sentimentReasons } : {}),\r\n        })\r\n        .where(\r\n          eq(callToActionResponseDetails.propertyId, du.documentPropertyId!),\r\n        )\r\n        .execute();\r\n      break;\r\n    case 'key_point':\r\n      await tx\r\n        .update(keyPointsDetails)\r\n        .set({\r\n          ...(complianceRating ? { compliance: complianceRating } : {}),\r\n          ...(complianceReasons?.length ? { complianceReasons } : {}),\r\n          ...(severityRating ? { severityRanking: severityRating } : {}),\r\n          ...(severityReasons?.length\r\n            ? { severityReason: severityReasons }\r\n            : {}),\r\n        })\r\n        .where(eq(keyPointsDetails.propertyId, du.documentPropertyId!))\r\n        .execute();\r\n      break;\r\n    case 'compliance':\r\n      await tx\r\n        .update(violationDetails)\r\n        .set({\r\n          ...(severityRating ? { severityLevel: severityRating } : {}),\r\n          ...(severityReasons?.length ? { severityReasons } : {}),\r\n          ...(titleIXRating ? { titleIxRelevancy: titleIXRating } : {}),\r\n          ...(chapter13Rating ? { chapt13Relevancy: chapter13Rating } : {}),\r\n        })\r\n        .where(eq(violationDetails.propertyId, du.documentPropertyId!))\r\n        .execute();\r\n      break;\r\n    default:\r\n      log((l) =>\r\n        l.warn(\r\n          'Attempted to update main record for unsupported document type',\r\n          {\r\n            documentType: du.documentType,\r\n          },\r\n        ),\r\n      );\r\n      failed.push({\r\n        id: du.documentPropertyId!,\r\n        error: 'Unsupported document type',\r\n        changes: {\r\n          severityRating,\r\n          severityReasons,\r\n          complianceRating,\r\n          complianceReasons,\r\n          completionRating,\r\n          completionReasons,\r\n          sentimentRating,\r\n          sentimentReasons,\r\n          chapter13Rating,\r\n          chapter13Reasons,\r\n          titleIXRating,\r\n          titleIXReasons,\r\n        },\r\n      });\r\n      tx.rollback();\r\n      return;\r\n  }\r\n  updated.push({\r\n    id: du.documentPropertyId!,\r\n    changes: {\r\n      severityRating,\r\n      severityReasons,\r\n      complianceRating,\r\n      complianceReasons,\r\n      completionRating,\r\n      completionReasons,\r\n      sentimentRating,\r\n      sentimentReasons,\r\n      chapter13Rating,\r\n      chapter13Reasons,\r\n      titleIXRating,\r\n      titleIXReasons,\r\n    },\r\n  });\r\n};\r\n\r\n/**\r\n * Adds notes to the database for a specific target document.\r\n *\r\n * @param params - An object containing the transaction, notes, target document, and arrays for inserted and failed records.\r\n * @returns A promise that resolves when the notes are added.\r\n * @example\r\n * await addNotes({\r\n *   tx,\r\n *   notes: ['Note 1', 'Note 2'],\r\n *   target: { unitId: 1, emailId: 'abc' },\r\n *   insertedRecords: [],\r\n *   failedRecords: []\r\n * });\r\n */\r\nconst addNotes = async ({\r\n  tx,\r\n  notes: notesFromProps,\r\n  target: { unitId },\r\n  insertedRecords,\r\n  failedRecords,\r\n}: {\r\n  tx: DbTransactionType;\r\n  notes?: Array<string>;\r\n  target: { unitId: number; emailId: string | null };\r\n  insertedRecords: Array<Amendment>;\r\n  failedRecords: Array<Amendment & { error: string }>;\r\n}) => {\r\n  if (notesFromProps?.length) {\r\n    try {\r\n      const notes = await addNotesToDocument({\r\n        db: tx,\r\n        documentId: unitId,\r\n        notes: notesFromProps,\r\n      });\r\n      insertedRecords.push(\r\n        ...notes.map((note) => ({\r\n          id: note.propertyId,\r\n          changes: { notes: [note.propertyValue!] },\r\n        })),\r\n      );\r\n    } catch (error) {\r\n      const le = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'amendCaseRecord:addNotes',\r\n        data: { notesFromProps, unitId },\r\n      });\r\n      failedRecords.push(\r\n        ...notesFromProps.map((note) => ({\r\n          id: note,\r\n          error: le.message ?? 'Failed to insert note',\r\n          changes: { notes: [note] },\r\n        })),\r\n      );\r\n      tx.rollback();\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Adds violations to the database for a specific target document.\r\n *\r\n * @param params - An object containing the transaction, violations, target document, and arrays for inserted and failed records.\r\n * @returns A promise that resolves when the violations are added.\r\n * @example\r\n * await addViolations({\r\n *   tx,\r\n *   violations: [{ violationType: 'Type A', severityLevel: 3 }],\r\n *   target: { unitId: 1, emailId: 'abc' },\r\n *   insertedRecords: [],\r\n *   failedRecords: []\r\n * });\r\n */\r\nexport const addViolations = async ({\r\n  tx,\r\n  violations,\r\n  insertedRecords,\r\n  failedRecords,\r\n  target: { unitId: emailDocumentId, emailId },\r\n}: Omit<CaseFileAmendment, 'targetCaseFileId' | 'explanation'> & {\r\n  tx: DbTransactionType;\r\n  target: { unitId: number; emailId: string | null };\r\n  insertedRecords: Array<Amendment>;\r\n  failedRecords: Array<Amendment & { error: string }>;\r\n}): Promise<void> => {\r\n  if (violations?.length) {\r\n    const violationRecords = violations.map(\r\n      ({\r\n        violationType,\r\n        severityLevel,\r\n        severityReasons,\r\n        violationReasons,\r\n        titleIxRelevancy,\r\n        chapt13Relevancy,\r\n        ferpaRelevancy,\r\n        otherRelevancy,\r\n      }) => {\r\n        return {\r\n          propertyId: newUuid(),\r\n          emailDocumentId,\r\n          violationType,\r\n          severityLevel,\r\n          severityReasons: severityReasons ?? [],\r\n          violationReasons,\r\n          titleIxRelevancy: titleIxRelevancy ?? 0,\r\n          chapt13Relevancy: chapt13Relevancy ?? 0,\r\n          ferpaRelevancy: ferpaRelevancy ?? 0,\r\n          otherRelevancy: otherRelevancy ?? 0,\r\n        };\r\n      },\r\n    );\r\n\r\n    try {\r\n      await tx\r\n        .insert(documentUnits)\r\n        .values(\r\n          violationRecords.map(({ violationType, propertyId }) => ({\r\n            emailId,\r\n            documentType: 'compliance',\r\n            createdOn: new Date(Date.now()).toISOString(),\r\n            content: violationType,\r\n            documentPropertyId: propertyId,\r\n          })),\r\n        )\r\n        .execute();\r\n\r\n      await tx\r\n        .insert(documentProperty)\r\n        .values(\r\n          violationRecords.map((v) => ({\r\n            propertyId: v.propertyId,\r\n            documentId: v.emailDocumentId,\r\n            severityLevel: v.severityLevel,\r\n            severityReason: v.severityReasons,\r\n            documentPropertyTypeId: EmailPropertyTypeTypeId.ViolationDetails,\r\n            createdOn: new Date(Date.now()).toISOString(),\r\n            propertyValue: v.violationType,\r\n          })),\r\n        )\r\n        .execute();\r\n      await tx.insert(violationDetails).values(violationRecords).execute();\r\n      insertedRecords.push(\r\n        ...violationRecords.map((record) => ({\r\n          id: record.propertyId,\r\n          changes: { violations: [record] },\r\n        })),\r\n      );\r\n    } catch (error) {\r\n      const le = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'amendCaseRecord:processViolations',\r\n        data: { violations },\r\n      });\r\n      failedRecords.push(\r\n        ...violationRecords.map((record) => ({\r\n          id: record.propertyId,\r\n          error: le.message ?? 'Failed to insert violation',\r\n          changes: { violations: [record] },\r\n        })),\r\n      );\r\n      tx.rollback();\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Associates responsive actions with a CTA response document.\r\n *\r\n * @param params - An object containing the transaction, responsive actions, and target document details.\r\n * @returns A promise that resolves when the associations are made.\r\n * @throws An error if the document type is not a CTA response or if the document property ID is missing.\r\n * @example\r\n * await associatResponsiveAction({\r\n *   tx,\r\n *   associateResponsiveAction: [{ relatedCtaDocumentId: 1 }],\r\n *   target: { documentType: 'cta_response', documentPropertyId: '123' }\r\n * });\r\n */\r\nconst associateResponsiveActions = async ({\r\n  tx,\r\n  associateResponsiveAction,\r\n  target: { documentType, documentPropertyId },\r\n}: {\r\n  tx: DbTransactionType;\r\n  target: {\r\n    unitId: number;\r\n    documentType: string | null;\r\n    documentPropertyId: string | null;\r\n  };\r\n  associateResponsiveAction: Array<ResponsiveActionAssociation> | undefined;\r\n}) => {\r\n  // See if we can early-exit\r\n  if (!associateResponsiveAction?.length) {\r\n    return;\r\n  }\r\n  // Verify we are dealing with a valid responsive action\r\n  if (documentType !== 'cta_response') {\r\n    throw new Error(\r\n      'The source document id must be a CTA Response to associate with a CTA.',\r\n    );\r\n  }\r\n  if (!documentPropertyId) {\r\n    throw new Error(\r\n      'The source document id must have a document property ID to associate with a CTA.',\r\n    );\r\n  }\r\n\r\n  const targetActions = (\r\n    await tx.query.documentUnits.findMany({\r\n      where: (documentUnits, { inArray, eq, and }) =>\r\n        and(\r\n          inArray(\r\n            documentUnits.unitId,\r\n            associateResponsiveAction.map((m) => m.relatedCtaDocumentId),\r\n          ),\r\n          eq(documentUnits.documentType, 'cta'),\r\n        ),\r\n      with: {\r\n        docProp: {\r\n          columns: {},\r\n          with: {\r\n            cta: {\r\n              columns: {},\r\n              with: {\r\n                responses: {\r\n                  columns: {},\r\n                  with: {\r\n                    ctaResponse: {\r\n                      columns: {\r\n                        propertyId: true,\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    })\r\n  ).filter((v) =>\r\n    (\r\n      v.docProp?.cta?.responses?.map((r) => r.ctaResponse?.propertyId ?? 0) ??\r\n      []\r\n    ).includes(documentPropertyId),\r\n  );\r\n  if (!targetActions || targetActions.length === 0) {\r\n    throw new Error(\r\n      'All target documents must refer to a call to action record.',\r\n    );\r\n  }\r\n  // match up actual found records with incoming requests\r\n  const records = associateResponsiveAction\r\n    .map((ra) => {\r\n      const cta = targetActions.find(\r\n        (ta) => ta.unitId === ra.relatedCtaDocumentId,\r\n      );\r\n      if (!cta) {\r\n        // I know, ick, but we filter it right away\r\n        return undefined as unknown as CallToActionResponsiveActionLinkType;\r\n      }\r\n      return {\r\n        callToActionId: cta.documentPropertyId!,\r\n        callToActionResponseId: documentPropertyId!,\r\n        complianceChapter13: ra.complianceChapter13,\r\n        complianceChapter13Reasons: ra.complianceChapter13Reasons,\r\n        completionPercentage: ra.completionPercentage,\r\n        completionPercentageReasons: ra.completionReasons,\r\n      } as CallToActionResponsiveActionLinkType;\r\n    })\r\n    .filter(Boolean);\r\n  // Finally, insert the records\r\n  await tx\r\n    .insert(callToActionDetailsCallToActionResponse)\r\n    .values(records)\r\n    .execute();\r\n};\r\n\r\n/**\r\n * Relates documents by adding relationships between a source document and target documents.\r\n *\r\n * @param params - An object containing the transaction, target document, inserted records array, and related documents to add.\r\n * @returns A promise that resolves when the relationships are added.\r\n * @example\r\n * await relateDocuments({\r\n *   tx,\r\n *   target: { unitId: 1, emailId: 'abc' },\r\n *   insertedRecords: [],\r\n *   addRelatedDocuments: [{ relatedToDocumentId: 2, relationshipType: 'typeA' }]\r\n * });\r\n */\r\nconst relateDocuments = async ({\r\n  tx,\r\n  target: { unitId },\r\n  insertedRecords,\r\n  addRelatedDocuments,\r\n}: {\r\n  tx: DbTransactionType;\r\n  insertedRecords: Array<Amendment>;\r\n  target: { unitId: number; emailId: string | null };\r\n  addRelatedDocuments?: Array<{\r\n    relatedToDocumentId: number;\r\n    relationshipType: string | number;\r\n  }>;\r\n}): Promise<void> => {\r\n  if (!addRelatedDocuments || !addRelatedDocuments.length) {\r\n    return;\r\n  }\r\n  // For our puposes, if we did not throw we can assume they were all\r\n  // added.  It's poissble we haev dupes or some relastions alraedy existed,\r\n  // but the model doesn't really care, it just needs to know they are there now.\r\n  const records = await addDocumentRelations({\r\n    db: tx,\r\n    addDocumentRelations: addRelatedDocuments.map(\r\n      ({ relatedToDocumentId, relationshipType }) => ({\r\n        sourceDocumentId: unitId,\r\n        targetDocumentId: relatedToDocumentId,\r\n        relationshipReasonId: relationshipType,\r\n      }),\r\n    ),\r\n  });\r\n  records.forEach(\r\n    ({ targetDocumentId, sourceDocumentId, relationshipReasonId }) => {\r\n      insertedRecords.push({\r\n        id: `${targetDocumentId}-${sourceDocumentId}-${relationshipReasonId}`,\r\n        changes: {\r\n          addRelatedDocuments: [\r\n            {\r\n              relatedToDocumentId: targetDocumentId,\r\n              relationshipType: String(relationshipReasonId),\r\n            },\r\n          ],\r\n        },\r\n      });\r\n    },\r\n  );\r\n};\r\n\r\n/**\r\n * Amends a case record by applying updates, adding notes, violations, and related documents.\r\n *\r\n * @param amendment - The case file amendment details including target case file ID, notes, violations, and related documents.\r\n * @returns A promise that resolves with the result of the amendment process.\r\n * @example\r\n * const result = await amendCaseRecord({\r\n *   targetcase_file_id: 1,\r\n *   notes: ['Note 1'],\r\n *   violations: [{ violationType: 'Type A', severityLevel: 3 }],\r\n *   explanation: 'Reason for amendment',\r\n *   addRelatedDocuments: [{ relatedToDocumentId: 2, relationshipType: 'typeA' }]\r\n * });\r\n */\r\nexport const amendCaseRecord = async ({\r\n  update: {\r\n    targetCaseFileId,\r\n    notes,\r\n    violations,\r\n    explanation,\r\n    addRelatedDocuments,\r\n    associateResponsiveAction,\r\n    ...props\r\n  },\r\n}: {\r\n  update: CaseFileAmendment;\r\n}): Promise<ToolCallbackResult<AmendmentResult>> => {\r\n  const startTime = Date.now();\r\n  const updatedRecords = [] as Array<Amendment>;\r\n  const insertedRecords = [] as Array<Amendment>;\r\n  const failedRecords = [] as Array<Amendment & { error: string }>;\r\n  let message: string | undefined;\r\n\r\n  // Record basic metrics attributes\r\n  const attributes = {\r\n    has_notes: Boolean(notes?.length),\r\n    has_violations: Boolean(violations?.length),\r\n    has_related_documents: Boolean(addRelatedDocuments?.length),\r\n    has_responsive_actions: Boolean(associateResponsiveAction?.length),\r\n  };\r\n\r\n  if (!explanation || explanation.trim().length === 0) {\r\n    // Record error metrics\r\n    amendmentErrorCounter.add(1, {\r\n      ...attributes,\r\n      error_type: 'missing_explanation',\r\n    });\r\n\r\n    amendCaseRecordDurationHistogram.record(Date.now() - startTime, {\r\n      ...attributes,\r\n      status: 'error',\r\n    });\r\n\r\n    return toolCallbackResultFactory<AmendmentResult>(\r\n      new Error('Explanation is required'),\r\n    );\r\n  }\r\n\r\n  try {\r\n    const targetDocumentId = await resolveCaseFileId(targetCaseFileId);\r\n    if (!targetDocumentId) {\r\n      // Record error metrics\r\n      amendmentErrorCounter.add(1, {\r\n        ...attributes,\r\n        error_type: 'target_not_found',\r\n      });\r\n\r\n      amendCaseRecordDurationHistogram.record(Date.now() - startTime, {\r\n        ...attributes,\r\n        status: 'error',\r\n      });\r\n\r\n      return toolCallbackResultFactory<AmendmentResult>(\r\n        new Error('Target case file ID not found'),\r\n      );\r\n    }\r\n\r\n    const target = await drizDb().query.documentUnits.findFirst({\r\n      where: (documentUnits, { eq }) =>\r\n        eq(documentUnits.unitId, targetDocumentId),\r\n      columns: {\r\n        content: false,\r\n      },\r\n      with: {\r\n        docProp: {},\r\n      },\r\n    });\r\n    if (target) {\r\n      await drizDb().transaction(async (tx) => {\r\n        // NOTE: Technically I could run these in parallel, but I want to ensure\r\n        // but lest have some success with it as-is first.\r\n        // Apply updates to the main record\r\n        await updateMainRecord(tx, target, {\r\n          ...props,\r\n          updated: updatedRecords,\r\n          failed: failedRecords,\r\n        });\r\n        // Handle notes\r\n        await addNotes({ tx, notes, target, insertedRecords, failedRecords });\r\n        // Handle violations\r\n        await addViolations({\r\n          tx,\r\n          violations,\r\n          target,\r\n          insertedRecords,\r\n          failedRecords,\r\n        });\r\n        // Related documents\r\n        await relateDocuments({\r\n          tx,\r\n          insertedRecords,\r\n          target,\r\n          addRelatedDocuments: addRelatedDocuments,\r\n        });\r\n        // Responsive actions\r\n        await associateResponsiveActions({\r\n          tx,\r\n          target,\r\n          associateResponsiveAction,\r\n        });\r\n        // Reason\r\n        await addNotesToDocument({\r\n          db: tx,\r\n          documentId: target.unitId,\r\n          notes: [\r\n            `${explanation}\\n\\nUpdated values: ${JSON.stringify(updatedRecords)}\\nInserted values: ${JSON.stringify(insertedRecords)}`,\r\n          ],\r\n        });\r\n      });\r\n    } else {\r\n      throw new Error('Target document not found', {\r\n        cause: targetDocumentId,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    const duration = Date.now() - startTime;\r\n\r\n    // Record error metrics\r\n    amendmentErrorCounter.add(1, {\r\n      ...attributes,\r\n      error_type: 'transaction_error',\r\n    });\r\n\r\n    amendCaseRecordDurationHistogram.record(duration, {\r\n      ...attributes,\r\n      status: 'error',\r\n    });\r\n\r\n    const le = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: 'amendCaseRecord',\r\n    });\r\n    message = `An error occurred ammending the case record; no updates were committed.  Details: ${le.message}`;\r\n  }\r\n\r\n  const duration = Date.now() - startTime;\r\n  const totalRecords = updatedRecords.length + insertedRecords.length;\r\n  const hasFailures = failedRecords.length > 0;\r\n\r\n  // Record success metrics\r\n  amendCaseRecordCounter.add(1, {\r\n    ...attributes,\r\n    status: hasFailures ? 'partial_failure' : 'success',\r\n  });\r\n\r\n  amendCaseRecordDurationHistogram.record(duration, {\r\n    ...attributes,\r\n    status: hasFailures ? 'partial_failure' : 'success',\r\n  });\r\n\r\n  amendmentRecordsHistogram.record(totalRecords, {\r\n    ...attributes,\r\n    operation_type: 'total_records',\r\n  });\r\n\r\n  amendmentRecordsHistogram.record(updatedRecords.length, {\r\n    ...attributes,\r\n    operation_type: 'updated_records',\r\n  });\r\n\r\n  amendmentRecordsHistogram.record(insertedRecords.length, {\r\n    ...attributes,\r\n    operation_type: 'inserted_records',\r\n  });\r\n\r\n  if (hasFailures) {\r\n    amendmentRecordsHistogram.record(failedRecords.length, {\r\n      ...attributes,\r\n      operation_type: 'failed_records',\r\n    });\r\n\r\n    message =\r\n      message ??\r\n      'We were unable to successfully amend the case record; no updates were committed.';\r\n  }\r\n\r\n  return toolCallbackResultFactory({\r\n    message: message ?? 'All requested updates were successfully applied.',\r\n    UpdatedRecords: updatedRecords,\r\n    InsertedRecords: insertedRecords,\r\n    FailedRecords: failedRecords,\r\n  });\r\n};\r\nexport const amendCaseRecordConfig = {\r\n  description:\r\n    'This tool supports updating values within existing case file documents.  It provides the following capabilities:\\n' +\r\n    '  - Adding a note to the file.\\n' +\r\n    '  - Associating existing call to action and call to action response files.\\n' +\r\n    '  - Adding a violation report to the case file.\\n' +\r\n    '  - Creating relationships between case file documents.\\n' +\r\n    '  - Updating select fields on extracted key points, notes, calls to action, responsive actions, or other relevant information.\\n\\n' +\r\n    'Must be used with caution, as it can modify existing case file documents; Write access required.',\r\n  inputSchema: {\r\n    update: CaseFileAmendmentShape,\r\n  },\r\n  outputSchema: toolCallbackArrayResultSchemaFactory(AmendmentResultShape),\r\n  annotations: {\r\n    title: 'Amend Case File Document',\r\n    readOnlyHint: false,\r\n    destructiveHint: false,\r\n    idempotentHint: true,\r\n    openWorldHint: false,\r\n  },\r\n} as const;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\caseFileDocumentQuery.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\documentResource.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[88,91],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[88,91],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[122,125],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[122,125],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":4,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":4,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[161,164],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[161,164],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":5,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":5,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[206,209],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[206,209],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\getCaseFileDocument\\compact-casefile-document.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":20,"column":1,"nodeType":"Program","endLine":489,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":273,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":273,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8488,8491],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8488,8491],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":310,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":310,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9591,9594],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9591,9594],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":319,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":319,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9792,9795],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9792,9795],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":376,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":376,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11591,11594],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11591,11594],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module compact-casefile-document\r\n * @fileoverview\r\n * Utilities for compacting, deduplicating, and normalizing deeply nested case file document structures.\r\n *\r\n * - Removes null/undefined fields recursively for serialization and storage efficiency.\r\n * - Deduplicates and merges related document references (target/source) into flat maps.\r\n * - Prevents self-referencing and content duplication in nested document/attachment trees.\r\n * - Handles CTA (call-to-action) and response normalization for downstream AI and UI consumers.\r\n *\r\n * Exported:\r\n * - compactCaseFileDocument: Main entry point for compacting a full document.\r\n *\r\n * Internal helpers:\r\n * - compactNulls: Recursively removes null/undefined fields from objects/arrays.\r\n * - mergeToMap/mergeToMaps: Deduplicate and merge related document references.\r\n * - compactDocProp, compactCta, compactCtaResponse: Normalize and compact document property/CTA trees.\r\n */\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\nimport { KeyOf } from '@/lib/typescript/_types';\r\nimport {\r\n  DocumentSchemaType,\r\n  RelatedDocumentSchemaType,\r\n  SourceDocumentSchemaType,\r\n  TargetDocumentSchemaType,\r\n} from '../schemas';\r\nimport {\r\n  BaseDocumentPropertySchemaType,\r\n  CtaResponseSchemaType,\r\n  CtaSchemaType,\r\n  DocumentPropertySchemaType,\r\n} from '../schemas/documentPropertyShape';\r\n\r\n/**\r\n * Overload signature for mergeToMap, supporting both Target and Source document types.\r\n */\r\ninterface MergeToMapOverloads {\r\n  (props: {\r\n    map: Map<number, TargetDocumentSchemaType>;\r\n    doc: TargetDocumentSchemaType;\r\n    referencedItem: string;\r\n  }): void;\r\n  (props: {\r\n    map: Map<number, SourceDocumentSchemaType>;\r\n    doc: SourceDocumentSchemaType;\r\n    referencedItem: string;\r\n  }): void;\r\n}\r\n\r\n/**\r\n * Recursively removes all null and undefined fields from an object (and optionally its nested children).\r\n *\r\n * @template TModel - The object type to compact.\r\n * @param target - The object to compact.\r\n * @param recurse - If true, recursively compact nested objects/arrays.\r\n * @returns The compacted object with all null/undefined fields removed.\r\n */\r\nconst compactNulls = <TModel extends object>(\r\n  target: TModel,\r\n  recurse: boolean = false,\r\n): TModel => {\r\n  Object.keys(target).forEach((key: unknown) => {\r\n    const k = key as KeyOf<TModel>;\r\n    const check = target[k];\r\n    if (check === undefined || check === null) {\r\n      delete target[k];\r\n    } else if (recurse && typeof check === 'object') {\r\n      if (Array.isArray(check)) {\r\n        check.forEach((item) => compactNulls(item, true));\r\n      } else {\r\n        compactNulls(check as object, true);\r\n      }\r\n    }\r\n  });\r\n  return target;\r\n};\r\n\r\n/**\r\n * Extracts a unique numeric id from a RelatedDocument, supporting multiple possible id fields.\r\n * Throws if no id can be found.\r\n *\r\n * @param doc - The related document object.\r\n * @returns The numeric id for the related document.\r\n * @throws {TypeError} If no id can be found.\r\n */\r\nconst getRelatedDocumentId = (doc: RelatedDocumentSchemaType): number => {\r\n  let checkId =\r\n    'targetDocumentId' in doc ? Number(doc.targetDocumentId) : undefined;\r\n  if (checkId && !isNaN(checkId)) {\r\n    return checkId;\r\n  }\r\n  checkId =\r\n    'sourceDocumentId' in doc ? Number(doc.sourceDocumentId) : undefined;\r\n  if (checkId && !isNaN(checkId)) {\r\n    return checkId;\r\n  }\r\n  checkId =\r\n    'targetDoc' in doc && doc.targetDoc && 'unitId' in doc.targetDoc\r\n      ? doc.targetDoc.unitId\r\n      : undefined;\r\n  if (checkId && !isNaN(checkId)) {\r\n    return checkId;\r\n  }\r\n  checkId =\r\n    'sourceDoc' in doc && doc.sourceDoc && 'unitId' in doc.sourceDoc\r\n      ? doc.sourceDoc.unitId\r\n      : undefined;\r\n  if (checkId && !isNaN(checkId)) {\r\n    return checkId;\r\n  }\r\n  // If we made it here there was no id to pull\r\n  throw new TypeError(\r\n    'Failed to parse - unable to locate related document id',\r\n    { cause: { doc } },\r\n  );\r\n};\r\n\r\n/**\r\n * Deduplicates and merges a related document into a map keyed by id, merging descriptions if duplicate.\r\n *\r\n * @param map - The map to merge into.\r\n * @param doc - The related document to merge.\r\n * @param referencedItem - String describing the referencing context.\r\n */\r\nconst mergeToMap: MergeToMapOverloads = ({\r\n  map,\r\n  doc,\r\n  referencedItem,\r\n}: {\r\n  map: Map<number, RelatedDocumentSchemaType>;\r\n  doc: RelatedDocumentSchemaType;\r\n  referencedItem: string;\r\n}) => {\r\n  const idValue = getRelatedDocumentId(doc);\r\n  const currentDoc = map.get(idValue);\r\n\r\n  // --- FIX: Always store description as an array if merging ---\r\n  const newDescription = `${doc.description ? doc.description : 'describes'} linked to ${referencedItem}`;\r\n  if (currentDoc) {\r\n    if (Array.isArray(currentDoc.description)) {\r\n      currentDoc.description.push(newDescription);\r\n    } else if (typeof currentDoc.description === 'string') {\r\n      currentDoc.description = [currentDoc.description, newDescription];\r\n    } else {\r\n      currentDoc.description = [newDescription];\r\n    }\r\n  } else {\r\n    // Always store as array for consistency if not present\r\n    doc.description = [newDescription];\r\n    map.set(idValue, compactNulls(doc));\r\n  }\r\n};\r\n\r\n/**\r\n * Deduplicates and merges all related documents from a container into target/source maps.\r\n *\r\n * @param targetMap - Map for target documents.\r\n * @param sourceMap - Map for source documents.\r\n * @param container - Object containing docRel_targetDoc/docRel_sourceDoc arrays.\r\n * @param referencedItem - String describing the referencing context.\r\n */\r\nconst mergeToMaps = ({\r\n  targetMap,\r\n  sourceMap,\r\n  container,\r\n  referencedItem,\r\n}: {\r\n  targetMap: Map<number, TargetDocumentSchemaType>;\r\n  sourceMap: Map<number, SourceDocumentSchemaType>;\r\n  referencedItem: string;\r\n  container:\r\n    | object\r\n    | {\r\n        docRel_targetDoc?: TargetDocumentSchemaType[];\r\n        docRel_sourceDoc?: SourceDocumentSchemaType[];\r\n      };\r\n}) => {\r\n  if (!container) {\r\n    return;\r\n  }\r\n  if ('docRel_targetDoc' in container) {\r\n    container.docRel_targetDoc?.forEach((doc) => {\r\n      mergeToMap({\r\n        map: targetMap,\r\n        doc,\r\n        referencedItem,\r\n      });\r\n    });\r\n    delete container.docRel_targetDoc;\r\n  }\r\n  if ('docRel_sourceDoc' in container) {\r\n    container.docRel_sourceDoc?.forEach((doc) => {\r\n      mergeToMap({\r\n        map: sourceMap,\r\n        doc,\r\n        referencedItem,\r\n      });\r\n    });\r\n    delete container.docRel_sourceDoc;\r\n  }\r\n};\r\n\r\n/**\r\n * Compacts a base document property object, merging related docs and removing nulls.\r\n *\r\n * @template TRet - The document property type.\r\n * @param props - The document property object.\r\n * @param targetMap - Map for target documents.\r\n * @param sourceMap - Map for source documents.\r\n * @param unitId - The parent document's unitId.\r\n * @param refItemType - String describing the property type (email, attachment, etc).\r\n * @returns The compacted document property object.\r\n */\r\nconst compactDocPropBase = <\r\n  TRet extends BaseDocumentPropertySchemaType['doc'],\r\n>({\r\n  props,\r\n  targetMap,\r\n  sourceMap,\r\n  refItemType,\r\n}: {\r\n  props: TRet;\r\n  targetMap: Map<number, TargetDocumentSchemaType>;\r\n  sourceMap: Map<number, SourceDocumentSchemaType>;\r\n  unitId: number;\r\n  refItemType: string;\r\n}): TRet => {\r\n  if (!props || typeof props !== 'object') {\r\n    return props;\r\n  }\r\n  let itemId: string | number;\r\n\r\n  switch (refItemType) {\r\n    case 'email':\r\n      itemId = props.emailId ?? props.unitId;\r\n      break;\r\n    case 'attachment':\r\n      itemId = props.attachmentId ?? props.emailId ?? props.unitId;\r\n      break;\r\n    default:\r\n      itemId = itemId = props.documentPropertyId ?? props.unitId;\r\n      break;\r\n  }\r\n  mergeToMaps({\r\n    targetMap,\r\n    sourceMap,\r\n    container: props,\r\n    referencedItem: `<${refItemType}:${itemId}>`,\r\n  });\r\n  return compactNulls(props);\r\n};\r\n\r\n/**\r\n * Compacts a CTA (call-to-action) object, merging related docs and removing nulls.\r\n *\r\n * @param cta - The CTA object.\r\n * @param targetMap - Map for target documents.\r\n * @param sourceMap - Map for source documents.\r\n * @param unitId - The parent document's unitId.\r\n * @returns The compacted CTA object.\r\n */\r\nconst compactCta = ({\r\n  cta,\r\n  targetMap,\r\n  sourceMap,\r\n  unitId: documentUnitId,\r\n}: {\r\n  cta: CtaSchemaType['cta'];\r\n  sourceMap: Map<number, SourceDocumentSchemaType>;\r\n  targetMap: Map<number, TargetDocumentSchemaType>;\r\n  unitId: number;\r\n}): CtaSchemaType['cta'] => {\r\n  return compactDocPropBase<any>({\r\n    props: cta,\r\n    targetMap,\r\n    sourceMap,\r\n    refItemType: 'cta',\r\n    unitId: documentUnitId,\r\n  });\r\n};\r\n\r\n/**\r\n * Compacts a CTA response object, merging related docs and removing nulls.\r\n *\r\n * @param response - The CTA response object.\r\n * @param targetMap - Map for target documents.\r\n * @param sourceMap - Map for source documents.\r\n * @param unitId - The parent document's unitId.\r\n * @returns The compacted CTA response object.\r\n */\r\nconst compactCtaResponse = ({\r\n  response,\r\n  targetMap,\r\n  sourceMap,\r\n  unitId: documentUnitId,\r\n}: {\r\n  response: CtaResponseSchemaType['response'];\r\n  sourceMap: Map<number, SourceDocumentSchemaType>;\r\n  targetMap: Map<number, TargetDocumentSchemaType>;\r\n  unitId: number;\r\n}): CtaResponseSchemaType['response'] => {\r\n  if (!response || typeof response !== 'object') {\r\n    return response;\r\n  }\r\n  if ('ctas' in response && Array.isArray(response.ctas)) {\r\n    response.ctas = (response.ctas ?? [])\r\n      .map((rec: Record<string, unknown>) => {\r\n        rec = compactNulls(rec);\r\n        rec.cta = compactCta({\r\n          cta: rec.cta as any,\r\n          targetMap,\r\n          sourceMap,\r\n          unitId: documentUnitId,\r\n        });\r\n        return compactNulls(rec);\r\n      })\r\n      .filter(Boolean);\r\n  }\r\n  return compactDocPropBase<any>({\r\n    props: response,\r\n    targetMap,\r\n    sourceMap,\r\n    refItemType: 'cta_response',\r\n    unitId: documentUnitId,\r\n  }) as CtaResponseSchemaType['response'];\r\n};\r\n\r\n/**\r\n * Compacts a document property, merging related docs, normalizing nested doc/cta/response, and removing nulls.\r\n *\r\n * @param docProps - The document property object.\r\n * @param targetMap - Map for target documents.\r\n * @param sourceMap - Map for source documents.\r\n * @param unitId - The parent document's unitId.\r\n * @returns The compacted document property object.\r\n */\r\nconst compactDocProp = ({\r\n  docProps,\r\n  targetMap,\r\n  sourceMap,\r\n  unitId: documentUnitId,\r\n}: {\r\n  docProps: DocumentPropertySchemaType | null | undefined;\r\n  sourceMap: Map<number, SourceDocumentSchemaType>;\r\n  targetMap: Map<number, TargetDocumentSchemaType>;\r\n  unitId: number;\r\n}): DocumentSchemaType['docProp'] => {\r\n  if (docProps === null || docProps === undefined) {\r\n    return docProps;\r\n  }\r\n\r\n  if (!docProps || typeof docProps !== 'object') {\r\n    return docProps;\r\n  }\r\n  docProps = compactNulls(docProps);\r\n  const refItemType =\r\n    'documentType' in docProps && docProps.documentType\r\n      ? String(docProps.documentType)\r\n      : 'attachmentId' in docProps\r\n        ? 'attachmentId'\r\n        : 'email';\r\n  if ('doc' in docProps && docProps.doc) {\r\n    if (typeof docProps.doc === 'object') {\r\n      const unitId =\r\n        'unitId' in docProps.doc ? Number(docProps.doc.unitId) : undefined;\r\n      // Remove self-referencing docs\r\n      if (unitId && unitId === documentUnitId) {\r\n        delete docProps.doc;\r\n      } else {\r\n        docProps.doc = compactDocPropBase({\r\n          props: docProps.doc,\r\n          targetMap,\r\n          sourceMap,\r\n          refItemType,\r\n          unitId: documentUnitId,\r\n        }) as any;\r\n      }\r\n    }\r\n    if ('response' in docProps) {\r\n      docProps.response = compactCtaResponse({\r\n        response: docProps.response as CtaResponseSchemaType['response'],\r\n        targetMap,\r\n        sourceMap,\r\n        unitId: documentUnitId,\r\n      });\r\n    }\r\n    if ('cta' in docProps) {\r\n      docProps.cta = compactCta({\r\n        cta: docProps.cta as CtaSchemaType['cta'],\r\n        targetMap,\r\n        sourceMap,\r\n        unitId: documentUnitId,\r\n      });\r\n    }\r\n  }\r\n  return compactNulls(docProps);\r\n};\r\n\r\n/**\r\n * Compacts a full case file document, deduplicating related docs, removing nulls, and normalizing nested properties.\r\n *\r\n * - Deep clones the input document to avoid mutation.\r\n * - Deduplicates related documents (target/source) into flat maps.\r\n * - Compacts all docProp/docProps, removes duplicate attachment content, and pushes distinct related docs to root.\r\n *\r\n * @param document - The full case file document to compact.\r\n * @returns The compacted, deduplicated, and normalized document.\r\n */\r\nexport const compactCaseFileDocument = (\r\n  document: DocumentSchemaType,\r\n): DocumentSchemaType => {\r\n  // Create a deep copy of the document to ensure original is not modified\r\n  const target = JSON.parse(JSON.stringify(document)) as DocumentSchemaType;\r\n  const makeDocMap = <TSchema extends RelatedDocumentSchemaType>({\r\n    source,\r\n  }: {\r\n    source: Array<TSchema> | undefined | null;\r\n  }) => {\r\n    const map = new Map<number, TSchema>();\r\n    (source ?? []).forEach((doc: TSchema) => {\r\n      const thisId = getRelatedDocumentId(doc);\r\n      if (thisId == target.unitId) {\r\n        return; // Skip self-referencing docs\r\n      }\r\n      if ('relationshipReasonId' in doc) {\r\n        delete doc.relationshipReasonId;\r\n      }\r\n\r\n      const existing = map.get(thisId);\r\n      if (existing) {\r\n        // Merge descriptions when deduplicating\r\n        const existingDesc = existing.description;\r\n        const newDesc = doc.description;\r\n\r\n        if (Array.isArray(existingDesc)) {\r\n          if (newDesc && !existingDesc.includes(newDesc as string)) {\r\n            existingDesc.push(newDesc as string);\r\n          }\r\n        } else if (existingDesc && newDesc && existingDesc !== newDesc) {\r\n          existing.description = [existingDesc as string, newDesc as string];\r\n        } else if (!existingDesc && newDesc) {\r\n          existing.description = newDesc;\r\n        }\r\n      } else {\r\n        map.set(thisId, doc);\r\n      }\r\n    });\r\n    return map;\r\n  };\r\n  // Load any existing root-level related docs into maps\r\n  const targetDocMap = makeDocMap({ source: target.docRel_targetDoc });\r\n  const sourceDocMap = makeDocMap({ source: target.docRel_sourceDoc });\r\n  // Document Properties\r\n  target.docProp = compactDocProp({\r\n    docProps: target.docProp,\r\n    targetMap: targetDocMap,\r\n    sourceMap: sourceDocMap,\r\n    unitId: target.unitId!,\r\n  });\r\n  target.docProps = (target.docProps ?? [])\r\n    .map(\r\n      (dp) =>\r\n        compactDocProp({\r\n          docProps: dp,\r\n          targetMap: targetDocMap,\r\n          sourceMap: sourceDocMap,\r\n          unitId: target.unitId!,\r\n        })!,\r\n    )\r\n    .filter(Boolean);\r\n  // Stop duplicating attachment content\r\n  if (target.email?.emailAttachments) {\r\n    target.email.emailAttachments.forEach((att) => {\r\n      if (Array.isArray(att.docs)) {\r\n        att.docs.forEach((doc) => {\r\n          if ('content' in doc && doc.content) {\r\n            delete doc.content;\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  // Push distinct related documents out to target\r\n  target.docRel_targetDoc = Array.from(targetDocMap.values());\r\n  target.docRel_sourceDoc = Array.from(sourceDocMap.values());\r\n  return compactNulls(target, true);\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\getCaseFileDocument\\get-casefile-document-index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":266,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { drizDb } from '@/lib/drizzle-db';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { DocumentResourceIndex } from '../documentResource';\r\nimport { DocumentIndexResourceToolResult } from '../types';\r\nimport {\r\n  toolCallbackArrayResultSchemaFactory,\r\n  toolCallbackResultFactory,\r\n} from '../utility';\r\nimport {\r\n  getCaseFileDocumentCounter,\r\n  getCaseFileDocumentDurationHistogram,\r\n  caseFileDocumentErrorCounter,\r\n} from './metrics';\r\nimport z from 'zod';\r\n\r\n/**\r\n * Maps an external document scope value to its serialized equivalent.\r\n *\r\n * @remarks\r\n * This function standardizes document type naming conventions by converting\r\n * database/external format names to API/UI format names.\r\n *\r\n * @param type - The external document type string to map\r\n * @returns The standardized document type string\r\n *\r\n * @example\r\n * ```typescript\r\n * mapDocumentType('key_point') // returns 'key-point'\r\n * mapDocumentType('cta') // returns 'call-to-action'\r\n * ```\r\n */\r\nconst mapDocumentType = (\r\n  type: string,\r\n):\r\n  | 'email'\r\n  | 'attachment'\r\n  | 'key-point'\r\n  | 'call-to-action'\r\n  | 'responsive-action'\r\n  | 'note' => {\r\n  switch (type) {\r\n    case 'email':\r\n    case 'attachment':\r\n      return type;\r\n    case 'key_point':\r\n      return 'key-point';\r\n    case 'cta_response':\r\n      return 'responsive-action';\r\n    case 'cta':\r\n      return 'call-to-action';\r\n    default:\r\n      return type as\r\n        | 'email'\r\n        | 'attachment'\r\n        | 'key-point'\r\n        | 'call-to-action'\r\n        | 'responsive-action'\r\n        | 'note';\r\n  }\r\n};\r\n/**\r\n * Maps a standardized document type to its database/external equivalent.\r\n *\r\n * @remarks\r\n * This function performs the reverse mapping of mapDocumentType, converting\r\n * API/UI format names back to database/external format names.\r\n *\r\n * @param type - The standardized document type string to map\r\n * @returns The external/database document type string\r\n *\r\n * @example\r\n * ```typescript\r\n * mapToDocumentType('key-point') // returns 'key_point'\r\n * mapToDocumentType('call-to-action') // returns 'cta'\r\n * ```\r\n */\r\nconst mapToDocumentType = (type: string): string => {\r\n  switch (type) {\r\n    case 'key-point':\r\n      return 'key_point';\r\n    case 'responsive-action':\r\n      return 'cta_response';\r\n    case 'call-to-action':\r\n      return 'cta';\r\n    default:\r\n      return type;\r\n  }\r\n};\r\n\r\n/**\r\n * Retrieves an index of all case file documents with optional scope filtering.\r\n *\r\n * @remarks\r\n * This function provides a lightweight way to retrieve document metadata without\r\n * the full document content. It supports filtering by document types and returns\r\n * essential identifying information for each document.\r\n *\r\n * @param params - The parameters for document index retrieval\r\n * @param params.scope - Optional array of document types to filter by\r\n * @returns A promise that resolves to a ToolCallbackResult containing an array of DocumentResourceIndex\r\n *\r\n * @example\r\n * ```typescript\r\n * // Get all documents\r\n * const allDocs = await getCaseFileDocumentIndex({});\r\n *\r\n * // Get only emails and attachments\r\n * const filtered = await getCaseFileDocumentIndex({\r\n *   scope: ['email', 'attachment']\r\n * });\r\n * ```\r\n */\r\nexport const getCaseFileDocumentIndex = async ({\r\n  scope: scopeFromProps,\r\n}: {\r\n  scope?: Array<\r\n    | 'email'\r\n    | 'attachment'\r\n    | 'core-document'\r\n    | 'key-point'\r\n    | 'call-to-action'\r\n    | 'responsive-action'\r\n    | 'note'\r\n  >;\r\n}): Promise<DocumentIndexResourceToolResult> => {\r\n  const startTime = Date.now();\r\n\r\n  const attributes = {\r\n    has_scope: Boolean(scopeFromProps?.length),\r\n    scope_count: scopeFromProps?.length || 0,\r\n  };\r\n\r\n  try {\r\n    const scope = (scopeFromProps ?? []).map((s) =>\r\n      mapToDocumentType(String(s)),\r\n    );\r\n    const index = await drizDb()\r\n      .query.documentUnits.findMany({\r\n        ...(scope.length > 0\r\n          ? { where: (du, { inArray }) => inArray(du.documentType, scope) }\r\n          : {}),\r\n        columns: {\r\n          unitId: true,\r\n          emailId: true,\r\n          attachmentId: true,\r\n          documentPropertyId: true,\r\n          documentType: true,\r\n          createdOn: true,\r\n        },\r\n      })\r\n      .then((documents) =>\r\n        documents.map((doc) => ({\r\n          ...doc,\r\n          createdOn: new Date(doc.createdOn ?? Date.now()),\r\n          documentType: mapDocumentType(doc.documentType ?? ''),\r\n        })),\r\n      );\r\n\r\n    const duration = Date.now() - startTime;\r\n\r\n    // Record success metrics\r\n    getCaseFileDocumentCounter.add(1, {\r\n      ...attributes,\r\n      operation_type: 'index',\r\n      status: 'success',\r\n      result_count: index.length,\r\n    });\r\n\r\n    getCaseFileDocumentDurationHistogram.record(duration, {\r\n      ...attributes,\r\n      operation_type: 'index',\r\n      status: 'success',\r\n    });\r\n\r\n    return toolCallbackResultFactory(index);\r\n  } catch (error) {\r\n    const duration = Date.now() - startTime;\r\n\r\n    caseFileDocumentErrorCounter.add(1, {\r\n      ...attributes,\r\n      error_type: 'index_error',\r\n    });\r\n\r\n    getCaseFileDocumentDurationHistogram.record(duration, {\r\n      ...attributes,\r\n      operation_type: 'index',\r\n      status: 'error',\r\n    });\r\n\r\n    return toolCallbackResultFactory<Array<DocumentResourceIndex>>(\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        message: 'Error retrieving case file document index',\r\n        data: { scope: scopeFromProps },\r\n      }),\r\n    );\r\n  }\r\n};\r\n\r\nexport const getCaseFileDocumentIndexConfig = {\r\n  description:\r\n    'Retrieves an index containing summary information about all case file documents, optionally filtered by document type.  This ' +\r\n    'index can be used as a quick and reliable way to obtain a listing of document types for performing iterative retrievals or analysis.',\r\n  inputSchema: {\r\n    scope: z\r\n      .array(\r\n        z.enum([\r\n          'email',\r\n          'attachment',\r\n          'core-document',\r\n          'key-point',\r\n          'call-to-action',\r\n          'responsive-action',\r\n          'note',\r\n        ]),\r\n      )\r\n      .optional()\r\n      .describe(\r\n        `An optional array of case file search scope types to filter the search results.  If not set, the search applies to all available scopes.  Available values are: \r\n  - 'email': represents email messages associated with the case file.\r\n  - 'attachment': represents file attachments related to the case file.\r\n  - 'core-document': an alias for 'email' and 'attachment', used to search across both scopes.\r\n  - 'key-point': represents key points extracted from the case file.\r\n  - 'call-to-action': represents actionable items identified in the case file.\r\n  - 'responsive-action': represents responsive actions identified in the case file.\r\n  - 'note': represents notes extracted from the case file.`,\r\n      ),\r\n  },\r\n  outputSchema: toolCallbackArrayResultSchemaFactory(\r\n    z.object({\r\n      unitId: z\r\n        .number()\r\n        .describe(\r\n          'The unique identifier of the case file document.  This value can be passed to the `getCaseFileDocument` or `getMultipleCaseFileDocuments` tools to retrieve the full contents of the document.',\r\n        ),\r\n      emailId: z\r\n        .string()\r\n        .nullable()\r\n        .describe(\r\n          'The unique identifier of the email associated with the case file document, if applicable.',\r\n        ),\r\n      attachmentId: z\r\n        .number()\r\n        .nullable()\r\n        .describe(\r\n          'The unique identifier of the document property associated with the case file document, if applicable.',\r\n        ),\r\n      documentType: z\r\n        .string()\r\n        .describe(\r\n          'The type of the case file document, such as email, attachment, key point, call to action, responsive action, or note.',\r\n        ),\r\n      createdOn: z\r\n        .date()\r\n        .describe('The date and time when the case file document was created.'),\r\n    }),\r\n  ),\r\n  annotations: {\r\n    title: 'Retrieve Case File Document Index',\r\n    readOnlyHint: true,\r\n    destructiveHint: false,\r\n    idempotentHint: true,\r\n    openWorldHint: false,\r\n  },\r\n} as const;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\getCaseFileDocument\\get-casefile-document.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":49,"column":1,"nodeType":"Program","endLine":533,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":383,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":383,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16551,16554],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16551,16554],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Case File Document Retrieval and Processing System\r\n *\r\n * This module provides comprehensive functionality for retrieving, processing, and analyzing\r\n * case file documents using AI-powered information extraction. It serves as the core document\r\n * processing pipeline for compliance analysis, policy review, and legal document examination.\r\n *\r\n * **Key Features:**\r\n * - **Intelligent Document Retrieval**: Efficiently fetches case file documents with relationship data\r\n * - **Smart Grouping Algorithm**: Optimizes AI processing by batching documents with identical goals\r\n * - **AI-Powered Analysis**: Extracts relevant information using sophisticated language models\r\n * - **Flexible Verbatim Control**: Adjustable fidelity levels from exact quotes to summaries\r\n * - **Comprehensive Monitoring**: Full OpenTelemetry integration for operational insights\r\n * - **Error Resilience**: Robust error handling with detailed logging and graceful degradation\r\n *\r\n * **Main Functions:**\r\n * - `getCaseFileDocument`: Single document retrieval wrapper\r\n * - `getMultipleCaseFileDocuments`: Batch document processing with goal-based grouping\r\n * - `getCaseFileDocumentIndex`: Lightweight metadata retrieval for document discovery\r\n * - `preprocessCaseFileDocument`: AI-powered information extraction and analysis\r\n *\r\n * **Architecture:**\r\n * ```\r\n * Client Request → ID Resolution → Database Query → Document Grouping → AI Processing → Response\r\n *                     ↓              ↓             ↓                ↓            ↓\r\n *                 Validation    Relationship    Goal-based      Prompt         Structured\r\n *                              Loading         Batching        Engineering     Output\r\n * ```\r\n *\r\n * **Performance Characteristics:**\r\n * - Supports batch processing for efficiency\r\n * - Intelligent model selection based on content size\r\n * - Comprehensive metrics collection for monitoring\r\n * - Optimized database queries with selective field loading\r\n *\r\n * **Use Cases:**\r\n * - Legal compliance review and audit\r\n * - Policy violation detection and analysis\r\n * - Contract analysis and risk assessment\r\n * - Regulatory compliance monitoring\r\n * - Document summarization and information extraction\r\n *\r\n * @module getCaseFileDocument\r\n * @version 2.0.0\r\n * @author AI Tools Team\r\n * @since 1.0.0\r\n */\r\n\r\nimport { drizDbWithInit } from '@/lib/drizzle-db';\r\nimport {\r\n  resolveCaseFileIdBatch,\r\n  toolCallbackArrayResultSchemaFactory,\r\n  toolCallbackResultFactory,\r\n} from '../utility';\r\nimport {\r\n  CaseFileRequestProps,\r\n  CaseFileResponse,\r\n  DocumentResource,\r\n  ToolCallbackResult,\r\n  ValidCaseFileRequestProps,\r\n} from '../types';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { log } from '@/lib/logger';\r\nimport { caseFileDocumentShape } from '../caseFileDocumentQuery';\r\nimport {\r\n  caseFileDocumentErrorCounter,\r\n  getCaseFileDocumentDurationHistogram,\r\n  caseFileDocumentSizeHistogram,\r\n  getCaseFileDocumentCounter,\r\n} from './metrics';\r\nimport { preprocessCaseFileDocument } from './preprocess-casefile-document';\r\nimport { countTokens } from '../../core/count-tokens';\r\nimport { generateChatId } from '../../core';\r\nimport {\r\n  caseFileRequestPropsShape,\r\n  CaseFileResponseShape,\r\n} from '../schemas/case-file-request-props-shape';\r\nimport z from 'zod';\r\nimport { env } from '@/lib/site-util/env';\r\nimport { compactCaseFileDocument } from './compact-casefile-document';\r\n\r\n/**\r\n * Retrieves a single case file document by delegating to getMultipleCaseFileDocuments.\r\n *\r\n * @remarks\r\n * This function serves as a convenience wrapper around getMultipleCaseFileDocuments\r\n * for single document retrieval. It handles the conversion from array response to\r\n * single document response.\r\n *\r\n * @param props - The case file request properties containing document ID, goals, and verbatim fidelity\r\n * @returns A promise that resolves to a ToolCallbackResult containing a single CaseFileResponse\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = await getCaseFileDocument({\r\n *   caseFileId: 12345,\r\n *   goals: ['compliance-check', 'policy-review'],\r\n *   verbatim_fidelity: 75\r\n * });\r\n * ```\r\n */\r\nexport const getCaseFileDocument = async (\r\n  props: CaseFileRequestProps,\r\n): Promise<ToolCallbackResult<CaseFileResponse>> => {\r\n  const result = await getMultipleCaseFileDocuments({\r\n    requests: [props],\r\n  });\r\n  if (result.structuredContent.result.isError) {\r\n    return result as ToolCallbackResult<CaseFileResponse>;\r\n  }\r\n  if (\r\n    !result.structuredContent.result ||\r\n    !result.structuredContent.result.items?.length\r\n  ) {\r\n    return result as ToolCallbackResult<CaseFileResponse>;\r\n  }\r\n  return toolCallbackResultFactory<CaseFileResponse>(\r\n    result.structuredContent.result.items[0],\r\n  );\r\n};\r\n\r\n/**\r\n * Retrieves multiple case file documents based on the provided requests, applying optional goals and verbatim fidelity.\r\n *\r\n * @remarks\r\n * This function implements a sophisticated document retrieval and grouping algorithm that optimizes\r\n * AI processing by batching documents with identical analysis goals. The grouping strategy reduces\r\n * redundant AI calls and ensures consistent analysis across documents with shared objectives.\r\n *\r\n * **Algorithm Overview:**\r\n * 1. **Request Resolution**: Converts case file identifiers to valid database IDs\r\n * 2. **Goal Merging**: Combines global and per-request goals, deduplicating automatically\r\n * 3. **Document Fetching**: Retrieves documents from database with full relationship data\r\n * 4. **Join Operation**: Associates each document with its request metadata (goals, fidelity)\r\n * 5. **Smart Grouping**: Groups documents by identical sorted goal arrays for batch processing\r\n * 6. **AI Processing**: Processes each group with shared goals through AI analysis pipeline\r\n * 7. **Result Flattening**: Returns a unified array of processed document responses\r\n *\r\n * **Performance Considerations:**\r\n * - Documents with identical goals are processed together to minimize AI calls\r\n * - Goal arrays are sorted before grouping to ensure consistent key generation\r\n * - Metrics are recorded for monitoring performance and error rates\r\n * - Large document sets may require chunking for optimal AI processing\r\n *\r\n * **Edge Cases Handled:**\r\n * - Invalid case file IDs are filtered out with proper error reporting\r\n * - Empty goal arrays result in unprocessed document passthrough\r\n * - Duplicate goals within a request are automatically deduplicated\r\n * - Missing verbatim fidelity defaults to 75% for balanced output quality\r\n *\r\n * @param params - The parameters for retrieving multiple case file documents.\r\n * @param params.requests - An array of case file request properties containing IDs, goals, and fidelity settings.\r\n * @param params.goals - (Optional) Global goals applied to all requests in addition to per-request goals.\r\n * @param params.verbatim_fidelity - (Optional) Default verbatim fidelity (1-100) when not specified per request.\r\n * @returns A promise that resolves to a `ToolCallbackResult` containing an array of `CaseFileResponse` objects.\r\n * @throws {Error} When no valid case file IDs can be resolved from the provided requests.\r\n *\r\n * @example\r\n * ```typescript\r\n * // Basic usage with multiple documents\r\n * const results = await getMultipleCaseFileDocuments({\r\n *   requests: [\r\n *     { caseFileId: 123, goals: ['compliance-check'], verbatim_fidelity: 80 },\r\n *     { caseFileId: 456, goals: ['policy-review'], verbatim_fidelity: 60 }\r\n *   ]\r\n * });\r\n *\r\n * // Using global goals applied to all documents\r\n * const results = await getMultipleCaseFileDocuments({\r\n *   requests: [\r\n *     { caseFileId: 123 },\r\n *     { caseFileId: 456 }\r\n *   ],\r\n *   goals: ['security-audit', 'compliance-check'],\r\n *   verbatimFidelity: 75\r\n * });\r\n *\r\n * // Documents with identical goals will be processed together for efficiency\r\n * const results = await getMultipleCaseFileDocuments({\r\n *   requests: [\r\n *     { caseFileId: 123, goals: ['policy-review', 'compliance'] },\r\n *     { caseFileId: 456, goals: ['compliance', 'policy-review'] }, // Same goals, different order\r\n *     { caseFileId: 789, goals: ['security-audit'] } // Different goals, separate processing\r\n *   ]\r\n * });\r\n * ```\r\n */\r\nexport const getMultipleCaseFileDocuments = async ({\r\n  requests,\r\n  verbatim_fidelity,\r\n  goals = [],\r\n}: {\r\n  requests: Array<CaseFileRequestProps>;\r\n  goals?: Array<string>;\r\n  verbatim_fidelity?: number;\r\n}): Promise<ToolCallbackResult<Array<CaseFileResponse>>> => {\r\n  const startTime = Date.now();\r\n  const globalGoals = goals ?? [];\r\n  const resolvedRequests = (await resolveCaseFileIdBatch(requests)).map(\r\n    (x: ValidCaseFileRequestProps) => ({\r\n      ...x,\r\n      verbatim_fidelity: x.verbatimFidelity ?? verbatim_fidelity ?? 75,\r\n      goals: [...new Set<string>([...(x.goals ?? []), ...globalGoals])],\r\n    }),\r\n  );\r\n  const attributes = {\r\n    // has_goals: Boolean(goals.length),\r\n    // has_reasoning: Boolean(reasoning),\r\n    // goals_count: goals.length,\r\n\r\n    initial_document_count: requests.length,\r\n    valid_document_count: resolvedRequests.length,\r\n  };\r\n  const requestId = generateChatId(JSON.stringify(resolvedRequests));\r\n  try {\r\n    const validIds = resolvedRequests.map((x) => x.caseFileId);\r\n    if (validIds.length === 0) {\r\n      caseFileDocumentErrorCounter.add(1, {\r\n        ...attributes,\r\n        error_type: 'no_valid_ids',\r\n      });\r\n\r\n      getCaseFileDocumentDurationHistogram.record(Date.now() - startTime, {\r\n        ...attributes,\r\n        status: 'error',\r\n      });\r\n\r\n      throw new Error(\r\n        `No valid Case File IDs could be resolved from the provided identifiers: ${requests.map((r) => r.caseFileId).join(', ')}`,\r\n      );\r\n    }\r\n    const documents = await drizDbWithInit((db) =>\r\n      db.query.documentUnits.findMany({\r\n        where: (du, { inArray }) => inArray(du.unitId, validIds),\r\n        ...caseFileDocumentShape,\r\n      }),\r\n    );\r\n\r\n    // Calculate total document size for metrics\r\n    const totalDocumentSize = documents.reduce(\r\n      (total, doc) => total + JSON.stringify(doc).length,\r\n      0,\r\n    );\r\n    caseFileDocumentSizeHistogram.record(totalDocumentSize, {\r\n      ...attributes,\r\n      operation_type: 'multiple_documents',\r\n    });\r\n\r\n    log((l) =>\r\n      l.info(\r\n        `getMultipleCaseFileDocuments: Retrieved ${documents.length} documents`,\r\n      ),\r\n    );\r\n\r\n    // Join documents with resolvedRequests based on unitId = caseFileId\r\n    // This creates a unified dataset where each document is paired with its analysis requirements\r\n    const joinedData = documents.map((document) => {\r\n      const matchingRequest = resolvedRequests.find(\r\n        (req) => req.caseFileId === document.unitId,\r\n      );\r\n      return {\r\n        document: compactCaseFileDocument(document),\r\n        verbatim_fidelity: matchingRequest?.verbatim_fidelity ?? 50,\r\n        goals: matchingRequest?.goals ?? [],\r\n      };\r\n    });\r\n\r\n    /**\r\n     * Group documents by distinct arrays of goals for optimized batch processing.\r\n     *\r\n     * This grouping strategy serves multiple purposes:\r\n     * 1. **Efficiency**: Documents with identical goals can be processed together in a single AI call\r\n     * 2. **Consistency**: Ensures uniform analysis approach for documents with shared objectives\r\n     * 3. **Cost Optimization**: Reduces the number of expensive AI API calls\r\n     *\r\n     * **Grouping Algorithm:**\r\n     * - Goals arrays are sorted alphabetically to ensure consistent grouping regardless of input order\r\n     * - JSON stringification of sorted arrays creates stable, unique group keys\r\n     * - Empty goal arrays are handled separately to avoid unnecessary AI processing\r\n     *\r\n     * **Example Grouping:**\r\n     * Input: [['policy', 'compliance'], ['compliance', 'policy'], ['security']]\r\n     * Groups: {'[\"compliance\",\"policy\"]': [...], '[\"security\"]': [...]}\r\n     */\r\n    const groupedByGoals = joinedData.reduce(\r\n      (acc, item) => {\r\n        // Sort the goals array to ensure consistent grouping regardless of order\r\n        const sortedGoals = [...(item.goals || [])].sort();\r\n        const goalsKey = JSON.stringify(sortedGoals);\r\n\r\n        if (!acc[goalsKey]) {\r\n          acc[goalsKey] = [];\r\n        }\r\n        acc[goalsKey].push({\r\n          document: item.document,\r\n          verbatim_fidelity: item.verbatim_fidelity,\r\n        });\r\n        return acc;\r\n      },\r\n      {} as Record<\r\n        string,\r\n        { document: DocumentResource; verbatim_fidelity: number }[]\r\n      >,\r\n    );\r\n\r\n    /**\r\n     * Process each group of documents with their shared goals using intelligent routing.\r\n     *\r\n     * **Processing Strategy:**\r\n     * 1. **Empty Goals**: Documents without goals bypass AI processing for efficiency\r\n     * 2. **Goal-Based Processing**: Documents with goals are analyzed using AI extraction\r\n     * 3. **Parallel Execution**: Multiple groups are processed concurrently for performance\r\n     * 4. **Result Consolidation**: All processed groups are flattened into a unified response\r\n     *\r\n     * This approach ensures that:\r\n     * - Documents without specific analysis needs aren't subjected to unnecessary AI processing\r\n     * - AI resources are used efficiently by processing similar documents together\r\n     * - System performance scales well with varying document loads and complexity\r\n     */\r\n    let processedGroups: Array<CaseFileResponse | Array<CaseFileResponse>>;\r\n    try {\r\n      processedGroups = await Promise.all(\r\n        Object.entries(groupedByGoals).map(\r\n          async ([goalsKey, groupDocuments]) => {\r\n            // Handle documents without goals - no AI processing needed\r\n            if (goalsKey.trim() === '' || goalsKey === '[]') {\r\n              return groupDocuments.map(\r\n                (d) =>\r\n                  ({\r\n                    document: d.document as DocumentResource,\r\n                  }) as CaseFileResponse,\r\n              );\r\n            }\r\n\r\n            // Process documents with goals through AI analysis pipeline\r\n            const groupGoals = JSON.parse(goalsKey) as string[];\r\n            // New batching strategy: accumulate documents until token threshold exceeded, then process batch.\r\n            // Threshold is configurable via env TOKEN_BATCH_THRESHOLD (defaults to 50,000 tokens).\r\n            // Fallback in unlikely case env factory returns undefined (e.g., client context)\r\n            const effectiveBatchThreshold =\r\n              env('TOKEN_BATCH_THRESHOLD') || 50000;\r\n            const aggregatedResults: Array<CaseFileResponse> = [];\r\n\r\n            let currentBatch: typeof groupDocuments = [];\r\n            let currentBatchTokens = 0;\r\n\r\n            const processCurrentBatch = async () => {\r\n              if (currentBatch.length === 0) return;\r\n              try {\r\n                const batchResults = await preprocessCaseFileDocument({\r\n                  documents: currentBatch,\r\n                  goals: groupGoals,\r\n                  requestContext: { requestId: requestId.id },\r\n                });\r\n                aggregatedResults.push(...batchResults);\r\n              } catch (error) {\r\n                const le = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n                  log: true,\r\n                  source:\r\n                    'getCaseFileDocument::preprocessCaseFileDocument:batch',\r\n                });\r\n                aggregatedResults.push(\r\n                  ...(currentBatch.map((d) => ({\r\n                    document: { unitId: d?.document?.unitId ?? '<<unknown>>' },\r\n                    text: `An unexpected error occurred processing case file id ${d?.document?.unitId ?? '<<unknown>>'}. Please try your request again later.  Error details: ${le.toString()}`,\r\n                  })) as Array<CaseFileResponse>),\r\n                );\r\n              } finally {\r\n                currentBatch = [];\r\n                currentBatchTokens = 0;\r\n              }\r\n            };\r\n\r\n            for (const doc of groupDocuments) {\r\n              let docTokens = 0;\r\n              try {\r\n                // Estimate tokens for this single document by serializing its content\r\n                docTokens = countTokens({\r\n                  // We approximate token usage by providing a single message with JSON of the document\r\n                  prompt: [\r\n                    { role: 'user', content: JSON.stringify(doc.document) },\r\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                  ] as any,\r\n                  enableLogging: false,\r\n                });\r\n              } catch {\r\n                // Fallback conservative estimate if token counting fails\r\n                docTokens = 2000;\r\n              }\r\n\r\n              // If adding this doc would exceed threshold, process existing batch first\r\n              if (\r\n                currentBatch.length > 0 &&\r\n                currentBatchTokens + docTokens > effectiveBatchThreshold\r\n              ) {\r\n                await processCurrentBatch();\r\n              }\r\n\r\n              currentBatch.push(doc);\r\n              currentBatchTokens += docTokens;\r\n\r\n              // If a single (or accumulated) batch crosses threshold, process immediately\r\n              if (currentBatchTokens > effectiveBatchThreshold) {\r\n                await processCurrentBatch();\r\n              }\r\n            }\r\n\r\n            // Process any remaining documents in the final batch\r\n            await processCurrentBatch();\r\n\r\n            return aggregatedResults;\r\n          },\r\n        ),\r\n      );\r\n    } finally {\r\n      // Clean up any resources or contexts\r\n    }\r\n\r\n    // Flatten the processed groups into a unified result array\r\n    const result: CaseFileResponse[] = processedGroups.flat().map((x) => {\r\n      if (x && 'document' in x) {\r\n        const { document: case_file, ...rest } = x;\r\n        return {\r\n          ...rest,\r\n          case_file,\r\n        };\r\n      }\r\n      return x as CaseFileResponse;\r\n    });\r\n\r\n    const duration = Date.now() - startTime;\r\n\r\n    // Record success metrics\r\n    getCaseFileDocumentCounter.add(1, {\r\n      ...attributes,\r\n      operation_type: 'multiple_documents',\r\n      status: 'success',\r\n      retrieved_count: documents.length,\r\n    });\r\n\r\n    getCaseFileDocumentDurationHistogram.record(duration, {\r\n      ...attributes,\r\n      operation_type: 'multiple_documents',\r\n      status: 'success',\r\n    });\r\n\r\n    return toolCallbackResultFactory(result);\r\n  } catch (error) {\r\n    const duration = Date.now() - startTime;\r\n\r\n    caseFileDocumentErrorCounter.add(1, {\r\n      ...attributes,\r\n      error_type: 'general_error',\r\n    });\r\n\r\n    getCaseFileDocumentDurationHistogram.record(duration, {\r\n      ...attributes,\r\n      status: 'error',\r\n    });\r\n\r\n    return toolCallbackResultFactory<Array<DocumentResource>>(\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n      }),\r\n    );\r\n  }\r\n};\r\n\r\nexport const getMultipleCaseFileDocumentsConfig = {\r\n  description:\r\n    'Retrieves and pre-processes the full contents of a batch of specific case file documents by ID.  This will include all metadata, as well as any linked case file documents, such as ' +\r\n    'extracted key points, notes, calls to action, responsive actions, or other relevant information.  Useful for performing detailed ' +\r\n    'analysis of the case file contents.  IMPORTANT: case ' +\r\n    'files are large and require a lot of context space, so pre-processing via goals is recommended. Never attempt to load more than 5 unprocessed documents at a time.  ' +\r\n    'With adequate summarization goals, more documents can be processed, but you should never request more than 100 documents at once.',\r\n  inputSchema: {\r\n    requests: z\r\n      .array(caseFileRequestPropsShape)\r\n      .describe('An array of case file requests.'),\r\n    goals: z\r\n      .array(z.string())\r\n      .describe(\r\n        'An array of goals identifying your task or describing what information should be extracted from the case files.  When set, each document will be pre-processed and relevant information returned, when left blank you will receive the full case files.  Case file documents are large and require a lot of context space, so pre-processing is recommended.',\r\n      )\r\n      .optional(),\r\n    verbatim_fidelity: z\r\n      .number()\r\n      .min(1)\r\n      .max(100)\r\n      .optional()\r\n      .describe(\r\n        'Controls how closely output should match source text. 100 = exact quotes with full context;  75 = exact excerpts with minimal context; 50 = summarized excerpts with some context; 1 = full summary, exact quotes not needed.  Set here to provide a default for all requests.',\r\n      ),\r\n  },\r\n  outputSchema: toolCallbackArrayResultSchemaFactory(\r\n    z.string().or(CaseFileResponseShape),\r\n  ),\r\n  annotations: {\r\n    title: 'Get Multiple Case Files',\r\n    readOnlyHint: true,\r\n    destructiveHint: false,\r\n    idempotentHint: true,\r\n    openWorldHint: false,\r\n  },\r\n} as const;\r\n\r\n/*\r\n  Single document tool - obsolete (not worth the toolspace, just load a multiple of 1)\r\nserver.registerTool(\r\n  'getCaseFileDocument',\r\n  {\r\n    description:\r\n      \"Retrieves the full contents of a specific case file document by it's ID.  This will include all metadata, as well as any linked case file documents, such as \" +\r\n      'extracted key points, notes, calls to action, responsive actions, or other relevant information.  Useful for performing detailed ' +\r\n      'analysis of the case file contents.  IMPORTANT: case files are large and require a lot of context space, so pre-processing via goals is recommended.',\r\n    inputSchema: {\r\n      ...caseFileRequestPropsShape.shape,\r\n    },\r\n    outputSchema: toolCallbackResultSchemaFactory(\r\n      z.string().or(DocumentSchema),\r\n    ),\r\n    annotations: {\r\n      title: 'Get Full Case File',\r\n      readOnlyHint: true,\r\n      destructiveHint: false,\r\n      idempotentHint: true,\r\n      openWorldHint: false,\r\n    },\r\n  },\r\n  getCaseFileDocument,\r\n);\r\n*/\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\getCaseFileDocument\\getCaseFileDocument.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\getCaseFileDocument\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":48,"column":1,"nodeType":"Program","endLine":54,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Case File Document Retrieval and Processing System\r\n *\r\n * This module provides comprehensive functionality for retrieving, processing, and analyzing\r\n * case file documents using AI-powered information extraction. It serves as the core document\r\n * processing pipeline for compliance analysis, policy review, and legal document examination.\r\n *\r\n * **Key Features:**\r\n * - **Intelligent Document Retrieval**: Efficiently fetches case file documents with relationship data\r\n * - **Smart Grouping Algorithm**: Optimizes AI processing by batching documents with identical goals\r\n * - **AI-Powered Analysis**: Extracts relevant information using sophisticated language models\r\n * - **Flexible Verbatim Control**: Adjustable fidelity levels from exact quotes to summaries\r\n * - **Comprehensive Monitoring**: Full OpenTelemetry integration for operational insights\r\n * - **Error Resilience**: Robust error handling with detailed logging and graceful degradation\r\n *\r\n * **Main Functions:**\r\n * - `getCaseFileDocument`: Single document retrieval wrapper\r\n * - `getMultipleCaseFileDocuments`: Batch document processing with goal-based grouping\r\n * - `getCaseFileDocumentIndex`: Lightweight metadata retrieval for document discovery\r\n * - `preprocessCaseFileDocument`: AI-powered information extraction and analysis\r\n *\r\n * **Architecture:**\r\n * ```\r\n * Client Request → ID Resolution → Database Query → Document Grouping → AI Processing → Response\r\n *                     ↓              ↓             ↓                ↓            ↓\r\n *                 Validation    Relationship    Goal-based      Prompt         Structured\r\n *                              Loading         Batching        Engineering     Output\r\n * ```\r\n *\r\n * **Performance Characteristics:**\r\n * - Supports batch processing for efficiency\r\n * - Intelligent model selection based on content size\r\n * - Comprehensive metrics collection for monitoring\r\n * - Optimized database queries with selective field loading\r\n *\r\n * **Use Cases:**\r\n * - Legal compliance review and audit\r\n * - Policy violation detection and analysis\r\n * - Contract analysis and risk assessment\r\n * - Regulatory compliance monitoring\r\n * - Document summarization and information extraction\r\n *\r\n * @module getCaseFileDocument\r\n * @version 2.0.0\r\n * @author AI Tools Team\r\n * @since 1.0.0\r\n */\r\nexport {\r\n  getCaseFileDocument,\r\n  getMultipleCaseFileDocuments,\r\n} from './get-casefile-document';\r\n\r\nexport { getCaseFileDocumentIndex } from './get-casefile-document-index';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\getCaseFileDocument\\metrics.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":20,"column":1,"nodeType":"Program","endLine":68,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * OpenTelemetry Metrics for Case File Document Operations\r\n *\r\n * These metrics provide comprehensive monitoring and observability for document\r\n * retrieval and processing operations. They enable performance tracking, error\r\n * analysis, and operational insights across the document processing pipeline.\r\n *\r\n * **Metric Categories:**\r\n * - **Counters**: Track operation counts, success/error rates, and preprocessing activities\r\n * - **Histograms**: Measure operation durations and document sizes for performance analysis\r\n * - **Attributes**: Include operation type, status, document counts, and error types\r\n *\r\n * **Usage in Monitoring:**\r\n * - Track system performance and identify bottlenecks\r\n * - Monitor error rates and failure patterns\r\n * - Analyze document processing costs and efficiency\r\n * - Alert on performance degradation or system issues\r\n */\r\n\r\nimport { appMeters } from '@/lib/site-util/metrics';\r\n\r\n// OpenTelemetry Metrics for GetCaseFileDocument Tool\r\nexport const getCaseFileDocumentCounter = appMeters.createCounter(\r\n  'ai_tool_get_case_file_document_total',\r\n  {\r\n    description: 'Total number of case file document retrieval operations',\r\n    unit: '1',\r\n  },\r\n);\r\n\r\nexport const getCaseFileDocumentDurationHistogram = appMeters.createHistogram(\r\n  'ai_tool_get_case_file_document_duration_ms',\r\n  {\r\n    description: 'Duration of case file document retrieval operations',\r\n    unit: 'ms',\r\n  },\r\n);\r\n\r\nexport const caseFileDocumentSizeHistogram = appMeters.createHistogram(\r\n  'ai_tool_case_file_document_size_bytes',\r\n  {\r\n    description: 'Size of retrieved case file documents in bytes',\r\n    unit: 'bytes',\r\n  },\r\n);\r\n\r\nexport const caseFileDocumentPreprocessingCounter = appMeters.createCounter(\r\n  'ai_tool_case_file_preprocessing_total',\r\n  {\r\n    description: 'Total number of case file document preprocessing operations',\r\n    unit: '1',\r\n  },\r\n);\r\n\r\nexport const caseFileDocumentPreprocessingDurationHistogram =\r\n  appMeters.createHistogram('ai_tool_case_file_preprocessing_duration_ms', {\r\n    description: 'Duration of case file document preprocessing operations',\r\n    unit: 'ms',\r\n  });\r\n\r\nexport const caseFileDocumentErrorCounter = appMeters.createCounter(\r\n  'ai_tool_get_case_file_document_errors_total',\r\n  {\r\n    description: 'Total number of case file document retrieval errors',\r\n    unit: '1',\r\n  },\r\n);\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\getCaseFileDocument\\preprocess-casefile-document.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":368,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { zodToStructure } from '@/lib/typescript';\r\nimport { GenerateTextResult, ToolSet } from 'ai';\r\nimport { log } from '@/lib/logger';\r\nimport { aiModelFactory } from '@/lib/ai/aiModelFactory';\r\nimport { DocumentResource } from '../documentResource';\r\nimport { DocumentSchema } from '../schemas';\r\nimport { CaseFileResponse, SummarizedDocumentResource } from '../types';\r\nimport {\r\n  caseFileDocumentPreprocessingCounter,\r\n  caseFileDocumentPreprocessingDurationHistogram,\r\n  caseFileDocumentSizeHistogram,\r\n} from './metrics';\r\nimport { wrapChatHistoryMiddleware } from '@/lib/ai/middleware/chat-history';\r\nimport { generateTextWithRetry } from '@/lib/ai/core/generate-text-with-retry';\r\nimport { createAgentHistoryContext } from '@/lib/ai/middleware/chat-history/create-chat-history-context';\r\n\r\n/**\r\n * Preprocesses case file documents using AI to extract relevant information based on specified goals.\r\n *\r\n * @remarks\r\n * This function represents the core AI processing pipeline for document analysis and information extraction.\r\n * It uses sophisticated natural language processing to identify and extract information relevant to specific\r\n * compliance, policy, or analysis goals from legal and business documents.\r\n *\r\n * **AI Processing Pipeline:**\r\n * 1. **Input Preparation**: Serializes documents and metadata into structured JSON format\r\n * 2. **Token Estimation**: Calculates input size to select appropriate AI model (standard vs. high-capacity)\r\n * 3. **Prompt Engineering**: Uses specialized extraction prompt with goal-specific instructions\r\n * 4. **AI Analysis**: Processes documents through language model with low temperature for consistency\r\n * 5. **Result Extraction**: Parses structured output or falls back to text-based response\r\n * 6. **Metrics Recording**: Tracks performance, size, and error metrics for monitoring\r\n *\r\n * **Verbatim Fidelity Levels:**\r\n * - **100**: Exact quotes with full surrounding context preserved\r\n * - **75**: Exact excerpts with minimal necessary context (default for balanced quality)\r\n * - **50**: Summarized excerpts retaining key information with some context\r\n * - **1**: Full summarization where exact quotes are not required\r\n *\r\n * **Model Selection Logic:**\r\n * - Documents > 100,000 tokens: Uses high-capacity model (google:lofi) for complex analysis\r\n * - Smaller documents: Uses standard model (lofi) for cost-effectiveness\r\n *\r\n * **Output Structure:**\r\n * The AI generates structured responses containing:\r\n * - Document metadata (ID, type, creation date, sender)\r\n * - Related document references with relationship types\r\n * - Policy references and compliance tags\r\n * - Extracted passages with goal alignment and location metadata\r\n * - Compliance scores with rationale and applicability\r\n * - Identified omissions or gaps in expected information\r\n *\r\n * **Error Handling:**\r\n * - Comprehensive logging with document IDs and goals for debugging\r\n * - Graceful degradation to text output if structured parsing fails\r\n * - Detailed error metrics for system monitoring and alerting\r\n *\r\n * @param params - The preprocessing parameters\r\n * @param params.documents - Array of documents with verbatim fidelity settings, or single document\r\n * @param params.goals - Array of analysis goals to focus the extraction on (e.g., 'compliance-check', 'policy-violations')\r\n * @returns A promise that resolves to an array of CaseFileResponse objects with extracted information\r\n *\r\n * @throws {LoggedError} When AI processing fails, invalid input is provided, or system errors occur\r\n *\r\n * @example\r\n * ```typescript\r\n * // Single document analysis with specific goals\r\n * const results = await preprocessCaseFileDocument({\r\n *   documents: { document: docResource, verbatim_fidelity: 75 },\r\n *   goals: ['compliance-check', 'policy-violations']\r\n * });\r\n *\r\n * // Multiple documents with varying fidelity levels\r\n * const results = await preprocessCaseFileDocument({\r\n *   documents: [\r\n *     { document: emailDoc, verbatim_fidelity: 100 }, // High fidelity for legal email\r\n *     { document: attachmentDoc, verbatim_fidelity: 50 } // Lower fidelity for summary\r\n *   ],\r\n *   goals: ['security-audit', 'data-privacy-compliance']\r\n * });\r\n *\r\n * // Batch processing with shared goals\r\n * const results = await preprocessCaseFileDocument({\r\n *   documents: [\r\n *     { document: contract1, verbatim_fidelity: 80 },\r\n *     { document: contract2, verbatim_fidelity: 80 }\r\n *   ],\r\n *   goals: ['contract-compliance', 'financial-review']\r\n * });\r\n * ```\r\n */\r\nexport const preprocessCaseFileDocument = async ({\r\n  documents,\r\n  goals,\r\n  requestContext: { requestId },\r\n}: {\r\n  documents:\r\n    | Array<{ verbatim_fidelity: number; document: DocumentResource }>\r\n    | { verbatim_fidelity: number; document: DocumentResource };\r\n  goals: Array<string>;\r\n  requestContext: { requestId: string };\r\n}): Promise<Array<CaseFileResponse>> => {\r\n  const preprocessingStartTime = Date.now();\r\n  const source = Array.isArray(documents) ? documents : [documents];\r\n  const recordContents = JSON.stringify(source, null, 2);\r\n  const originalLength = recordContents.length;\r\n  const { document_ids, document_types, fidelity } = source.reduce(\r\n    (acc, doc) => {\r\n      acc.document_ids.push(doc?.document?.unitId ?? 'missing');\r\n      acc.document_types.push(doc?.document?.documentType ?? 'missing');\r\n      acc.fidelity.push(doc?.verbatim_fidelity ?? 75);\r\n      return acc;\r\n    },\r\n    {\r\n      document_ids: [] as Array<number>,\r\n      document_types: [] as Array<string>,\r\n      fidelity: [] as Array<number>,\r\n    },\r\n  );\r\n\r\n  const preprocessingAttributes = {\r\n    document_ids,\r\n    document_types,\r\n    verbatim_fidelity: fidelity,\r\n    original_size_bytes: originalLength,\r\n    goals_count: goals.length,\r\n  };\r\n\r\n  log((l) =>\r\n    l.info(\r\n      `getCaseFileDocument::preprocessCaseFileDocument: Starting preprocessing for documents with ID ${document_ids.join(', ')} - original length: ${originalLength}`,\r\n    ),\r\n  );\r\n\r\n  /**\r\n   * Specialized AI prompt for document information extraction and compliance analysis.\r\n   *\r\n   * This prompt is engineered to:\r\n   * 1. **Establish Context**: Positions the AI as part of a multi-stage compliance system\r\n   * 2. **Define Goals**: Clearly specifies the analysis objectives with visual emphasis\r\n   * 3. **Control Fidelity**: Provides precise instructions for verbatim vs. summarized extraction\r\n   * 4. **Structure Output**: Defines comprehensive JSON schema for consistent results\r\n   * 5. **Handle Edge Cases**: Includes instructions for missing information and error states\r\n   *\r\n   * The prompt uses a structured approach that balances thorough analysis with practical\r\n   * constraints like token limits and processing efficiency.\r\n   */\r\n  const PROMPT = `You are an information extraction pipeline in a multi-stage AI compliance system. Your task is to extract all information from a set of case file records that are directly relevant to the following goals:\r\n  -  ${goals.map((goal) => `***${goal}***`).join('\\n   - ')}.\r\n\r\nInstructions:\r\n  - The verbatim_fidelity level controls how closely output should match source text.\r\n      100 = exact quotes with full context\r\n      75 = exact excerpts with minimal context\r\n      50 = summarized excerpts with some context\r\n      1 = full summary, exact quotes not needed.\r\n  - Keep extracted text brief and focused on the goals - one or two sentences per extracted passage max.\r\n  - Always include:\r\n    - Document ID, type, creation date, sender/originator. Line and character number the extraction begins.\r\n    - If type is not email or attachment, include the ID of the email or attachment record associated with the document.\r\n  - For each related relevant document, include its ID, type, and a brief snippet (first 1-2 sentences or most relevant passage).\r\n  - All policy references, compliance tags, and any structured compliance annotations present in the record and relevant to goals.\r\n  - For each extracted passage:\r\n    - Include relevant excerpt, the goal(s) it addresses, and its location in the document.\r\n      - Locations should include type of sub-record (email content, attachment, call to action, etc.) (e.g., paragraph, section, or key point / call to action / note) and the line+character offset the extraction begins.\r\n    - If there is an explicit document id associated with the passage, include it as well.\r\n    - List all compliance tags that apply to this passage and relevant to goals.\r\n  - For each compliance tag, include any associated severity or sentiment scores, with:\r\n    - The score value and type (e.g., severity, sentiment).\r\n    - The rationale or explanation for the score (if available).\r\n    - The specific passage, policy, or tag the score is evaluating.\r\n  - If a compliance tag or score applies to multiple passages, make this mapping explicit.\r\n  - Note any expected information that is missing (e.g., lack of acknowledgment of a complaint) in an \"omissionsOrGaps\" section.\r\n  - If no relevant information is found, return a status field with the value 'no relevant information'.\r\n\r\nInput Record Format:\r\n[\r\n{\r\n  \"verbatim_fidelity\": ...,\r\n  \"document\": ${zodToStructure(DocumentSchema)}  \r\n}, ...]\r\n\r\nOutput Record Format: [\r\n{\r\n  \"documentId\": ...,\r\n  \"documentPropertyId\": ...,\r\n  \"documentType\": ...,\r\n  \"createdOn\": ...,\r\n  \"sender\": ...,\r\n  \"relatedDocuments\": [\r\n    { \r\n      documentId: ...,\r\n      documentType: ...,\r\n      relationshipType: ...,\r\n      snippit: ...,\r\n    }\r\n  ],\r\n  \"policyReferences\": [...],\r\n  \"complianceTags\": [...],\r\n  \"extractedPassages\": [\r\n    {\r\n      \"text\": \"...\",\r\n      \"goal\": \"...\",\r\n      \"location\": \"...\",\r\n      \"complianceTags\": [...],\r\n      \"scores\": [\r\n        {\r\n          \"type\": \"...\",\r\n          \"value\": ...,\r\n          \"rationale\": \"...\",\r\n          \"appliesTo\": \"...\"\r\n        }\r\n      ]\r\n    }\r\n  ],\r\n  \"omissionsOrGaps\": [...]\r\n},\r\n...]\r\n `;\r\n  try {\r\n    const payload = {\r\n      // model,\r\n      // prompt: PROMPT,\r\n      prompt: [\r\n        {\r\n          role: 'user' as const,\r\n          content: [\r\n            {\r\n              type: 'text' as const,\r\n              text: PROMPT,\r\n            },\r\n            {\r\n              type: 'text' as const,\r\n              text: `The document record to analyze is as follows:\r\n___BEGIN CASE FILE___\r\n${recordContents}\r\n___END CASE FILE___`,\r\n            },\r\n          ],\r\n        },\r\n      ],\r\n      temperature: 0.1,\r\n      experimental_telemetry: {\r\n        isEnabled: true,\r\n        functionId: 'completion-tool-case-file-preprocess',\r\n        metadata: {\r\n          documentId: document_ids.join(', '),\r\n          goals: goals.join(', '),\r\n          requestId: requestId,\r\n        },\r\n      },\r\n    };\r\n\r\n    let response: GenerateTextResult<ToolSet, unknown>;\r\n    const chatHistoryContext = createAgentHistoryContext({\r\n      operation: 'summarize.case-file',\r\n      iteration: 1,\r\n      originatingUserId: '-1',\r\n      metadata: {\r\n        requestId,\r\n        documentId: document_ids.join(', '),\r\n        goals: goals.join(', '),\r\n      },\r\n    });\r\n    try {\r\n      const model = wrapChatHistoryMiddleware({\r\n        model: aiModelFactory('lofi'),\r\n        chatHistoryContext,\r\n      });\r\n      response = await generateTextWithRetry({\r\n        ...payload,\r\n        model,\r\n      });\r\n    } catch (error) {\r\n      chatHistoryContext.error = error;\r\n      throw LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'getCaseFileDocument::preprocessCaseFileDocument',\r\n      });\r\n    } finally {\r\n      chatHistoryContext?.dispose();\r\n    }\r\n\r\n    const preprocessingDuration = Date.now() - preprocessingStartTime;\r\n\r\n    // Record preprocessing success metrics\r\n    caseFileDocumentPreprocessingCounter.add(1, {\r\n      ...preprocessingAttributes,\r\n      status: 'success',\r\n    });\r\n\r\n    caseFileDocumentPreprocessingDurationHistogram.record(\r\n      preprocessingDuration,\r\n      {\r\n        ...preprocessingAttributes,\r\n        status: 'success',\r\n      },\r\n    );\r\n\r\n    // Record processed size metrics\r\n    caseFileDocumentSizeHistogram.record(response.text.length, {\r\n      ...preprocessingAttributes,\r\n      operation_type: 'preprocessed_output',\r\n    });\r\n\r\n    log((l) =>\r\n      l.info(\r\n        `getCaseFileDocument::preprocessCaseFileDocument: Processed documents with ID ${document_ids.join(', ')} - original length: ${originalLength}, response length: ${response.text.length}`,\r\n      ),\r\n    );\r\n\r\n    /**\r\n     * Handle AI response parsing with graceful fallback strategy.\r\n     *\r\n     * **Response Processing Logic:**\r\n     * 1. **Structured Output Priority**: Attempts to extract structured JSON from provider metadata\r\n     * 2. **Array Normalization**: Ensures consistent array format for downstream processing\r\n     * 3. **Fallback Handling**: Falls back to text-based response if structured parsing fails\r\n     * 4. **Type Safety**: Applies appropriate type casting for SummarizedDocumentResource\r\n     *\r\n     * This approach provides resilience against variations in AI provider response formats\r\n     * while maintaining type safety and consistent data structures for client consumption.\r\n     */\r\n    if (response.providerMetadata?.structuredOutputs) {\r\n      // Handle structured outputs from AI provider\r\n      return Array.isArray(response.providerMetadata.structuredOutputs)\r\n        ? response.providerMetadata.structuredOutputs.map((x) => ({\r\n            summary: x as SummarizedDocumentResource,\r\n          }))\r\n        : [\r\n            {\r\n              summary: response.providerMetadata\r\n                .structuredOutputs as SummarizedDocumentResource,\r\n            },\r\n          ]; // Ensure we always return an array for consistent handling\r\n    }\r\n\r\n    // Fallback to text-based response when structured parsing isn't available\r\n    return [{ text: response.text }];\r\n  } catch (error) {\r\n    const preprocessingDuration = Date.now() - preprocessingStartTime;\r\n\r\n    // Record preprocessing error metrics\r\n    caseFileDocumentPreprocessingCounter.add(1, {\r\n      ...preprocessingAttributes,\r\n      status: 'error',\r\n    });\r\n\r\n    caseFileDocumentPreprocessingDurationHistogram.record(\r\n      preprocessingDuration,\r\n      {\r\n        ...preprocessingAttributes,\r\n        status: 'error',\r\n      },\r\n    );\r\n\r\n    throw LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: 'getCaseFileDocument::preprocessCaseFileDocument',\r\n      message: 'Error processing case file document',\r\n      data: {\r\n        documentId: document_ids.join(', '),\r\n        goals: goals.join(', '),\r\n      },\r\n    });\r\n  }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\mcpToolsMetrics.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":8,"column":1,"nodeType":"Program","endLine":237,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module mcpToolsMetrics\r\n *\r\n * Centralized metrics export and management for all MCP (Model Context Protocol) tools.\r\n * Provides comprehensive OpenTelemetry metrics for AI tool usage, performance, and observability.\r\n */\r\n\r\nimport { log } from '@/lib/logger';\r\n\r\n/**\r\n * Type definitions for MCP tool metrics\r\n */\r\ninterface ToolMetrics {\r\n  counters?: Record<string, string>;\r\n  histograms?: Record<string, string>;\r\n  gauges?: Record<string, string>;\r\n  description: string;\r\n}\r\n\r\ninterface MetricsRegistry {\r\n  [toolName: string]: ToolMetrics;\r\n}\r\n\r\n/**\r\n * MCP Tools Metrics Registry\r\n *\r\n * Provides a centralized way to export all MCP tool metrics for observability backends\r\n * like Prometheus, DataDog, or other OpenTelemetry-compatible systems.\r\n */\r\nexport const mcpToolsMetricsRegistry = {\r\n  /**\r\n   * Export all MCP tool metrics for external observability systems\r\n   *\r\n   * @returns Object containing all MCP tool metric names and metadata\r\n   */\r\n  exportAllMetrics: (): MetricsRegistry => {\r\n    return {\r\n      // Amendment Tool Metrics\r\n      amendment: {\r\n        counters: {\r\n          total_operations: 'ai_tool_amend_case_record_total',\r\n          errors: 'ai_tool_amend_case_record_errors_total',\r\n        },\r\n        histograms: {\r\n          duration: 'ai_tool_amend_case_record_duration_ms',\r\n          records_count: 'ai_tool_amendment_records_count',\r\n        },\r\n        description: 'Metrics for case record amendment operations',\r\n      },\r\n\r\n      // Case File Document Retrieval Metrics\r\n      caseFileDocument: {\r\n        counters: {\r\n          total_operations: 'ai_tool_get_case_file_document_total',\r\n          errors: 'ai_tool_get_case_file_document_errors_total',\r\n          preprocessing_operations: 'ai_tool_case_file_preprocessing_total',\r\n        },\r\n        histograms: {\r\n          duration: 'ai_tool_get_case_file_document_duration_ms',\r\n          document_size: 'ai_tool_case_file_document_size_bytes',\r\n          preprocessing_duration: 'ai_tool_case_file_preprocessing_duration_ms',\r\n        },\r\n        description:\r\n          'Metrics for case file document retrieval and preprocessing',\r\n      },\r\n\r\n      // Search Tools Metrics\r\n      search: {\r\n        counters: {\r\n          case_file_operations: 'ai_tool_search_case_file_total',\r\n          case_file_errors: 'ai_tool_search_case_file_errors_total',\r\n          policy_store_operations: 'ai_tool_search_policy_store_total',\r\n          policy_store_errors: 'ai_tool_search_policy_store_errors_total',\r\n        },\r\n        histograms: {\r\n          case_file_duration: 'ai_tool_search_case_file_duration_ms',\r\n          case_file_results: 'ai_tool_search_case_file_results_count',\r\n          policy_store_duration: 'ai_tool_search_policy_store_duration_ms',\r\n          policy_store_results: 'ai_tool_search_policy_store_results_count',\r\n        },\r\n        description:\r\n          'Metrics for search operations across case files and policy stores',\r\n      },\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Start periodic metrics collection for gauges and other metrics that need regular updates\r\n   *\r\n   * @param intervalMs Interval in milliseconds for periodic updates (default: 30 seconds)\r\n   * @returns Cleanup function to stop periodic updates\r\n   */\r\n  startPeriodicMetricsUpdate: (intervalMs: number = 30000) => {\r\n    const updateInterval = setInterval(() => {\r\n      try {\r\n        // Add any periodic gauge updates here if needed in the future\r\n        // For now, most MCP tool metrics are event-based (counters/histograms)\r\n      } catch (error) {\r\n        console.error('Failed to update periodic MCP tool metrics:', error);\r\n      }\r\n    }, intervalMs);\r\n\r\n    // Return cleanup function\r\n    return () => {\r\n      clearInterval(updateInterval);\r\n      log((l) => l.info('Stopped periodic metrics updates for MCP tools'));\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Get a summary of all available MCP tool metrics\r\n   *\r\n   * @returns Summary object with metric counts and categories\r\n   */\r\n  getMetricsSummary: () => {\r\n    const metrics = mcpToolsMetricsRegistry.exportAllMetrics();\r\n\r\n    let totalCounters = 0;\r\n    let totalHistograms = 0;\r\n    let totalGauges = 0;\r\n\r\n    Object.values(metrics).forEach((toolMetrics: ToolMetrics) => {\r\n      totalCounters += Object.keys(toolMetrics.counters || {}).length;\r\n      totalHistograms += Object.keys(toolMetrics.histograms || {}).length;\r\n      totalGauges += Object.keys(toolMetrics.gauges || {}).length;\r\n    });\r\n\r\n    return {\r\n      totalTools: Object.keys(metrics).length,\r\n      totalCounters,\r\n      totalHistograms,\r\n      totalGauges,\r\n      totalMetrics: totalCounters + totalHistograms + totalGauges,\r\n      tools: Object.keys(metrics),\r\n      lastUpdated: new Date().toISOString(),\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Validate that all metrics are properly configured and accessible\r\n   *\r\n   * @returns Validation results for all MCP tool metrics\r\n   */\r\n  validateMetrics: () => {\r\n    const validation = {\r\n      valid: true,\r\n      errors: [] as string[],\r\n      warnings: [] as string[],\r\n      validatedAt: new Date().toISOString(),\r\n    };\r\n\r\n    try {\r\n      const metrics = mcpToolsMetricsRegistry.exportAllMetrics();\r\n\r\n      // Basic validation - ensure all metric names are strings and follow naming conventions\r\n      Object.entries(metrics).forEach(\r\n        ([toolName, toolMetrics]: [string, ToolMetrics]) => {\r\n          const allMetricNames = [\r\n            ...Object.values(toolMetrics.counters || {}),\r\n            ...Object.values(toolMetrics.histograms || {}),\r\n            ...Object.values(toolMetrics.gauges || {}),\r\n          ] as string[];\r\n\r\n          allMetricNames.forEach((metricName) => {\r\n            if (typeof metricName !== 'string') {\r\n              validation.errors.push(\r\n                `Invalid metric name type in ${toolName}: ${metricName}`,\r\n              );\r\n              validation.valid = false;\r\n            } else if (!metricName.startsWith('ai_tool_')) {\r\n              validation.warnings.push(\r\n                `Metric ${metricName} in ${toolName} doesn't follow naming convention`,\r\n              );\r\n            }\r\n          });\r\n        },\r\n      );\r\n    } catch (error) {\r\n      validation.errors.push(`Validation failed: ${error}`);\r\n      validation.valid = false;\r\n    }\r\n\r\n    return validation;\r\n  },\r\n};\r\n\r\n/**\r\n * Helper function to create standardized MCP tool metric attributes\r\n *\r\n * @param toolName Name of the MCP tool\r\n * @param operation Type of operation being performed\r\n * @param additionalAttributes Any additional attributes specific to the operation\r\n * @returns Standardized attributes object for OpenTelemetry metrics\r\n */\r\nexport const createMcpToolAttributes = (\r\n  toolName: string,\r\n  operation: string,\r\n  additionalAttributes: Record<string, string | number | boolean> = {},\r\n) => {\r\n  return {\r\n    tool_name: toolName,\r\n    operation_type: operation,\r\n    service_name: 'WebUi',\r\n    service_namespace: 'ObApps.ComplianceTheatre',\r\n    ...additionalAttributes,\r\n  };\r\n};\r\n\r\n/**\r\n * Helper function for consistent error categorization across MCP tools\r\n *\r\n * @param error The error object or string\r\n * @returns Categorized error type for metrics\r\n */\r\nexport const categorizeMcpToolError = (error: unknown): string => {\r\n  if (typeof error === 'string') {\r\n    if (error.includes('not found')) return 'not_found';\r\n    if (error.includes('permission')) return 'permission_denied';\r\n    if (error.includes('timeout')) return 'timeout';\r\n    if (error.includes('validation')) return 'validation_error';\r\n    return 'string_error';\r\n  }\r\n\r\n  if (error instanceof Error) {\r\n    const message = error.message.toLowerCase();\r\n    if (message.includes('not found')) return 'not_found';\r\n    if (message.includes('permission')) return 'permission_denied';\r\n    if (message.includes('timeout')) return 'timeout';\r\n    if (message.includes('validation')) return 'validation_error';\r\n    if (message.includes('network')) return 'network_error';\r\n    if (message.includes('database')) return 'database_error';\r\n    return 'runtime_error';\r\n  }\r\n\r\n  return 'unknown_error';\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\ping-pong.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\schemas\\amendment-result-schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\schemas\\base-document-property-shape.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\schemas\\case-file-request-props-shape.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":64,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import z from 'zod';\r\nimport { SummarizedDocumentSchema } from './summarized-document-results';\r\nimport { DocumentSchema } from './case-file-shape';\r\n\r\n/**\r\n * Schema for validating the properties required to request processing of a case file.\r\n *\r\n * @property caseFileId - The ID of the case file to process.\r\n * @property goals - (Optional) An array of goals identifying your task or describing what information should be extracted from the case files.\r\n *   When set, each document will be pre-processed and relevant information returned.\r\n *   When left blank, you will receive the full case files.\r\n *   Case file documents are large and require a lot of context space, so pre-processing is recommended.\r\n * @property verbatimFidelity - (Optional) Controls how closely output should match source text.\r\n *   100 = exact quotes with full context;\r\n *   75 = exact excerpts with minimal context;\r\n *   50 = summarized excerpts with some context;\r\n *   1 = full summary, exact quotes not needed.\r\n *   Set here to provide a default for all requests.\r\n */\r\nexport const caseFileRequestPropsShape = z.object({\r\n  caseFileId: z.any().describe('The ID of the case file to process.'),\r\n  goals: z\r\n    .array(z.string())\r\n    .describe(\r\n      'An array of goals used to pre-process the results.  Values set here are specific to the case file and override the value passed at the request level.',\r\n    )\r\n    .optional(),\r\n  verbatimFidelity: z\r\n    .number()\r\n    .min(1)\r\n    .max(100)\r\n    .optional()\r\n    .describe(\r\n      'Controls how closely output should match source text. Values set here are specific to the case file and override the value passed at the request level.',\r\n    ),\r\n});\r\n\r\n/**\r\n * Schema for the response shape of a case file request.\r\n *\r\n * @property case_file - The full case file document, retuned if no summary is requested.\r\n * @property summary - The summarized document, returned if a summary is requested.\r\n * @property text - Raw content of the document, if structured output is not available.\r\n */\r\nexport const CaseFileResponseShape = z.object({\r\n  case_file: DocumentSchema.extend({})\r\n    .optional()\r\n    .nullable()\r\n    .describe(\r\n      'The full case file document, returned if no goals were provided for pre-processing.',\r\n    ),\r\n  summary: SummarizedDocumentSchema.extend({})\r\n    .optional()\r\n    .nullable()\r\n    .describe('The summarized document, returned when goals are provided to pre-process the result.'),\r\n  text: z\r\n    .string()\r\n    .optional()\r\n    .nullable()\r\n    .describe(\r\n      'Raw content of the document - only returned when no pre-processing goals were provided but the file cannot be extracted as valid structured output.',\r\n    ),\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\schemas\\case-file-shape.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\schemas\\caseFileAmendmentShape.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":85,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { z } from 'zod';\r\nimport CaseFileViolationShape from './caseFileViolationShape';\r\n\r\n/**\r\n * Schema for amending a case file, specifying updates to ratings, notes, related documents, responsive actions, and violations.\r\n *\r\n * @property targetCaseFileId - Case file ID to update (number or string).\r\n * @property severityRating - Optional severity rating.\r\n * @property severityReasons - Optional array of reasons for severity rating.\r\n * @property notes - Optional array of notes.\r\n * @property complianceRating - Optional compliance rating.\r\n * @property complianceReasons - Optional array of reasons for compliance rating.\r\n * @property completionRating - Optional completion rating.\r\n * @property completionReasons - Optional array of reasons for completion rating.\r\n * @property addRelatedDocuments - Optional array to link documents together, each specifying a related document ID and relationship type (e.g., \"supports\", \"responds to\", \"contradicts\").\r\n * @property associateResponsiveAction - Optional array to associate responsive actions with CTAs, including CTA document ID, Chapter 13 compliance rating and reasons, completion percentage, and completion reasons.\r\n * @property violations - Optional array of violations to associate with the case file.\r\n * @property sentimentRating - Optional new sentiment rating (retains existing if not set).\r\n * @property sentimentReasons - Optional array of reasons for sentiment rating.\r\n * @property chapter13Rating - Optional new Chapter 13 rating (retains existing if not set).\r\n * @property chapter13Reasons - Optional array of reasons for Chapter 13 rating (required if chapter13Rating is set).\r\n * @property titleIXRating - Optional new Title IX rating (retains existing if not set).\r\n * @property titleIXReasons - Optional array of reasons for Title IX rating (required if titleIXRating is set).\r\n * @property explanation - Required explanation of changes and rationale.\r\n */\r\nexport const CaseFileAmendmentShape = z\r\n  .object({\r\n    targetCaseFileId: z\r\n      .union([z.number(), z.string()])\r\n      .describe('Identifies case file to amend.'),\r\n    severityRating: z.number().optional(),\r\n    severityReasons: z.array(z.string()).optional(),\r\n    notes: z.array(z.string()).optional(),\r\n    complianceRating: z.number().optional(),\r\n    complianceReasons: z.array(z.string()).optional(),\r\n    completionRating: z\r\n      .number()\r\n      .optional()\r\n      .describe('Rates how close to fully complete the CTA is.'),\r\n    completionReasons: z.array(z.string()).optional(),\r\n    addRelatedDocuments: z\r\n      .array(\r\n        z.object({\r\n          relatedToDocumentId: z\r\n            .number()\r\n            .describe('Identifies related document.'),\r\n          relationshipType: z\r\n            .string()\r\n            .describe('Describes how the document is related to case file.'),\r\n        }),\r\n      )\r\n      .optional()\r\n      .describe('Establishes relationships between case files.'),\r\n    associateResponsiveAction: z\r\n      .array(\r\n        z.object({\r\n          relatedCtaDocumentId: z\r\n            .number()\r\n            .describe('Identifies CTA case file.'),\r\n          complianceChapter13: z.number(),\r\n          complianceChapter13Reasons: z\r\n            .array(z.string())\r\n            .describe('Factors impacting complianceChapter13.'),\r\n          completionPercentage: z.number(),\r\n          completionReasons: z\r\n            .array(z.string())\r\n            .describe('Factors impacting completionPercentage.'),\r\n        }),\r\n      )\r\n      .optional(),\r\n    violations: z.array(CaseFileViolationShape).optional(),\r\n    sentimentRating: z.number().optional(),\r\n    sentimentReasons: z.array(z.string()).optional(),\r\n    chapter13Rating: z.number().optional(),\r\n    chapter13Reasons: z.array(z.string()).optional(),\r\n    titleIXRating: z.number().optional(),\r\n    titleIXReasons: z.array(z.string()).optional(),\r\n    explanation: z\r\n      .string()\r\n      .describe('Reason amendment is being made - required.'),\r\n  })\r\n  .describe(\r\n    'Describes the changes to make to a case file.  Properties that are not set will maintain current values.  When updating a Rating field the associated Reasons field must contain at least 3 values - eg changing the severityRating value necessitates passing 3 or more strings in the severityReasons property.',\r\n  );\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\schemas\\caseFileViolationShape.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\schemas\\docPropCtaResponseShape.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\schemas\\docPropCtaShape.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\schemas\\docPropKeyPointShape.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\schemas\\documentPropertyShape.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\schemas\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\schemas\\searchObjects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\schemas\\summarized-document-results.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":102,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import z from 'zod';\r\n\r\n/**\r\n * Schema representing the summarized results of a case file document.\r\n *\r\n * @property documentId - Unique identifier for the document.\r\n * @property documentType - Type of document (e.g., email, attachment).\r\n * @property createdOn - Creation date and time of the document.\r\n * @property sender - Name and email of the document sender.\r\n * @property relatedDocuments - Array of related documents, each including:\r\n *   - documentId: Unique identifier for the related document.\r\n *   - relationshipType: Type of relationship (e.g., \"supports\", \"responds to\", \"contradicts\").\r\n *   - documentType: Type of the related document (call to action, note, email, etc).\r\n *   - excerpt: Short excerpt or summary of the related document.\r\n * @property policyReferences - Array of relevant policy references and statutes.\r\n * @property complianceTags - Array of compliance-related tags.\r\n * @property extractedPassages - Array of extracted passages with metadata, each including:\r\n *   - text: Extracted text passage.\r\n *   - goal: Goal this passage addresses.\r\n *   - location: Location in document (e.g., paragraph, line number).\r\n *   - complianceTags: Compliance tags specific to this passage.\r\n *   - scores: Array of scores associated with this passage, each including:\r\n *     - type: Type of score (e.g., severity, sentiment).\r\n *     - value: Numeric score value.\r\n *     - rationale: Explanation for the score.\r\n *     - appliesTo: What the score is evaluating.\r\n * @property omissionsOrGaps - Array of identified omissions or gaps in compliance.\r\n */\r\nexport const SummarizedDocumentSchema = z.object({\r\n  documentId: z.string().or(z.number()).describe('Unique identifier for the document'),\r\n  documentType: z\r\n    .string()\r\n    .describe('Type of document (e.g., email, attachment)'),\r\n  createdOn: z.string().describe('Creation date and time of the document'),\r\n  sender: z.string().nullable().describe('Name and email of the document sender'),\r\n  relatedDocuments: z\r\n    .array(\r\n      z.object({\r\n        documentId: z\r\n          .string()\r\n          .or(z.number())\r\n          .describe('Unique identifier for the related document'),\r\n        relationshipType: z\r\n          .string()\r\n          .describe(\r\n            'Type of relationship (e.g., \"supports\", \"responds to\", \"contradicts\")',\r\n          ),\r\n        documentType: z\r\n          .string()\r\n          .describe(\r\n            'Type of the related document (call to action, note, etc, email, etc)',\r\n          ),\r\n        excerpt: z\r\n          .string()\r\n          .optional()\r\n          .nullable()\r\n          .describe('Short excerpt or summary of the related document'),\r\n      }).passthrough(),\r\n    )\r\n    .describe('Array of related document identifiers'),\r\n  policyReferences: z\r\n    .array(z.string())\r\n    .describe('Array of relevant policy references and statutes'),\r\n  complianceTags: z\r\n    .array(z.string())\r\n    .describe('Array of compliance-related tags'),\r\n  extractedPassages: z\r\n    .array(\r\n      z.object({\r\n        text: z.string().describe('Extracted text passage'),\r\n        goal: z.string().describe('Goal this passage addresses'),\r\n        location: z\r\n          .string()\r\n          .describe('Location in document (e.g., paragraph, line number)'),\r\n        complianceTags: z\r\n          .array(z.string())\r\n          .describe('Compliance tags specific to this passage')\r\n          .optional()\r\n          .nullable(),\r\n        scores: z\r\n          .array(\r\n            z.object({\r\n              type: z\r\n                .string()\r\n                .describe('Type of score (e.g., severity, sentiment)'),\r\n              value: z.number().describe('Numeric score value'),\r\n              rationale: z.string().describe('Explanation for the score'),\r\n              appliesTo: z.string().describe('What the score is evaluating'),\r\n            }),\r\n          )\r\n          .describe('Array of scores associated with this passage'),\r\n      }).passthrough(),\r\n    )\r\n    .optional()\r\n    .describe('Array of extracted passages with metadata'),\r\n  omissionsOrGaps: z\r\n    .array(z.string())\r\n    .describe('Array of identified omissions or gaps in compliance')\r\n    .optional()\r\n    .nullable(),\r\n}).passthrough();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\searchCaseFile.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'extra' is defined but never used.","line":78,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":78,"endColumn":8,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\searchPolicyStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\sequentialthinking\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\sequentialthinking\\sequential-thinking-server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\sequentialthinking\\tool-callback.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\todo\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\todo\\todo-manager.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":552,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { log } from '@/lib/logger';\r\n\r\nexport type TodoStatus = 'pending' | 'active' | 'complete';\r\n\r\nexport type TodoPriority = 'high' | 'medium' | 'low';\r\n\r\n/**\r\n * Represents a single todo item in the system.\r\n */\r\nexport interface Todo {\r\n  id: string;\r\n  title: string;\r\n  description?: string;\r\n  completed: boolean;\r\n  status: TodoStatus;\r\n  priority: TodoPriority;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport interface TodoList {\r\n  id: string;\r\n  title: string;\r\n  description?: string;\r\n  status: TodoStatus;\r\n  priority: TodoPriority;\r\n  todos: Todo[];\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport type TodoListUpsertInput = {\r\n  id?: string;\r\n  title: string;\r\n  description?: string;\r\n  status?: TodoStatus;\r\n  priority?: TodoPriority;\r\n  createdAt?: Date;\r\n  updatedAt?: Date;\r\n  todos?: Array<{\r\n    id?: string;\r\n    title: string;\r\n    description?: string;\r\n    completed?: boolean;\r\n    status?: TodoStatus;\r\n    priority?: TodoPriority;\r\n    createdAt?: Date;\r\n    updatedAt?: Date;\r\n  }>;\r\n};\r\n\r\nconst DEFAULT_LIST_ID = 'default';\r\nconst DEFAULT_LIST_TITLE = 'Default Todo List';\r\nconst DEFAULT_LIST_STATUS: TodoStatus = 'active';\r\nconst DEFAULT_LIST_PRIORITY: TodoPriority = 'medium';\r\n\r\n/**\r\n * TodoManager - Manages in-memory todo lists and items.\r\n *\r\n * This class provides CRUD operations for managing todos and their lists. It's\r\n * designed as a singleton to maintain state across multiple tool invocations\r\n * within the same process.\r\n */\r\nexport class TodoManager {\r\n  private todos: Map<string, Todo> = new Map();\r\n  private todoLists: Map<string, TodoList> = new Map();\r\n  private todoToList: Map<string, string> = new Map();\r\n\r\n  constructor() {\r\n    log((l) => l.debug('TodoManager instance created'));\r\n  }\r\n\r\n  /**\r\n   * Create a new todo item inside the default list. This is primarily used by\r\n   * legacy flows that still operate at the item level.\r\n   */\r\n  createTodo(\r\n    title: string,\r\n    description?: string,\r\n    options?: { status?: TodoStatus; priority?: TodoPriority },\r\n  ): Todo {\r\n    const list = this.ensureDefaultList();\r\n    const todo = this.createTodoRecord(\r\n      {\r\n        title,\r\n        description,\r\n        status: options?.status,\r\n        priority: options?.priority,\r\n      },\r\n      list.id,\r\n    );\r\n\r\n    list.todos.push(todo);\r\n    list.updatedAt = todo.updatedAt;\r\n    this.todos.set(todo.id, todo);\r\n    this.todoToList.set(todo.id, list.id);\r\n\r\n    log((l) => l.debug('Todo created', { id: todo.id, title }));\r\n\r\n    return todo;\r\n  }\r\n\r\n  /**\r\n   * Upsert (create or replace) a todo list.\r\n   */\r\n  upsertTodoList(input: TodoListUpsertInput): TodoList {\r\n    const listId = input.id ?? this.generateListId();\r\n    const now = new Date();\r\n\r\n    const existingList = this.todoLists.get(listId);\r\n    if (existingList) {\r\n      existingList.todos.forEach((todo) => {\r\n        this.todos.delete(todo.id);\r\n        this.todoToList.delete(todo.id);\r\n      });\r\n    }\r\n\r\n    const createdAt = input.createdAt ?? existingList?.createdAt ?? now;\r\n    const todos = (input.todos ?? []).map((todoInput) =>\r\n      this.createTodoRecord(todoInput, listId),\r\n    );\r\n\r\n    const list: TodoList = {\r\n      id: listId,\r\n      title: input.title,\r\n      description: input.description,\r\n      status: input.status ?? 'active',\r\n      priority: input.priority ?? 'medium',\r\n      todos,\r\n      createdAt,\r\n      updatedAt: input.updatedAt ?? now,\r\n    };\r\n\r\n    this.todoLists.set(listId, list);\r\n    todos.forEach((todo) => {\r\n      this.todos.set(todo.id, todo);\r\n      this.todoToList.set(todo.id, listId);\r\n    });\r\n\r\n    log((l) =>\r\n      l.debug('Todo list upserted', {\r\n        id: listId,\r\n        title: input.title,\r\n        replaced: Boolean(existingList),\r\n        itemCount: todos.length,\r\n      }),\r\n    );\r\n\r\n    return list;\r\n  }\r\n\r\n  /**\r\n   * Retrieve all todo lists, optionally filtering todos by completion state.\r\n   */\r\n  getTodoLists(options?: { completed?: boolean }): TodoList[] {\r\n    const completed = options?.completed;\r\n    return Array.from(this.todoLists.values()).map((list) =>\r\n      this.cloneListWithFilter(list, completed),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Retrieve a single todo list by ID.\r\n   */\r\n  getTodoList(\r\n    id: string,\r\n    options?: { completed?: boolean },\r\n  ): TodoList | undefined {\r\n    const list = this.todoLists.get(id);\r\n    if (!list) {\r\n      return undefined;\r\n    }\r\n    return this.cloneListWithFilter(list, options?.completed);\r\n  }\r\n\r\n  /**\r\n   * Get all todos, optionally filtered by completion status.\r\n   */\r\n  getTodos(completed?: boolean): Todo[] {\r\n    const todos = Array.from(this.todos.values());\r\n    if (completed === undefined) {\r\n      return todos;\r\n    }\r\n    return todos.filter((todo) => todo.completed === completed);\r\n  }\r\n\r\n  /**\r\n   * Get a specific todo by ID.\r\n   */\r\n  getTodo(id: string): Todo | undefined {\r\n    return this.todos.get(id);\r\n  }\r\n\r\n  /**\r\n   * Update an existing todo.\r\n   */\r\n  updateTodo(\r\n    id: string,\r\n    updates: {\r\n      title?: string;\r\n      description?: string;\r\n      completed?: boolean;\r\n      status?: TodoStatus;\r\n      priority?: TodoPriority;\r\n    },\r\n  ): Todo | undefined {\r\n    const todo = this.todos.get(id);\r\n    if (!todo) {\r\n      return undefined;\r\n    }\r\n\r\n    const listId = this.todoToList.get(id);\r\n    const list = listId ? this.todoLists.get(listId) : undefined;\r\n    if (!list) {\r\n      this.todos.delete(id);\r\n      this.todoToList.delete(id);\r\n      return undefined;\r\n    }\r\n\r\n    const { status: nextStatus, completed: nextCompleted } =\r\n      this.resolveStatusAndCompletion(todo, updates);\r\n    const nextPriority = updates.priority ?? todo.priority;\r\n\r\n    const updatedTodo: Todo = {\r\n      ...todo,\r\n      title: updates.title ?? todo.title,\r\n      description: updates.description ?? todo.description,\r\n      priority: nextPriority,\r\n      status: nextStatus,\r\n      completed: nextCompleted,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    this.todos.set(id, updatedTodo);\r\n\r\n    const idx = list.todos.findIndex((t) => t.id === id);\r\n    if (idx !== -1) {\r\n      list.todos[idx] = updatedTodo;\r\n    } else {\r\n      list.todos.push(updatedTodo);\r\n    }\r\n    list.updatedAt = updatedTodo.updatedAt;\r\n    this.updateListStatus(list);\r\n\r\n    log((l) => l.debug('Todo updated', { id, updates }));\r\n\r\n    return updatedTodo;\r\n  }\r\n\r\n  /**\r\n   * Delete a todo by ID.\r\n   */\r\n  deleteTodo(id: string): boolean {\r\n    const listId = this.todoToList.get(id);\r\n    const list = listId ? this.todoLists.get(listId) : undefined;\r\n\r\n    const result = this.todos.delete(id);\r\n    this.todoToList.delete(id);\r\n\r\n    if (list) {\r\n      const nextTodos = list.todos.filter((todo) => todo.id !== id);\r\n      if (nextTodos.length !== list.todos.length) {\r\n        list.todos = nextTodos;\r\n        list.updatedAt = new Date();\r\n        this.updateListStatus(list);\r\n      }\r\n    }\r\n\r\n    if (result) {\r\n      log((l) => l.debug('Todo deleted', { id }));\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Toggle the completed status of a todo.\r\n   */\r\n  toggleTodo(id: string): TodoList | undefined {\r\n    const todo = this.todos.get(id);\r\n    if (!todo) {\r\n      return undefined;\r\n    }\r\n\r\n    const listId = this.todoToList.get(id);\r\n    if (!listId) {\r\n      this.todos.delete(id);\r\n      this.todoToList.delete(id);\r\n      return undefined;\r\n    }\r\n\r\n    const list = this.todoLists.get(listId);\r\n    if (!list) {\r\n      this.todos.delete(id);\r\n      this.todoToList.delete(id);\r\n      return undefined;\r\n    }\r\n\r\n    const { status: nextStatus, completed: nextCompleted } =\r\n      this.advanceTodoState(todo);\r\n\r\n    const updatedTodo: Todo = {\r\n      ...todo,\r\n      status: nextStatus,\r\n      completed: nextCompleted,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    this.todos.set(id, updatedTodo);\r\n\r\n    const idx = list.todos.findIndex((item) => item.id === id);\r\n    if (idx !== -1) {\r\n      list.todos[idx] = updatedTodo;\r\n    } else {\r\n      list.todos.push(updatedTodo);\r\n    }\r\n\r\n    list.updatedAt = updatedTodo.updatedAt;\r\n    this.updateListStatus(list);\r\n\r\n    log((l) =>\r\n      l.debug('Todo toggled', {\r\n        id,\r\n        listId,\r\n        status: updatedTodo.status,\r\n        completed: updatedTodo.completed,\r\n      }),\r\n    );\r\n\r\n    return this.cloneListWithFilter(list);\r\n  }\r\n\r\n  /**\r\n   * Clear all todos and lists.\r\n   */\r\n  clearAll(): void {\r\n    this.todos.clear();\r\n    this.todoLists.clear();\r\n    this.todoToList.clear();\r\n    log((l) => l.debug('All todos and lists cleared'));\r\n  }\r\n\r\n  /**\r\n   * Get the total count of todos across all lists.\r\n   */\r\n  getCount(): number {\r\n    return this.todos.size;\r\n  }\r\n\r\n  private createTodoRecord(\r\n    input: {\r\n      id?: string;\r\n      title?: string;\r\n      description?: string;\r\n      completed?: boolean;\r\n      status?: TodoStatus;\r\n      priority?: TodoPriority;\r\n      createdAt?: Date;\r\n      updatedAt?: Date;\r\n    },\r\n    listId: string,\r\n  ): Todo {\r\n    const id =\r\n      input.id ??\r\n      `todo-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\r\n    const now = new Date();\r\n    const { status, completed } = this.resolveCreationStatusAndCompletion({\r\n      status: input.status,\r\n      completed: input.completed,\r\n    });\r\n\r\n    const createdAt = input.createdAt ?? now;\r\n    const updatedAt = input.updatedAt ?? now;\r\n\r\n    const todo: Todo = {\r\n      id,\r\n      title: input.title ?? 'Untitled Task',\r\n      description: input.description,\r\n      completed,\r\n      status,\r\n      priority: input.priority ?? 'medium',\r\n      createdAt,\r\n      updatedAt,\r\n    };\r\n\r\n    this.todoToList.set(id, listId);\r\n\r\n    return todo;\r\n  }\r\n\r\n  private resolveStatusAndCompletion(\r\n    todo: Todo,\r\n    updates: {\r\n      completed?: boolean;\r\n      status?: TodoStatus;\r\n    },\r\n  ): { status: TodoStatus; completed: boolean } {\r\n    let nextStatus = todo.status;\r\n    let nextCompleted = todo.completed;\r\n\r\n    if (updates.status) {\r\n      nextStatus = updates.status;\r\n      nextCompleted = updates.status === 'complete';\r\n    }\r\n\r\n    if (updates.completed !== undefined) {\r\n      nextCompleted = updates.completed;\r\n      nextStatus = updates.completed\r\n        ? 'complete'\r\n        : this.inferIncompleteStatus(nextStatus);\r\n    }\r\n\r\n    return { status: nextStatus, completed: nextCompleted };\r\n  }\r\n\r\n  private resolveCreationStatusAndCompletion(options?: {\r\n    status?: TodoStatus;\r\n    completed?: boolean;\r\n  }): { status: TodoStatus; completed: boolean } {\r\n    const statusFromInput = options?.status;\r\n    const completedFromInput = options?.completed;\r\n\r\n    if (statusFromInput) {\r\n      return {\r\n        status: statusFromInput,\r\n        completed:\r\n          completedFromInput !== undefined\r\n            ? completedFromInput\r\n            : statusFromInput === 'complete',\r\n      };\r\n    }\r\n\r\n    if (completedFromInput !== undefined) {\r\n      return {\r\n        status: completedFromInput ? 'complete' : 'active',\r\n        completed: completedFromInput,\r\n      };\r\n    }\r\n\r\n    return { status: 'pending', completed: false };\r\n  }\r\n\r\n  private inferIncompleteStatus(previousStatus: TodoStatus): TodoStatus {\r\n    if (previousStatus === 'complete') {\r\n      return 'active';\r\n    }\r\n\r\n    return previousStatus;\r\n  }\r\n\r\n  private advanceTodoState(todo: Todo): {\r\n    status: TodoStatus;\r\n    completed: boolean;\r\n  } {\r\n    switch (todo.status) {\r\n      case 'pending':\r\n        return { status: 'active', completed: false };\r\n      case 'active':\r\n        return { status: 'complete', completed: true };\r\n      case 'complete':\r\n      default:\r\n        return { status: 'active', completed: false };\r\n    }\r\n  }\r\n\r\n  private updateListStatus(list: TodoList): void {\r\n    if (list.todos.length === 0) {\r\n      list.status = 'pending';\r\n      return;\r\n    }\r\n\r\n    if (list.todos.every((todo) => todo.completed)) {\r\n      list.status = 'complete';\r\n      return;\r\n    }\r\n\r\n    if (list.todos.some((todo) => todo.status !== 'pending')) {\r\n      list.status = 'active';\r\n      return;\r\n    }\r\n\r\n    list.status = 'pending';\r\n  }\r\n\r\n  private ensureDefaultList(): TodoList {\r\n    const existing = this.todoLists.get(DEFAULT_LIST_ID);\r\n    if (existing) {\r\n      return existing;\r\n    }\r\n\r\n    const now = new Date();\r\n    const list: TodoList = {\r\n      id: DEFAULT_LIST_ID,\r\n      title: DEFAULT_LIST_TITLE,\r\n      description: undefined,\r\n      status: DEFAULT_LIST_STATUS,\r\n      priority: DEFAULT_LIST_PRIORITY,\r\n      todos: [],\r\n      createdAt: now,\r\n      updatedAt: now,\r\n    };\r\n\r\n    this.todoLists.set(DEFAULT_LIST_ID, list);\r\n    return list;\r\n  }\r\n\r\n  private cloneListWithFilter(list: TodoList, completed?: boolean): TodoList {\r\n    const todos =\r\n      completed === undefined\r\n        ? [...list.todos]\r\n        : list.todos.filter((todo) => todo.completed === completed);\r\n\r\n    return {\r\n      ...list,\r\n      todos,\r\n    };\r\n  }\r\n\r\n  private generateListId(): string {\r\n    return `list-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\r\n  }\r\n}\r\n\r\nconst TODO_MANAGER = Symbol.for('@noeducation/ai/TodoManager');\r\n\r\ntype GlobalWithTodoManager = typeof globalThis & {\r\n  [TODO_MANAGER]?: TodoManager;\r\n};\r\n\r\n/**\r\n * Get the singleton TodoManager instance.\r\n * @returns The TodoManager singleton\r\n */\r\nexport const getTodoManager = (): TodoManager => {\r\n  const globalWithTodoManager = globalThis as GlobalWithTodoManager;\r\n  let todoManagerInstance = globalWithTodoManager[TODO_MANAGER];\r\n  if (!todoManagerInstance) {\r\n    todoManagerInstance = new TodoManager();\r\n    globalWithTodoManager[TODO_MANAGER] = todoManagerInstance;\r\n    log((l) => l.debug('TodoManager singleton instance created'));\r\n  }\r\n  return todoManagerInstance;\r\n};\r\n\r\nexport const resetTodoManager = (): void => {\r\n  const globalWithTodoManager = globalThis as GlobalWithTodoManager;\r\n  if (globalWithTodoManager[TODO_MANAGER]) {\r\n    delete globalWithTodoManager[TODO_MANAGER];\r\n    log((l) => l.debug('TodoManager singleton reset'));\r\n  }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\todo\\tool-callback.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":309,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":92,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3251,3254],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3251,3254],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":222,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":222,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8562,8565],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8562,8565],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  AiSearchResultEnvelope,\r\n  HybridSearchOptions,\r\n} from '../services/search';\r\nimport { PolicySearchScopeType, CaseFileSearchScopeType } from './unions';\r\nimport {\r\n  DocumentResource,\r\n  EmailResource,\r\n  AttachmentResource,\r\n  DocumentPropertyResource,\r\n  DocumentResourceIndex,\r\n} from './documentResource';\r\nimport { violationDetails } from '@/drizzle/schema';\r\n\r\n/**\r\n * Options for performing a policy search, extending {@link HybridSearchOptions}.\r\n *\r\n * @remarks\r\n * This type allows specifying additional search parameters, including the scope of the policy search.\r\n *\r\n * @property scope - An optional array of `PolicySearchScopeType` values that define the scope(s) to search within.\r\n *                   If omitted, the search may apply to all available scopes.\r\n */\r\nexport type PolicySearchOptions = HybridSearchOptions & {\r\n  scope?: PolicySearchScopeType[];\r\n};\r\n\r\n/**\r\n * Options for performing a case file search, extending {@link HybridSearchOptions}.\r\n *\r\n * @property {CaseFileSearchScopeType[]} [scope] - Optional array specifying the search scope(s) for case files.\r\n */\r\nexport type CaseFileSearchOptions = HybridSearchOptions & {\r\n  scope?: CaseFileSearchScopeType[];\r\n  emailId?: string; // email_id\r\n  threadId?: string; // thread_id\r\n  attachmentId?: number; // attachment_id\r\n  documentId?: number; // id\r\n  replyToDocumentId?: number; // parent_email_id\r\n  relatedToDocumentId?: number; // relatedEmailIds\r\n};\r\n\r\n/**\r\n * Represents the result of a tool callback operation.\r\n *\r\n * @template T The type of the structured result.\r\n * @property content An array containing a single object with a type of 'text' and the corresponding text content.\r\n * @property structuredContent An object describing the structured result:\r\n * - If successful, contains the result of type `T` and `isError: false`.\r\n * - If an error occurred, contains `result: undefined`, `isError: true`, and an optional error message.\r\n */\r\nexport type ToolCallbackResult<T> = {\r\n  /**\r\n   * An array containing a single object with type 'text' and the text content.\r\n   */\r\n  content: Array<{ type: 'text'; text: string }>;\r\n} & (\r\n  | {\r\n      isError?: true;\r\n      /**\r\n       * An object wrapping the structured return value of the tool callback.\r\n       */\r\n      structuredContent: {\r\n        /**\r\n         * The result of the tool callback operation, always undefined when the operation failed.\r\n         */\r\n        result: {\r\n          /**\r\n           * Indicates whether an error occurred processing the operation - always true in this case.\r\n           */\r\n          isError: true;\r\n          /**\r\n           * An optional error message providing details about the failure.\r\n           */\r\n          message?: string;\r\n          /**\r\n           * An optional cause of the error, which can be any type.\r\n           */\r\n          cause?: unknown;\r\n        };\r\n      };\r\n    }\r\n  | {\r\n      structuredContent: {\r\n        /**\r\n         * The result of the tool callback operation, of array type `T`.\r\n         */\r\n        result: {\r\n          isError: false;\r\n          items?: T extends Array<infer U> ? Array<U> : never;\r\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n          value?: T extends Array<any> ? never : T;\r\n        };\r\n      };\r\n    }\r\n);\r\n\r\nexport type {\r\n  DocumentResource,\r\n  EmailResource,\r\n  AttachmentResource,\r\n  DocumentPropertyResource,\r\n  DocumentResourceIndex,\r\n};\r\n\r\n/**\r\n * Represents the result of an AI search tool operation.\r\n *\r\n * This type is a specialization of `ToolCallbackResult` that wraps an `AiSearchResultEnvelope`,\r\n * encapsulating the outcome and data returned by an AI-powered search tool.\r\n */\r\nexport type AiSearchToolResult = ToolCallbackResult<AiSearchResultEnvelope>;\r\n\r\nexport type DocumentIndexResourceToolResult = ToolCallbackResult<\r\n  Array<DocumentResourceIndex>\r\n>;\r\n\r\n/**\r\n * Represents a case file amendment request containing various compliance and rating updates.\r\n *\r\n * @property targetCaseFileId - The identifier of the case file to be amended (number or string)\r\n * @property severityRating - Optional numeric severity rating for the case\r\n * @property severityReasons - Optional array of reasons explaining the severity rating\r\n * @property notes - Optional array of additional notes or comments\r\n * @property complianceRating - Optional numeric compliance rating\r\n * @property complianceReasons - Optional array of reasons explaining the compliance rating\r\n * @property completionRating - Optional numeric completion rating\r\n * @property completionReasons - Optional array of reasons explaining the completion rating\r\n * @property addRelatedDocuments - Optional array of documents to link to this case file\r\n * @property associateResponsiveAction - Optional array of responsive actions to associate\r\n * @property violations - Optional array of violation details to add to the case file\r\n * @property sentimentRating - Optional numeric sentiment rating\r\n * @property sentimentReasons - Optional array of reasons explaining the sentiment rating\r\n * @property chapter13Rating - Optional numeric Chapter 13 compliance rating\r\n * @property chapter13Reasons - Optional array of reasons for Chapter 13 rating\r\n * @property titleIXRating - Optional numeric Title IX compliance rating\r\n * @property titleIXReasons - Optional array of reasons for Title IX rating\r\n * @property explanation - Required explanation of all changes and rationale\r\n */\r\nexport type CaseFileAmendment = {\r\n  targetCaseFileId: number | string;\r\n  severityRating?: number;\r\n  severityReasons?: Array<string>;\r\n  notes?: Array<string>;\r\n  complianceRating?: number;\r\n  complianceReasons?: Array<string>;\r\n  completionRating?: number;\r\n  completionReasons?: Array<string>;\r\n  addRelatedDocuments?: Array<{\r\n    relatedToDocumentId: number;\r\n    relationshipType: string;\r\n  }>;\r\n  associateResponsiveAction?: Array<ResponsiveActionAssociation>;\r\n  violations?: Array<typeof violationDetails.$inferInsert>;\r\n\r\n  sentimentRating?: number;\r\n  sentimentReasons?: Array<string>;\r\n  chapter13Rating?: number;\r\n  chapter13Reasons?: Array<string>;\r\n  titleIXRating?: number;\r\n  titleIXReasons?: Array<string>;\r\n  explanation: string;\r\n};\r\n\r\n/**\r\n * Represents a single amendment with an identifier and changes to apply.\r\n *\r\n * @property id - Unique identifier for the amendment (number or string)\r\n * @property changes - Partial case file amendment changes to apply\r\n */\r\nexport type Amendment = {\r\n  id: number | string;\r\n  changes: Partial<CaseFileAmendment>;\r\n};\r\n\r\n/**\r\n * Represents the result of a batch amendment operation.\r\n *\r\n * @property message - Human-readable message describing the operation outcome\r\n * @property UpdatedRecords - Array of successfully updated amendment records\r\n * @property InsertedRecords - Array of successfully inserted new amendment records\r\n * @property FailedRecords - Array of amendment records that failed to process, including error details\r\n */\r\nexport type AmendmentResult = {\r\n  message: string;\r\n  UpdatedRecords: Array<Amendment>;\r\n  InsertedRecords: Array<Amendment>;\r\n  FailedRecords: Array<\r\n    Amendment & {\r\n      error: string;\r\n    }\r\n  >;\r\n};\r\n\r\n/**\r\n * Represents an association between a responsive action and a call-to-action document.\r\n *\r\n * @property relatedCtaDocumentId - The identifier of the related call-to-action document\r\n * @property complianceChapter13 - Numeric rating for Chapter 13 compliance\r\n * @property complianceChapter13Reasons - Array of reasons explaining the Chapter 13 compliance rating\r\n * @property completionPercentage - Percentage of completion for the responsive action\r\n * @property completionReasons - Array of reasons explaining the completion status\r\n */\r\nexport type ResponsiveActionAssociation = {\r\n  relatedCtaDocumentId: number;\r\n  complianceChapter13: number;\r\n  complianceChapter13Reasons: Array<string>;\r\n  completionPercentage: number;\r\n  completionReasons: Array<string>;\r\n};\r\n\r\n/**\r\n * Represents the properties for a case file request.\r\n *\r\n * @property caseFileId - The case file identifier (can be any type, typically number or string)\r\n * @property goals - Optional array of goals or objectives for the case file analysis\r\n * @property verbatim_fidelity - Optional numeric value indicating the level of verbatim fidelity required (0-100)\r\n * @property max_response_tokens - maximum number of response tokens to return.  If not set, default of 1000 is used.\r\n */\r\nexport type CaseFileRequestProps = {\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  caseFileId?: any;\r\n  goals?: Array<string>;\r\n  verbatimFidelity?: number;\r\n  max_response_tokens?: number;\r\n};\r\n\r\n/**\r\n * Represents validated case file request properties with guaranteed numeric caseFileId.\r\n *\r\n * @remarks\r\n * This type ensures that the caseFileId has been validated and converted to a number,\r\n * removing the ambiguity of the original CaseFileRequestProps type.\r\n *\r\n * @property caseFileId - The validated numeric case file identifier\r\n * @property goals - Optional array of goals or objectives for the case file analysis\r\n * @property verbatim_fidelity - Optional numeric value indicating the level of verbatim fidelity required (0-100)\r\n */\r\nexport type ValidCaseFileRequestProps = Omit<\r\n  CaseFileRequestProps,\r\n  'caseFileId'\r\n> & {\r\n  caseFileId: number; // Ensure caseFileId is always a number\r\n};\r\n\r\n/**\r\n * Represents a summarized document resource with extracted compliance information.\r\n *\r\n * @remarks\r\n * This type contains processed and analyzed document information, including extracted passages,\r\n * compliance tags, policy references, and scoring data. It's typically the result of AI-powered\r\n * document analysis and summarization processes.\r\n *\r\n * @property documentId - Unique identifier for the document\r\n * @property documentType - Type classification of the document (e.g., email, attachment, note)\r\n * @property createdOn - ISO timestamp string of when the document was created\r\n * @property sender - Name and contact information of the document sender/creator\r\n * @property relatedDocuments - Array of related documents with metadata\r\n * @property policyReferences - Array of relevant policy, statute, or regulation references\r\n * @property complianceTags - Array of compliance-related classification tags\r\n * @property extractedPassages - Array of key passages extracted from the document with analysis\r\n * @property omissionsOrGaps - Array of identified missing information or compliance gaps\r\n */\r\nexport type SummarizedDocumentResource = {\r\n  documentId: string;\r\n  documentType: string;\r\n  createdOn: string;\r\n  sender: string;\r\n  relatedDocuments: Array<{\r\n    documentId: string;\r\n    relationshipType: string;\r\n    documentType: string;\r\n    excerpt: string;\r\n  }>;\r\n  policyReferences: Array<string>;\r\n  complianceTags: Array<string>;\r\n  extractedPassages: Array<{\r\n    text: string;\r\n    goal: string;\r\n    location: string;\r\n    complianceTags: Array<string>;\r\n    scores: Array<{\r\n      type: string;\r\n      value: number;\r\n      rationale: string;\r\n      appliesTo: string;\r\n    }>;\r\n  }>;\r\n  omissionsOrGaps: Array<string>;\r\n};\r\n\r\n/**\r\n * Represents a case file response containing both raw and summarized document data.\r\n *\r\n * @remarks\r\n * This type allows for flexible responses where either the full document resource,\r\n * a summarized version, both, or neither may be present depending on the request\r\n * parameters and processing results.\r\n *\r\n * @property case_file - Optional full document resource containing all raw document data\r\n * @property summary - Optional summarized document resource with extracted and analyzed content\r\n * @property text - Optional raw text content of the document, if structured output is not available\r\n */\r\nexport type CaseFileResponse = {\r\n  case_file?: DocumentResource | null;\r\n  summary?: SummarizedDocumentResource | null;\r\n  text?: string;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\unions.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":10,"column":1,"nodeType":"Program","endLine":55,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * An array of valid policy search scope types.\r\n *\r\n * - `'school-district'`: Represents a school district level scope.\r\n * - `'state'`: Represents a state level scope.\r\n * - `'federal'`: Represents a federal level scope.\r\n *\r\n * This constant can be used to validate or restrict policy search operations to these predefined scopes.\r\n */\r\nexport const PolicySearchScopeTypeValues = [\r\n  'school-district',\r\n  'state',\r\n  'federal',\r\n] as const;\r\n\r\n/**\r\n * An array of string literals representing the possible search scope types for a case file.\r\n *\r\n * The available values are:\r\n * - `'email'`: Represents email messages associated with the case file.\r\n * - `'attachment'`: Represents file attachments related to the case file.\r\n * - `'core-document'`: An alias for `'email'` and `'attachment'`.\r\n * - `'key-point'`: Represents key points extracted from the case file.\r\n * - `'call-to-action'`: Represents actionable items identified in the case file.\r\n * - `'responsive-action'`: Represents actions that are responsive to one or more call-to-actions.\r\n * This constant is used to restrict and validate the allowed search scope types within the application.\r\n */\r\nexport const CaseFileSearchScopeTypeValues = [\r\n  'core-document',\r\n  'email',\r\n  'attachment',\r\n  'key-point',\r\n  'call-to-action',\r\n  'responsive-action',\r\n  'note',\r\n] as const;\r\n\r\n/**\r\n * Represents the possible values for the policy search scope.\r\n * This type is derived from the elements of the `PolicySearchScopeTypeValues` array.\r\n *\r\n * @see PolicySearchScopeTypeValues\r\n */\r\nexport type PolicySearchScopeType =\r\n  (typeof PolicySearchScopeTypeValues)[number];\r\n\r\n/**\r\n * Represents the possible values for the case file search scope type.\r\n * The type is derived from the elements of the `CaseFileSearchScopeTypeValues` array.\r\n *\r\n * @see CaseFileSearchScopeTypeValues\r\n */\r\nexport type CaseFileSearchScopeType =\r\n  (typeof CaseFileSearchScopeTypeValues)[number];\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\tools\\utility.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":266,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":49,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1518,1521],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1518,1521],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import z, { ZodRawShape } from 'zod';\r\nimport {\r\n  CaseFileRequestProps,\r\n  ToolCallbackResult,\r\n  ValidCaseFileRequestProps,\r\n} from './types';\r\nimport { isError } from '@/lib/react-util/utility-methods';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { drizDb, drizDbWithInit } from '@/lib/drizzle-db';\r\n\r\ninterface ToolCallbackResultOverloads {\r\n  <T>(result: T): ToolCallbackResult<T>;\r\n  <T>(error: Error, message?: string): ToolCallbackResult<T>;\r\n}\r\n\r\nexport const toolCallbackResultFactory: ToolCallbackResultOverloads = <T>(\r\n  result: T | Error,\r\n  message?: string,\r\n): ToolCallbackResult<T> => {\r\n  if (isError(result)) {\r\n    return {\r\n      content: [{ type: 'text', text: message ?? result.message }],\r\n      structuredContent: {\r\n        result: {\r\n          isError: true,\r\n          message: message ?? result.message,\r\n          cause: result.cause,\r\n        },\r\n      },\r\n      isError: true,\r\n    };\r\n  }\r\n  return Array.isArray(result)\r\n    ? {\r\n        content: [{ type: 'text', text: 'tool success' }],\r\n        structuredContent: {\r\n          result: {\r\n            isError: false,\r\n            items: result as T extends Array<infer U> ? Array<U> : never,\r\n          },\r\n        },\r\n      }\r\n    : {\r\n        content: [{ type: 'text', text: 'tool success' }],\r\n        structuredContent: {\r\n          result: {\r\n            isError: false,\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            value: result as T extends Array<any> ? never : T,\r\n          },\r\n        },\r\n      };\r\n};\r\n\r\nexport const toolCallbackResultSchemaFactory = <T extends ZodRawShape>(\r\n  resultSchema:\r\n    | z.ZodObject<T>\r\n    | z.ZodString\r\n    | z.ZodUnion<[z.ZodString, z.ZodObject<T>]>,\r\n) => {\r\n  const error = z.object({\r\n    isError: z.literal(true),\r\n    message: z.string().optional(),\r\n    cause: z.any().optional(),\r\n  });\r\n\r\n  const success = z.object({\r\n    isError: z.literal(false).optional(),\r\n    value: resultSchema.optional(),\r\n  });\r\n\r\n  const result = z.discriminatedUnion('isError', [error, success]);\r\n\r\n  return {\r\n    result: result,\r\n    //.describe('The returned value.')\r\n  };\r\n};\r\nexport const toolCallbackArrayResultSchemaFactory = <T extends ZodRawShape>(\r\n  resultSchema:\r\n    | z.ZodObject<T>\r\n    | z.ZodString\r\n    | z.ZodUnion<[z.ZodString, z.ZodObject<T>]>,\r\n) => {\r\n  const error = z.object({\r\n    isError: z.literal(true),\r\n    message: z.string().optional(),\r\n    cause: z.any().optional(),\r\n  });\r\n\r\n  const success = z.object({\r\n    isError: z.literal(false).optional(),\r\n    items: z.array(resultSchema).optional(),\r\n  });\r\n\r\n  const result = z.discriminatedUnion('isError', [error, success]);\r\n\r\n  return {\r\n    result,\r\n  };\r\n};\r\n\r\n/**\r\n * Checks if the provided string is a valid version 4 UUID.\r\n *\r\n * A valid UUID v4 is in the format: xxxxxxxx-xxxx-4xxx-[8|9|A|B]xxx-xxxxxxxxxxxx,\r\n * where 'x' is a hexadecimal digit.\r\n *\r\n * @param id - The string to validate as a UUID v4.\r\n * @returns `true` if the string is a valid UUID v4, otherwise `false`.\r\n */\r\nexport const isValidUuid = (id: string): boolean =>\r\n  /[0-9a-z]{8}-[0-9a-z]{4}-4[0-9a-z]{3}-[89ABab][0-9a-z]{3}-[0-9a-z]{12}/i.test(\r\n    id,\r\n  );\r\n\r\n/**\r\n * Resolves a case file's unit ID from a given document identifier.\r\n *\r\n * The function attempts to parse the provided `documentId` as a number.\r\n * If the `documentId` is a string that does not represent a number (e.g., a GUID or other non-numeric string),\r\n * it queries the database to find a matching document unit by `emailId` (with `documentType` 'email')\r\n * or by `documentPropertyId`. If a match is found, the corresponding `unitId` is returned.\r\n *\r\n * @param documentId - The identifier of the document, which can be a number or a string.\r\n * @returns A promise that resolves to the unit ID as a number, or `undefined` if not found.\r\n */\r\nexport const resolveCaseFileId = async (\r\n  documentId: number | string,\r\n): Promise<number | undefined> => {\r\n  let parsedId: number | undefined;\r\n  if (typeof documentId === 'string') {\r\n    const isUuid = isValidUuid(documentId);\r\n    if (isUuid) {\r\n      parsedId = await drizDb()\r\n        .query.documentUnits.findFirst({\r\n          where: (du, { eq, and, or }) =>\r\n            or(\r\n              and(eq(du.emailId, documentId), eq(du.documentType, 'email')),\r\n              eq(du.documentPropertyId, documentId),\r\n            ),\r\n          columns: {\r\n            unitId: true,\r\n          },\r\n        })\r\n        .then((result) => result?.unitId)\r\n        .catch((err) => {\r\n          LoggedError.isTurtlesAllTheWayDownBaby(err, {\r\n            log: true,\r\n            source: 'resolveCaseFileId',\r\n            message:\r\n              'Error querying for case file ID - validate document ID format',\r\n            include: { documentId },\r\n          });\r\n          return undefined;\r\n        });\r\n    } else {\r\n      parsedId = parseInt(documentId, 10);\r\n      if (isNaN(parsedId)) {\r\n        parsedId = undefined;\r\n      }\r\n    }\r\n  } else if (typeof documentId === 'number') {\r\n    parsedId = documentId;\r\n  } else {\r\n    parsedId = undefined;\r\n  }\r\n  return parsedId;\r\n};\r\n\r\n/**\r\n * Resolves a batch of case file identifiers to their corresponding numeric IDs.\r\n *\r\n * This function processes an array of requests, each containing a `caseFileId` that may be:\r\n * - A number (already resolved)\r\n * - A string representing a UUID (pending resolution)\r\n * - A string that can be parsed as a number (resolved)\r\n * - An invalid value (ignored)\r\n *\r\n * For UUIDs, the function queries the database to find matching records and resolves them to their numeric IDs.\r\n * Returns an array of objects, each with a resolved numeric `caseFileId`.\r\n *\r\n * @param requests - An array of objects containing a `caseFileId` property, which may be a number or string.\r\n * @returns A promise that resolves to an array of objects with a numeric `caseFileId`.\r\n */\r\nexport const resolveCaseFileIdBatch = async (\r\n  requests: Array<CaseFileRequestProps>,\r\n): Promise<Array<ValidCaseFileRequestProps>> => {\r\n  // First, split up into valid and pending sets, dropping anything so invalid we wont even try\r\n  const { valid, pending } = requests.reduce(\r\n    (acc, request) => {\r\n      // If input is a number then it is valid\r\n      if (typeof request.caseFileId === 'number') {\r\n        acc.valid.push({ caseFileId: request.caseFileId });\r\n        return acc;\r\n      }\r\n      // If input is a string, check if it's a UUID or numeric string\r\n      if (typeof request.caseFileId === 'string') {\r\n        // First check if it's a valid UUID\r\n        if (isValidUuid(request.caseFileId)) {\r\n          acc.pending.push(request);\r\n          return acc;\r\n        }\r\n\r\n        // Then check if it's a valid numeric string\r\n        const check = request.caseFileId.trim();\r\n        if (/^-?\\d+$/.test(check)) {\r\n          const parsedId = parseInt(request.caseFileId, 10);\r\n          if (!isNaN(parsedId)) {\r\n            acc.valid.push({\r\n              ...request,\r\n              caseFileId: parsedId,\r\n            });\r\n          }\r\n        }\r\n        return acc;\r\n      }\r\n      // All other values are so hosed we just drop them\r\n      return acc;\r\n    },\r\n    {\r\n      valid: [] as Array<ValidCaseFileRequestProps>,\r\n      pending: [] as Array<CaseFileRequestProps>,\r\n    },\r\n  );\r\n  // Now lets try and look up these GUIDs\r\n  const guids = pending.map((r) => r.caseFileId as string);\r\n  if (!guids.length) {\r\n    return valid;\r\n  }\r\n  const records = await drizDbWithInit((db) => {\r\n    return db.query.documentUnits.findMany({\r\n      where: (du, { and, or, eq, inArray }) =>\r\n        or(\r\n          and(inArray(du.emailId, guids), eq(du.documentType, 'email')),\r\n          inArray(du.documentPropertyId, guids),\r\n        ),\r\n      columns: {\r\n        unitId: true,\r\n        documentPropertyId: true,\r\n        emailId: true,\r\n      },\r\n    });\r\n  });\r\n  // Now use records to translate pending into valid\r\n  const { resolved } = pending.reduce(\r\n    (acc, request) => {\r\n      const record = records.find(\r\n        (r) =>\r\n          r.documentPropertyId === request.caseFileId ||\r\n          r.emailId === request.caseFileId,\r\n      );\r\n      if (record) {\r\n        request.caseFileId = record.unitId;\r\n        acc.resolved.push({\r\n          ...request,\r\n          caseFileId: record.unitId,\r\n        });\r\n      }\r\n      return acc;\r\n    },\r\n    { resolved: valid },\r\n  );\r\n  return resolved;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\types\\message-structure-preservation.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":11,"column":1,"nodeType":"Program","endLine":310,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Strongly-typed interface for message structure preservation\r\n *\r\n * This module defines a type-safe alternative to the '__preserveStructure' magic property,\r\n * providing compile-time type checking and better developer experience for message\r\n * structure preservation logic.\r\n *\r\n * @module lib/ai/types/message-structure-preservation\r\n */\r\n\r\nimport type { UIMessage, UIMessagePart, UIDataTypes, UITools } from 'ai';\r\n\r\n/**\r\n * Preservation strategy types for different use cases\r\n */\r\nexport type PreservationStrategy =\r\n  | 'full' // Preserve complete message structure including metadata\r\n  | 'content-only' // Preserve only text content, strip metadata\r\n  | 'semantic' // Preserve semantic meaning while allowing format changes\r\n  | 'minimal' // Preserve only essential fields for functionality\r\n  | 'custom'; // Use custom preservation rules\r\n\r\n/**\r\n * Configuration for preserving message parts based on type\r\n */\r\nexport interface MessagePartPreservationRules {\r\n  /** Whether to preserve text parts */\r\n  text?: boolean;\r\n  /** Whether to preserve tool call parts */\r\n  toolCall?: boolean;\r\n  /** Whether to preserve tool result parts */\r\n  toolResult?: boolean;\r\n  /** Whether to preserve file attachment parts */\r\n  file?: boolean;\r\n  /** Whether to preserve image parts */\r\n  image?: boolean;\r\n  /** Whether to preserve custom/dynamic parts */\r\n  dynamic?: boolean;\r\n}\r\n\r\n/**\r\n * Metadata preservation configuration\r\n */\r\nexport interface MetadataPreservationOptions {\r\n  /** Preserve timestamps */\r\n  timestamps?: boolean;\r\n  /** Preserve user identifiers */\r\n  userIds?: boolean;\r\n  /** Preserve message IDs */\r\n  messageIds?: boolean;\r\n  /** Preserve tool execution metadata */\r\n  toolMetadata?: boolean;\r\n  /** Preserve custom metadata fields */\r\n  customFields?: string[];\r\n}\r\n\r\n/**\r\n * Content transformation options for preserved messages\r\n */\r\nexport interface ContentTransformationOptions {\r\n  /** Maximum length for preserved content */\r\n  maxContentLength?: number;\r\n  /** Whether to truncate long content */\r\n  truncateContent?: boolean;\r\n  /** Truncation suffix (e.g., \"...\") */\r\n  truncationSuffix?: string;\r\n  /** Whether to summarize long content instead of truncating */\r\n  summarizeContent?: boolean;\r\n  /** Custom content transformer function */\r\n  contentTransformer?: (content: string) => string;\r\n}\r\n\r\n/**\r\n * Tool-specific preservation rules\r\n */\r\nexport interface ToolPreservationRules {\r\n  /** Tools to always preserve */\r\n  alwaysPreserve?: string[];\r\n  /** Tools to never preserve */\r\n  neverPreserve?: string[];\r\n  /** Custom preservation logic for specific tools */\r\n  customRules?: Record<\r\n    string,\r\n    (part: UIMessagePart<UIDataTypes, UITools>) => boolean\r\n  >;\r\n}\r\n\r\n/**\r\n * Context-aware preservation options\r\n */\r\nexport interface ContextualPreservationOptions {\r\n  /** Preserve messages within this many recent interactions */\r\n  recentInteractionCount?: number;\r\n  /** Preserve messages containing these keywords */\r\n  preserveKeywords?: string[];\r\n  /** Preserve messages matching these patterns */\r\n  preservePatterns?: RegExp[];\r\n  /** Custom context evaluation function */\r\n  contextEvaluator?: (\r\n    message: UIMessage,\r\n    index: number,\r\n    messages: UIMessage[],\r\n  ) => boolean;\r\n}\r\n\r\n/**\r\n * Performance optimization options\r\n */\r\nexport interface PerformanceOptions {\r\n  /** Enable caching of preservation decisions */\r\n  enableCaching?: boolean;\r\n  /** Cache TTL in milliseconds */\r\n  cacheTtlMs?: number;\r\n  /** Maximum number of items to cache */\r\n  maxCacheSize?: number;\r\n  /** Enable async processing for large message sets */\r\n  enableAsyncProcessing?: boolean;\r\n}\r\n\r\n/**\r\n * Main interface for message structure preservation configuration\r\n *\r\n * This interface replaces the '__preserveStructure' magic property with\r\n * a strongly-typed, comprehensive configuration system.\r\n *\r\n * @example\r\n * ```typescript\r\n * const preservationConfig: MessageStructureOptions = {\r\n *   strategy: 'semantic',\r\n *   partRules: {\r\n *     text: true,\r\n *     toolCall: true,\r\n *     toolResult: false\r\n *   },\r\n *   metadata: {\r\n *     timestamps: true,\r\n *     messageIds: true\r\n *   },\r\n *   performance: {\r\n *     enableCaching: true,\r\n *     cacheTtlMs: 300000\r\n *   }\r\n * };\r\n * ```\r\n */\r\nexport interface MessageStructureOptions {\r\n  /** Whether preservation is enabled */\r\n  enabled?: boolean;\r\n\r\n  /** Overall preservation strategy */\r\n  strategy?: PreservationStrategy;\r\n\r\n  /** Rules for preserving different message part types */\r\n  partRules?: MessagePartPreservationRules;\r\n\r\n  /** Metadata preservation configuration */\r\n  metadata?: MetadataPreservationOptions;\r\n\r\n  /** Content transformation options */\r\n  contentTransformation?: ContentTransformationOptions;\r\n\r\n  /** Tool-specific preservation rules */\r\n  toolRules?: ToolPreservationRules;\r\n\r\n  /** Context-aware preservation options */\r\n  contextual?: ContextualPreservationOptions;\r\n\r\n  /** Performance optimization settings */\r\n  performance?: PerformanceOptions;\r\n\r\n  /** Custom validation function for preserved messages */\r\n  validator?: (preservedMessage: UIMessage) => boolean;\r\n\r\n  /** Debug mode for logging preservation decisions */\r\n  debug?: boolean;\r\n}\r\n\r\n/**\r\n * Result of message structure preservation operation\r\n */\r\nexport interface MessagePreservationResult {\r\n  /** Successfully preserved messages */\r\n  preserved: UIMessage[];\r\n\r\n  /** Messages that were filtered out */\r\n  filtered: UIMessage[];\r\n\r\n  /** Preservation statistics */\r\n  stats: {\r\n    originalCount: number;\r\n    preservedCount: number;\r\n    filteredCount: number;\r\n    processingTimeMs: number;\r\n    cacheHits?: number;\r\n    cacheMisses?: number;\r\n  };\r\n\r\n  /** Any warnings or issues during preservation */\r\n  warnings?: string[];\r\n\r\n  /** Debug information (if debug mode enabled) */\r\n  debugInfo?: {\r\n    decisions: Array<{\r\n      messageId: string;\r\n      preserved: boolean;\r\n      reason: string;\r\n      strategy: PreservationStrategy;\r\n    }>;\r\n  };\r\n}\r\n\r\n/**\r\n * Type guard to check if an object has message structure options\r\n */\r\nexport function hasMessageStructureOptions(\r\n  obj: unknown,\r\n): obj is { messageStructure: MessageStructureOptions } {\r\n  return (\r\n    typeof obj === 'object' &&\r\n    obj !== null &&\r\n    'messageStructure' in obj &&\r\n    typeof obj.messageStructure === 'object'\r\n  );\r\n}\r\n\r\n/**\r\n * Type guard to check if preservation is enabled in options\r\n */\r\nexport function isPreservationEnabled(\r\n  options: MessageStructureOptions,\r\n): boolean {\r\n  return options.enabled !== false; // Default to true if not explicitly disabled\r\n}\r\n\r\n/**\r\n * Default preservation configuration\r\n */\r\nexport const DEFAULT_MESSAGE_STRUCTURE_OPTIONS: MessageStructureOptions = {\r\n  enabled: true,\r\n  strategy: 'semantic',\r\n  partRules: {\r\n    text: true,\r\n    toolCall: true,\r\n    toolResult: true,\r\n    file: true,\r\n    image: true,\r\n    dynamic: false,\r\n  },\r\n  metadata: {\r\n    timestamps: true,\r\n    userIds: true,\r\n    messageIds: true,\r\n    toolMetadata: true,\r\n    customFields: [],\r\n  },\r\n  contentTransformation: {\r\n    maxContentLength: 2000,\r\n    truncateContent: true,\r\n    truncationSuffix: '...',\r\n    summarizeContent: false,\r\n  },\r\n  contextual: {\r\n    recentInteractionCount: 5,\r\n  },\r\n  performance: {\r\n    enableCaching: true,\r\n    cacheTtlMs: 300000, // 5 minutes\r\n    maxCacheSize: 1000,\r\n    enableAsyncProcessing: false,\r\n  },\r\n  debug: false,\r\n} as const;\r\n\r\n/**\r\n * Utility type to create partial preservation options with type checking\r\n */\r\nexport type PartialMessageStructureOptions = Partial<MessageStructureOptions>;\r\n\r\n/**\r\n * Factory function to create preservation options with defaults\r\n */\r\nexport function createMessageStructureOptions(\r\n  options: PartialMessageStructureOptions = {},\r\n): MessageStructureOptions {\r\n  return {\r\n    ...DEFAULT_MESSAGE_STRUCTURE_OPTIONS,\r\n    ...options,\r\n    partRules: {\r\n      ...DEFAULT_MESSAGE_STRUCTURE_OPTIONS.partRules,\r\n      ...options.partRules,\r\n    },\r\n    metadata: {\r\n      ...DEFAULT_MESSAGE_STRUCTURE_OPTIONS.metadata,\r\n      ...options.metadata,\r\n    },\r\n    contentTransformation: {\r\n      ...DEFAULT_MESSAGE_STRUCTURE_OPTIONS.contentTransformation,\r\n      ...options.contentTransformation,\r\n    },\r\n    contextual: {\r\n      ...DEFAULT_MESSAGE_STRUCTURE_OPTIONS.contextual,\r\n      ...options.contextual,\r\n    },\r\n    performance: {\r\n      ...DEFAULT_MESSAGE_STRUCTURE_OPTIONS.performance,\r\n      ...options.performance,\r\n    },\r\n  };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\ai\\utils\\message-structure-preservation.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":12,"column":1,"nodeType":"Program","endLine":558,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Utility functions for message structure preservation\r\n const shouldPreservePart = (\r\n  part: UIMessagePart<UIDataTypes, UITools>,\r\n  rules: MessagePartPreservationRules\r\n): boolean => { This module provides utility functions for working with the MessageStructureOptions\r\n * interface, including message filtering, preservation logic, and performance optimizations.\r\n *\r\n * @module lib/ai/utils/message-structure-preservation\r\n */\r\n\r\nimport type { UIMessage, UIMessagePart, UIDataTypes, UITools } from 'ai';\r\nimport type {\r\n  MessageStructureOptions,\r\n  MessagePreservationResult,\r\n  PreservationStrategy,\r\n  MessagePartPreservationRules,\r\n} from '@/lib/ai/types/message-structure-preservation';\r\nimport {\r\n  createMessageStructureOptions,\r\n  isPreservationEnabled,\r\n} from '@/lib/ai/types/message-structure-preservation';\r\nimport { log } from '@/lib/logger';\r\n\r\n/**\r\n * Cache for preservation decisions to improve performance\r\n */\r\nconst preservationCache = new Map<string, boolean>();\r\nconst cacheStats = {\r\n  hits: 0,\r\n  misses: 0,\r\n  created: Date.now(),\r\n};\r\n\r\n/**\r\n * Generate a cache key for a message preservation decision\r\n */\r\nconst generateCacheKey = (\r\n  message: UIMessage,\r\n  options: MessageStructureOptions,\r\n): string => {\r\n  const messageHash = JSON.stringify({\r\n    id: message.id,\r\n    role: message.role,\r\n    partsLength: message.parts.length,\r\n    strategy: options.strategy,\r\n  });\r\n  return `preserve_${Buffer.from(messageHash).toString('base64').slice(0, 16)}`;\r\n};\r\n\r\n/**\r\n * Clear the preservation cache\r\n */\r\nexport function clearPreservationCache(): void {\r\n  preservationCache.clear();\r\n  cacheStats.hits = 0;\r\n  cacheStats.misses = 0;\r\n  cacheStats.created = Date.now();\r\n}\r\n\r\n/**\r\n * Get cache statistics\r\n */\r\nexport function getPreservationCacheStats() {\r\n  const total = cacheStats.hits + cacheStats.misses;\r\n  return {\r\n    size: preservationCache.size,\r\n    hits: cacheStats.hits,\r\n    misses: cacheStats.misses,\r\n    hitRate: total > 0 ? cacheStats.hits / total : 0,\r\n    ageMs: Date.now() - cacheStats.created,\r\n  };\r\n}\r\n\r\n/**\r\n * Evaluate whether a message part should be preserved based on rules\r\n */\r\nfunction shouldPreservePart(\r\n  part: UIMessagePart<UIDataTypes, UITools>,\r\n  rules: MessagePartPreservationRules,\r\n): boolean {\r\n  switch (part.type) {\r\n    case 'text':\r\n      return rules.text ?? true;\r\n    case 'tool-call':\r\n      return rules.toolCall ?? true;\r\n    case 'tool-result':\r\n      return rules.toolResult ?? true;\r\n    case 'file':\r\n      return rules.file ?? true;\r\n    default:\r\n      // Handle dynamic/unknown parts including image and others\r\n      return rules.dynamic ?? false;\r\n  }\r\n}\r\n\r\n/**\r\n * Apply content transformation to a message part\r\n */\r\nfunction transformMessageContent(\r\n  part: UIMessagePart<UIDataTypes, UITools>,\r\n  options: MessageStructureOptions,\r\n): UIMessagePart<UIDataTypes, UITools> {\r\n  const transformation = options.contentTransformation;\r\n\r\n  if (!transformation || part.type !== 'text') {\r\n    return part;\r\n  }\r\n\r\n  const textPart = part as { type: 'text'; text: string };\r\n  let content = textPart.text;\r\n\r\n  // Apply custom transformer first\r\n  if (transformation.contentTransformer) {\r\n    content = transformation.contentTransformer(content);\r\n  }\r\n\r\n  // Apply length limits\r\n  if (\r\n    transformation.maxContentLength &&\r\n    content.length > transformation.maxContentLength\r\n  ) {\r\n    if (transformation.summarizeContent) {\r\n      // In a real implementation, you might call a summarization service here\r\n      content =\r\n        content.substring(0, transformation.maxContentLength / 2) +\r\n        (transformation.truncationSuffix || '...');\r\n    } else if (transformation.truncateContent) {\r\n      content =\r\n        content.substring(0, transformation.maxContentLength) +\r\n        (transformation.truncationSuffix || '...');\r\n    }\r\n  }\r\n\r\n  return {\r\n    ...part,\r\n    text: content,\r\n  } as UIMessagePart<UIDataTypes, UITools>;\r\n}\r\n\r\n/**\r\n * Check if a message should be preserved based on contextual rules\r\n */\r\nfunction evaluateContextualPreservation(\r\n  message: UIMessage,\r\n  index: number,\r\n  messages: UIMessage[],\r\n  options: MessageStructureOptions,\r\n): { preserve: boolean; reason: string } {\r\n  const contextual = options.contextual;\r\n\r\n  if (!contextual) {\r\n    return { preserve: true, reason: 'No contextual rules' };\r\n  }\r\n\r\n  // Apply custom context evaluator first (highest priority)\r\n  if (contextual.contextEvaluator) {\r\n    const shouldPreserve = contextual.contextEvaluator(\r\n      message,\r\n      index,\r\n      messages,\r\n    );\r\n    return {\r\n      preserve: shouldPreserve,\r\n      reason: shouldPreserve\r\n        ? 'Custom evaluator: preserve'\r\n        : 'Custom evaluator: filter',\r\n    };\r\n  }\r\n\r\n  // Check recent interaction count\r\n  if (\r\n    contextual.recentInteractionCount &&\r\n    index >= messages.length - contextual.recentInteractionCount\r\n  ) {\r\n    return { preserve: true, reason: 'Within recent interaction count' };\r\n  }\r\n\r\n  // Check for preserve keywords\r\n  if (contextual.preserveKeywords?.length) {\r\n    const hasKeyword = message.parts.some((part) => {\r\n      if (part.type === 'text') {\r\n        const textPart = part as { type: 'text'; text: string };\r\n        return contextual.preserveKeywords!.some((keyword) =>\r\n          textPart.text.toLowerCase().includes(keyword.toLowerCase()),\r\n        );\r\n      }\r\n      return false;\r\n    });\r\n\r\n    if (hasKeyword) {\r\n      return { preserve: true, reason: 'Contains preserve keyword' };\r\n    }\r\n  }\r\n\r\n  // Check for preserve patterns\r\n  if (contextual.preservePatterns?.length) {\r\n    const matchesPattern = message.parts.some((part) => {\r\n      if (part.type === 'text') {\r\n        const textPart = part as { type: 'text'; text: string };\r\n        return contextual.preservePatterns!.some((pattern) =>\r\n          pattern.test(textPart.text),\r\n        );\r\n      }\r\n      return false;\r\n    });\r\n\r\n    if (matchesPattern) {\r\n      return { preserve: true, reason: 'Matches preserve pattern' };\r\n    }\r\n  }\r\n\r\n  return {\r\n    preserve: false,\r\n    reason: 'No contextual preservation rules matched',\r\n  };\r\n}\r\n\r\n/**\r\n * Evaluate whether a message should be preserved based on all rules\r\n */\r\nfunction evaluateMessagePreservation(\r\n  message: UIMessage,\r\n  index: number,\r\n  messages: UIMessage[],\r\n  options: MessageStructureOptions,\r\n): { preserve: boolean; reason: string; strategy: PreservationStrategy } {\r\n  const strategy = options.strategy || 'semantic';\r\n\r\n  // Check cache first\r\n  const cacheKey = generateCacheKey(message, options);\r\n  if (options.performance?.enableCaching) {\r\n    const cached = preservationCache.get(cacheKey);\r\n    if (cached !== undefined) {\r\n      cacheStats.hits++;\r\n      return {\r\n        preserve: cached,\r\n        reason: 'Cached decision',\r\n        strategy,\r\n      };\r\n    }\r\n    cacheStats.misses++;\r\n  }\r\n\r\n  let preserve = true;\r\n  let reason = 'Default preserve';\r\n\r\n  // Strategy-based evaluation\r\n  switch (strategy) {\r\n    case 'full':\r\n      preserve = true;\r\n      reason = 'Full preservation strategy';\r\n      break;\r\n\r\n    case 'minimal':\r\n      // Only preserve if it has essential content\r\n      preserve = message.parts.some(\r\n        (part) => part.type === 'text' || part.type === 'tool-call',\r\n      );\r\n      reason = preserve ? 'Has essential content' : 'No essential content';\r\n      break;\r\n\r\n    case 'content-only':\r\n      // Preserve if it has text content\r\n      preserve = message.parts.some((part) => part.type === 'text');\r\n      reason = preserve ? 'Has text content' : 'No text content';\r\n      break;\r\n\r\n    case 'semantic':\r\n      // Contextual evaluation for semantic preservation\r\n      const contextResult = evaluateContextualPreservation(\r\n        message,\r\n        index,\r\n        messages,\r\n        options,\r\n      );\r\n      preserve = contextResult.preserve;\r\n      reason = contextResult.reason;\r\n      break;\r\n\r\n    case 'custom':\r\n      // Apply custom validator if provided\r\n      if (options.validator) {\r\n        preserve = options.validator(message);\r\n        reason = preserve\r\n          ? 'Custom validator: preserve'\r\n          : 'Custom validator: filter';\r\n      }\r\n      break;\r\n  }\r\n\r\n  // Cache the decision\r\n  if (options.performance?.enableCaching) {\r\n    preservationCache.set(cacheKey, preserve);\r\n\r\n    // Cleanup cache if it gets too large\r\n    if (preservationCache.size > (options.performance.maxCacheSize || 1000)) {\r\n      const keysToDelete = Array.from(preservationCache.keys()).slice(0, 100);\r\n      keysToDelete.forEach((key) => preservationCache.delete(key));\r\n    }\r\n  }\r\n\r\n  return { preserve, reason, strategy };\r\n}\r\n\r\n/**\r\n * Process and filter messages based on preservation options\r\n */\r\nexport function preserveMessageStructure(\r\n  messages: UIMessage[],\r\n  options: MessageStructureOptions = {},\r\n): MessagePreservationResult {\r\n  const startTime = Date.now();\r\n  const fullOptions = createMessageStructureOptions(options);\r\n\r\n  // Early return if preservation is disabled\r\n  if (!isPreservationEnabled(fullOptions)) {\r\n    return {\r\n      preserved: messages,\r\n      filtered: [],\r\n      stats: {\r\n        originalCount: messages.length,\r\n        preservedCount: messages.length,\r\n        filteredCount: 0,\r\n        processingTimeMs: Date.now() - startTime,\r\n      },\r\n      warnings: ['Preservation is disabled - returning all messages'],\r\n    };\r\n  }\r\n\r\n  const preserved: UIMessage[] = [];\r\n  const filtered: UIMessage[] = [];\r\n  const warnings: string[] = [];\r\n  const debugDecisions: Array<{\r\n    messageId: string;\r\n    preserved: boolean;\r\n    reason: string;\r\n    strategy: PreservationStrategy;\r\n  }> = [];\r\n\r\n  // Process each message\r\n  for (let i = 0; i < messages.length; i++) {\r\n    const message = messages[i];\r\n\r\n    try {\r\n      const evaluation = evaluateMessagePreservation(\r\n        message,\r\n        i,\r\n        messages,\r\n        fullOptions,\r\n      );\r\n\r\n      if (fullOptions.debug) {\r\n        debugDecisions.push({\r\n          messageId: message.id,\r\n          preserved: evaluation.preserve,\r\n          reason: evaluation.reason,\r\n          strategy: evaluation.strategy,\r\n        });\r\n      }\r\n\r\n      if (evaluation.preserve) {\r\n        // Transform message content if needed\r\n        const transformedParts = message.parts\r\n          .filter((part) =>\r\n            shouldPreservePart(part, fullOptions.partRules || {}),\r\n          )\r\n          .map((part) => transformMessageContent(part, fullOptions));\r\n\r\n        if (transformedParts.length > 0) {\r\n          preserved.push({\r\n            ...message,\r\n            parts: transformedParts,\r\n          });\r\n        } else {\r\n          filtered.push(message);\r\n          warnings.push(\r\n            `Message ${message.id} preserved but has no valid parts after filtering`,\r\n          );\r\n        }\r\n      } else {\r\n        filtered.push(message);\r\n      }\r\n    } catch (error) {\r\n      filtered.push(message);\r\n      warnings.push(`Error processing message ${message.id}: ${error}`);\r\n\r\n      if (fullOptions.debug) {\r\n        log((l) =>\r\n          l.warn('Message preservation error', {\r\n            messageId: message.id,\r\n            error: error instanceof Error ? error.message : String(error),\r\n          }),\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  const result: MessagePreservationResult = {\r\n    preserved,\r\n    filtered,\r\n    stats: {\r\n      originalCount: messages.length,\r\n      preservedCount: preserved.length,\r\n      filteredCount: filtered.length,\r\n      processingTimeMs: Date.now() - startTime,\r\n      ...(fullOptions.performance?.enableCaching && {\r\n        cacheHits: cacheStats.hits,\r\n        cacheMisses: cacheStats.misses,\r\n      }),\r\n    },\r\n    warnings: warnings.length > 0 ? warnings : undefined,\r\n    ...(fullOptions.debug && {\r\n      debugInfo: { decisions: debugDecisions },\r\n    }),\r\n  };\r\n\r\n  // Log performance information if debug is enabled\r\n  if (fullOptions.debug) {\r\n    log((l) =>\r\n      l.debug('Message structure preservation completed', {\r\n        originalCount: messages.length,\r\n        preservedCount: preserved.length,\r\n        filteredCount: filtered.length,\r\n        processingTimeMs: result.stats.processingTimeMs,\r\n        strategy: fullOptions.strategy,\r\n      }),\r\n    );\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Validate message structure options\r\n */\r\nexport function validateMessageStructureOptions(\r\n  options: MessageStructureOptions,\r\n): { valid: boolean; errors: string[] } {\r\n  const errors: string[] = [];\r\n\r\n  // Validate strategy\r\n  const validStrategies: PreservationStrategy[] = [\r\n    'full',\r\n    'content-only',\r\n    'semantic',\r\n    'minimal',\r\n    'custom',\r\n  ];\r\n  if (options.strategy && !validStrategies.includes(options.strategy)) {\r\n    errors.push(\r\n      `Invalid strategy: ${options.strategy}. Must be one of: ${validStrategies.join(', ')}`,\r\n    );\r\n  }\r\n\r\n  // Validate performance options\r\n  if (options.performance) {\r\n    const perf = options.performance;\r\n    if (perf.cacheTtlMs !== undefined && perf.cacheTtlMs <= 0) {\r\n      errors.push('cacheTtlMs must be positive');\r\n    }\r\n    if (perf.maxCacheSize !== undefined && perf.maxCacheSize <= 0) {\r\n      errors.push('maxCacheSize must be positive');\r\n    }\r\n  }\r\n\r\n  // Validate content transformation\r\n  if (options.contentTransformation) {\r\n    const content = options.contentTransformation;\r\n    if (\r\n      content.maxContentLength !== undefined &&\r\n      content.maxContentLength <= 0\r\n    ) {\r\n      errors.push('maxContentLength must be positive');\r\n    }\r\n  }\r\n\r\n  // Validate contextual options\r\n  if (options.contextual) {\r\n    const contextual = options.contextual;\r\n    if (\r\n      contextual.recentInteractionCount !== undefined &&\r\n      contextual.recentInteractionCount <= 0\r\n    ) {\r\n      errors.push('recentInteractionCount must be positive');\r\n    }\r\n  }\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n  };\r\n}\r\n\r\n/**\r\n * Create a preset configuration for common use cases\r\n */\r\nexport function createPresetConfiguration(\r\n  preset: 'minimal' | 'balanced' | 'comprehensive' | 'performance',\r\n): MessageStructureOptions {\r\n  switch (preset) {\r\n    case 'minimal':\r\n      return createMessageStructureOptions({\r\n        strategy: 'minimal',\r\n        partRules: {\r\n          text: true,\r\n          toolCall: false,\r\n          toolResult: false,\r\n          file: false,\r\n          image: false,\r\n          dynamic: false,\r\n        },\r\n        performance: {\r\n          enableCaching: false,\r\n        },\r\n      });\r\n\r\n    case 'balanced':\r\n      return createMessageStructureOptions({\r\n        strategy: 'semantic',\r\n        contextual: {\r\n          recentInteractionCount: 3,\r\n        },\r\n        contentTransformation: {\r\n          maxContentLength: 1000,\r\n          truncateContent: true,\r\n        },\r\n      });\r\n\r\n    case 'comprehensive':\r\n      return createMessageStructureOptions({\r\n        strategy: 'full',\r\n        debug: true,\r\n        performance: {\r\n          enableCaching: true,\r\n          enableAsyncProcessing: true,\r\n        },\r\n      });\r\n\r\n    case 'performance':\r\n      return createMessageStructureOptions({\r\n        strategy: 'content-only',\r\n        performance: {\r\n          enableCaching: true,\r\n          cacheTtlMs: 600000, // 10 minutes\r\n          maxCacheSize: 5000,\r\n        },\r\n        contentTransformation: {\r\n          maxContentLength: 500,\r\n          truncateContent: true,\r\n        },\r\n      });\r\n\r\n    default:\r\n      return createMessageStructureOptions();\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\_baseDrizzleRepository.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":387,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { drizDbWithInit } from '@/lib/drizzle-db';\r\nimport {\r\n  ObjectRepository,\r\n  DrizzleRepositoryConfig,\r\n  IObjectRepositoryExt,\r\n} from './_types';\r\nimport { PaginatedResultset, PaginationStats } from '@/data-models/_types';\r\nimport { PartialExceptFor } from '@/lib/typescript';\r\nimport { eq, count, SQL } from 'drizzle-orm';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { log } from '@/lib/logger';\r\nimport { getTableConfig } from 'drizzle-orm/pg-core';\r\nimport { PgColumn } from 'drizzle-orm/pg-core';\r\n\r\n/**\r\n * Helper function to detect primary key column and field name from a Drizzle table schema\r\n */\r\nfunction detectPrimaryKey<T extends object, KId extends keyof T>(\r\n  config: DrizzleRepositoryConfig<T, KId>,\r\n): { idColumn: PgColumn; idField: KId } {\r\n  try {\r\n    const tableConfig = getTableConfig(config.table);\r\n    const tableName = config.tableName || tableConfig.name;\r\n\r\n    // Find the primary key column\r\n    const primaryKeyColumns = tableConfig.columns.filter((col) => col.primary);\r\n\r\n    if (primaryKeyColumns.length === 0) {\r\n      throw new Error(`No primary key found in table ${tableName}`);\r\n    }\r\n\r\n    if (primaryKeyColumns.length > 1) {\r\n      throw new Error(\r\n        `Multiple primary keys found in table ${tableName}. Please specify idColumn and idField manually.`,\r\n      );\r\n    }\r\n\r\n    const primaryKeyColumn = primaryKeyColumns[0];\r\n\r\n    // Convert snake_case database column name to camelCase field name\r\n    const databaseColumnName = primaryKeyColumn.name;\r\n    const camelCaseFieldName = databaseColumnName.replace(\r\n      /_([a-z])/g,\r\n      (_, letter) => letter.toUpperCase(),\r\n    );\r\n\r\n    return {\r\n      idColumn: primaryKeyColumn,\r\n      idField: camelCaseFieldName as KId,\r\n    };\r\n  } catch (error) {\r\n    const tableName = config.tableName || getTableConfig(config.table).name;\r\n    throw new Error(\r\n      `Unable to auto-detect primary key for table ${tableName}. ` +\r\n        `Please provide idColumn and idField explicitly in the config. ` +\r\n        `Error: ${error instanceof Error ? error.message : String(error)}`,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * BaseDrizzleRepository is a generic class that provides basic CRUD operations for objects of type T\r\n * using Drizzle ORM. It implements the ObjectRepository interface and provides methods for listing,\r\n * getting, creating, updating, and deleting records in a database.\r\n *\r\n * @template T - The type of the objects managed by this repository.\r\n * @template KId - The type of the key field in the objects managed by this repository.\r\n *\r\n * @implements {ObjectRepository<T, KId>}\r\n */\r\nexport abstract class BaseDrizzleRepository<\r\n  T extends object,\r\n  KId extends keyof T,\r\n> implements ObjectRepository<T, KId>\r\n{\r\n  protected readonly config: DrizzleRepositoryConfig<T, KId>;\r\n  protected readonly idColumn: PgColumn;\r\n  protected readonly idField: KId;\r\n  protected readonly tableName: string;\r\n\r\n  constructor(config: DrizzleRepositoryConfig<T, KId>) {\r\n    this.config = config;\r\n\r\n    // Auto-detect table name if not provided\r\n    this.tableName = config.tableName || getTableConfig(config.table).name;\r\n\r\n    // Auto-detect primary key if not provided\r\n    if (!config.idColumn || !config.idField) {\r\n      const detected = detectPrimaryKey(config);\r\n      this.idColumn = config.idColumn || detected.idColumn;\r\n      this.idField = config.idField || detected.idField;\r\n    } else {\r\n      this.idColumn = config.idColumn;\r\n      this.idField = config.idField;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validates the input for a specific repository method.\r\n   * Override this method in subclasses to provide custom validation.\r\n   */\r\n  protected validate<TMethod extends keyof ObjectRepository<T, KId>>(\r\n    method: TMethod,\r\n    obj: Record<string, unknown>,\r\n  ): void {\r\n    // NO-OP by default, can be overridden\r\n    log((l) =>\r\n      l.silly(`Validating ${String(method)} operation`, {\r\n        obj,\r\n        tableName: this.tableName,\r\n      }),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Retrieves a paginated list of objects.\r\n   */\r\n  async list(\r\n    pagination?: PaginationStats,\r\n  ): Promise<PaginatedResultset<Partial<T>>> {\r\n    try {\r\n      const page = pagination?.page ?? 1;\r\n      const num = pagination?.num ?? 10;\r\n      const offset = (page - 1) * num;\r\n\r\n      // Get the query conditions from subclasses (if any)\r\n      const queryConditions = this.buildQueryConditions();\r\n\r\n      const validDb = await drizDbWithInit();\r\n      // Build count query with the same conditions\r\n      const countQueryBase = validDb\r\n        .select({ count: count() })\r\n        .from(this.config.table);\r\n      const countQuery = queryConditions\r\n        ? countQueryBase.where(queryConditions)\r\n        : countQueryBase;\r\n\r\n      // Build data query with the same conditions\r\n      const dataQueryBase = validDb.select().from(this.config.table);\r\n      const dataQuery = queryConditions\r\n        ? dataQueryBase.where(queryConditions)\r\n        : dataQueryBase;\r\n\r\n      // Execute both queries\r\n      const [countRecords, results] = await Promise.all([\r\n        countQuery.execute(),\r\n        dataQuery\r\n          .offset(offset)\r\n          .limit(num)\r\n          .execute()\r\n          .then((x) => x.map(this.config.summaryMapper)),\r\n      ]);\r\n      const [{ count: totalCount }] = countRecords;\r\n\r\n      log((l) =>\r\n        l.verbose({\r\n          message: `[[AUDIT]] - ${this.tableName} list retrieved ${results.length} of ${totalCount} records.`,\r\n          data: {\r\n            results,\r\n            totalCount,\r\n            page,\r\n            num,\r\n          },\r\n        }),\r\n      );\r\n\r\n      return {\r\n        results,\r\n        pageStats: {\r\n          total: totalCount,\r\n          page,\r\n          num,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      throw this.logDatabaseError('list', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves a single object by its unique identifier.\r\n   */\r\n  async get(recordId: T[KId]): Promise<T | null> {\r\n    try {\r\n      this.validate('get', { [this.idField]: recordId });\r\n\r\n      const records = await drizDbWithInit((db) =>\r\n        db\r\n          .select()\r\n          .from(this.config.table)\r\n          .where(eq(this.idColumn, recordId as string | number))\r\n          .execute(),\r\n      );\r\n\r\n      if (records.length === 0) {\r\n        return null;\r\n      }\r\n\r\n      if (records.length > 1) {\r\n        throw new Error(\r\n          `Multiple records found for ${String(this.idField)}: ${recordId}`,\r\n        );\r\n      }\r\n\r\n      const result = this.config.recordMapper(records[0]);\r\n\r\n      log((l) =>\r\n        l.verbose({\r\n          message: `[[AUDIT]] - ${this.tableName} record retrieved:`,\r\n          resultset: result,\r\n        }),\r\n      );\r\n\r\n      return result;\r\n    } catch (error) {\r\n      const le = this.logDatabaseError('get', error);\r\n      throw le;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new object.\r\n   */\r\n  async create(model: Omit<T, KId>): Promise<T> {\r\n    try {\r\n      this.validate('create', model);\r\n\r\n      const insertData = this.prepareInsertData(model);\r\n      const records = await drizDbWithInit((db) =>\r\n        db.insert(this.config.table).values(insertData).returning(),\r\n      );\r\n\r\n      if (records.length !== 1) {\r\n        throw new Error(`Failed to create ${this.tableName} record`);\r\n      }\r\n\r\n      const result = this.config.recordMapper(records[0]);\r\n\r\n      log((l) =>\r\n        l.verbose({\r\n          message: `[[AUDIT]] - ${this.tableName} record created:`,\r\n          resultset: result,\r\n        }),\r\n      );\r\n\r\n      return result;\r\n    } catch (error) {\r\n      throw this.logDatabaseError('create', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates an existing object.\r\n   */\r\n  async update(\r\n    model: PartialExceptFor<T, KId> & Required<Pick<T, KId>>,\r\n  ): Promise<T> {\r\n    try {\r\n      this.validate('update', model);\r\n\r\n      const updateData = this.prepareUpdateData(model);\r\n      const records = await drizDbWithInit((db) =>\r\n        db\r\n          .update(this.config.table)\r\n          .set(updateData)\r\n          .where(eq(this.idColumn, model[this.idField] as string | number))\r\n          .returning(),\r\n      );\r\n\r\n      if (records.length === 0) {\r\n        throw new Error(`${this.tableName} record not found for update`);\r\n      }\r\n\r\n      if (records.length > 1) {\r\n        throw new Error(`Multiple ${this.tableName} records updated`);\r\n      }\r\n\r\n      const result = this.config.recordMapper(records[0]);\r\n\r\n      log((l) =>\r\n        l.verbose({\r\n          message: `[[AUDIT]] - ${this.tableName} record updated:`,\r\n          resultset: result,\r\n        }),\r\n      );\r\n\r\n      return result;\r\n    } catch (error) {\r\n      throw this.logDatabaseError('update', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deletes an object by its unique identifier.\r\n   */\r\n  async delete(recordId: T[KId]): Promise<boolean> {\r\n    try {\r\n      this.validate('delete', { [this.idField]: recordId });\r\n\r\n      const record = await drizDbWithInit((db) =>\r\n        db\r\n          .delete(this.config.table)\r\n          .where(eq(this.idColumn, recordId as string | number))\r\n          .returning()\r\n          .then((records) => records.at(0)),\r\n      );\r\n      if (!record) {\r\n        return false;\r\n      }\r\n\r\n      const result = this.config.recordMapper(record);\r\n\r\n      log((l) =>\r\n        l.verbose({\r\n          message: `[[AUDIT]] - ${this.tableName} record deleted:`,\r\n          resultset: result,\r\n        }),\r\n      );\r\n\r\n      return true;\r\n    } catch (error) {\r\n      throw this.logDatabaseError('delete', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Inner query method for accessing repository functionality.\r\n   * Note: This is a simplified implementation for Drizzle compatibility.\r\n   */\r\n  innerQuery<TRet>(query: (repo: IObjectRepositoryExt<T>) => TRet): TRet {\r\n    // For Drizzle repositories, we simplify this interface by casting to the expected type\r\n    return query(this as unknown as IObjectRepositoryExt<T>);\r\n  }\r\n\r\n  /**\r\n   * Builds the query conditions for list operations.\r\n   * Override this method in subclasses to add filtering logic.\r\n   * This single method ensures perfect consistency between count and data results.\r\n   *\r\n   * Example usage:\r\n   * ```typescript\r\n   * protected buildQueryConditions(): SQL | undefined {\r\n   *   // Apply filters based on repository state or parameters\r\n   *   if (this.emailId) {\r\n   *     return eq(this.config.table.emailId, this.emailId);\r\n   *   }\r\n   *   if (this.statusFilter) {\r\n   *     return eq(this.config.table.status, this.statusFilter);\r\n   *   }\r\n   *   return undefined; // No filtering\r\n   * }\r\n   * ```\r\n   *\r\n   * @returns Query conditions that will be applied to both count and data queries\r\n   */\r\n  protected buildQueryConditions(): SQL | undefined {\r\n    // By default, no additional conditions (return all records)\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Prepares data for insert operations.\r\n   * Override this method to customize how domain objects are mapped to database inserts.\r\n   */\r\n  protected abstract prepareInsertData(\r\n    model: Omit<T, KId>,\r\n  ): Record<string, unknown>;\r\n\r\n  /**\r\n   * Prepares data for update operations.\r\n   * Override this method to customize how domain objects are mapped to database updates.\r\n   */\r\n  protected abstract prepareUpdateData(\r\n    model: Partial<T>,\r\n  ): Record<string, unknown>;\r\n\r\n  /**\r\n   * Logs database errors with consistent formatting.\r\n   */\r\n  protected logDatabaseError(operation: string, error: unknown): LoggedError {\r\n    return LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: `${this.tableName}DrizzleRepository::${operation}`,\r\n    });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\_baseObjectRepository.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":335,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":90,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3122,3125],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3122,3125],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":107,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3663,3666],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3663,3666],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":123,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":123,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4142,4145],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4142,4145],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":138,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4649,4652],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4649,4652],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":175,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":175,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6046,6049],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6046,6049],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PaginationStats, PaginatedResultset } from '@/data-models/_types';\r\nimport { log } from '../logger';\r\nimport { query, queryExt, TransformedFullQueryResults } from '@/lib/neondb';\r\nimport { FirstParameter, PartialExceptFor } from '../typescript';\r\nimport {\r\n  IObjectRepositoryExt,\r\n  ObjectRepository,\r\n  RecordToObjectImpl,\r\n  RecordToSummaryImpl,\r\n} from './_types';\r\nimport { snakeToCamel } from 'google-auth-library/build/src/util';\r\nimport { AbstractObjectRepository } from './abstractObjectRepository';\r\n\r\n/**\r\n * BaseObjectRepository is a generic class that provides basic CRUD operations for objects of type T.\r\n * It implements the ObjectRepository interface and provides methods for listing, getting, creating,\r\n * updating, and deleting records in a database.\r\n *\r\n * @template T - The type of the objects managed by this repository.\r\n * @template KId - The type of the key field in the objects managed by this repository.\r\n *\r\n * @implements {ObjectRepository<T, KId>}\r\n */\r\nexport class BaseObjectRepository<T extends object, KId extends keyof T>\r\n  extends AbstractObjectRepository<T>\r\n  implements ObjectRepository<T, KId>\r\n{\r\n  /**\r\n   * The name of the table in the database.\r\n   * @type {string}\r\n   */\r\n  protected readonly objectIdField: KId;\r\n  /**\r\n   * The name of the key field in the database table.\r\n   * @type {string}\r\n   */\r\n  protected readonly tableIdField: string;\r\n\r\n  /**\r\n   * Constructs a new instance of BaseObjectRepository.\r\n   *\r\n   * @param {string} tableName - The name of the table in the database.\r\n   * @param {KId | [KId, string]} idField - The key field in the database table.\r\n   * @param {RecordToObjectImpl<T>} objectMap - Function to map database records to objects.\r\n   * @param {RecordToSummaryImpl<T>} summaryMap - Function to map database records to summaries.\r\n   */\r\n  constructor({\r\n    tableName,\r\n    idField,\r\n    objectMap,\r\n    summaryMap,\r\n  }: {\r\n    tableName: string;\r\n    idField: KId | [KId, string];\r\n    objectMap: RecordToObjectImpl<T> | string;\r\n    summaryMap: RecordToSummaryImpl<T> | string;\r\n  }) {\r\n    super({ tableName, objectMap, summaryMap });\r\n    if (Array.isArray(idField)) {\r\n      this.objectIdField = idField[0];\r\n      this.tableIdField = idField[1];\r\n    } else {\r\n      this.objectIdField = idField;\r\n      this.tableIdField = snakeToCamel(idField.toString());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the unique identifier of the model object.\r\n   *\r\n   * @returns {KId} The unique identifier of the object.\r\n   */\r\n  public get objectId(): KId {\r\n    return this.objectIdField;\r\n  }\r\n  /**\r\n   * Gets the list query properties.\r\n   *\r\n   * This method should be overridden in derived classes to provide the necessary\r\n   * query properties for listing objects. The returned value is a tuple containing\r\n   * template strings arrays and an array of any type.\r\n   *\r\n   * @throws {Error} Method not implemented.\r\n   *\r\n   * @returns {[string, Array<any>, string]} The list query properties.\r\n   */\r\n  protected getListQueryProperties(): [\r\n    string,\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    Array<any>,\r\n    string,\r\n  ] {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n\r\n  /**\r\n   * Gets the properties required to create a query.\r\n   *\r\n   * @returns {[string, Array<any>]} A tuple containing a `TemplateStringsArray` and an array of any type.\r\n   * @throws {Error} An error indicating that the method is not implemented.\r\n   */\r\n  protected getCreateQueryProperties({}: FirstParameter<\r\n    ObjectRepository<T, KId>['create']\r\n  >): [\r\n    string,\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    Array<any>,\r\n  ] {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n\r\n  /**\r\n   * Retrieves the query properties.\r\n   *\r\n   * @returns {[string, Array<any>]} A tuple containing a TemplateStringsArray and an array of any type.\r\n   * @throws {Error} If the method is not implemented.\r\n   */\r\n  protected getQueryProperties({}: FirstParameter<\r\n    ObjectRepository<T, KId>['get']\r\n  >): [\r\n    string,\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    Array<any>,\r\n  ] {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n\r\n  /**\r\n   * Gets the properties required to update a query.\r\n   *\r\n   * @returns {[Record<string, any>]} An object containing the properties for the update query.\r\n   * @throws {Error} Throws an error if the method is not implemented.\r\n   */\r\n  protected getUpdateQueryProperties({}: FirstParameter<\r\n    ObjectRepository<T, KId>['update']\r\n  >): [\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    Record<string, any>,\r\n  ] {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n\r\n  /**\r\n   * Retrieves a list of items with optional pagination.\r\n   *\r\n   * @param {PaginationStats} [pagination] - Optional pagination parameters.\r\n   * @returns {Promise<PaginatedResultset<Partial<T>>>} A promise that resolves to a paginated result set of partial items.\r\n   */\r\n  list(pagination?: PaginationStats): Promise<PaginatedResultset<Partial<T>>> {\r\n    const [sqlQuery, values, sqlCountQuery] = this.getListQueryProperties();\r\n    return this.defaultListImpl(\r\n      { sqlQuery, values, sqlCountQuery },\r\n      pagination,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Default implementation for listing items with optional pagination.\r\n   *\r\n   * @param {Object} params - The parameters for the list query.\r\n   * @param {string} params.sqlQuery - The SQL query string.\r\n   * @param {Array<any>} params.values - The values for the SQL query.\r\n   * @param {string} params.sqlCountQuery - The SQL count query string.\r\n   * @param {PaginationStats} [pagination] - Optional pagination parameters.\r\n   * @returns {Promise<PaginatedResultset<Partial<T>>>} A promise that resolves to a paginated result set of partial items.\r\n   */\r\n  defaultListImpl(\r\n    {\r\n      sqlCountQuery,\r\n      sqlQuery,\r\n      values,\r\n    }: {\r\n      sqlQuery: string;\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      values: Array<any>;\r\n      sqlCountQuery: string;\r\n    },\r\n    pagination?: PaginationStats,\r\n  ): Promise<PaginatedResultset<Partial<T>>> {\r\n    return this.innerList(\r\n      () =>\r\n        query(\r\n          (sql) => this.forwardCallToDb<false, false>(sql, sqlQuery, values),\r\n          {\r\n            transform: this.mapRecordToSummary,\r\n          },\r\n        ),\r\n      () =>\r\n        query((sql) =>\r\n          this.forwardCallToDb<false, false>(sql, sqlCountQuery, values),\r\n        ),\r\n      pagination,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Retrieves an item by its ID.\r\n   *\r\n   * @param {T[KId]} recordId - The ID of the record to retrieve.\r\n   * @returns {Promise<T | null>} A promise that resolves to the retrieved item or null if not found.\r\n   */\r\n  get(recordId: T[KId]): Promise<T | null> {\r\n    return this.innerGet(\r\n      () => this.validate('get', recordId),\r\n      () => {\r\n        const [sqlImp, sqlArgs] = this.getQueryProperties(recordId);\r\n        return query(\r\n          (sql) => this.forwardCallToDb<false, false>(sql, sqlImp, sqlArgs),\r\n          {\r\n            transform: this.mapRecordToObject,\r\n          },\r\n        );\r\n      },\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Creates a new item.\r\n   *\r\n   * @param {Omit<T, KId>} props - The properties of the item to create.\r\n   * @returns {Promise<T>} A promise that resolves to the created item.\r\n   */\r\n  create(props: Omit<T, KId>): Promise<T> {\r\n    return this.innerCreate(\r\n      () => this.validate('create', props),\r\n      () => {\r\n        const [sqlImp, sqlArgs] = this.getCreateQueryProperties(props);\r\n        return query(\r\n          (sql) => this.forwardCallToDb<false, false>(sql, sqlImp, sqlArgs),\r\n          {\r\n            transform: this.mapRecordToObject,\r\n          },\r\n        );\r\n      },\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Updates an existing item.\r\n   *\r\n   * @param {PartialExceptFor<T, KId>} props - The properties of the item to update.\r\n   * @returns {Promise<T>} A promise that resolves to the updated item.\r\n   */\r\n  update(props: PartialExceptFor<T, KId> & Required<Pick<T, KId>>): Promise<T> {\r\n    return this.innerUpdate(\r\n      () => this.validate('update', props),\r\n      () => {\r\n        const [fieldMap] = this.getUpdateQueryProperties(props);\r\n        const updateFields: string[] = [];\r\n        const values: unknown[] = [];\r\n        let paramIndex = 1;\r\n        Object.entries(fieldMap).forEach(([key, value]) => {\r\n          if (value !== undefined) {\r\n            updateFields.push(`\"${key}\" = $${paramIndex++}`);\r\n            values.push(value);\r\n          }\r\n        });\r\n        values.push(props[this.objectIdField]);\r\n        const ret = queryExt(\r\n          (sql) =>\r\n            sql<false, true>(\r\n              `UPDATE ${this.tableName} SET ${updateFields.join(\r\n                ', ',\r\n              )} WHERE \"${String(\r\n                this.tableIdField,\r\n              )}\" = $${paramIndex} RETURNING *`.toString(),\r\n              values,\r\n            ),\r\n          { transform: this.mapRecordToObject },\r\n        );\r\n        return this.postProcessUpdate({ updateQuery: ret, props });\r\n      },\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Override to append post-processing logic to the update query.\r\n   * @param updateQuery Update query promise\r\n   * @returns The updateQuery argument\r\n   */\r\n  protected postProcessUpdate({\r\n    updateQuery,\r\n  }: {\r\n    props: PartialExceptFor<T, KId> & Required<Pick<T, KId>>;\r\n    updateQuery: Promise<TransformedFullQueryResults<T>>;\r\n  }): Promise<TransformedFullQueryResults<T>> {\r\n    return updateQuery;\r\n  }\r\n\r\n  /**\r\n   * Deletes an item by its ID.\r\n   *\r\n   * @param {T[KId]} recordId - The ID of the record to delete.\r\n   * @returns {Promise<boolean>} A promise that resolves to true if the item was deleted, otherwise false.\r\n   */\r\n  delete(recordId: T[KId]): Promise<boolean> {\r\n    return this.innerDelete(\r\n      () => this.validate('delete', recordId),\r\n      () => {\r\n        const sqlImpl = `DELETE FROM ${this.tableName} \r\n          WHERE ${String(this.tableIdField)}=$1`.toString();\r\n        return queryExt<T>((sql) => sql<false, true>(sqlImpl, [recordId]));\r\n      },\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Validates the given object using the specified method.\r\n   * This is a no-op by default but can be overridden in subclasses.\r\n   *\r\n   * @template TMethod - The type of the method in the ObjectRepository.\r\n   * @param {TMethod} method - The method to use for validation.\r\n   * @param {FirstParameter<Pick<ObjectRepository<T, KId>, TMethod>[TMethod]>} obj - The object to validate, which is the first parameter of the specified method.\r\n   */\r\n  validate<TMethod extends keyof ObjectRepository<T, KId>>(\r\n    method: TMethod,\r\n    obj: FirstParameter<Pick<ObjectRepository<T, KId>, TMethod>[TMethod]>,\r\n  ): void {\r\n    // NO-OP, but can be overridden\r\n    log((l) =>\r\n      l.silly(`Using ${method} so the squigglies leave me alone...`, obj),\r\n    );\r\n  }\r\n\r\n  innerQuery<TRet>(query: (repo: IObjectRepositoryExt<T>) => TRet): TRet {\r\n    return query({\r\n      list: this.innerList.bind(this),\r\n      get: this.innerGet.bind(this),\r\n      create: this.innerCreate.bind(this),\r\n      update: this.innerUpdate.bind(this),\r\n      delete: this.innerDelete.bind(this),\r\n    });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\_types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":180,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PaginatedResultset, PaginationStats } from '@/data-models/_types';\r\nimport { PartialExceptFor } from '../typescript';\r\nimport { TransformedFullQueryResults } from '../neondb';\r\nimport { PgTable, PgColumn } from 'drizzle-orm/pg-core';\r\n\r\n/**\r\n * Configuration interface for BaseDrizzleRepository\r\n */\r\nexport interface DrizzleRepositoryConfig<\r\n  T extends object,\r\n  KId extends keyof T,\r\n> {\r\n  /** The Drizzle table schema */\r\n  table: PgTable;\r\n  /** The primary key column in the table (optional - will be auto-detected if not provided) */\r\n  idColumn?: PgColumn;\r\n  /** Function to map database record to domain object */\r\n  recordMapper: (record: Record<string, unknown>) => T;\r\n  /** Function to map database record to summary object */\r\n  summaryMapper: (record: Record<string, unknown>) => Partial<T>;\r\n  /** Table name for logging purposes (optional - will be auto-detected if not provided) */\r\n  tableName?: string;\r\n  /** The property name of the ID field in the domain object (optional - will be auto-detected if not provided) */\r\n  idField?: KId;\r\n}\r\n\r\n/**\r\n * Parameters for making a paginated request to the API.\r\n *\r\n * @property {number} num - The number of items per page.\r\n * @property {number} page - The current page number.\r\n */\r\nexport type PaginatedRequestApiParams = {\r\n  num?: number;\r\n  page?: number;\r\n};\r\n\r\n/**\r\n * A generic repository interface for managing objects of type `T`.\r\n *\r\n * @template T - The type of the objects managed by the repository.\r\n * @template K - The key of the unique identifier property in type `T`.\r\n */\r\nexport type ObjectRepository<T extends object, K extends keyof T> = {\r\n  /**\r\n   * Retrieves a list of objects with optional pagination.\r\n   *\r\n   * @param pagination - Optional pagination parameters.\r\n   * @returns A promise that resolves to a paginated result set of partial objects of type `T`.\r\n   */\r\n  list: (\r\n    pagination?: PaginationStats,\r\n  ) => Promise<PaginatedResultset<Partial<T>>>;\r\n\r\n  /**\r\n   * Retrieves a single object by its unique identifier.\r\n   *\r\n   * @param recordId - The unique identifier of the object to retrieve.\r\n   * @returns A promise that resolves to the object of type `T` or `null` if not found.\r\n   */\r\n  get: (recordId: T[K]) => Promise<T | null>;\r\n\r\n  /**\r\n   * Creates a new object.\r\n   *\r\n   * @param model - The object to create, excluding the unique identifier property.\r\n   * @returns A promise that resolves to the created object of type `T`.\r\n   */\r\n  create: (model: Omit<T, K>) => Promise<T>;\r\n\r\n  /**\r\n   * Updates an existing object.\r\n   *\r\n   * @param model - The object to update, with all properties optional except for the unique identifier property.\r\n   * @returns A promise that resolves to the updated object of type `T`.\r\n   */\r\n  update: (model: PartialExceptFor<T, K> & Required<Pick<T, K>>) => Promise<T>;\r\n\r\n  /**\r\n   * Deletes an object by its unique identifier.\r\n   *\r\n   * @param recordId - The unique identifier of the object to delete.\r\n   * @returns A promise that resolves to `true` if the object was successfully deleted, or `false` otherwise.\r\n   */\r\n  delete: (recordId: T[K]) => Promise<boolean>;\r\n\r\n  /**\r\n   * Retrieves the inner repository.\r\n   * @returns A function that returns the inner repository.\r\n   */\r\n  innerQuery: <TRet>(query: (repo: IObjectRepositoryExt<T>) => TRet) => TRet;\r\n};\r\n\r\n/**\r\n * A generic repository interface for managing objects of type `T`.\r\n *\r\n * @template T - The type of the objects managed by the repository.\r\n */\r\nexport type IObjectRepositoryExt<T extends object> = {\r\n  /**\r\n   * Retrieves a list of objects with optional pagination.\r\n   *\r\n   * @param pagination - Optional pagination parameters.\r\n   * @returns A promise that resolves to a paginated result set of partial objects of type `T`.\r\n   */\r\n  list: (\r\n    getData: (\r\n      num: number,\r\n      page: number,\r\n      offset: number,\r\n    ) => Promise<Array<Partial<T>>>,\r\n    getDataCount: () => Promise<Record<string, unknown>[]>,\r\n    pagination?: PaginationStats,\r\n  ) => Promise<PaginatedResultset<Partial<T>>>;\r\n\r\n  /**\r\n   * Retrieves a single object by its unique identifier.\r\n   *\r\n   * @param recordId - The unique identifier of the object to retrieve.\r\n   * @returns A promise that resolves to the object of type `T` or `null` if not found.\r\n   */\r\n  get: (\r\n    validateData: () => void,\r\n    doQuery: () => Promise<T[]>,\r\n  ) => Promise<T | null>;\r\n\r\n  /**\r\n   * Creates a new object.\r\n   *\r\n   * @param model - The object to create, excluding the unique identifier property.\r\n   * @returns A promise that resolves to the created object of type `T`.\r\n   */\r\n  create: (validateData: () => void, doQuery: () => Promise<T[]>) => Promise<T>;\r\n\r\n  /**\r\n   * Updates an existing object.\r\n   *\r\n   * @param model - The object to update, with all properties optional except for the unique identifier property.\r\n   * @returns A promise that resolves to the updated object of type `T`.\r\n   */\r\n  update: (\r\n    validateData: () => void,\r\n    doQuery: () => Promise<TransformedFullQueryResults<T>>,\r\n  ) => Promise<T>;\r\n\r\n  /**\r\n   * Deletes an object by its unique identifier.\r\n   *\r\n   * @param recordId - The unique identifier of the object to delete.\r\n   * @returns A promise that resolves to `true` if the object was successfully deleted, or `false` otherwise.\r\n   */\r\n  delete: (\r\n    validate: () => void,\r\n    doQuery: () => Promise<TransformedFullQueryResults<T>>,\r\n  ) => Promise<boolean>;\r\n};\r\n\r\n/**\r\n * A function type that transforms a record of unknown values into a partial object of type `T`.\r\n *\r\n * @template T - The type of the object to be returned.\r\n * @param record - A record with string keys and unknown values.\r\n * @returns A partial object of type `T`.\r\n */\r\nexport type RecordToSummaryImpl<T extends object> = (\r\n  record: Record<string, unknown>,\r\n) => Partial<T>;\r\n\r\n/**\r\n * A type alias for a function that converts a record with string keys and unknown values\r\n * to an object of type T.\r\n *\r\n * @template T - The type of the object to be returned.\r\n * @param record - The record with string keys and unknown values to be converted.\r\n * @returns An object of type T.\r\n */\r\nexport type RecordToObjectImpl<T extends object> = (\r\n  record: Record<string, unknown>,\r\n) => T;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\abstractObjectRepository.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":448,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":226,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":226,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8288,8291],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8288,8291],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PaginationStats, PaginatedResultset } from '@/data-models/_types';\r\nimport {\r\n  isError,\r\n  isTemplateStringsArray,\r\n} from '@/lib/react-util/utility-methods';\r\nimport { log } from '../logger';\r\nimport type {\r\n  TransformedFullQueryResults,\r\n  DbQueryFunction,\r\n} from '@/lib/neondb';\r\nimport { ValidationError } from '../react-util';\r\nimport { DataIntegrityError } from '../react-util/errors/data-integrity-error';\r\nimport { LoggedError } from '../react-util/errors/logged-error';\r\nimport { RecordToObjectImpl, RecordToSummaryImpl } from './_types';\r\nimport { GridFilterModel, GridSortModel } from '@mui/x-data-grid-pro';\r\nimport { parsePaginationStats } from '@/lib/components/mui/data-grid/queryHelpers/utility';\r\n\r\n/**\r\n * AbstractObjectRepository is a base class for handling database operations\r\n * and error logging for objects of type T.\r\n *\r\n * @template T - The type of object this repository handles.\r\n */\r\n/**\r\n * AbstractObjectRepository is a generic class that provides common database operations\r\n * for objects of type `T`. It includes methods for logging database errors, mapping\r\n * database records to objects, and performing CRUD operations.\r\n *\r\n * @template T - The type of objects managed by this repository.\r\n */\r\nexport class AbstractObjectRepository<T extends object> {\r\n  /**\r\n   * Logs and throws a database error.\r\n   *\r\n   * This method processes different types of errors and throws a `LoggedError` with appropriate details.\r\n   * It handles generic errors, data integrity errors, and validation errors, logging them accordingly.\r\n   *\r\n   * @param params - The parameters for logging the database error.\r\n   * @param params.error - The error object to be logged and thrown.\r\n   * @param params.source - The source of the error, typically indicating where the error originated.\r\n   *\r\n   * @throws {LoggedError} - Throws a `LoggedError` with details about the error, including its criticality and source.\r\n   */\r\n  static logDatabaseError(params: { error: unknown; source: string }): never;\r\n\r\n  /**\r\n   * Logs and throws a database error.\r\n   *\r\n   * This method processes different types of errors and throws a `LoggedError` with appropriate details.\r\n   * It handles generic errors, data integrity errors, and validation errors, logging them accordingly.\r\n   *\r\n   * @param {string} source - The source of the error, typically indicating where the error originated.\r\n   * @param {unknown} error - The error object to be logged and thrown.\r\n   *\r\n   * @throws {LoggedError} - Throws a `LoggedError` with details about the error, including its criticality and source.\r\n   */\r\n  static logDatabaseError(source: string, error: unknown): never;\r\n\r\n  /**\r\n   * Logs a database error and throws a `LoggedError` with appropriate details.\r\n   *\r\n   * @param paramsOrSource - Either an object containing the error and source, or a string representing the source.\r\n   * @param errorFromArgs - The error to be logged if `paramsOrSource` is a string.\r\n   * @throws {LoggedError} - Throws a `LoggedError` with details about the error.\r\n   *\r\n   * @overload\r\n   * @param paramsOrSource - An object containing the error and source.\r\n   * @param paramsOrSource.error - The error to be logged.\r\n   * @param paramsOrSource.source - The source of the error.\r\n   * @throws {LoggedError} - Throws a `LoggedError` with details about the error.\r\n   *\r\n   * @overload\r\n   * @param paramsOrSource - A string representing the source of the error.\r\n   * @param errorFromArgs - The error to be logged.\r\n   * @throws {LoggedError} - Throws a `LoggedError` with details about the error.\r\n   */\r\n  static logDatabaseError(\r\n    paramsOrSource: { error: unknown; source: string } | string,\r\n    errorFromArgs?: unknown,\r\n  ): never {\r\n    let error: unknown;\r\n    let source: string;\r\n    if (typeof paramsOrSource === 'string') {\r\n      source = paramsOrSource;\r\n      error = errorFromArgs;\r\n    } else {\r\n      source = paramsOrSource.source;\r\n      error = paramsOrSource.error;\r\n    }\r\n    if (typeof error !== 'object' || error === null) {\r\n      throw LoggedError.isTurtlesAllTheWayDownBaby({\r\n        error: new Error(String(error)),\r\n        log: true,\r\n        source,\r\n        critical: true,\r\n      });\r\n    }\r\n    if (DataIntegrityError.isDataIntegrityError(error)) {\r\n      throw LoggedError.isTurtlesAllTheWayDownBaby({\r\n        error,\r\n        critical: false,\r\n        source,\r\n        log: true,\r\n      });\r\n    }\r\n    if (ValidationError.isValidationError(error)) {\r\n      throw LoggedError.isTurtlesAllTheWayDownBaby({\r\n        error,\r\n        critical: false,\r\n        message: 'Validation error',\r\n        source,\r\n        log: true,\r\n      });\r\n    }\r\n    throw LoggedError.isTurtlesAllTheWayDownBaby({\r\n      error: isError(error) ? error : new Error(String(error)),\r\n      critical: true,\r\n      log: true,\r\n      shouldLog: true,\r\n      source,\r\n      message: '[AUDIT] A database operation failed',\r\n    });\r\n  }\r\n\r\n  readonly #tableName: string;\r\n  readonly #objectMap: RecordToObjectImpl<T> | string;\r\n  readonly #summaryMap: RecordToSummaryImpl<T> | string;\r\n\r\n  /**\r\n   * Constructs a new instance of the class.\r\n   *\r\n   * @param tableName - The name of the table.\r\n   * @param objectMap - A mapping of records to objects.\r\n   * @param summaryMap - A mapping of records to summaries.\r\n   */\r\n  constructor({\r\n    tableName,\r\n    objectMap,\r\n    summaryMap,\r\n  }: {\r\n    tableName: string;\r\n    objectMap: RecordToObjectImpl<T> | string;\r\n    summaryMap: RecordToSummaryImpl<T> | string;\r\n  }) {\r\n    this.#tableName = tableName;\r\n    this.#objectMap = objectMap;\r\n    this.#summaryMap = summaryMap;\r\n  }\r\n\r\n  /**\r\n   * Maps a database record to a partial object of type T.\r\n   * Set in constructor\r\n   *\r\n   * @type {(record: Record<string, unknown>) => Partial<T>}\r\n   */\r\n  get mapRecordToSummary(): RecordToSummaryImpl<T> {\r\n    if (typeof this.#summaryMap === 'string') {\r\n      if (this.#summaryMap in this) {\r\n        return (this as Record<string, unknown>)[\r\n          this.#summaryMap\r\n        ] as RecordToSummaryImpl<T>;\r\n      }\r\n      throw new Error(\r\n        `The summary map \"${this.#summaryMap}\" is not a valid function.`,\r\n      );\r\n    }\r\n    return this.#summaryMap;\r\n  }\r\n\r\n  /**\r\n   * Gets the mapping function that converts a record to an object of type `T`.\r\n   *\r\n   * @returns {RecordToObjectImpl<T>} The function that maps a record to an object.\r\n   */\r\n  get mapRecordToObject(): RecordToObjectImpl<T> {\r\n    if (typeof this.#objectMap === 'string') {\r\n      if (this.#objectMap in this) {\r\n        return (this as Record<string, unknown>)[\r\n          this.#objectMap\r\n        ] as RecordToObjectImpl<T>;\r\n      }\r\n      throw new Error(\r\n        `The object map \"${this.#objectMap}\" is not a valid function.`,\r\n      );\r\n    }\r\n    return this.#objectMap;\r\n  }\r\n\r\n  /**\r\n   * Gets the name of the table associated with this repository.\r\n   *\r\n   * @returns {string} The name of the table.\r\n   */\r\n  protected get tableName(): string {\r\n    return this.#tableName;\r\n  }\r\n  /**\r\n   * Gets the source string for the repository.\r\n   * The source string is generated by taking the `tableName` property,\r\n   * capitalizing the first letter, and appending \"Repository\" to the rest of the word.\r\n   *\r\n   * @returns {string} The formatted source string for the repository.\r\n   */\r\n  protected get source(): string {\r\n    const restOfWord = this.tableName.slice(1);\r\n    return `${this.tableName[0].toUpperCase()}${restOfWord}Repository`;\r\n  }\r\n\r\n  /**\r\n   * Forwards a call to the database using the provided SQL query function.\r\n   *\r\n   * @template ArrayMode - Indicates if the result should be an array.\r\n   * @template FullResults - Indicates if the full results should be returned.\r\n   * @param sql - The SQL query function to execute.\r\n   * @param sqlQuery - The SQL query string or template strings array.\r\n   * @param values - The values to be used in the SQL query.\r\n   * @returns The result of the SQL query execution.\r\n   */\r\n  protected forwardCallToDb = <\r\n    ArrayMode extends boolean,\r\n    FullResults extends boolean,\r\n  >(\r\n    sql: DbQueryFunction<ArrayMode, FullResults>,\r\n    sqlQuery: string | TemplateStringsArray,\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    values: Array<any>,\r\n  ) => {\r\n    values = values?.map((x) => (x instanceof Date ? x.toISOString() : x));\r\n    return isTemplateStringsArray(sqlQuery)\r\n      ? sql(sqlQuery, ...values)\r\n      : sql(sqlQuery, values);\r\n  };\r\n\r\n  /**\r\n   * Retrieves a paginated list of partial objects of type T.\r\n   *\r\n   * @template T - The type of the objects being retrieved.\r\n   * @param getData - A function that fetches the data. It takes three parameters:\r\n   *   - `num`: The number of items to retrieve.\r\n   *   - `page`: The current page number.\r\n   *   - `offset`: The offset from which to start retrieving items.\r\n   *   The function returns a promise that resolves to an array of partial objects of type T.\r\n   * @param getDataCount - A function that fetches the total count of records. It returns a promise that resolves to an array of records.\r\n   * @param pagination - Optional pagination statistics. If not provided, default values will be used.\r\n   * @returns A promise that resolves to a `PaginatedResultset` containing the results and pagination statistics.\r\n   * @throws Will log an error if the data retrieval fails.\r\n   */\r\n  protected async innerList(\r\n    getData:\r\n      | ((\r\n          num: number,\r\n          page: number,\r\n          offset: number,\r\n        ) => Promise<Array<Partial<T>>>)\r\n      | ((\r\n          num: number,\r\n          page: number,\r\n          offset: number,\r\n          sort?: GridSortModel,\r\n          filter?: GridFilterModel,\r\n        ) => Promise<Array<Partial<T>>>),\r\n    getDataCount: (\r\n      filter?: GridFilterModel,\r\n    ) => Promise<Record<string, unknown>[]>,\r\n    pagination?: PaginationStats,\r\n  ): Promise<PaginatedResultset<Partial<T>>> {\r\n    const { num, page, offset, filter, sort } =\r\n      parsePaginationStats(pagination);\r\n    try {\r\n      const results = await getData(num, page, offset, sort, filter);\r\n      if (results.length >= num) {\r\n        const totalRecord = await getDataCount(filter);\r\n        let total: number = 0;\r\n        if (totalRecord.length > 0) {\r\n          if ('records' in totalRecord[0])\r\n            total = Number(totalRecord[0].records);\r\n          else total = Number(Object.values(totalRecord[0])[0]);\r\n        } else {\r\n          total = 0;\r\n        }\r\n        return {\r\n          results,\r\n          pageStats: {\r\n            num,\r\n            page,\r\n            total,\r\n          },\r\n        };\r\n      } else {\r\n        return {\r\n          results,\r\n          pageStats: {\r\n            num,\r\n            page,\r\n            total: offset + results.length,\r\n          },\r\n        };\r\n      }\r\n    } catch (error) {\r\n      AbstractObjectRepository.logDatabaseError({ source: this.source, error });\r\n    }\r\n    return {\r\n      results: [],\r\n      pageStats: {\r\n        num: 0,\r\n        page: 0,\r\n        total: 0,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Executes a query and returns a single result if exactly one item is found.\r\n   *\r\n   * @template T - The type of the items being queried.\r\n   * @param validateData - A function to validate the data before executing the query.\r\n   * @param doQuery - A function that performs the query and returns a promise that resolves to an array of items of type T.\r\n   * @returns A promise that resolves to an item of type T if exactly one item is found, otherwise null.\r\n   * @throws Will log an error if the query fails.\r\n   */\r\n  protected async innerGet(\r\n    validateData: () => void,\r\n    doQuery: () => Promise<T[]>,\r\n  ): Promise<T | null> {\r\n    validateData();\r\n    try {\r\n      const result = await doQuery();\r\n      return result.length === 1 ? result[0] : null;\r\n    } catch (error) {\r\n      AbstractObjectRepository.logDatabaseError({ source: this.source, error });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates a record in the database.\r\n   *\r\n   * @protected\r\n   * @async\r\n   * @param {Record<KId, unknown>} props - The properties of the record to update.\r\n   * @param {() => void} validateData - A function to validate the data before updating.\r\n   * @param {() => Promise<TransformedFullQueryResults<T>>} doQuery - A function that performs the update query and returns the result.\r\n   * @returns {Promise<T>} The updated record.\r\n   * @throws {DataIntegrityError} If the update fails due to no rows being affected.\r\n   */\r\n  protected async innerUpdate(\r\n    validateData: () => void,\r\n    doQuery: () => Promise<TransformedFullQueryResults<T>>,\r\n  ) {\r\n    validateData();\r\n    try {\r\n      const result = await doQuery();\r\n\r\n      if (result.rowCount === 0) {\r\n        throw new DataIntegrityError(\r\n          `Failed to update \"${this.tableName}\" record`,\r\n          {\r\n            table: this.tableName,\r\n          },\r\n        );\r\n      }\r\n      log((l) =>\r\n        l.verbose({\r\n          message: `[[AUDIT]] -  ${this.tableName} updated:`,\r\n          row: result.rows[0],\r\n        }),\r\n      );\r\n      return result.rows[0];\r\n    } catch (error) {\r\n      AbstractObjectRepository.logDatabaseError({ source: this.source, error });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new record in the repository.\r\n   *\r\n   * @protected\r\n   * @template T The type of the record to be created.\r\n   * @param {() => void} validateData - A function to validate the data before creating the record.\r\n   * @param {() => Promise<T[]>} doQuery - A function that performs the query to create the record and returns a promise that resolves to an array of created records.\r\n   * @returns {Promise<T>} A promise that resolves to the created record.\r\n   * @throws {DataIntegrityError} If the number of created records is not exactly one.\r\n   */\r\n  protected async innerCreate(\r\n    validateData: () => void,\r\n    doQuery: () => Promise<T[]>,\r\n  ): Promise<T> {\r\n    validateData();\r\n    try {\r\n      const result = await doQuery();\r\n      log((l) =>\r\n        l.verbose({\r\n          message: `[[AUDIT]] -  ${this.tableName} record created:`,\r\n          row: result[0],\r\n        }),\r\n      );\r\n      if (result.length !== 1) {\r\n        throw new DataIntegrityError(\r\n          `Failed to create \"${this.tableName}\" record.`,\r\n          {\r\n            table: this.tableName,\r\n          },\r\n        );\r\n      }\r\n      return result[0];\r\n    } catch (error) {\r\n      AbstractObjectRepository.logDatabaseError({ source: this.source, error });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deletes a record from the repository after validation and query execution.\r\n   *\r\n   * @protected\r\n   * @param validate - A function to validate the deletion process.\r\n   * @param doQuery - A function that executes the deletion query and returns the results.\r\n   * @returns A promise that resolves to `true` if the deletion was successful, otherwise `false`.\r\n   * @throws {DataIntegrityError} If the deletion query does not affect any rows.\r\n   */\r\n  protected async innerDelete(\r\n    validate: () => void,\r\n    doQuery: () => Promise<TransformedFullQueryResults<T>>,\r\n  ): Promise<boolean> {\r\n    validate();\r\n    try {\r\n      const results = await doQuery();\r\n      if (results.rowCount === 0) {\r\n        throw new DataIntegrityError(\r\n          `Failed to delete from ${this.tableName}`,\r\n          {\r\n            table: this.tableName,\r\n          },\r\n        );\r\n      }\r\n      log((l) =>\r\n        l.verbose({\r\n          message: `[[AUDIT]] -  ${this.tableName} deleted a record.`,\r\n        }),\r\n      );\r\n      return true;\r\n    } catch (error) {\r\n      if (!AbstractObjectRepository.logDatabaseError(this.source, error)) {\r\n        throw error;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\attachment\\auto-drizzle-repository.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":89,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseDrizzleRepository } from '../_baseDrizzleRepository';\r\nimport { EmailAttachment } from '@/data-models/api/attachment';\r\nimport { emailAttachments } from '@/drizzle/schema';\r\n\r\n/**\r\n * Maps a database record to an EmailAttachment domain object\r\n */\r\nconst mapRecordToEmailAttachment = (\r\n  record: Record<string, unknown>,\r\n): EmailAttachment => ({\r\n  attachmentId: record.attachmentId as number,\r\n  fileName: record.fileName as string,\r\n  filePath: record.filePath as string,\r\n  extractedText: (record.extractedText as string) || null,\r\n  extractedTextTsv: null, // Not supported in Drizzle schema yet\r\n  policyId: (record.policyId as number) || null,\r\n  summary: (record.summary as string) || null,\r\n  emailId: record.emailId as string,\r\n  mimeType: record.mimeType as string,\r\n  size: record.size as number,\r\n});\r\n\r\n/**\r\n * Maps a database record to a partial EmailAttachment (summary view)\r\n */\r\nconst mapRecordToEmailAttachmentSummary = (\r\n  record: Record<string, unknown>,\r\n): Partial<EmailAttachment> => ({\r\n  attachmentId: record.attachmentId as number,\r\n  fileName: record.fileName as string,\r\n  filePath: record.filePath as string,\r\n  policyId: (record.policyId as number) || null,\r\n  emailId: record.emailId as string,\r\n  mimeType: record.mimeType as string,\r\n  size: record.size as number,\r\n});\r\n\r\n/**\r\n * Example repository demonstrating auto-detection of primary key column and field.\r\n * This shows how idColumn and idField can be automatically inferred from the table schema.\r\n */\r\nexport class EmailAttachmentAutoDrizzleRepository extends BaseDrizzleRepository<\r\n  EmailAttachment,\r\n  'attachmentId'\r\n> {\r\n  constructor() {\r\n    super({\r\n      table: emailAttachments,\r\n      // No idColumn or idField specified - they will be auto-detected!\r\n      // The primary key column 'attachment_id' will be detected and mapped to field 'attachmentId'\r\n      recordMapper: mapRecordToEmailAttachment,\r\n      summaryMapper: mapRecordToEmailAttachmentSummary,\r\n      tableName: 'email_attachments',\r\n    });\r\n  }\r\n\r\n  protected prepareInsertData(\r\n    model: Omit<EmailAttachment, 'attachmentId'>,\r\n  ): Record<string, unknown> {\r\n    return {\r\n      fileName: model.fileName,\r\n      filePath: model.filePath,\r\n      extractedText: model.extractedText || null,\r\n      policyId: model.policyId || null,\r\n      summary: model.summary || null,\r\n      emailId: model.emailId,\r\n      mimeType: model.mimeType,\r\n      size: model.size,\r\n    };\r\n  }\r\n\r\n  protected prepareUpdateData(\r\n    model: Partial<EmailAttachment>,\r\n  ): Record<string, unknown> {\r\n    const updateData: Record<string, unknown> = {};\r\n\r\n    if (model.fileName !== undefined) updateData.fileName = model.fileName;\r\n    if (model.filePath !== undefined) updateData.filePath = model.filePath;\r\n    if (model.extractedText !== undefined)\r\n      updateData.extractedText = model.extractedText;\r\n    if (model.policyId !== undefined) updateData.policyId = model.policyId;\r\n    if (model.summary !== undefined) updateData.summary = model.summary;\r\n    if (model.mimeType !== undefined) updateData.mimeType = model.mimeType;\r\n    if (model.size !== undefined) updateData.size = model.size;\r\n\r\n    return updateData;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\attachment\\download-url-builder.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":70,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { EmailAttachment } from '@/data-models/api/attachment';\r\nimport { EmailAttachmentType } from '@/lib/drizzle-db';\r\nimport { env } from '@/lib/site-util/env';\r\nimport {\r\n  AccountSASPermissions,\r\n  AccountSASResourceTypes,\r\n  AccountSASServices,\r\n  generateAccountSASQueryParameters,\r\n  SASProtocol,\r\n  StorageSharedKeyCredential,\r\n} from '@azure/storage-blob';\r\nimport { URL } from 'url';\r\n\r\ninterface AttachmentDownloadUrlBuilderOverloads {\r\n  (attachment: EmailAttachment): URL;\r\n  (attachment: EmailAttachmentType): URL;\r\n}\r\n\r\nlet _sasKey: string | undefined = undefined;\r\nconst getSasKey = (): string => {\r\n  if (_sasKey === undefined) {\r\n    const sasOptions = {\r\n      services: AccountSASServices.parse('b').toString(), // blobs, tables, queues, files\r\n      resourceTypes: AccountSASResourceTypes.parse('sco').toString(), // service, container, object\r\n      permissions: AccountSASPermissions.parse('r'), // permissions\r\n      protocol: SASProtocol.Https,\r\n      startsOn: new Date(),\r\n      expiresOn: new Date(new Date().valueOf() + 3 * 60 * 60 * 1000), // 3 hours\r\n    };\r\n\r\n    const sasToken = generateAccountSASQueryParameters(\r\n      sasOptions,\r\n      new StorageSharedKeyCredential(\r\n        env('AZURE_STORAGE_ACCOUNT_NAME'),\r\n        env('AZURE_STORAGE_ACCOUNT_KEY'),\r\n      ),\r\n    ).toString();\r\n    _sasKey = sasToken[0] === '?' ? sasToken : `?${sasToken}`;\r\n  }\r\n  return _sasKey;\r\n};\r\n\r\n/**\r\n * Builds a download URL for an email attachment.\r\n *\r\n * This function supports multiple input types:\r\n//  * - If given a number, it treats it as an attachment ID, fetches the corresponding `EmailAttachment` from the database,\r\n *   and recursively builds the download URL.\r\n * - If given an `EmailAttachment` object (with a `filePath` property), it generates a download URL using the file path and a SAS key.\r\n *\r\n * @param input - The attachment identifier, which can be either:\r\n *   - A number representing the attachment ID,\r\n *   - An `EmailAttachment` object,\r\n *   - Or an `EmailAttachmentType`.\r\n * @returns A `Promise<URL>` representing the download URL for the attachment.\r\n * @throws If the attachment is not found, the file path is missing, or the input type is invalid.\r\n */\r\nexport const buildAttachmentDownloadUrl: AttachmentDownloadUrlBuilderOverloads =\r\n  (input: EmailAttachment | EmailAttachmentType) => {\r\n    if (!!input && 'filePath' in input) {\r\n      const filePath = input.filePath;\r\n      if (!filePath) {\r\n        throw new Error('Attachment file path is missing');\r\n      }\r\n      const key = getSasKey();\r\n      return new URL(`${input.filePath}${key}`);\r\n    }\r\n    throw new Error('Invalid input type. Expected EmailAttachment object.');\r\n  };\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\attachment\\drizzle-repository.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":146,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'attachmentId' is assigned a value but never used.","line":133,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":133,"endColumn":25,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'emailId' is assigned a value but never used.","line":133,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":133,"endColumn":34,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'extractedTextTsv' is assigned a value but never used.","line":133,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":133,"endColumn":52,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseDrizzleRepository } from '../_baseDrizzleRepository';\r\nimport { EmailAttachment } from '@/data-models/api/attachment';\r\nimport { emailAttachments } from '@/drizzle/schema';\r\nimport { ValidationError } from '@/lib/react-util/errors/validation-error';\r\n\r\n/**\r\n * Maps a database record to an EmailAttachment domain object\r\n */\r\nconst mapRecordToEmailAttachment = (\r\n  record: Record<string, unknown>,\r\n): EmailAttachment => ({\r\n  attachmentId: record.attachmentId as number,\r\n  fileName: record.fileName as string,\r\n  filePath: record.filePath as string,\r\n  extractedText: (record.extractedText as string) || null,\r\n  extractedTextTsv: null, // Not supported in Drizzle schema yet\r\n  policyId: (record.policyId as number) || null,\r\n  summary: (record.summary as string) || null,\r\n  emailId: record.emailId as string,\r\n  mimeType: record.mimeType as string,\r\n  size: record.size as number,\r\n});\r\n\r\n/**\r\n * Maps a database record to a partial EmailAttachment (summary view)\r\n */\r\nconst mapRecordToEmailAttachmentSummary = (\r\n  record: Record<string, unknown>,\r\n): Partial<EmailAttachment> => ({\r\n  attachmentId: record.attachmentId as number,\r\n  fileName: record.fileName as string,\r\n  filePath: record.filePath as string,\r\n  policyId: (record.policyId as number) || null,\r\n  emailId: record.emailId as string,\r\n  mimeType: record.mimeType as string,\r\n  size: record.size as number,\r\n});\r\n\r\n/**\r\n * EmailAttachmentDrizzleRepository provides Drizzle ORM-based data access\r\n * for email attachment records in a flattened format suitable for REST API consumption.\r\n *\r\n * This repository matches the output format of the existing SQL-based implementation\r\n * while leveraging Drizzle's type-safe query capabilities.\r\n */\r\nexport class EmailAttachmentDrizzleRepository extends BaseDrizzleRepository<\r\n  EmailAttachment,\r\n  'attachmentId'\r\n> {\r\n  constructor() {\r\n    super({\r\n      table: emailAttachments,\r\n      recordMapper: mapRecordToEmailAttachment,\r\n      summaryMapper: mapRecordToEmailAttachmentSummary,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Validates email attachment data for repository operations\r\n   */\r\n  protected validate<TMethod extends keyof EmailAttachmentDrizzleRepository>(\r\n    method: TMethod,\r\n    obj: Record<string, unknown>,\r\n  ): void {\r\n    super.validate(method, obj);\r\n\r\n    const asModel = obj as EmailAttachment;\r\n\r\n    switch (method) {\r\n      case 'create':\r\n        if (!asModel.fileName || !asModel.filePath || !asModel.emailId) {\r\n          throw new ValidationError({\r\n            field: 'fileName, filePath, or emailId',\r\n            source: 'EmailAttachmentDrizzleRepository',\r\n          });\r\n        }\r\n        if (!asModel.mimeType || typeof asModel.size !== 'number') {\r\n          throw new ValidationError({\r\n            field: 'mimeType or size',\r\n            source: 'EmailAttachmentDrizzleRepository',\r\n          });\r\n        }\r\n        break;\r\n\r\n      case 'update':\r\n        if (!asModel.attachmentId) {\r\n          throw new ValidationError({\r\n            field: 'attachmentId',\r\n            source: 'EmailAttachmentDrizzleRepository',\r\n          });\r\n        }\r\n        break;\r\n\r\n      case 'get':\r\n      case 'delete':\r\n        if (!obj[this.idField]) {\r\n          throw new ValidationError({\r\n            field: String(this.idField),\r\n            source: 'EmailAttachmentDrizzleRepository',\r\n          });\r\n        }\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Prepares EmailAttachment data for database insertion\r\n   */\r\n  protected prepareInsertData(\r\n    model: Omit<EmailAttachment, 'attachmentId'>,\r\n  ): Record<string, unknown> {\r\n    return {\r\n      fileName: model.fileName,\r\n      filePath: model.filePath,\r\n      extractedText: model.extractedText || null,\r\n      // Note: extractedTextTsv is not included as it's not supported in the Drizzle schema yet\r\n      policyId: model.policyId || null,\r\n      summary: model.summary || null,\r\n      emailId: model.emailId,\r\n      mimeType: model.mimeType,\r\n      size: model.size,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Prepares EmailAttachment data for database updates\r\n   */\r\n  protected prepareUpdateData(\r\n    model: Partial<EmailAttachment>,\r\n  ): Record<string, unknown> {\r\n    // Exclude non-updatable fields and fields not in database schema\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    const { attachmentId, emailId, extractedTextTsv, ...updateFields } = model;\r\n\r\n    // Filter out undefined values to only include fields being updated\r\n    const updateData: Record<string, unknown> = {};\r\n    Object.entries(updateFields).forEach(([key, value]) => {\r\n      if (value !== undefined) {\r\n        updateData[key] = value;\r\n      }\r\n    });\r\n\r\n    return updateData;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\attachment\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\contacts\\database.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\document-unit\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":347,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseObjectRepository } from '../_baseObjectRepository';\r\nimport { ObjectRepository } from '../_types';\r\nimport { ValidationError } from '@/lib/react-util/errors/validation-error';\r\nimport { FirstParameter } from '@/lib/typescript';\r\nimport {\r\n  DocumentUnit,\r\n  DocumentUnitSummary,\r\n  isDocumentUnitType,\r\n} from '@/data-models/api/document-unit';\r\nimport {\r\n  AccountSASPermissions,\r\n  AccountSASResourceTypes,\r\n  AccountSASServices,\r\n  generateAccountSASQueryParameters,\r\n  SASProtocol,\r\n  StorageSharedKeyCredential,\r\n} from '@azure/storage-blob';\r\nimport { env } from '@/lib/site-util/env';\r\n\r\n/**\r\n * Repository for managing `DocumentUnit` objects.\r\n */\r\nexport class DocumentUnitRepository extends BaseObjectRepository<\r\n  DocumentUnit,\r\n  'unitId'\r\n> {\r\n  #sasKey: string | undefined = undefined;\r\n  #generateDownloadKey: boolean = false;\r\n  #pendingEmbed: boolean = false;\r\n  /**\r\n   * Initializes a new instance of the `DocumentUnitsRepository` class.\r\n   */\r\n  constructor({\r\n    generateDownloadKey = false,\r\n    alwaysReturnContent = false,\r\n    pendingEmbed = false,\r\n  }: {\r\n    generateDownloadKey?: boolean;\r\n    alwaysReturnContent?: boolean;\r\n    pendingEmbed?: boolean;\r\n  } = {}) {\r\n    super({\r\n      tableName: 'document_units',\r\n      idField: ['unitId', 'unit_id'],\r\n      objectMap: 'mapToDocumentUnit',\r\n      summaryMap:\r\n        (alwaysReturnContent ?? false)\r\n          ? 'mapToDocumentUnit'\r\n          : 'mapToDocumentUnitSummary',\r\n    });\r\n    this.#generateDownloadKey = generateDownloadKey ?? false;\r\n    this.#pendingEmbed = pendingEmbed ?? false;\r\n  }\r\n  protected get SasKey(): string {\r\n    if (!this.#generateDownloadKey) {\r\n      return '';\r\n    }\r\n    if (this.#sasKey === undefined) {\r\n      const sasOptions = {\r\n        services: AccountSASServices.parse('b').toString(), // blobs, tables, queues, files\r\n        resourceTypes: AccountSASResourceTypes.parse('sco').toString(), // service, container, object\r\n        permissions: AccountSASPermissions.parse('r'), // permissions\r\n        protocol: SASProtocol.Https,\r\n        startsOn: new Date(),\r\n        expiresOn: new Date(new Date().valueOf() + 3 * 60 * 60 * 1000), // 3 hours\r\n      };\r\n\r\n      const sasToken = generateAccountSASQueryParameters(\r\n        sasOptions,\r\n        new StorageSharedKeyCredential(\r\n          env('AZURE_STORAGE_ACCOUNT_NAME'),\r\n          env('AZURE_STORAGE_ACCOUNT_KEY'),\r\n        ),\r\n      ).toString();\r\n      this.#sasKey = sasToken[0] === '?' ? sasToken : `?${sasToken}`;\r\n    }\r\n    return this.#sasKey;\r\n  }\r\n\r\n  /**\r\n   * Validates a `DocumentUnit` object based on the specified method.\r\n   *\r\n   * @param method - The repository method being invoked (e.g., 'create', 'update').\r\n   * @param obj - The object to validate.\r\n   * @throws {ValidationError} If validation fails.\r\n   */\r\n  validate<TMethod extends keyof ObjectRepository<DocumentUnit, 'unitId'>>(\r\n    method: TMethod,\r\n    obj: FirstParameter<\r\n      Pick<ObjectRepository<DocumentUnit, 'unitId'>, TMethod>[TMethod]\r\n    >,\r\n  ): void {\r\n    switch (method) {\r\n      case 'create':\r\n        break;\r\n      case 'get':\r\n      case 'delete':\r\n        if (Array.isArray(obj)) {\r\n          if (obj.length < 1 || isNaN(Number.parseInt(obj[0]))) {\r\n            throw new ValidationError({\r\n              field: 'unitId',\r\n              value: obj,\r\n              source: 'DocumentUnitsRepository',\r\n            });\r\n          }\r\n        } else if (isNaN(Number.parseInt(String(obj)))) {\r\n          throw new ValidationError({\r\n            field: 'unitId',\r\n            value: obj,\r\n            source: 'DocumentUnitsRepository',\r\n          });\r\n        }\r\n        break;\r\n      case 'create':\r\n        const asCreateModel = obj as DocumentUnit;\r\n        if (!isDocumentUnitType(asCreateModel.documentType)) {\r\n          throw new ValidationError({\r\n            field: 'documentType',\r\n            value: asCreateModel.documentType,\r\n            source: 'DocumentUnitsRepository',\r\n          });\r\n        }\r\n        if (!asCreateModel.content) {\r\n          throw new ValidationError({\r\n            field: 'content',\r\n            source: 'DocumentUnitsRepository',\r\n          });\r\n        }\r\n        break;\r\n      default:\r\n        const asModel = obj as DocumentUnit;\r\n        if (asModel.documentType && !isDocumentUnitType(asModel.documentType)) {\r\n          throw new ValidationError({\r\n            field: 'documentType',\r\n            value: asModel.documentType,\r\n            source: 'DocumentUnitsRepository',\r\n          });\r\n        }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves the query properties for listing `DocumentUnit` records.\r\n   *\r\n   * @returns A tuple containing the SQL query, parameters, and count query.\r\n   */\r\n  protected getListQueryProperties(): [string, Array<unknown>, string] {\r\n    const wherePendingEmbed = this.#pendingEmbed\r\n      ? ' WHERE du.embedded_on IS NULL'\r\n      : '';\r\n    return [\r\n      `SELECT du.*, ea.file_path, e.thread_id,\r\n  ARRAY(\r\n    SELECT e.email_id\r\n    FROM document_property ep\r\n    JOIN emails e ON ep.property_value = e.global_message_id\r\n    WHERE ep.email_id = du.email_id\r\n      AND ep.document_property_type_id = 22\r\n  ) AS related_email_ids,\r\n  (\r\n    SELECT e.email_id\r\n    FROM document_property ep\r\n    JOIN emails e ON ep.property_value = e.global_message_id\r\n    WHERE ep.email_id = du.email_id\r\n      AND ep.document_property_type_id = 26\r\n  ) AS parent_email_id\r\n    FROM document_units du\r\n    LEFT JOIN email_attachments ea ON du.attachment_id = ea.attachment_id\r\n    LEFT JOIN emails e ON du.email_id = e.email_id\r\n    ${wherePendingEmbed} \r\n    ORDER BY du.unit_id`.toString(),\r\n      [],\r\n      `SELECT COUNT(*) as records FROM document_units du ${wherePendingEmbed}`.toString(),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Retrieves the query properties for fetching a specific `DocumentUnit` record.\r\n   *\r\n   * @param recordId - The ID of the record to fetch.\r\n   * @returns A tuple containing the SQL query and parameters.\r\n   */\r\n  protected getQueryProperties(recordId: number): [string, Array<unknown>] {\r\n    return [\r\n      `SELECT du.*, ea.file_path, e.thread_id,\r\n  ARRAY(\r\n    SELECT e.email_id\r\n    FROM document_property ep\r\n    JOIN emails e ON ep.property_value = e.global_message_id\r\n    WHERE ep.email_id = du.email_id\r\n      AND ep.document_property_type_id = 22\r\n  ) AS related_email_ids,\r\n  (\r\n    SELECT e.email_id\r\n    FROM document_property ep\r\n    JOIN emails e ON ep.property_value = e.global_message_id\r\n    WHERE ep.email_id = du.email_id\r\n      AND ep.document_property_type_id = 26\r\n  ) AS parent_email_id\r\n    FROM document_units du\r\n    LEFT JOIN emails e ON du.email_id = e.email_id\r\n    LEFT JOIN email_attachments ea ON du.attachment_id = ea.attachment_id WHERE unit_id = $1`,\r\n      [recordId],\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Retrieves the query properties for creating a new `DocumentUnit` record.\r\n   *\r\n   * @param documentUnit - The `DocumentUnit` object to create.\r\n   * @returns A tuple containing the SQL query and parameters.\r\n   */\r\n  protected getCreateQueryProperties({\r\n    emailId,\r\n    attachmentId,\r\n    emailPropertyId,\r\n    content,\r\n    documentType,\r\n    embeddingModel,\r\n  }: DocumentUnit): [string, Array<unknown>] {\r\n    return [\r\n      `INSERT INTO document_units (email_id, attachment_id, email_property_id, content, document_type, embedding_model) \r\n       VALUES ($1, $2, $3, $4, $5, $6) RETURNING *`,\r\n      [\r\n        emailId,\r\n        attachmentId,\r\n        emailPropertyId,\r\n        content,\r\n        documentType,\r\n        embeddingModel,\r\n      ],\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Retrieves the query properties for updating an existing `DocumentUnit` record.\r\n   *\r\n   * @param documentUnit - The `DocumentUnit` object to update.\r\n   * @returns An array containing the updated fields and their values.\r\n   */\r\n  protected getUpdateQueryProperties({\r\n    content,\r\n    documentType,\r\n    embeddingModel,\r\n    embeddedOn,\r\n  }: DocumentUnit): [Record<string, unknown>] {\r\n    return [\r\n      {\r\n        content,\r\n        document_type: documentType,\r\n        embedding_model: embeddingModel,\r\n        embedded_on: embeddedOn,\r\n      },\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Maps a record object to a `DocumentUnitSummary` object.\r\n   *\r\n   * @param record - A record object containing key-value pairs representing the document unit data.\r\n   * @returns A `DocumentUnitSummary` object with the mapped properties.\r\n   *\r\n   * - `unitId`: The unit ID, converted to a number.\r\n   * - `emailId`: The email ID, converted to a string if present, otherwise `null`.\r\n   * - `attachmentId`: The attachment ID, converted to a number if present, otherwise `null`.\r\n   * - `emailPropertyId`: The email property ID, converted to a string if present, otherwise `null`.\r\n   * - `documentType`: The document type, cast to the `DocumentUnit['documentType']` type.\r\n   * - `createdOn`: The creation date, converted to a `Date` object.\r\n   */\r\n  mapToDocumentUnitSummary = (\r\n    record: Record<string, unknown>,\r\n  ): DocumentUnitSummary => {\r\n    const ret: DocumentUnitSummary = {\r\n      unitId: Number(record.unit_id),\r\n      emailId: record.email_id ? String(record.email_id) : null,\r\n      attachmentId: record.attachment_id ? Number(record.attachment_id) : null,\r\n      emailPropertyId: record.email_property_id\r\n        ? String(record.email_property_id)\r\n        : null,\r\n      threadId: record.thread_id ? Number(record.thread_id) : 0,\r\n      relatedEmailIds: record.related_email_ids\r\n        ? (record.related_email_ids as string[])\r\n        : [],\r\n      documentType: String(\r\n        record.document_type,\r\n      ) as DocumentUnit['documentType'],\r\n      createdOn: new Date(String(record.created_on)),\r\n      parentEmailId: record.parent_email_id\r\n        ? String(record.parent_email_id)\r\n        : null,\r\n      embeddingModel: record.embedding_model\r\n        ? String(record.embedding_model)\r\n        : null,\r\n      embeddedOn: new Date(String(record.embedded_on)),\r\n    };\r\n    switch (ret.documentType) {\r\n      case 'email':\r\n        ret.hrefDocument = `${env('NEXT_PUBLIC_HOSTNAME')}/api/email/${ret.emailId}`;\r\n        ret.hrefApi = `${env('NEXT_PUBLIC_HOSTNAME')}/api/email/${ret.emailId}`;\r\n        break;\r\n      case 'attachment':\r\n        ret.hrefDocument = record.file_path\r\n          ? `${record.file_path}${this.SasKey}`\r\n          : undefined;\r\n        ret.hrefApi = `${env('NEXT_PUBLIC_HOSTNAME')}/api/attachment/${ret.attachmentId}`;\r\n        break;\r\n      case 'note':\r\n        ret.hrefDocument = `${env('NEXT_PUBLIC_HOSTNAME')}/api/email/${ret.emailId}/properties/${ret.emailPropertyId}`;\r\n        ret.hrefApi = `${env('NEXT_PUBLIC_HOSTNAME')}/api/email/${ret.emailId}/properties/${ret.emailPropertyId}`;\r\n        break;\r\n      case 'key_point':\r\n        ret.hrefDocument = `${env('NEXT_PUBLIC_HOSTNAME')}/api/email/${ret.emailId}/properties/key-points/${ret.emailPropertyId}`;\r\n        ret.hrefApi = `${env('NEXT_PUBLIC_HOSTNAME')}/api/email/${ret.emailId}/properties/key-points/${ret.emailPropertyId}`;\r\n        break;\r\n      case 'cta':\r\n        ret.hrefDocument = `${env('NEXT_PUBLIC_HOSTNAME')}/api/email/${ret.emailId}/properties/call-to-action/${ret.emailPropertyId}`;\r\n        ret.hrefApi = `${env('NEXT_PUBLIC_HOSTNAME')}/api/email/${ret.emailId}/properties/call-to-action/${ret.emailPropertyId}`;\r\n        break;\r\n      case 'sentiment':\r\n        ret.hrefDocument = `${env('NEXT_PUBLIC_HOSTNAME')}/api/email/${ret.emailId}/properties/sentiment-analysis/${ret.emailPropertyId}`;\r\n        ret.hrefApi = `${env('NEXT_PUBLIC_HOSTNAME')}/api/email/${ret.emailId}/properties/sentiment-analysis/${ret.emailPropertyId}`;\r\n        break;\r\n      case 'compliance':\r\n        ret.hrefDocument = `${env('NEXT_PUBLIC_HOSTNAME')}/api/email/${ret.emailId}/properties/compliance-scores/${ret.emailPropertyId}`;\r\n        ret.hrefApi = `${env('NEXT_PUBLIC_HOSTNAME')}/api/email/${ret.emailId}/properties/compliance-scores/${ret.emailPropertyId}`;\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n    return ret;\r\n  };\r\n\r\n  /**\r\n   * Maps a record object to a `DocumentUnit` object.\r\n   *\r\n   * @param record - A record object containing key-value pairs representing the document unit data.\r\n   * @returns A `DocumentUnit` object with the mapped properties.\r\n   */\r\n  mapToDocumentUnit = (record: Record<string, unknown>): DocumentUnit => {\r\n    const ret = this.mapToDocumentUnitSummary(record);\r\n    return {\r\n      ...ret,\r\n      content: String(record.content),\r\n    };\r\n  };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\drizzle-crud-controller.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":298,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":31,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1558,1561],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1558,1561],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":31,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":59,"suggestions":[{"messageId":"suggestPropertyKey","fix":{"range":[1563,1572],"text":"PropertyKey"},"desc":"Use `PropertyKey` instead, this is more explicit than `keyof any`."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":35,"column":5,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":8,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1743,1746],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1743,1746],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":7,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":10,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1848,1851],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1848,1851],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1915,1918],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1915,1918],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":7,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":10,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2016,2019],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2016,2019],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":5,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":8,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2163,2166],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2163,2166],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":50,"column":7,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":10,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2288,2291],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2288,2291],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":50,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2336,2339],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2336,2339],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":7,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":10,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2452,2455],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2452,2455],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { BaseDrizzleRepository } from './_baseDrizzleRepository';\r\nimport { PickField } from '@/lib/typescript';\r\nimport { LikeNextRequest } from '@/lib/nextjs-util/types';\r\nimport { isRequestOrApiRequest } from '@/lib/nextjs-util/guards';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { PaginatedResultset } from '@/data-models/_types';\r\nimport type { PaginationStats } from '@/data-models/_types';\r\nimport { GridSortModel, GridFilterModel } from '@mui/x-data-grid-pro';\r\nimport { PaginatedGridListRequest } from '../components/mui/data-grid';\r\nimport { parsePaginationStats } from '@/lib/components/mui/data-grid/queryHelpers/utility';\r\n\r\ntype KeysFromModel<\r\n  TRepositoryModel,\r\n  TRepositoryKey extends keyof TRepositoryModel,\r\n> = {\r\n  [key in TRepositoryKey]: PickField<TRepositoryModel, key>;\r\n};\r\n\r\n/**\r\n * DrizzleCrudRepositoryController provides REST API endpoints for any BaseDrizzleRepository implementation.\r\n * It handles HTTP requests and delegates to the repository for data operations while providing\r\n * consistent error handling and response formatting.\r\n *\r\n * @template TRepository - The specific DrizzleRepository implementation\r\n * @template TRepositoryModel - The domain model type managed by the repository\r\n * @template TRepositoryKey - The primary key field of the domain model\r\n */\r\nexport class DrizzleCrudRepositoryController<\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  TRepository extends BaseDrizzleRepository<any, keyof any>,\r\n  TRepositoryModel extends TRepository extends BaseDrizzleRepository<\r\n    infer TInferModel,\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    any\r\n  >\r\n    ? TInferModel\r\n    : // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      any = TRepository extends BaseDrizzleRepository<infer TInferModel, any>\r\n    ? TInferModel\r\n    : // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      any,\r\n  TRepositoryKey extends TRepository extends BaseDrizzleRepository<\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    any,\r\n    infer TInferKey\r\n  >\r\n    ? TInferKey\r\n    : // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      any = TRepository extends BaseDrizzleRepository<any, infer TInferKey>\r\n    ? TInferKey\r\n    : // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      any,\r\n> {\r\n  constructor(private repository: TRepository) {}\r\n\r\n  /**\r\n   * Handles GET requests for listing resources with optional pagination\r\n   */\r\n  async list(): Promise<\r\n    NextResponse<\r\n      PaginatedResultset<Partial<TRepositoryModel>> | { error: string }\r\n    >\r\n  >;\r\n  async list(\r\n    ops: PaginationStats,\r\n    sort?: GridSortModel,\r\n    filter?: GridFilterModel,\r\n  ): Promise<\r\n    NextResponse<\r\n      PaginatedResultset<Partial<TRepositoryModel>> | { error: string }\r\n    >\r\n  >;\r\n  async list(\r\n    req: LikeNextRequest,\r\n  ): Promise<\r\n    NextResponse<\r\n      PaginatedResultset<Partial<TRepositoryModel>> | { error: string }\r\n    >\r\n  >;\r\n\r\n  async list(\r\n    ops?: LikeNextRequest | PaginatedGridListRequest,\r\n  ): Promise<\r\n    NextResponse<\r\n      PaginatedResultset<Partial<TRepositoryModel>> | { error: string }\r\n    >\r\n  > {\r\n    let pagination: PaginatedGridListRequest & { offset?: number };\r\n    if (isRequestOrApiRequest(ops)) {\r\n      const thisUrl = new URL(ops.url!);\r\n      pagination = ops.url\r\n        ? parsePaginationStats(thisUrl)\r\n        : { page: 1, num: 10, total: 0 };\r\n    } else if (ops) {\r\n      pagination = {\r\n        page: ops.page ?? 1,\r\n        num: ops.num ?? 10,\r\n        filter: ops.filter,\r\n        sort: ops.sort,\r\n        total: ops.total ?? 0,\r\n      };\r\n    } else {\r\n      pagination = { page: 1, num: 10, total: 0 };\r\n    }\r\n\r\n    try {\r\n      const result = await this.repository.list(pagination);\r\n      return NextResponse.json(result, { status: 200 });\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'DrizzleCrudRepositoryController::list',\r\n      });\r\n      return NextResponse.json(\r\n        { error: 'Internal Server Error' },\r\n        { status: 500 },\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles GET requests for retrieving a single resource by ID\r\n   */\r\n  async get(\r\n    req: NextRequest,\r\n    args: {\r\n      params: Promise<KeysFromModel<TRepositoryModel, TRepositoryKey>>;\r\n    },\r\n  ): Promise<\r\n    NextResponse<TRepositoryModel | { success: false; error: string }>\r\n  > {\r\n    try {\r\n      const params = await args.params;\r\n      const keys = Object.keys(params);\r\n      if (keys.length !== 1) {\r\n        return NextResponse.json(\r\n          { success: false, error: 'Invalid parameters' },\r\n          { status: 400 },\r\n        );\r\n      }\r\n\r\n      const idValue = params[keys[0] as TRepositoryKey];\r\n      const record = await this.repository.get(idValue);\r\n\r\n      if (!record) {\r\n        return NextResponse.json(\r\n          { success: false, error: 'Record not found' },\r\n          { status: 404 },\r\n        );\r\n      }\r\n\r\n      return NextResponse.json(record, { status: 200 });\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'DrizzleCrudRepositoryController::get',\r\n      });\r\n      return NextResponse.json(\r\n        { success: false, error: 'Internal Server Error' },\r\n        { status: 500 },\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles POST requests for creating new resources\r\n   */\r\n  async create(\r\n    req: NextRequest,\r\n  ): Promise<\r\n    NextResponse<TRepositoryModel | { success: false; error: string }>\r\n  > {\r\n    try {\r\n      const body = await req.json();\r\n      const newRecord = await this.repository.create(body);\r\n      return NextResponse.json(newRecord, { status: 201 });\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'DrizzleCrudRepositoryController::create',\r\n      });\r\n      return NextResponse.json(\r\n        { success: false, error: 'Internal Server Error' },\r\n        { status: 500 },\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles PUT requests for updating existing resources\r\n   */\r\n  async update(\r\n    req: NextRequest,\r\n    args: {\r\n      params: Promise<KeysFromModel<TRepositoryModel, TRepositoryKey>>;\r\n    },\r\n  ): Promise<\r\n    NextResponse<TRepositoryModel | { success: false; error: string }>\r\n  > {\r\n    try {\r\n      const params = await args.params;\r\n      const body = await req.json();\r\n\r\n      const keys = Object.keys(params);\r\n      if (keys.length !== 1) {\r\n        return NextResponse.json(\r\n          { success: false, error: 'Invalid parameters' },\r\n          { status: 400 },\r\n        );\r\n      }\r\n\r\n      const idKey = keys[0] as TRepositoryKey;\r\n      const idValue = params[idKey];\r\n\r\n      // Ensure the ID is included in the update data\r\n      const updateData = { ...body, [idKey]: idValue };\r\n\r\n      const updatedRecord = await this.repository.update(updateData);\r\n      return NextResponse.json(updatedRecord, { status: 200 });\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'DrizzleCrudRepositoryController::update',\r\n      });\r\n      return NextResponse.json(\r\n        { success: false, error: 'Internal Server Error' },\r\n        { status: 500 },\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles DELETE requests for removing resources\r\n   */\r\n  async delete(\r\n    req: NextRequest,\r\n    args: {\r\n      params: Promise<KeysFromModel<TRepositoryModel, TRepositoryKey>>;\r\n    },\r\n  ): Promise<NextResponse<{ success: boolean; error?: string }>> {\r\n    try {\r\n      const params = await args.params;\r\n      const keys = Object.keys(params);\r\n      if (keys.length !== 1) {\r\n        return NextResponse.json(\r\n          { success: false, error: 'Invalid parameters' },\r\n          { status: 400 },\r\n        );\r\n      }\r\n\r\n      const idValue = params[keys[0] as TRepositoryKey];\r\n      const deleted = await this.repository.delete(idValue);\r\n\r\n      if (!deleted) {\r\n        return NextResponse.json(\r\n          { success: false, error: 'Record not found' },\r\n          { status: 404 },\r\n        );\r\n      }\r\n\r\n      return NextResponse.json({ success: true }, { status: 200 });\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'DrizzleCrudRepositoryController::delete',\r\n      });\r\n      return NextResponse.json(\r\n        { success: false, error: 'Internal Server Error' },\r\n        { status: 500 },\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Executes a custom operation using the repository\r\n   */\r\n  async updateFromRepository(\r\n    callback: (repository: TRepository) => Promise<TRepositoryModel>,\r\n  ): Promise<\r\n    NextResponse<TRepositoryModel | { success: false; error: string }>\r\n  > {\r\n    try {\r\n      const result = await callback(this.repository);\r\n      return NextResponse.json(result, { status: 200 });\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'DrizzleCrudRepositoryController::updateFromRepository',\r\n      });\r\n      return NextResponse.json(\r\n        { success: false, error: 'Internal Server Error' },\r\n        { status: 500 },\r\n      );\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\client.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":147,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type {\r\n  EmailMessageSummary,\r\n  EmailMessage,\r\n  EmailMessageStats,\r\n} from '@/data-models/api/email-message';\r\nimport type { PaginatedResultset, PaginationStats } from '@/data-models/_types';\r\nimport type { EmailSearchApiParams } from './types';\r\nimport siteMap from '@/lib/site-util/url-builder';\r\nimport {\r\n  apiRequestHelperFactory,\r\n  ApiRequestHelper,\r\n} from '@/lib/send-api-request';\r\nimport { ICancellablePromiseExt } from '@/lib/typescript';\r\n\r\nconst apiRequest = <TResult>(\r\n  cb: (api: ApiRequestHelper, builder: typeof siteMap.api.email) => TResult,\r\n): TResult => {\r\n  const apiHelper = apiRequestHelperFactory({ area: 'email' });\r\n  const builder = siteMap.api.email;\r\n  return cb(apiHelper, builder);\r\n};\r\n\r\n/**\r\n * Fetches a list of email messages.\r\n *\r\n * @returns {ICancellablePromiseExt<ReadonlyArray<EmailMessageSummary>>} A ICancellablePromiseExt that resolves to an array of email message summaries.\r\n */\r\nexport const getEmailList = ({\r\n  page,\r\n  num,\r\n}: Omit<PaginationStats, 'total'>): ICancellablePromiseExt<\r\n  ReadonlyArray<EmailMessageSummary>\r\n> =>\r\n  apiRequest((apiHelper, builder) =>\r\n    apiHelper.get<ReadonlyArray<EmailMessageSummary>>({\r\n      url: builder.page({ page, num }),\r\n      action: 'list',\r\n    }),\r\n  );\r\n\r\n/**\r\n * Fetches a specific email message by its ID.\r\n *\r\n * @param {number} id - The ID of the email message to fetch.\r\n * @returns {ICancellablePromiseExt<ReadonlyArray<EmailMessage>>} A ICancellablePromiseExt that resolves to the email message.\r\n */\r\nexport const getEmail = (id: string): ICancellablePromiseExt<EmailMessage> =>\r\n  apiRequest((apiHelper, builder) =>\r\n    apiHelper.get<EmailMessage>({\r\n      url: builder.page(id),\r\n      action: 'load',\r\n    }),\r\n  );\r\n\r\n/**\r\n * Creates a new email record.\r\n *\r\n * @param {Omit<EmailMessage, 'emailId'>} email - The email message data to create.\r\n * @returns {ICancellablePromiseExt<EmailMessage>} A ICancellablePromiseExt that resolves to the created email message.\r\n */\r\nexport const createEmailRecord = (\r\n  email: Omit<EmailMessage, 'emailId'>,\r\n): ICancellablePromiseExt<EmailMessage> =>\r\n  apiRequest((apiHelper, builder) =>\r\n    apiHelper.post<EmailMessage>({\r\n      url: builder.page(),\r\n      action: 'create',\r\n      input: email,\r\n    }),\r\n  );\r\n\r\n/**\r\n * Updates an existing email record.\r\n *\r\n * @param {EmailMessage} email - The email message data to update.\r\n * @returns {ICancellablePromiseExt<EmailMessage>} A ICancellablePromiseExt that resolves to the updated email message.\r\n */\r\nexport const updateEmailRecord = (\r\n  email: EmailMessage,\r\n): ICancellablePromiseExt<EmailMessage> =>\r\n  apiRequest((apiHelper, builder) =>\r\n    apiHelper.put<EmailMessage>({\r\n      url: builder.page(),\r\n      action: 'update',\r\n      input: email,\r\n    }),\r\n  );\r\n\r\n/**\r\n * Writes an email record. If the email has an `emailId` greater than 0, it updates the existing record.\r\n * Otherwise, it creates a new email record.\r\n *\r\n * @param email - The email message object. It omits the `emailId` property but allows it to be partially included.\r\n * @returns A cancellable promise that resolves to the email message.\r\n */\r\nexport const writeEmailRecord = (\r\n  email: Omit<EmailMessage, 'emailId'> & Partial<Pick<EmailMessage, 'emailId'>>,\r\n): ICancellablePromiseExt<EmailMessage> =>\r\n  (email.emailId ?? 0 > 0)\r\n    ? updateEmailRecord(email as EmailMessage)\r\n    : createEmailRecord(email);\r\n\r\n/**\r\n * Deletes an email record by its ID.\r\n *\r\n * @param {number} id - The ID of the email message to delete.\r\n * @returns {ICancellablePromiseExt<EmailMessageSummary>} A ICancellablePromiseExt that resolves to the summary of the deleted email message.\r\n */\r\nexport const deleteEmailRecord = (\r\n  id: number,\r\n): ICancellablePromiseExt<EmailMessageSummary> =>\r\n  apiRequest((apiHelper, builder) =>\r\n    apiHelper.delete<EmailMessageSummary>({\r\n      url: builder.page(id),\r\n      action: 'delete',\r\n    }),\r\n  );\r\n\r\n/**\r\n * Fetches email statistics.\r\n *\r\n * @returns {ICancellablePromiseExt<EmailMessageStats>} A ICancellablePromiseExt that resolves to the email message statistics.\r\n */\r\nexport const getEmailStats = (): ICancellablePromiseExt<EmailMessageStats> =>\r\n  apiRequest((apiHelper, builder) =>\r\n    apiHelper.get<EmailMessageStats>({\r\n      url: builder.stats(),\r\n      action: 'stats',\r\n    }),\r\n  );\r\n\r\n/**\r\n * Fetches email search results based on the provided search parameters.\r\n *\r\n * @param {EmailSearchApiParams} ops - The search parameters.\r\n * @returns {ICancellablePromiseExt<PaginatedResultset<EmailMessageSummary>>} A ICancellablePromiseExt that resolves to a paginated result set of email message summaries.\r\n */\r\nexport const getEmailSearchResults = (\r\n  ops: EmailSearchApiParams,\r\n): ICancellablePromiseExt<PaginatedResultset<EmailMessageSummary>> =>\r\n  apiRequest((apiHelper, builder) =>\r\n    apiHelper.get<PaginatedResultset<EmailMessageSummary>>({\r\n      url: builder.search(ops),\r\n      action: 'search',\r\n    }),\r\n  );\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\database.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":347,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":122,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":122,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3963,3966],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3963,3966],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":130,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":130,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4252,4255],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4252,4255],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ValidationError } from '@/lib/react-util/errors';\r\nimport { FirstParameter, newUuid } from '@/lib/typescript';\r\nimport { ObjectRepository } from '../_types';\r\nimport {\r\n  EmailMessageAttachment,\r\n  EmailMessageAttachmentSummary,\r\n  EmailMessageSummary,\r\n} from '@/data-models/api/email-message';\r\nimport { BaseObjectRepository } from '../_baseObjectRepository';\r\nimport { query } from '@/lib/neondb';\r\nimport { AbstractObjectRepository } from '../abstractObjectRepository';\r\nimport { db } from '@/lib/neondb';\r\n\r\ntype RepositoryEmailSummary = Omit<\r\n  EmailMessageSummary,\r\n  'sender' | 'recipients'\r\n> & { senderId: number };\r\n\r\ntype RepositoryEmail = RepositoryEmailSummary & {\r\n  emailContents: string;\r\n  documentId?: number;\r\n};\r\n\r\nconst mapRecordToSummary = (\r\n  record: Record<string, unknown>,\r\n): RepositoryEmailSummary => ({\r\n  emailId: record.email_id as string,\r\n  subject: record.subject as string,\r\n  sentOn: record.sent_timestamp as Date,\r\n  senderId: Number(record.sender_id),\r\n  globalMessageId: (record.global_message_id as string) ?? undefined,\r\n  parentEmailId: record.parent_email_id as string | null,\r\n  importedFromId: record.imported_from_id\r\n    ? (record.imported_from_id as string)\r\n    : null,\r\n  threadId: record.thread_id ? (record.thread_id as number) : undefined,\r\n});\r\n\r\nconst mapRecordToObject = (record: Record<string, unknown>) => ({\r\n  ...mapRecordToSummary(record),\r\n  senderId: Number(record.sender_id),\r\n  emailContents: record.email_contents as string,\r\n});\r\n\r\nexport class EmailRepository extends BaseObjectRepository<\r\n  RepositoryEmail,\r\n  'emailId'\r\n> {\r\n  constructor() {\r\n    super({\r\n      tableName: 'emails',\r\n      idField: 'emailId',\r\n      objectMap: mapRecordToObject,\r\n      summaryMap: mapRecordToSummary,\r\n    });\r\n  }\r\n\r\n  public async create(\r\n    props: Omit<RepositoryEmail, 'emailId'>,\r\n  ): Promise<RepositoryEmail> {\r\n    const ret = await super.create(props);\r\n    if (ret && ret.emailId) {\r\n      const importDate = props.sentOn ? new Date(props.sentOn) : new Date();\r\n      const res = await db(\r\n        (\r\n          sql,\r\n        ) => sql`INSERT INTO document_units (email_id, content, created_on, document_type)\r\n        VALUES (${ret.emailId}, ${props.emailContents}, ${importDate.toISOString()}, 'email')\r\n        returning unit_id`,\r\n      );\r\n      if (res.length < 1) {\r\n        throw new Error('Failed to create document unit');\r\n      }\r\n      ret.documentId = res[0].unit_id;\r\n    }\r\n    return ret;\r\n  }\r\n  /**\r\n   * Validates the input for a specific method.\r\n   *\r\n   * @template TMethod\r\n   * @param {TMethod} method - The method to validate.\r\n   * @param {FirstParameter<ObjectRepository<T, KId>[TMethod]>} obj - The input to validate.\r\n   */\r\n  validate<TMethod extends keyof ObjectRepository<RepositoryEmail, 'emailId'>>(\r\n    method: TMethod,\r\n    obj: FirstParameter<\r\n      Pick<ObjectRepository<RepositoryEmail, 'emailId'>, TMethod>[TMethod]\r\n    >,\r\n  ): void {\r\n    const asModel = obj as RepositoryEmail;\r\n    switch (method) {\r\n      case 'create':\r\n        if (!asModel.senderId || !asModel.subject || !asModel.emailContents) {\r\n          throw new ValidationError({\r\n            field: 'senderId||subject||emailContents',\r\n            source: 'EmailRepository',\r\n          });\r\n        }\r\n        break;\r\n      case 'update':\r\n        if (\r\n          !asModel.emailId ||\r\n          (!asModel.senderId &&\r\n            !asModel.subject &&\r\n            !asModel.globalMessageId &&\r\n            !asModel.importedFromId &&\r\n            !asModel.emailContents &&\r\n            !asModel.sentOn)\r\n        ) {\r\n          throw new ValidationError({\r\n            field: 'emailId||At least one field is required for update',\r\n            source: 'EmailRepository',\r\n          });\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  protected getListQueryProperties(): [string, Array<any>, string] {\r\n    return [\r\n      `SELECT * FROM emails ORDER BY sent_timestamp`,\r\n      [],\r\n      `SELECT COUNT(*) as records FROM emails`,\r\n    ];\r\n  }\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  protected getQueryProperties(emailId: string): [string, Array<any>] {\r\n    return ['SELECT * FROM emails WHERE email_id = $1', [emailId]];\r\n  }\r\n  protected getCreateQueryProperties(\r\n    obj: RepositoryEmail,\r\n  ): [\r\n    string,\r\n    [\r\n      string,\r\n      number,\r\n      number | null,\r\n      string | null,\r\n      string,\r\n      string,\r\n      string | null,\r\n      string | null,\r\n      string | Date | null,\r\n    ],\r\n  ] {\r\n    if (!obj.emailId) {\r\n      obj.emailId = newUuid();\r\n    }\r\n    return [\r\n      'INSERT INTO emails (email_id, sender_id, thread_id, parent_id, subject, email_contents, global_message_id, imported_from_id, sent_timestamp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING email_id',\r\n      [\r\n        obj.emailId,\r\n        obj.senderId,\r\n        obj.threadId ?? null,\r\n        obj.parentEmailId ?? null,\r\n        obj.subject,\r\n        obj.emailContents,\r\n        obj.globalMessageId ?? null,\r\n        obj.importedFromId ?? null,\r\n        !obj.sentOn\r\n          ? null\r\n          : typeof obj.sentOn === 'string'\r\n            ? obj.sentOn\r\n            : obj.sentOn.toISOString(),\r\n      ],\r\n    ];\r\n  }\r\n  protected getUpdateQueryProperties(\r\n    obj: RepositoryEmail,\r\n  ): [Record<string, unknown>] {\r\n    return [\r\n      {\r\n        sender_id: obj.senderId,\r\n        thread_id: obj.threadId,\r\n        parent_email_id: obj.parentEmailId,\r\n        subject: obj.subject,\r\n        email_contents: obj.emailContents,\r\n        sent_timestamp: obj.sentOn,\r\n        imported_from_id: obj.importedFromId,\r\n        global_message_id: obj.globalMessageId,\r\n      },\r\n    ];\r\n  }\r\n  async getIdForUniqueMessageId(\r\n    uniqueId: string | null,\r\n  ): Promise<string | null> {\r\n    if (!uniqueId) return null;\r\n    try {\r\n      const result = await query(\r\n        (sql) =>\r\n          sql`select email_id from emails where global_message_id = ${uniqueId}`,\r\n      );\r\n      return result.length === 1 ? (result[0].email_id as string) : null;\r\n    } catch (error) {\r\n      AbstractObjectRepository.logDatabaseError(this.source, error);\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\nconst mapAttachmentRecordToSummary = (\r\n  record: Record<string, unknown>,\r\n): EmailMessageAttachmentSummary => ({\r\n  attachmentId: record.attachment_id as number,\r\n  emailId: record.email_id as string,\r\n  fileName: record.file_name as string,\r\n  filePath: record.file_path as string,\r\n  size: record.size as number,\r\n  mimeType: record.mime_type as string,\r\n});\r\n\r\nconst mapAttachmentRecordToObject = (\r\n  record: Record<string, unknown>,\r\n): EmailMessageAttachment => ({\r\n  ...mapAttachmentRecordToSummary(record),\r\n  extractedText: record.extracted_text as string | null,\r\n  extractedTextVector: record.extracted_text_vector as string | null,\r\n  policyId: record.policy_id as number | null,\r\n  summary: record.summary as string | null,\r\n});\r\n\r\nexport class EmailAttachmentRepository extends BaseObjectRepository<\r\n  EmailMessageAttachment,\r\n  'attachmentId'\r\n> {\r\n  constructor() {\r\n    super({\r\n      tableName: 'email_attachments',\r\n      idField: 'attachmentId',\r\n      objectMap: mapAttachmentRecordToObject,\r\n      summaryMap: mapAttachmentRecordToSummary,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Validates the input for a specific method.\r\n   *\r\n   * @template TMethod\r\n   * @param {TMethod} method - The method to validate.\r\n   * @param {FirstParameter<ObjectRepository<T, KId>[TMethod]>} obj - The input to validate.\r\n   */\r\n  validate<\r\n    TMethod extends keyof ObjectRepository<\r\n      EmailMessageAttachment,\r\n      'attachmentId'\r\n    >,\r\n  >(\r\n    method: TMethod,\r\n    obj: FirstParameter<\r\n      Pick<\r\n        ObjectRepository<EmailMessageAttachment, 'attachmentId'>,\r\n        TMethod\r\n      >[TMethod]\r\n    >,\r\n  ): void {\r\n    const asModel = obj as EmailMessageAttachment;\r\n    switch (method) {\r\n      case 'create':\r\n        if (!asModel.fileName || !asModel.filePath || !asModel.emailId) {\r\n          throw new ValidationError({\r\n            field: 'fileName||filePath||emailId',\r\n            source: 'EmailAttachmentRepository',\r\n          });\r\n        }\r\n        break;\r\n      case 'update':\r\n        if (\r\n          !asModel.attachmentId ||\r\n          (!asModel.fileName &&\r\n            !asModel.filePath &&\r\n            !asModel.emailId &&\r\n            !asModel.extractedText &&\r\n            !asModel.extractedTextVector &&\r\n            !asModel.size &&\r\n            !asModel.mimeType &&\r\n            !asModel.policyId &&\r\n            !asModel.summary)\r\n        ) {\r\n          throw new ValidationError({\r\n            field: 'attachmentId||At least one field is required for update',\r\n            source: 'EmailAttachmentRepository',\r\n          });\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n  protected getQueryProperties(attachmentId: number): [string, Array<number>] {\r\n    return [\r\n      'SELECT * FROM email_attachments WHERE attachment_id = $1',\r\n      [attachmentId],\r\n    ];\r\n  }\r\n  protected getCreateQueryProperties(\r\n    obj: EmailMessageAttachment,\r\n  ): [\r\n    string,\r\n    [\r\n      string,\r\n      string,\r\n      string | null,\r\n      string | null,\r\n      number | null,\r\n      string | null,\r\n      string,\r\n      number,\r\n      string,\r\n    ],\r\n  ] {\r\n    return [\r\n      'INSERT INTO email_attachments (file_name, file_path, extracted_text, extracted_text_tsv, policy_id, summary, email_id, size, mime_type) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING email_id',\r\n      [\r\n        obj.fileName,\r\n        obj.filePath,\r\n        obj.extractedText,\r\n        obj.extractedTextVector,\r\n        obj.policyId,\r\n        obj.summary,\r\n        obj.emailId,\r\n        obj.size,\r\n        obj.mimeType,\r\n      ],\r\n    ];\r\n  }\r\n  protected getUpdateQueryProperties(\r\n    obj: EmailMessageAttachment,\r\n  ): [Record<string, string | number | null>] {\r\n    return [\r\n      {\r\n        file_name: obj.fileName,\r\n        file_path: obj.filePath,\r\n        extracted_text: obj.extractedText,\r\n        extracted_text_tsv: obj.extractedTextVector,\r\n        policy_id: obj.policyId,\r\n        summary: obj.summary,\r\n        email_id: obj.emailId,\r\n        size: obj.size,\r\n        mime_type: obj.mimeType,\r\n      },\r\n    ];\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\drizzle\\query-parts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\email-drizzle-repository.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":252,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseDrizzleRepository } from '../_baseDrizzleRepository';\r\nimport { emails } from '@/drizzle/schema';\r\nimport { drizDbWithInit } from '@/lib/drizzle-db';\r\nimport { ValidationError } from '@/lib/react-util/errors/validation-error';\r\nimport { eq } from 'drizzle-orm';\r\n\r\n/**\r\n * Base repository interface supports object repository implementation\r\n */\r\ntype BaseEmailDrizzleRepository = BaseDrizzleRepository<EmailDomain, 'emailId'>;\r\n\r\n/**\r\n * Domain model for Email entity used by the repository\r\n * This flattens the complex EmailMessage structure for database operations\r\n */\r\nexport type EmailDomain = {\r\n  /** Unique identifier of the email */\r\n  emailId: string;\r\n  /** ID of the sender contact */\r\n  senderId: number;\r\n  /** Email subject */\r\n  subject: string;\r\n  /** Email body content */\r\n  emailContents: string;\r\n  /** When the email was sent */\r\n  sentTimestamp: Date | string;\r\n  /** Thread ID if part of a conversation */\r\n  threadId?: number | null;\r\n  /** Parent email ID if this is a reply */\r\n  parentId?: string | null;\r\n  /** Import source identifier */\r\n  importedFromId?: string | null;\r\n  /** Global message identifier */\r\n  globalMessageId?: string | null;\r\n};\r\n\r\n/**\r\n * Maps a database record to an EmailDomain object\r\n *\r\n * @param record - Database record from Drizzle query\r\n * @returns Mapped EmailDomain object\r\n */\r\nconst mapRecordToEmailDomain = (\r\n  record: Record<string, unknown>,\r\n): EmailDomain => ({\r\n  emailId: record.emailId as string,\r\n  senderId: record.senderId as number,\r\n  subject: record.subject as string,\r\n  emailContents: record.emailContents as string,\r\n  sentTimestamp: record.sentTimestamp as string,\r\n  threadId: record.threadId as number | null,\r\n  parentId: record.parentId as string | null,\r\n  importedFromId: record.importedFromId as string | null,\r\n  globalMessageId: record.globalMessageId as string | null,\r\n});\r\n\r\n/**\r\n * Maps a database record to an EmailDomainSummary object (for list operations)\r\n *\r\n * @param record - Database record from Drizzle query\r\n * @returns Mapped EmailDomainSummary object\r\n */\r\nconst mapRecordToEmailDomainSummary = (\r\n  record: Record<string, unknown>,\r\n): Partial<EmailDomain> => ({\r\n  emailId: record.emailId as string,\r\n  senderId: record.senderId as number,\r\n  subject: record.subject as string,\r\n  sentTimestamp: record.sentTimestamp as string,\r\n  threadId: record.threadId as number | null,\r\n  parentId: record.parentId as string | null,\r\n  importedFromId: record.importedFromId as string | null,\r\n  globalMessageId: record.globalMessageId as string | null,\r\n  // Note: emailContents is excluded from summary\r\n});\r\n\r\n/**\r\n * EmailDrizzleRepository provides Drizzle ORM-based data access\r\n * for email records. This repository handles the core email entity\r\n * operations using the drizzle data access layer.\r\n *\r\n * The repository operates on a flattened domain model that can be\r\n * easily converted to the API response format by higher-level services.\r\n *\r\n * @example\r\n * ```typescript\r\n * const repository = new EmailDrizzleRepository();\r\n *\r\n * // Create a new email\r\n * const newEmail = await repository.create({\r\n *   senderId: 123,\r\n *   subject: \"Test Email\",\r\n *   emailContents: \"Hello World\",\r\n *   sentTimestamp: new Date()\r\n * });\r\n *\r\n * // Get paginated list\r\n * const emails = await repository.list({ page: 1, num: 10 });\r\n *\r\n * // Get single email\r\n * const email = await repository.get('email-uuid');\r\n * ```\r\n */\r\nexport class EmailDrizzleRepository\r\n  extends BaseDrizzleRepository<EmailDomain, 'emailId'>\r\n  implements BaseEmailDrizzleRepository\r\n{\r\n  constructor() {\r\n    super({\r\n      table: emails,\r\n      recordMapper: mapRecordToEmailDomain,\r\n      summaryMapper: mapRecordToEmailDomainSummary,\r\n      tableName: 'emails',\r\n      idField: 'emailId',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Validates email data for repository operations\r\n   *\r\n   * @param method - The repository method being called\r\n   * @param obj - The data object to validate\r\n   * @throws {ValidationError} When validation fails\r\n   */\r\n  protected validate<TMethod extends keyof BaseEmailDrizzleRepository>(\r\n    method: TMethod,\r\n    obj: Record<string, unknown>,\r\n  ): void {\r\n    super.validate(method, obj);\r\n\r\n    const email = obj as Partial<EmailDomain>;\r\n\r\n    switch (method) {\r\n      case 'create':\r\n        if (!email.senderId || !email.subject || !email.emailContents) {\r\n          throw new ValidationError({\r\n            field: 'senderId||subject||emailContents',\r\n            source: 'EmailDrizzleRepository::create',\r\n          });\r\n        }\r\n        break;\r\n      case 'update':\r\n        if (!email.emailId) {\r\n          throw new ValidationError({\r\n            field: 'emailId',\r\n            source: 'EmailDrizzleRepository::update',\r\n          });\r\n        }\r\n        // At least one field besides emailId must be provided for update\r\n        const updateFields = [\r\n          'senderId',\r\n          'subject',\r\n          'emailContents',\r\n          'sentTimestamp',\r\n          'threadId',\r\n          'parentId',\r\n          'importedFromId',\r\n          'globalMessageId',\r\n        ];\r\n        if (\r\n          !updateFields.some(\r\n            (field) => email[field as keyof EmailDomain] !== undefined,\r\n          )\r\n        ) {\r\n          throw new ValidationError({\r\n            field: 'At least one field is required for update',\r\n            source: 'EmailDrizzleRepository::update',\r\n          });\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Prepares data for database insert operations\r\n   * Maps domain object fields to database column names\r\n   *\r\n   * @param model - Email domain object without ID\r\n   * @returns Database insert data\r\n   */\r\n  protected prepareInsertData(\r\n    model: Omit<EmailDomain, 'emailId'>,\r\n  ): Record<string, unknown> {\r\n    return {\r\n      sender_id: model.senderId,\r\n      subject: model.subject,\r\n      email_contents: model.emailContents,\r\n      sent_timestamp: model.sentTimestamp || new Date(),\r\n      thread_id: model.threadId || null,\r\n      parent_id: model.parentId || null,\r\n      imported_from_id: model.importedFromId || null,\r\n      global_message_id: model.globalMessageId || null,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Prepares data for database update operations\r\n   * Maps domain object fields to database column names\r\n   *\r\n   * @param model - Partial email domain object with ID\r\n   * @returns Database update data\r\n   */\r\n  protected prepareUpdateData(\r\n    model: Partial<EmailDomain>,\r\n  ): Record<string, unknown> {\r\n    const updateData: Record<string, unknown> = {};\r\n\r\n    if (model.senderId !== undefined) updateData.sender_id = model.senderId;\r\n    if (model.subject !== undefined) updateData.subject = model.subject;\r\n    if (model.emailContents !== undefined)\r\n      updateData.email_contents = model.emailContents;\r\n    if (model.sentTimestamp !== undefined)\r\n      updateData.sent_timestamp = model.sentTimestamp;\r\n    if (model.threadId !== undefined) updateData.thread_id = model.threadId;\r\n    if (model.parentId !== undefined) updateData.parent_id = model.parentId;\r\n    if (model.importedFromId !== undefined)\r\n      updateData.imported_from_id = model.importedFromId;\r\n    if (model.globalMessageId !== undefined)\r\n      updateData.global_message_id = model.globalMessageId;\r\n\r\n    return updateData;\r\n  }\r\n\r\n  /**\r\n   * Finds an email by its global message ID\r\n   *\r\n   * @param globalMessageId - The global message identifier to search for\r\n   * @returns Promise resolving to email domain object or null if not found\r\n   */\r\n  async findByGlobalMessageId(\r\n    globalMessageId: string,\r\n  ): Promise<EmailDomain | null> {\r\n    try {\r\n      const record = await drizDbWithInit((db) =>\r\n        db\r\n          .select()\r\n          .from(this.config.table)\r\n          .where(eq(emails.globalMessageId, globalMessageId))\r\n          .limit(1)\r\n          .execute()\r\n          .then((x) => x.at(0)),\r\n      );\r\n      return record ? this.config.recordMapper(record) : null;\r\n    } catch (error) {\r\n      this.logDatabaseError('findByGlobalMessageId', error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\email-service.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":360,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  EmailDrizzleRepository,\r\n  EmailDomain,\r\n} from './email-drizzle-repository';\r\nimport { EmailMessage } from '@/data-models/api/email-message';\r\nimport { ContactSummary } from '@/data-models/api/contact';\r\nimport { query } from '@/lib/neondb';\r\nimport { log } from '@/lib/logger';\r\n\r\n/**\r\n * Request model for creating emails via the service\r\n */\r\nexport type CreateEmailRequest = {\r\n  senderId: number;\r\n  subject: string;\r\n  body: string;\r\n  sentOn?: Date | string;\r\n  threadId?: number | null;\r\n  parentEmailId?: string | null;\r\n  recipients: Array<{\r\n    recipientId: number;\r\n    recipientName?: string;\r\n    recipientEmail?: string;\r\n  }>;\r\n  sender?: {\r\n    contactId: number;\r\n  };\r\n};\r\n\r\n/**\r\n * Request model for updating emails via the service\r\n */\r\nexport type UpdateEmailRequest = {\r\n  emailId: string;\r\n  senderId?: number;\r\n  subject?: string;\r\n  body?: string;\r\n  sentOn?: Date | string;\r\n  threadId?: number | null;\r\n  parentEmailId?: string | null;\r\n  recipients?: Array<{\r\n    recipientId: number;\r\n    recipientName?: string;\r\n    recipientEmail?: string;\r\n  }>;\r\n  sender?: {\r\n    contactId: number;\r\n  };\r\n};\r\n\r\n/**\r\n * EmailService provides business logic layer for email operations.\r\n * It bridges between the API layer and the data access layer, handling\r\n * complex operations like fetching related data (contacts, recipients)\r\n * and converting between different data models.\r\n *\r\n * This service abstracts the complexity of working with the drizzle repository\r\n * and provides a clean interface for the API routes.\r\n *\r\n * @example\r\n * ```typescript\r\n * const service = new EmailService();\r\n *\r\n * // Get emails with full contact information\r\n * const emails = await service.getEmailsSummary({ page: 1, num: 10 });\r\n *\r\n * // Create new email with recipients\r\n * const newEmail = await service.createEmail({\r\n *   senderId: 123,\r\n *   subject: \"Test\",\r\n *   body: \"Hello\",\r\n *   recipients: [{ recipientId: 456 }]\r\n * });\r\n * ```\r\n */\r\nexport class EmailService {\r\n  private repository: EmailDrizzleRepository;\r\n\r\n  constructor() {\r\n    this.repository = new EmailDrizzleRepository();\r\n  }\r\n\r\n  /**\r\n   * Retrieves a single email by ID with full details\r\n   *\r\n   * @param emailId - The email ID to retrieve\r\n   * @returns Promise resolving to email with full details or null\r\n   */\r\n  async getEmailById(emailId: string): Promise<EmailMessage | null> {\r\n    try {\r\n      const emailDomain = await this.repository.get(emailId);\r\n      if (!emailDomain) {\r\n        return null;\r\n      }\r\n\r\n      // Fetch sender information\r\n      const senderResult = await query(\r\n        (sql) =>\r\n          sql`SELECT contact_id, name, email FROM contacts WHERE contact_id = ${emailDomain.senderId}`,\r\n      );\r\n\r\n      const sender: ContactSummary =\r\n        senderResult.length > 0\r\n          ? {\r\n              contactId: senderResult[0].contact_id as number,\r\n              name: senderResult[0].name as string,\r\n              email: senderResult[0].email as string,\r\n            }\r\n          : {\r\n              contactId: emailDomain.senderId,\r\n              name: 'Unknown',\r\n              email: 'unknown@example.com',\r\n            };\r\n\r\n      // Fetch recipients information\r\n      const recipientsResult = await query(\r\n        (sql) => sql`\r\n          SELECT \r\n            c.contact_id as recipient_id,\r\n            c.name as recipient_name,\r\n            c.email as recipient_email\r\n          FROM email_recipients er\r\n          LEFT JOIN contacts c ON er.recipient_id = c.contact_id\r\n          WHERE er.email_id = ${emailId}\r\n            AND c.contact_id IS NOT NULL\r\n        `,\r\n      );\r\n\r\n      const recipients: ContactSummary[] = recipientsResult.map((rec) => ({\r\n        contactId: rec.recipient_id as number,\r\n        name: rec.recipient_name as string,\r\n        email: rec.recipient_email as string,\r\n      }));\r\n\r\n      return {\r\n        emailId: emailDomain.emailId,\r\n        sender,\r\n        subject: emailDomain.subject,\r\n        body: emailDomain.emailContents,\r\n        sentOn: emailDomain.sentTimestamp,\r\n        threadId: emailDomain.threadId || null,\r\n        parentEmailId: emailDomain.parentId || null,\r\n        importedFromId: emailDomain.importedFromId || null,\r\n        globalMessageId: emailDomain.globalMessageId || null,\r\n        recipients,\r\n      };\r\n    } catch (error) {\r\n      log((l) => l.error({ source: 'EmailService::getEmailById', error }));\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new email with recipients\r\n   *\r\n   * @param request - Email creation request\r\n   * @returns Promise resolving to created email with full details\r\n   */\r\n  async createEmail(request: CreateEmailRequest): Promise<EmailMessage> {\r\n    try {\r\n      // Support taking senderId from either the direct field or sender object\r\n      const senderId = request.senderId ?? request.sender?.contactId;\r\n\r\n      if (!senderId) {\r\n        throw new Error('Sender ID is required');\r\n      }\r\n\r\n      // Create the email using the repository\r\n      const emailDomain: Omit<EmailDomain, 'emailId'> = {\r\n        senderId,\r\n        subject: request.subject,\r\n        emailContents: request.body,\r\n        sentTimestamp: request.sentOn || new Date(),\r\n        threadId: request.threadId || null,\r\n        parentId: request.parentEmailId || null,\r\n      };\r\n\r\n      const createdEmail = await this.repository.create(emailDomain);\r\n\r\n      // Insert recipients\r\n      if (request.recipients && request.recipients.length > 0) {\r\n        await this.insertRecipients(createdEmail.emailId, request.recipients);\r\n      }\r\n\r\n      // Create document unit for the email content\r\n      const importDate = createdEmail.sentTimestamp\r\n        ? new Date(createdEmail.sentTimestamp)\r\n        : new Date();\r\n      await query(\r\n        (sql) => sql`\r\n          INSERT INTO document_units (email_id, content, created_on, document_type)\r\n          VALUES (${createdEmail.emailId}, ${createdEmail.emailContents}, ${importDate}, 'email')\r\n        `,\r\n      );\r\n\r\n      // Return the full email details\r\n      const fullEmail = await this.getEmailById(createdEmail.emailId);\r\n      if (!fullEmail) {\r\n        throw new Error('Failed to retrieve created email');\r\n      }\r\n\r\n      log((l) =>\r\n        l.verbose({\r\n          message: '[[AUDIT]] - Email created via service:',\r\n          resultset: fullEmail,\r\n        }),\r\n      );\r\n\r\n      return fullEmail;\r\n    } catch (error) {\r\n      log((l) => l.error({ source: 'EmailService::createEmail', error }));\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates an existing email\r\n   *\r\n   * @param request - Email update request\r\n   * @returns Promise resolving to updated email with full details\r\n   */\r\n  async updateEmail(request: UpdateEmailRequest): Promise<EmailMessage> {\r\n    try {\r\n      // Support taking senderId from either the direct field or sender object\r\n      const senderId = request.senderId ?? request.sender?.contactId;\r\n\r\n      // Build update object\r\n      const updateData: Partial<EmailDomain> &\r\n        Required<Pick<EmailDomain, 'emailId'>> = {\r\n        emailId: request.emailId,\r\n      };\r\n\r\n      if (senderId !== undefined) updateData.senderId = senderId;\r\n      if (request.subject !== undefined) updateData.subject = request.subject;\r\n      if (request.body !== undefined) updateData.emailContents = request.body;\r\n      if (request.sentOn !== undefined)\r\n        updateData.sentTimestamp = request.sentOn;\r\n      if (request.threadId !== undefined)\r\n        updateData.threadId = request.threadId;\r\n      if (request.parentEmailId !== undefined)\r\n        updateData.parentId = request.parentEmailId;\r\n\r\n      const updatedEmail = await this.repository.update(updateData);\r\n\r\n      // Update recipients if provided\r\n      if (request.recipients && request.recipients.length > 0) {\r\n        await this.insertRecipients(request.emailId, request.recipients, true);\r\n      }\r\n\r\n      // Return the full email details\r\n      const fullEmail = await this.getEmailById(updatedEmail.emailId);\r\n      if (!fullEmail) {\r\n        throw new Error('Failed to retrieve updated email');\r\n      }\r\n\r\n      log((l) =>\r\n        l.verbose({\r\n          message: '[[AUDIT]] - Email updated via service:',\r\n          resultset: fullEmail,\r\n        }),\r\n      );\r\n\r\n      return fullEmail;\r\n    } catch (error) {\r\n      log((l) => l.error({ source: 'EmailService::updateEmail', error }));\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deletes an email by ID\r\n   *\r\n   * @param emailId - The email ID to delete\r\n   * @returns Promise resolving to true if deleted, false if not found\r\n   */\r\n  async deleteEmail(emailId: string): Promise<boolean> {\r\n    try {\r\n      const result = await this.repository.delete(emailId);\r\n\r\n      log((l) =>\r\n        l.verbose({\r\n          message: '[[AUDIT]] - Email deleted via service:',\r\n          emailId,\r\n          success: result,\r\n        }),\r\n      );\r\n\r\n      return result;\r\n    } catch (error) {\r\n      log((l) => l.error({ source: 'EmailService::deleteEmail', error }));\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Finds an email by its global message ID\r\n   *\r\n   * @param globalMessageId - The global message ID to search for\r\n   * @returns Promise resolving to email ID or null if not found\r\n   */\r\n  async findEmailIdByGlobalMessageId(\r\n    globalMessageId: string,\r\n  ): Promise<string | null> {\r\n    try {\r\n      const email =\r\n        await this.repository.findByGlobalMessageId(globalMessageId);\r\n      return email?.emailId || null;\r\n    } catch (error) {\r\n      log((l) =>\r\n        l.error({\r\n          source: 'EmailService::findEmailIdByGlobalMessageId',\r\n          error,\r\n        }),\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Inserts or updates recipients for an email\r\n   *\r\n   * @param emailId - The email ID\r\n   * @param recipients - Array of recipient information\r\n   * @param replaceExisting - Whether to delete existing recipients first\r\n   */\r\n  private async insertRecipients(\r\n    emailId: string,\r\n    recipients: Array<{\r\n      recipientId: number;\r\n      recipientName?: string;\r\n      recipientEmail?: string;\r\n    }>,\r\n    replaceExisting = false,\r\n  ): Promise<void> {\r\n    try {\r\n      if (replaceExisting) {\r\n        // Delete existing recipients\r\n        await query(\r\n          (sql) =>\r\n            sql`DELETE FROM email_recipients WHERE email_id = ${emailId}`,\r\n        );\r\n      }\r\n\r\n      // Insert new recipients\r\n      for (const recipient of recipients) {\r\n        await query(\r\n          (sql) => sql`\r\n            INSERT INTO email_recipients (email_id, recipient_id)\r\n            VALUES (${emailId}, ${recipient.recipientId})\r\n            ON CONFLICT (email_id, recipient_id) DO NOTHING\r\n          `,\r\n        );\r\n      }\r\n    } catch (error) {\r\n      log((l) => l.error({ source: 'EmailService::insertRecipients', error }));\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\email-validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\import\\google\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":12,"column":1,"nodeType":"Program","endLine":184,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module googleEmailImport\r\n *\r\n * This module provides functions to interact with the Google email import API.\r\n * It includes functionalities to search for emails, load email details, and queue emails for import.\r\n *\r\n * Functions:\r\n * - `searchEmails`: Searches for emails based on provided criteria.\r\n * - `loadEmail`: Loads the details of a specific email by its ID.\r\n * - `queueEmailImport`: Queues an email for import by its ID.\r\n */\r\nimport type {\r\n  AdditionalRequestParams,\r\n  ApiRequestHelper,\r\n} from '@/lib/send-api-request';\r\nimport { apiRequestHelperFactory } from '@/lib/send-api-request';\r\n\r\nimport siteMap from '@/lib/site-util/url-builder';\r\nimport type { PaginatedResultset } from '@/data-models/_types';\r\nimport type {\r\n  EmailSearchResult,\r\n  ImportResponse,\r\n  ImportSourceMessage,\r\n  MessageImportStatusWithChildren,\r\n} from '@/data-models/api/import/email-message';\r\n\r\nconst apiRequest = <TResult>(\r\n  cb: (\r\n    api: ApiRequestHelper,\r\n    builder: typeof siteMap.api.email.import.google,\r\n  ) => TResult,\r\n): TResult => {\r\n  const apiHelper = apiRequestHelperFactory({ area: 'email/import/google' });\r\n  const builder = siteMap.api.email.import.google;\r\n  return cb(apiHelper, builder);\r\n};\r\n\r\n/**\r\n * Searches for emails based on the provided criteria.\r\n *\r\n * @param from - The sender's email address to filter by.\r\n * @param to - The recipient's email address to filter by.\r\n * @param label - An array of labels to filter by.\r\n * @param page - The page number for pagination (default is 1).\r\n * @param limit - The number of results per page (default is 100).\r\n * @returns A promise that resolves to a paginated result set of email search results.\r\n */\r\nexport const searchEmails = (\r\n  {\r\n    from,\r\n    to,\r\n    label,\r\n    page = 1,\r\n    limit = 100,\r\n  }: {\r\n    from?: string;\r\n    to?: string;\r\n    label?: string[];\r\n    page?: number;\r\n    limit?: number;\r\n  },\r\n  params?: AdditionalRequestParams,\r\n) => {\r\n  if (from === 'm.sean.o@gmail.com') {\r\n    to = '@plsas.org';\r\n  }\r\n\r\n  return apiRequest((api, builder) =>\r\n    api.get<PaginatedResultset<EmailSearchResult, string | undefined>>(\r\n      {\r\n        url: builder.search({\r\n          from,\r\n          to,\r\n          label,\r\n          page,\r\n          limit,\r\n        }),\r\n        action: 'search',\r\n      },\r\n      params,\r\n    ),\r\n  );\r\n};\r\n/**\r\n * Loads the details of a specific email by its ID.\r\n *\r\n * @param emailId - The ID of the email to load.\r\n * @returns A promise that resolves to the details of the email.\r\n */\r\nexport const loadEmail = (emailId: string, params?: AdditionalRequestParams) =>\r\n  apiRequest((api, builder) =>\r\n    api.get<ImportSourceMessage>(\r\n      {\r\n        url: builder.page('message', emailId),\r\n        action: 'load',\r\n      },\r\n      params,\r\n    ),\r\n  );\r\n\r\n/**\r\n * Queues an email for import by its ID.\r\n *\r\n * @param emailId - The ID of the email to queue for import.\r\n * @returns A promise that resolves to the details of the queued email.\r\n */\r\nexport const queueEmailImport = (\r\n  emailId: string,\r\n  params?: AdditionalRequestParams,\r\n) =>\r\n  apiRequest((api, builder) => {\r\n    return api.post<ImportSourceMessage>(\r\n      {\r\n        url: builder.page('message', emailId),\r\n        action: 'queue',\r\n        input: {},\r\n      },\r\n      params,\r\n    );\r\n  });\r\n\r\n/**\r\n * Stages an email for import by its ID.\r\n *\r\n * @param emailId - The ID of the email to queue for import.\r\n * @returns A promise that resolves to the details of the queued email.\r\n */\r\nexport const createStagingRecord = (\r\n  emailId: string,\r\n  params?: AdditionalRequestParams,\r\n) =>\r\n  apiRequest((api, builder) =>\r\n    api.put<ImportSourceMessage>(\r\n      {\r\n        url: builder.message.page(emailId),\r\n        action: 'stage',\r\n        input: {},\r\n      },\r\n      params,\r\n    ),\r\n  );\r\n\r\n/**\r\n * Stages an email for import by its ID.\r\n *\r\n * @param emailId - The ID of the email to queue for import.\r\n * @returns A promise that resolves to the details of the imported email.\r\n */\r\nexport const importEmailRecord = (\r\n  emailId: string,\r\n  params?: AdditionalRequestParams,\r\n) =>\r\n  apiRequest((api, builder) =>\r\n    api.post<ImportResponse>(\r\n      {\r\n        url: builder.message.page(emailId),\r\n        action: 'import',\r\n        input: {},\r\n      },\r\n      params,\r\n    ),\r\n  );\r\n\r\n/**\r\n * Queries the import status of a message by its email ID.\r\n *\r\n * @param emailId - The unique identifier of the email message.\r\n * @param params - Optional additional request parameters.\r\n * @returns A promise that resolves to the import status of the message, including any child messages.\r\n */\r\nexport const queryImportStatus = (\r\n  emailId: string,\r\n  params?: AdditionalRequestParams,\r\n) =>\r\n  apiRequest((api, builder) =>\r\n    api.get<MessageImportStatusWithChildren>(\r\n      {\r\n        url: builder.child('message', emailId).page('status'),\r\n        action: 'status',\r\n      },\r\n      params,\r\n    ),\r\n  );\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\import\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\import\\staged-attachment.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":142,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":101,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3249,3252],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3249,3252],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":109,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3575,3578],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3575,3578],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":128,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4273,4276],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4273,4276],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseObjectRepository } from '@/lib/api/_baseObjectRepository';\r\nimport { ObjectRepository } from '@/lib/api/_types';\r\nimport { buildOrderBy } from '@/lib/components/mui/data-grid/server';\r\nimport { query } from '@/lib/neondb';\r\nimport { ValidationError } from '@/lib/react-util/errors/validation-error';\r\nimport { FirstParameter } from '@/lib/typescript';\r\nimport { GridSortModel } from '@mui/x-data-grid-pro';\r\n\r\nexport type StagedAttachment = {\r\n  stagedMessageId: string;\r\n  partId: number;\r\n  filename: string;\r\n  mimeType: string | null;\r\n  storageId: string | null;\r\n  imported: boolean;\r\n  size: number;\r\n  fileOid: string | null;\r\n  attachmentId: string | null;\r\n  extractedText?: string | null;\r\n};\r\n\r\nconst mapRecordToObject = (\r\n  record: Record<string, unknown>,\r\n): StagedAttachment => ({\r\n  stagedMessageId: record.staging_message_id as string,\r\n  partId: record.partId as number,\r\n  filename: record.filename as string,\r\n  mimeType: record.mimeType as string,\r\n  storageId: record.storageId as string | null,\r\n  imported: record.imported as boolean,\r\n  size: record.size as number,\r\n  fileOid: record.file_oid as string | null,\r\n  attachmentId: record.attachmentId as string | null,\r\n  extractedText: record.extractedText as string | null,\r\n});\r\n\r\nexport class StagedAttachmentRepository extends BaseObjectRepository<\r\n  StagedAttachment,\r\n  'partId'\r\n> {\r\n  constructor() {\r\n    super({\r\n      tableName: 'staging_attachment',\r\n      idField: 'partId',\r\n      objectMap: mapRecordToObject,\r\n      summaryMap: mapRecordToObject,\r\n    });\r\n  }\r\n\r\n  async create(\r\n    props: Omit<StagedAttachment, 'partId'> &\r\n      Partial<Pick<StagedAttachment, 'partId'>>,\r\n  ): Promise<StagedAttachment> {\r\n    return super.create(props);\r\n  }\r\n\r\n  async getForMessage(\r\n    stagedMessageId: string,\r\n  ): Promise<ReadonlyArray<StagedAttachment>> {\r\n    const runQuery = (x: number, y: number, z: number, sort?: GridSortModel) =>\r\n      query(\r\n        (sql) => sql`\r\n      SELECT * FROM staging_attachment WHERE staging_message_id = ${stagedMessageId} ${buildOrderBy({ source: sort, sql })}`,\r\n      );\r\n    const runQueryCount = () =>\r\n      query(\r\n        (sql) =>\r\n          sql`SELECT COUNT(*) as records FROM staging_attachment WHERE staging_message_id = ${stagedMessageId}`,\r\n      );\r\n    return this.innerList(runQuery, runQueryCount).then(\r\n      (x) => x.results as ReadonlyArray<StagedAttachment>,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Validates the input for a specific method.\r\n   *\r\n   * @template TMethod\r\n   * @param {TMethod} method - The method to validate.\r\n   * @param {FirstParameter<ObjectRepository<T, KId>[TMethod]>} obj - The input to validate.\r\n   */\r\n  validate<TMethod extends keyof ObjectRepository<StagedAttachment, 'partId'>>(\r\n    method: TMethod,\r\n    obj: FirstParameter<\r\n      Pick<ObjectRepository<StagedAttachment, 'partId'>, TMethod>[TMethod]\r\n    >,\r\n  ): void {\r\n    if (!obj) {\r\n      throw new ValidationError('No object provided');\r\n    }\r\n    switch (method) {\r\n      case 'create':\r\n        break;\r\n      case 'update':\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  protected getListQueryProperties(): [string, Array<any>, string] {\r\n    return [\r\n      `SELECT * FROM staging_attachment ORDER BY staging_message_id, partId`,\r\n      [],\r\n      `SELECT COUNT(*) as records FROM staging_attachment`,\r\n    ];\r\n  }\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  protected getQueryProperties(recordId: number): [string, Array<any>] {\r\n    return ['SELECT * FROM staging_attachment WHERE partId = $1', [recordId]];\r\n  }\r\n  protected getCreateQueryProperties({\r\n    stagedMessageId,\r\n    partId,\r\n    filename,\r\n    mimeType,\r\n    size,\r\n    attachmentId,\r\n  }: StagedAttachment): [string, Array<unknown>] {\r\n    return [\r\n      `INSERT INTO staging_attachment (staging_message_id, \"partId\", filename, \"mimeType\", size, \"attachmentId\") VALUES ($1, $2, $3, $4, $5, $6) RETURNING *`,\r\n      [stagedMessageId, partId, filename, mimeType, size, attachmentId],\r\n    ];\r\n  }\r\n  protected getUpdateQueryProperties(\r\n    obj: StagedAttachment,\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  ): [Record<string, any>] {\r\n    return [\r\n      {\r\n        staged_message_id: obj.stagedMessageId,\r\n        partId: obj.partId,\r\n        filename: obj.filename,\r\n        mimeType: obj.mimeType,\r\n        size: obj.size,\r\n        file_oid: obj.fileOid,\r\n        attachmentId: obj.attachmentId,\r\n      },\r\n    ];\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\postgres\\query-parts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\properties\\call-to-action-response\\call-to-action-response-details-repository.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":197,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseObjectRepository } from '../../../_baseObjectRepository';\r\nimport { ObjectRepository } from '../../../_types';\r\nimport { ValidationError } from '@/lib/react-util/errors/validation-error';\r\nimport { FirstParameter, newUuid } from '@/lib/typescript';\r\nimport { CallToActionResponseDetails } from '@/data-models/api';\r\nimport {\r\n  EmailPropertyRepository,\r\n  mapEmailPropertyRecordToObject,\r\n} from '../email-property-repository';\r\nimport { TransformedFullQueryResults } from '@/lib/neondb';\r\n\r\nconst mapRecordToObject = (\r\n  record: Record<string, unknown>,\r\n): CallToActionResponseDetails => {\r\n  return {\r\n    ...mapEmailPropertyRecordToObject(record),\r\n    actionPropertyId: String(record.action_property_id),\r\n    completionPercentage: Number(record.completion_percentage),\r\n    responseTimestamp: new Date(String(record.response_timestamp)),\r\n    severity:\r\n      record.severity == null || record.severity === undefined\r\n        ? undefined\r\n        : Number(record.severity),\r\n    severity_reasons:\r\n      record.severity_reasons == null ||\r\n      record.severity_reasons === undefined ||\r\n      !Array.isArray(record.severity_reasons) ||\r\n      record.severity_reasons.length === 0\r\n        ? undefined\r\n        : (record.severity_reasons as string[]),\r\n    inferred:\r\n      record.inferred == null || record.inferred === undefined\r\n        ? undefined\r\n        : Boolean(record.inferred),\r\n    compliance_average_chapter_13:\r\n      record.compliance_average_chapter_13 == null ||\r\n      record.compliance_average_chapter_13 === undefined\r\n        ? undefined\r\n        : Number(record.compliance_average_chapter_13),\r\n    compliance_chapter_13_reasons:\r\n      record.compliance_chapter_13_reasons == null ||\r\n      record.compliance_chapter_13_reasons === undefined ||\r\n      !Array.isArray(record.compliance_chapter_13_reasons) ||\r\n      record.compliance_chapter_13_reasons.length === 0\r\n        ? undefined\r\n        : (record.compliance_chapter_13_reasons as string[]),\r\n    sentiment:\r\n      record.sentiment == null || record.sentiment === undefined\r\n        ? undefined\r\n        : Number(record.sentiment),\r\n    sentiment_reasons:\r\n      record.sentiment_reasons == null ||\r\n      record.sentiment_reasons === undefined ||\r\n      !Array.isArray(record.sentiment_reasons) ||\r\n      record.sentiment_reasons.length === 0\r\n        ? undefined\r\n        : (record.sentiment_reasons as string[]),\r\n  };\r\n};\r\n\r\nexport class CallToActionResponseDetailsRepository extends BaseObjectRepository<\r\n  CallToActionResponseDetails,\r\n  'propertyId'\r\n> {\r\n  constructor() {\r\n    super({\r\n      tableName: 'call_to_action_response_details',\r\n      idField: ['propertyId', 'property_id'],\r\n      objectMap: mapRecordToObject,\r\n      summaryMap: mapRecordToObject,\r\n    });\r\n  }\r\n\r\n  validate<\r\n    TMethod extends keyof ObjectRepository<\r\n      CallToActionResponseDetails,\r\n      'propertyId'\r\n    >,\r\n  >(\r\n    method: TMethod,\r\n    obj: FirstParameter<\r\n      Pick<\r\n        ObjectRepository<CallToActionResponseDetails, 'propertyId'>,\r\n        TMethod\r\n      >[TMethod]\r\n    >,\r\n  ): void {\r\n    const asModel = obj as CallToActionResponseDetails;\r\n    switch (method) {\r\n      case 'create':\r\n        if (!asModel.propertyId) {\r\n          asModel.propertyId = newUuid();\r\n        }\r\n        break;\r\n      case 'update':\r\n        if (!asModel.propertyId) {\r\n          throw new ValidationError({\r\n            field: 'propertyId',\r\n            source: 'CallToActionResponseDetailsRepository',\r\n          });\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  protected getListQueryProperties(): [string, Array<unknown>, string] {\r\n    return [\r\n      `SELECT * FROM call_to_action_response_details \r\n       JOIN document_property ON call_to_action_response_details.property_id = document_property.property_id \r\n       ORDER BY call_to_action_response_details.property_id`,\r\n      [],\r\n      `SELECT COUNT(*) as records FROM call_to_action_response_details`,\r\n    ];\r\n  }\r\n\r\n  protected getQueryProperties(recordId: string): [string, Array<unknown>] {\r\n    return [\r\n      `SELECT ep.*, ept.property_name, epc.description, epc.email_property_category_id,\r\n            ctar.action_property_id, ctar.completion_percentage, ctar.response_timestamp\r\n            FROM document_property ep \r\n             JOIN call_to_action_response_details ctar ON ctar.property_id = ep.property_id \r\n             JOIN email_property_type ept ON ept.document_property_type_id = ep.document_property_type_id\r\n             JOIN email_property_category epc ON ept.email_property_category_id = epc.email_property_category_id\r\n       WHERE ctar.property_id = $1`,\r\n      [recordId],\r\n    ];\r\n  }\r\n\r\n  protected getCreateQueryProperties({\r\n    propertyId,\r\n    actionPropertyId,\r\n    completionPercentage,\r\n    responseTimestamp,\r\n    value,\r\n    documentId,\r\n    tags,\r\n    policy_basis,\r\n    createdOn,\r\n  }: CallToActionResponseDetails): [string, Array<unknown>] {\r\n    return [\r\n      `WITH ins1 AS (\r\n        INSERT INTO document_property (property_value, document_property_type_id, property_id, document_id, created_on, tags, policy_basis) \r\n        VALUES ($1, 7, $2, $3, $4, $8, $9) RETURNING property_id\r\n      )\r\n      INSERT INTO call_to_action_response_details (property_id, action_property_id, completion_percentage, response_timestamp) \r\n      VALUES ((SELECT property_id FROM ins1), $5, $6, $7) RETURNING *`,\r\n      [\r\n        value,\r\n        propertyId,\r\n        documentId,\r\n        createdOn ?? new Date(),\r\n        actionPropertyId,\r\n        completionPercentage,\r\n        responseTimestamp ?? new Date(),\r\n        tags?.length ? tags : null,\r\n        policy_basis?.length ? policy_basis : null,\r\n      ],\r\n    ];\r\n  }\r\n\r\n  protected getUpdateQueryProperties({\r\n    actionPropertyId,\r\n    completionPercentage,\r\n    responseTimestamp,\r\n  }: CallToActionResponseDetails): [Record<string, unknown>] {\r\n    return [\r\n      {\r\n        action_property_id: actionPropertyId,\r\n        completion_percentage: completionPercentage,\r\n        response_timestamp: responseTimestamp,\r\n      },\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Override to append post-processing logic to the update query.\r\n   * @param updateQuery Update query promise\r\n   * @returns The updateQuery argument\r\n   */\r\n  protected postProcessUpdate({\r\n    updateQuery,\r\n    props,\r\n  }: {\r\n    props: CallToActionResponseDetails;\r\n    updateQuery: Promise<\r\n      TransformedFullQueryResults<CallToActionResponseDetails>\r\n    >;\r\n  }): Promise<TransformedFullQueryResults<CallToActionResponseDetails>> {\r\n    return updateQuery.then((result) => {\r\n      const repo = new EmailPropertyRepository();\r\n      return repo.update(props).then(() => result);\r\n    });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\properties\\call-to-action\\cta-details-repository.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":284,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseObjectRepository } from '../../../_baseObjectRepository';\r\nimport { ObjectRepository } from '../../../_types';\r\nimport { ValidationError } from '@/lib/react-util/errors/validation-error';\r\nimport { FirstParameter, newUuid } from '@/lib/typescript';\r\nimport { CallToActionDetails } from '@/data-models/api';\r\nimport {\r\n  EmailPropertyRepository,\r\n  mapEmailPropertyRecordToObject,\r\n} from '../email-property-repository';\r\nimport { TransformedFullQueryResults } from '@/lib/neondb';\r\n\r\nconst mapRecordToObject = (\r\n  record: Record<string, unknown>,\r\n): CallToActionDetails => {\r\n  return {\r\n    ...mapEmailPropertyRecordToObject(record),\r\n    opened_date: record.opened_date\r\n      ? new Date(String(record.opened_date))\r\n      : null,\r\n    closed_date: record.closed_date\r\n      ? new Date(String(record.closed_date))\r\n      : null,\r\n    compliancy_close_date: record.compliancy_close_date\r\n      ? new Date(String(record.compliancy_close_date))\r\n      : null,\r\n    completion_percentage: Number(record.completion_percentage),\r\n    compliance_rating:\r\n      record.compliance_rating !== undefined &&\r\n      record.compliance_rating !== null\r\n        ? Number(record.compliance_rating)\r\n        : null,\r\n    inferred: Boolean(record.inferred),\r\n    compliance_date_enforceable: Boolean(record.compliance_date_enforceable),\r\n    sentiment:\r\n      record.sentiment !== undefined && record.sentiment !== null\r\n        ? Number(record.sentiment)\r\n        : null,\r\n    sentiment_reasons: Array.isArray(record.sentiment_reasons)\r\n      ? (record.sentiment_reasons as string[])\r\n      : record.sentiment_reasons\r\n        ? String(record.sentiment_reasons).split(',')\r\n        : null,\r\n    compliance_rating_reasons: Array.isArray(record.compliance_rating_reasons)\r\n      ? (record.compliance_rating_reasons as string[])\r\n      : record.compliance_rating_reasons\r\n        ? String(record.compliance_rating_reasons).split(',')\r\n        : null,\r\n    severity:\r\n      record.severity !== undefined && record.severity !== null\r\n        ? Number(record.severity)\r\n        : null,\r\n    severity_reason: Array.isArray(record.severity_reason)\r\n      ? (record.severity_reason as string[])\r\n      : record.severity_reason\r\n        ? String(record.severity_reason).split(',')\r\n        : null,\r\n    title_ix_applicable:\r\n      record.title_ix_applicable !== undefined &&\r\n      record.title_ix_applicable !== null\r\n        ? Number(record.title_ix_applicable)\r\n        : null,\r\n    title_ix_applicable_reasons: Array.isArray(\r\n      record.title_ix_applicable_reasons,\r\n    )\r\n      ? (record.title_ix_applicable_reasons as string[])\r\n      : record.title_ix_applicable_reasons\r\n        ? String(record.title_ix_applicable_reasons).split(',')\r\n        : null,\r\n    closure_actions: Array.isArray(record.closure_actions)\r\n      ? (record.closure_actions as string[])\r\n      : record.closure_actions\r\n        ? String(record.closure_actions).split(',')\r\n        : null,\r\n\r\n    compliance_average_chapter_13:\r\n      record.compliance_average_chapter_13 !== undefined &&\r\n      record.compliance_average_chapter_13 !== null\r\n        ? Number(record.compliance_average_chapter_13)\r\n        : null,\r\n    compliance_chapter_13_reasons: Array.isArray(\r\n      record.compliance_chapter_13_reasons,\r\n    )\r\n      ? (record.compliance_chapter_13_reasons as string[])\r\n      : record.compliance_chapter_13_reasons\r\n        ? String(record.compliance_chapter_13_reasons).split(',')\r\n        : null,\r\n  };\r\n};\r\n\r\nexport class CallToActionDetailsRepository extends BaseObjectRepository<\r\n  CallToActionDetails,\r\n  'propertyId'\r\n> {\r\n  constructor() {\r\n    super({\r\n      tableName: 'call_to_action_details',\r\n      idField: ['propertyId', 'property_id'],\r\n      objectMap: mapRecordToObject,\r\n      summaryMap: mapRecordToObject,\r\n    });\r\n  }\r\n\r\n  validate<\r\n    TMethod extends keyof ObjectRepository<CallToActionDetails, 'propertyId'>,\r\n  >(\r\n    method: TMethod,\r\n    obj: FirstParameter<\r\n      Pick<\r\n        ObjectRepository<CallToActionDetails, 'propertyId'>,\r\n        TMethod\r\n      >[TMethod]\r\n    >,\r\n  ): void {\r\n    const asModel = obj as CallToActionDetails;\r\n    switch (method) {\r\n      case 'create':\r\n        if (!asModel.propertyId) {\r\n          asModel.propertyId = newUuid();\r\n        }\r\n        break;\r\n      case 'update':\r\n        if (!asModel.propertyId) {\r\n          throw new ValidationError({\r\n            field: 'propertyId',\r\n            source: 'CallToActionDetailsRepository',\r\n          });\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  protected getListQueryProperties(): [string, Array<unknown>, string] {\r\n    return [\r\n      `SELECT * FROM call_to_action_details \r\n       JOIN document_property ON call_to_action_details.property_id = document_property.property_id \r\n       ORDER BY call_to_action_details.property_id`,\r\n      [],\r\n      `SELECT COUNT(*) as records FROM call_to_action_details`,\r\n    ];\r\n  }\r\n\r\n  protected getQueryProperties(recordId: string): [string, Array<unknown>] {\r\n    return [\r\n      `SELECT ep.*, ept.property_name,epc.description, epc.email_property_category_id,\r\n            cta.opened_date, cta.closed_date, cta.compliancy_close_date, cta.completion_percentage, \r\n            cta.compliance_rating, cta.inferred, cta.compliance_date_enforceable, cta.reasonable_request, \r\n            cta.reasonable_reasons, cta.sentiment, cta.sentiment_reasons, cta.compliance_rating_reasons, \r\n            cta.severity, cta.severity_reason, cta.title_ix_applicable, cta.title_ix_applicable_reasons, \r\n            cta.closure_actions\r\n            FROM document_property ep \r\n             JOIN call_to_action_details cta ON cta.property_id = ep.property_id \r\n             JOIN email_property_type ept ON ept.document_property_type_id = ep.document_property_type_id\r\n             JOIN email_property_category epc ON ept.email_property_category_id = epc.email_property_category_id\r\n       WHERE cta.property_id = $1`,\r\n      [recordId],\r\n    ];\r\n  }\r\n\r\n  protected getCreateQueryProperties({\r\n    propertyId,\r\n    opened_date,\r\n    closed_date,\r\n    compliancy_close_date,\r\n    completion_percentage,\r\n    compliance_rating,\r\n    inferred,\r\n    compliance_date_enforceable,\r\n    reasonable_request,\r\n    reasonable_reasons,\r\n    sentiment,\r\n    sentiment_reasons,\r\n    compliance_rating_reasons,\r\n    severity,\r\n    severity_reason,\r\n    title_ix_applicable,\r\n    title_ix_applicable_reasons,\r\n    closure_actions,\r\n    value,\r\n    documentId,\r\n    tags,\r\n    policy_basis,\r\n    createdOn,\r\n  }: CallToActionDetails): [string, Array<unknown>] {\r\n    return [\r\n      `WITH ins1 AS (\r\n        INSERT INTO document_property (property_value, document_property_type_id, property_id, document_id, created_on, tags, policy_basis) \r\n        VALUES ($1, 4, $2, $3, $4, $5, $6) RETURNING property_id\r\n      )\r\n      INSERT INTO call_to_action_details (\r\n        property_id, opened_date, closed_date, compliancy_close_date, completion_percentage, compliance_rating, inferred, compliance_date_enforceable, reasonable_request, reasonable_reasons, sentiment, sentiment_reasons, compliance_rating_reasons, severity, severity_reason, title_ix_applicable, title_ix_applicable_reasons, closure_actions\r\n      ) \r\n      VALUES (\r\n        (SELECT property_id FROM ins1), $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24\r\n      ) RETURNING *`,\r\n      [\r\n        value,\r\n        propertyId,\r\n        documentId,\r\n        createdOn ?? new Date(),\r\n        tags?.length ? tags : null,\r\n        policy_basis?.length ? policy_basis : null,\r\n        opened_date ?? null,\r\n        closed_date ?? null,\r\n        compliancy_close_date ?? null,\r\n        completion_percentage ?? null,\r\n        compliance_rating ?? null,\r\n        inferred ?? null,\r\n        compliance_date_enforceable ?? null,\r\n        reasonable_request ?? null,\r\n        reasonable_reasons ?? null,\r\n        sentiment ?? null,\r\n        sentiment_reasons ?? null,\r\n        compliance_rating_reasons ?? null,\r\n        severity ?? null,\r\n        severity_reason ?? null,\r\n        title_ix_applicable ?? null,\r\n        title_ix_applicable_reasons ?? null,\r\n        closure_actions ?? null,\r\n      ],\r\n    ];\r\n  }\r\n\r\n  protected getUpdateQueryProperties({\r\n    opened_date,\r\n    closed_date,\r\n    compliancy_close_date,\r\n    completion_percentage,\r\n    compliance_rating,\r\n    inferred,\r\n    compliance_date_enforceable,\r\n    reasonable_request,\r\n    reasonable_reasons,\r\n    sentiment,\r\n    sentiment_reasons,\r\n    compliance_rating_reasons,\r\n    severity,\r\n    severity_reason,\r\n    title_ix_applicable,\r\n    title_ix_applicable_reasons,\r\n    closure_actions,\r\n  }: CallToActionDetails): [Record<string, unknown>] {\r\n    return [\r\n      {\r\n        opened_date: opened_date,\r\n        closed_date: closed_date,\r\n        compliancy_close_date: compliancy_close_date,\r\n        completion_percentage: completion_percentage,\r\n        compliance_rating: compliance_rating,\r\n        inferred: inferred,\r\n        compliance_date_enforceable: compliance_date_enforceable,\r\n        reasonable_request: reasonable_request,\r\n        reasonable_reasons: reasonable_reasons,\r\n        sentiment: sentiment,\r\n        sentiment_reasons: sentiment_reasons,\r\n        compliance_rating_reasons: compliance_rating_reasons,\r\n        severity: severity,\r\n        severity_reason: severity_reason,\r\n        title_ix_applicable: title_ix_applicable,\r\n        title_ix_applicable_reasons: title_ix_applicable_reasons,\r\n        closure_actions: closure_actions,\r\n      },\r\n    ];\r\n  }\r\n  /**\r\n   * Override to append post-processing logic to the update query.\r\n   * @param updateQuery Update query promise\r\n   * @returns The updateQuery argument\r\n   */\r\n  protected postProcessUpdate({\r\n    updateQuery,\r\n    props,\r\n  }: {\r\n    props: CallToActionDetails;\r\n    updateQuery: Promise<TransformedFullQueryResults<CallToActionDetails>>;\r\n  }): Promise<TransformedFullQueryResults<CallToActionDetails>> {\r\n    return updateQuery.then((result) => {\r\n      const repo = new EmailPropertyRepository();\r\n      return repo.update(props).then(() => result);\r\n    });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\properties\\client.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":130,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { PaginatedResultset, PaginationStats } from '@/data-models/_types';\r\nimport type {\r\n  KeyPointsDetails,\r\n  CallToActionDetails,\r\n  CallToActionResponseDetails,\r\n  ComplianceScoresDetails,\r\n  EmailSentimentAnalysisDetails,\r\n  ViolationDetails,\r\n} from '@/data-models/api/email-properties/extended-properties';\r\nimport type { EmailPropertySummary } from '@/data-models/api/email-properties/property-type';\r\nimport siteMap from '@/lib/site-util/url-builder';\r\nimport {\r\n  apiRequestHelperFactory,\r\n  ApiRequestHelper,\r\n} from '@/lib/send-api-request';\r\nimport { ICancellablePromiseExt } from '@/lib/typescript';\r\n\r\nconst apiRequest = <TResult>(\r\n  cb: (\r\n    api: ApiRequestHelper,\r\n    builder: typeof siteMap.api.email.properties,\r\n  ) => TResult,\r\n): TResult => {\r\n  const apiHelper = apiRequestHelperFactory({ area: 'email/properties' });\r\n  const builder = siteMap.api.email.properties;\r\n  return cb(apiHelper, builder);\r\n};\r\n\r\ntype ListRequestProps = Partial<Omit<PaginationStats, 'total'>> & {\r\n  emailId: string;\r\n  api: keyof ReturnType<typeof siteMap.api.email.properties>;\r\n};\r\n\r\nconst listPropertyRequest = <\r\n  TModel extends Omit<EmailPropertySummary, 'typeId'>,\r\n>({\r\n  api,\r\n  page,\r\n  num,\r\n  emailId,\r\n}: ListRequestProps): ICancellablePromiseExt<PaginatedResultset<TModel>> =>\r\n  apiRequest((apiHelper, builder) => {\r\n    const b = builder(emailId)[api] as (props: object) => URL;\r\n    return apiHelper.get<PaginatedResultset<TModel>>({\r\n      url: b({ page, num }),\r\n      action: 'list',\r\n    });\r\n  });\r\n\r\n/**\r\n * Retrieves email headers by making a property list request.\r\n *\r\n * @param props - The properties for the list request, including any necessary parameters.\r\n * @returns The result of the property list request for email headers.\r\n */\r\nexport const getEmailHeaders = (props: Omit<ListRequestProps, 'api'>) =>\r\n  listPropertyRequest({ ...props, api: 'emailHeader' });\r\n\r\n/**\r\n * Retrieves key points by making a property list request.\r\n *\r\n * @param props - The properties for the list request, including any necessary parameters.\r\n * @returns The result of the property list request for key points.\r\n */\r\nexport const getKeyPoints = (props: Omit<ListRequestProps, 'api'>) =>\r\n  listPropertyRequest<KeyPointsDetails>({ ...props, api: 'keyPoints' });\r\n\r\n/**\r\n * Retrieves call-to-action details by making a property list request.\r\n *\r\n * @param props - The properties for the list request, including any necessary parameters.\r\n * @returns The result of the property list request for call-to-action details.\r\n */\r\nexport const getCallToAction = (props: Omit<ListRequestProps, 'api'>) =>\r\n  listPropertyRequest<CallToActionDetails>({ ...props, api: 'callToAction' });\r\n\r\n/**\r\n * Retrieves call-to-action responses by making a property list request.\r\n *\r\n * @param props - The properties for the list request, including any necessary parameters.\r\n * @returns The result of the property list request for call-to-action responses.\r\n */\r\nexport const getCallToActionResponse = (props: Omit<ListRequestProps, 'api'>) =>\r\n  listPropertyRequest<CallToActionResponseDetails>({\r\n    ...props,\r\n    api: 'callToActionResponse',\r\n  });\r\n\r\n/**\r\n * Retrieves compliance scores by making a property list request.\r\n *\r\n * @param props - The properties for the list request, including any necessary parameters.\r\n * @returns The result of the property list request for compliance scores.\r\n */\r\nexport const getComplianceScores = (props: Omit<ListRequestProps, 'api'>) =>\r\n  listPropertyRequest<ComplianceScoresDetails>({\r\n    ...props,\r\n    api: 'complianceScores',\r\n  });\r\n\r\n/**\r\n * Retrieves sentiment analysis by making a property list request.\r\n *\r\n * @param props - The properties for the list request, including any necessary parameters.\r\n * @returns The result of the property list request for sentiment analysis.\r\n */\r\nexport const getSentimentAnalysis = (props: Omit<ListRequestProps, 'api'>) =>\r\n  listPropertyRequest<EmailSentimentAnalysisDetails>({\r\n    ...props,\r\n    api: 'sentimentAnalysis',\r\n  });\r\n\r\n/**\r\n * Retrieves violation details by making a property list request.\r\n *\r\n * @param props - The properties for the list request, including any necessary parameters.\r\n * @returns The result of the property list request for violation details.\r\n */\r\nexport const getViolationDetails = (props: Omit<ListRequestProps, 'api'>) =>\r\n  listPropertyRequest<ViolationDetails>({ ...props, api: 'violationDetails' });\r\n\r\n/**\r\n * Retrieves notes by making a property list request.\r\n *\r\n * @param props - The properties for the list request, including any necessary parameters.\r\n * @returns The result of the property list request for notes.\r\n */\r\nexport const getNotes = (props: Omit<ListRequestProps, 'api'>) =>\r\n  listPropertyRequest({ ...props, api: 'notes' });\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\properties\\compliance-scores\\compliance-scores-details-repository.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":180,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseObjectRepository } from '../../../_baseObjectRepository';\r\nimport { ObjectRepository } from '../../../_types';\r\nimport { ValidationError } from '@/lib/react-util/errors/validation-error';\r\nimport { FirstParameter, newUuid } from '@/lib/typescript';\r\nimport { ComplianceScoresDetails } from '@/data-models/api';\r\nimport {\r\n  EmailPropertyRepository,\r\n  mapEmailPropertyRecordToObject,\r\n} from '../email-property-repository';\r\nimport { TransformedFullQueryResults } from '@/lib/neondb';\r\n\r\nconst mapRecordToObject = (\r\n  record: Record<string, unknown>,\r\n): ComplianceScoresDetails => {\r\n  return {\r\n    ...mapEmailPropertyRecordToObject(record),\r\n    actionPropertyId: record.action_property_id\r\n      ? String(record.action_property_id)\r\n      : null,\r\n    complianceScore: record.compliance_score\r\n      ? Number(record.compliance_score)\r\n      : null,\r\n    violationsFound: record.violations_found\r\n      ? Number(record.violations_found)\r\n      : 0,\r\n    responseDelayDays: record.response_delay_days\r\n      ? Number(record.response_delay_days)\r\n      : 0,\r\n    overallGrade: record.overall_grade ? String(record.overall_grade) : null,\r\n    evaluatedOn: new Date(String(record.evaluated_on)),\r\n  };\r\n};\r\n\r\nexport class ComplianceScoresDetailsRepository extends BaseObjectRepository<\r\n  ComplianceScoresDetails,\r\n  'propertyId'\r\n> {\r\n  constructor() {\r\n    super({\r\n      tableName: 'compliance_scores_details',\r\n      idField: ['propertyId', 'property_id'],\r\n      objectMap: mapRecordToObject,\r\n      summaryMap: mapRecordToObject,\r\n    });\r\n  }\r\n\r\n  validate<\r\n    TMethod extends keyof ObjectRepository<\r\n      ComplianceScoresDetails,\r\n      'propertyId'\r\n    >,\r\n  >(\r\n    method: TMethod,\r\n    obj: FirstParameter<\r\n      Pick<\r\n        ObjectRepository<ComplianceScoresDetails, 'propertyId'>,\r\n        TMethod\r\n      >[TMethod]\r\n    >,\r\n  ): void {\r\n    const asModel = obj as ComplianceScoresDetails;\r\n    switch (method) {\r\n      case 'create':\r\n        if (!asModel.propertyId) {\r\n          asModel.propertyId = newUuid();\r\n        }\r\n        break;\r\n      case 'update':\r\n        if (!asModel.propertyId) {\r\n          throw new ValidationError({\r\n            field: 'propertyId',\r\n            source: 'ComplianceScoresDetailsRepository',\r\n          });\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  protected getListQueryProperties(): [string, Array<unknown>, string] {\r\n    return [\r\n      `SELECT * FROM compliance_scores_details \r\n       JOIN document_property ON compliance_scores_details.property_id = document_property.property_id \r\n       ORDER BY compliance_scores_details.property_id`,\r\n      [],\r\n      `SELECT COUNT(*) as records FROM compliance_scores_details`,\r\n    ];\r\n  }\r\n\r\n  protected getQueryProperties(recordId: string): [string, Array<unknown>] {\r\n    return [\r\n      `SELECT ep.*, ept.property_name, epc.description, epc.email_property_category_id,\r\n            csd.action_property_id, csd.compliance_score, csd.violations_found, csd.response_delay_days, csd.overall_grade, csd.evaluated_on\r\n            FROM document_property ep \r\n             JOIN compliance_scores_details csd ON csd.property_id = ep.property_id \r\n             JOIN email_property_type ept ON ept.document_property_type_id = ep.document_property_type_id\r\n             JOIN email_property_category epc ON ept.email_property_category_id = epc.email_property_category_id\r\n       WHERE csd.property_id = $1`,\r\n      [recordId],\r\n    ];\r\n  }\r\n\r\n  protected getCreateQueryProperties({\r\n    propertyId,\r\n    actionPropertyId,\r\n    complianceScore,\r\n    violationsFound,\r\n    responseDelayDays,\r\n    overallGrade,\r\n    evaluatedOn,\r\n    value,\r\n    documentId,\r\n    tags,\r\n    policy_basis,\r\n    createdOn,\r\n  }: ComplianceScoresDetails): [string, Array<unknown>] {\r\n    return [\r\n      `WITH ins1 AS (\r\n        INSERT INTO document_property (property_value, document_property_type_id, property_id, document_id, created_on, tags, policy_basis) \r\n        VALUES ($1, 6, $2, $3, $4, $11, $12) RETURNING property_id\r\n      )\r\n      INSERT INTO compliance_scores_details (property_id, action_property_id, compliance_score, violations_found, response_delay_days, overall_grade, evaluated_on) \r\n      VALUES ((SELECT property_id FROM ins1), $5, $6, $7, $8, $9, $10) RETURNING *`,\r\n      [\r\n        value,\r\n        propertyId,\r\n        documentId,\r\n        createdOn ?? new Date(),\r\n        actionPropertyId,\r\n        complianceScore,\r\n        violationsFound,\r\n        responseDelayDays,\r\n        overallGrade,\r\n        evaluatedOn ?? new Date(),\r\n        tags?.length ? tags : null,\r\n        policy_basis?.length ? policy_basis : null,\r\n      ],\r\n    ];\r\n  }\r\n\r\n  protected getUpdateQueryProperties({\r\n    actionPropertyId,\r\n    complianceScore,\r\n    violationsFound,\r\n    responseDelayDays,\r\n    overallGrade,\r\n    evaluatedOn,\r\n  }: ComplianceScoresDetails): [Record<string, unknown>] {\r\n    return [\r\n      {\r\n        action_property_id: actionPropertyId,\r\n        compliance_score: complianceScore,\r\n        violations_found: violationsFound,\r\n        response_delay_days: responseDelayDays,\r\n        overall_grade: overallGrade,\r\n        evaluated_on: evaluatedOn,\r\n      },\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Override to append post-processing logic to the update query.\r\n   * @param updateQuery Update query promise\r\n   * @returns The updateQuery argument\r\n   */\r\n  protected postProcessUpdate({\r\n    updateQuery,\r\n    props,\r\n  }: {\r\n    props: ComplianceScoresDetails;\r\n    updateQuery: Promise<TransformedFullQueryResults<ComplianceScoresDetails>>;\r\n  }): Promise<TransformedFullQueryResults<ComplianceScoresDetails>> {\r\n    return updateQuery.then((result) => {\r\n      const repo = new EmailPropertyRepository();\r\n      return repo.update(props).then(() => result);\r\n    });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\properties\\create-document-property.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\properties\\email-headers\\email-header-details-repository.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":140,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseObjectRepository } from '../../../_baseObjectRepository';\r\nimport { ObjectRepository } from '../../../_types';\r\nimport { ValidationError } from '@/lib/react-util/errors/validation-error';\r\nimport { FirstParameter, newUuid } from '@/lib/typescript';\r\nimport { EmailProperty } from '@/data-models/api';\r\nimport {\r\n  EmailPropertyRepository,\r\n  mapEmailPropertyRecordToObject,\r\n} from '../email-property-repository';\r\nimport { TransformedFullQueryResults } from '@/lib/neondb';\r\n\r\nconst mapRecordToObject = (record: Record<string, unknown>): EmailProperty => {\r\n  return {\r\n    ...mapEmailPropertyRecordToObject(record),\r\n  };\r\n};\r\n\r\nexport class EmailHeaderDetailsRepository extends BaseObjectRepository<\r\n  EmailProperty,\r\n  'propertyId'\r\n> {\r\n  constructor() {\r\n    super({\r\n      tableName: 'document_property',\r\n      idField: ['propertyId', 'property_id'],\r\n      objectMap: mapRecordToObject,\r\n      summaryMap: mapRecordToObject,\r\n    });\r\n  }\r\n\r\n  validate<TMethod extends keyof ObjectRepository<EmailProperty, 'propertyId'>>(\r\n    method: TMethod,\r\n    obj: FirstParameter<\r\n      Pick<ObjectRepository<EmailProperty, 'propertyId'>, TMethod>[TMethod]\r\n    >,\r\n  ): void {\r\n    const asModel = obj as EmailProperty;\r\n    switch (method) {\r\n      case 'create':\r\n        if (!asModel.propertyId) {\r\n          asModel.propertyId = newUuid();\r\n        }\r\n        break;\r\n      case 'update':\r\n        if (!asModel.propertyId) {\r\n          throw new ValidationError({\r\n            field: 'propertyId',\r\n            source: 'EmailHeaderDetailsRepository',\r\n          });\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  protected getListQueryProperties(): [string, Array<unknown>, string] {\r\n    return [\r\n      `SELECT ep.*, ept.property_name, epc.description, epc.email_property_category_id\r\n       FROM document_property ep\r\n       JOIN email_property_type ept ON ept.document_property_type_id = ep.document_property_type_id\r\n       JOIN email_property_category epc ON ept.email_property_category_id = epc.email_property_category_id\r\n       WHERE ept.email_property_category_id = 1\r\n       ORDER BY ep.property_id`,\r\n      [],\r\n      `SELECT COUNT(*) as records \r\n       FROM document_property ep\r\n       JOIN email_property_type ept ON ept.document_property_type_id = ep.document_property_type_id\r\n       WHERE ept.email_property_category_id = 1`,\r\n    ];\r\n  }\r\n\r\n  protected getQueryProperties(recordId: string): [string, Array<unknown>] {\r\n    return [\r\n      `SELECT ep.*, ept.property_name, epc.description, epc.email_property_category_id\r\n       FROM document_property ep\r\n       JOIN email_property_type ept ON ept.document_property_type_id = ep.document_property_type_id\r\n       JOIN email_property_category epc ON ept.email_property_category_id = epc.email_property_category_id\r\n       WHERE ep.property_id = $1 AND ept.email_property_category_id = 1`,\r\n      [recordId],\r\n    ];\r\n  }\r\n\r\n  protected getCreateQueryProperties({\r\n    propertyId,\r\n    value,\r\n    documentId,\r\n    createdOn,\r\n    typeId,\r\n    tags,\r\n    policy_basis,\r\n  }: EmailProperty): [string, Array<unknown>] {\r\n    return [\r\n      `INSERT INTO document_property (property_value, document_property_type_id, property_id, document_id, created_on, tags, policy_basis) \r\n       VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING *`,\r\n      [\r\n        value,\r\n        typeId,\r\n        propertyId,\r\n        documentId,\r\n        createdOn ?? new Date(),\r\n        tags?.length ? tags : null,\r\n        policy_basis?.length ? policy_basis : null,\r\n      ],\r\n    ];\r\n  }\r\n\r\n  protected getUpdateQueryProperties({\r\n    value,\r\n    tags,\r\n    policy_basis,\r\n  }: EmailProperty): [Record<string, unknown>] {\r\n    return [\r\n      {\r\n        property_value: value,\r\n        tags: tags?.length ? tags : null,\r\n        policy_basis: policy_basis?.length ? policy_basis : null,\r\n      },\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Override to append post-processing logic to the update query.\r\n   * @param updateQuery Update query promise\r\n   * @returns The updateQuery argument\r\n   */\r\n  protected postProcessUpdate({\r\n    updateQuery,\r\n    props,\r\n  }: {\r\n    props: EmailProperty;\r\n    updateQuery: Promise<TransformedFullQueryResults<EmailProperty>>;\r\n  }): Promise<TransformedFullQueryResults<EmailProperty>> {\r\n    return updateQuery.then((result) => {\r\n      const repo = new EmailPropertyRepository();\r\n      return repo.update(props).then(() => result);\r\n    });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\properties\\email-property-repository.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":158,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":98,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3460,3463],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3460,3463],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":110,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":110,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4087,4090],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4087,4090],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":128,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4765,4768],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4765,4768],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  EmailProperty,\r\n  EmailPropertyTypeTypeValues,\r\n} from '@/data-models/api/email-properties/property-type';\r\nimport { ValidationError } from '@/lib/react-util/errors/validation-error';\r\nimport { FirstParameter, newUuid } from '@/lib/typescript';\r\nimport { BaseObjectRepository } from '../../_baseObjectRepository';\r\nimport { ObjectRepository } from '../../_types';\r\n\r\nexport const mapEmailPropertyRecordToObject = (\r\n  record: Record<string, unknown>,\r\n) => ({\r\n  value: String(record.property_value),\r\n  typeId: Number(record.document_property_type_id),\r\n  propertyId: String(record.property_id),\r\n  documentId: Number(record.document_id),\r\n  typeName: record.property_name ? String(record.property_name) : undefined,\r\n  categoryName: record.description ? String(record.description) : undefined,\r\n  tags: record.tags ? (record.tags as string[]) : [],\r\n  policy_basis: record.policy_basis ? (record.policy_basis as string[]) : [],\r\n  categoryId: !!record.email_property_category_id\r\n    ? Number(record.email_property_category_id)\r\n    : undefined,\r\n  propertyUnitId: !!record.property_unit_id\r\n    ? Number(record.property_unit_id)\r\n    : undefined,\r\n  createdOn:\r\n    record.created_on instanceof Date\r\n      ? record.created_on\r\n      : new Date(String(record.created_on)),\r\n});\r\n\r\nexport class EmailPropertyRepository extends BaseObjectRepository<\r\n  EmailProperty,\r\n  'propertyId'\r\n> {\r\n  constructor() {\r\n    super({\r\n      tableName: 'document_property',\r\n      idField: ['propertyId', 'property_id'],\r\n      objectMap: mapEmailPropertyRecordToObject,\r\n      summaryMap: mapEmailPropertyRecordToObject,\r\n    });\r\n  }\r\n  /**\r\n   * Validates the input for a specific method.\r\n   *\r\n   * @template TMethod\r\n   * @param {TMethod} method - The method to validate.\r\n   * @param {FirstParameter<ObjectRepository<T, KId>[TMethod]>} obj - The input to validate.\r\n   */\r\n  validate<TMethod extends keyof ObjectRepository<EmailProperty, 'propertyId'>>(\r\n    method: TMethod,\r\n    obj: FirstParameter<\r\n      Pick<ObjectRepository<EmailProperty, 'propertyId'>, TMethod>[TMethod]\r\n    >,\r\n  ): void {\r\n    const asModel = obj as EmailProperty;\r\n    if (asModel.typeId && typeof asModel.typeId !== 'number') {\r\n      const parsedTypeId = EmailPropertyTypeTypeValues.indexOf(asModel.typeId);\r\n      if (parsedTypeId === -1) {\r\n        throw new ValidationError({\r\n          field: 'typeId',\r\n          value: asModel.typeId,\r\n          source: 'EmailPropertyRepository',\r\n        });\r\n      }\r\n      asModel.typeId = parsedTypeId;\r\n    }\r\n    switch (method) {\r\n      case 'create':\r\n        if (!asModel.documentId || !asModel.typeId) {\r\n          throw new ValidationError({\r\n            field: 'propertyId||At least one field is required for update',\r\n            source: 'EmailPropertyRepository',\r\n          });\r\n        }\r\n        if (!asModel.propertyId) {\r\n          asModel.propertyId = newUuid();\r\n        }\r\n        break;\r\n      case 'update':\r\n        if (\r\n          !asModel.propertyId ||\r\n          (!asModel.documentId && !asModel.typeId && !asModel.value)\r\n        ) {\r\n          throw new ValidationError({\r\n            field: 'propertyId||At least one field is required for update',\r\n            source: 'EmailPropertyRepository',\r\n          });\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  protected getListQueryProperties(): [string, Array<any>, string] {\r\n    return [\r\n      `SELECT ep.* ,ept.property_name,epc.description, epc.email_property_category_id\r\n            FROM document_property ep\r\n            JOIN email_property_type ept ON ept.document_property_type_id = ep.document_property_type_id\r\n            JOIN email_property_category epc ON ept.email_property_category_id = epc.email_property_category_id      \r\n      ORDER BY document_id`,\r\n      [],\r\n      `SELECT COUNT(*) as records FROM document_property`,\r\n    ];\r\n  }\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  protected getQueryProperties(recordId: string): [string, Array<any>] {\r\n    return [\r\n      'SELECT ep.* ,ept.property_name,epc.description, epc.email_property_category_id \\\r\n            FROM document_property ep \\\r\n            JOIN email_property_type ept ON ept.document_property_type_id = ep.document_property_type_id \\\r\n            JOIN email_property_category epc ON ept.email_property_category_id = epc.email_property_category_id WHERE property_id = $1',\r\n      [recordId],\r\n    ];\r\n  }\r\n  protected getCreateQueryProperties({\r\n    value,\r\n    typeId,\r\n    documentId,\r\n    createdOn,\r\n    propertyId,\r\n    policy_basis,\r\n    tags,\r\n  }: // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  EmailProperty): [string, Array<any>] {\r\n    return [\r\n      `INSERT INTO document_property (property_value, document_property_type_id, document_id, created_on, property_id, tags, policy_basis) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING *`,\r\n      [\r\n        value,\r\n        typeId,\r\n        documentId,\r\n        createdOn ?? new Date(),\r\n        propertyId,\r\n        (tags ?? []).length ? tags : null,\r\n        (policy_basis ?? []).length ? policy_basis : null,\r\n      ],\r\n    ];\r\n  }\r\n  protected getUpdateQueryProperties(\r\n    obj: EmailProperty,\r\n  ): [Record<string, unknown>] {\r\n    return [\r\n      {\r\n        property_value: obj.value,\r\n        document_property_type_id: obj.typeId,\r\n        property_id: obj.propertyId,\r\n        document_id: obj.documentId,\r\n        created_on: obj.createdOn,\r\n        tags: (obj.tags ?? []).length ? obj.tags : null,\r\n        policy_basis: (obj.policy_basis ?? []).length ? obj.policy_basis : null,\r\n      },\r\n    ];\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\properties\\email-property-type-repository.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":181,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":126,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4221,4224],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4221,4224],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":134,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":134,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4549,4552],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4549,4552],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  EmailPropertyType,\r\n  EmailPropertyCategoryTypeId,\r\n  EmailPropertyCategoryType,\r\n} from '@/data-models/api/email-properties/property-type';\r\nimport { PaginationStats, PaginatedResultset } from '@/data-models/_types';\r\nimport {\r\n  lookupEmailPropertyCategory,\r\n  lookupEmailPropertyType,\r\n} from '@/data-models/_utilities';\r\nimport { ValidationError } from '@/lib/react-util/errors/validation-error';\r\nimport { FirstParameter } from '@/lib/typescript';\r\nimport { BaseObjectRepository } from '../../_baseObjectRepository';\r\nimport { ObjectRepository } from '../../_types';\r\n\r\nexport const mapPropertyTypeRecordToObject = (\r\n  record: Record<string, unknown>,\r\n): EmailPropertyType => ({\r\n  categoryId: Number(record.email_property_category_id),\r\n  typeId: Number(record.document_property_type_id),\r\n  name: String(record.property_name),\r\n  createdOn:\r\n    record.created_at instanceof Date\r\n      ? record.created_at\r\n      : new Date(String(record.created_at)),\r\n});\r\n\r\nexport class EmailPropertyTypeRepository extends BaseObjectRepository<\r\n  EmailPropertyType,\r\n  'typeId'\r\n> {\r\n  constructor() {\r\n    super({\r\n      tableName: 'email_property_type',\r\n      idField: ['typeId', 'document_property_type_id'],\r\n      objectMap: mapPropertyTypeRecordToObject,\r\n      summaryMap: mapPropertyTypeRecordToObject,\r\n    });\r\n  }\r\n\r\n  async listForCategory(\r\n    categoryId: EmailPropertyCategoryTypeId | EmailPropertyCategoryType,\r\n    pagination: PaginationStats = { page: 1, num: 1000, total: 1000 },\r\n  ): Promise<PaginatedResultset<EmailPropertyType>> {\r\n    const [, , sqlCountQuery] = this.getListQueryProperties();\r\n    const values = [lookupEmailPropertyCategory(categoryId)];\r\n    const sqlQuery =\r\n      'SELECT * FROM email_property_type WHERE email_property_category_id = $1';\r\n    const results = await this.defaultListImpl(\r\n      {\r\n        sqlQuery,\r\n        values,\r\n        sqlCountQuery,\r\n      },\r\n      pagination,\r\n    );\r\n    return results as PaginatedResultset<EmailPropertyType>;\r\n  }\r\n\r\n  /**\r\n   * Validates the input for a specific method.\r\n   *\r\n   * @template TMethod\r\n   * @param {TMethod} method - The method to validate.\r\n   * @param {FirstParameter<ObjectRepository<T, KId>[TMethod]>} obj - The input to validate.\r\n   */\r\n  validate<TMethod extends keyof ObjectRepository<EmailPropertyType, 'typeId'>>(\r\n    method: TMethod,\r\n    obj: FirstParameter<\r\n      Pick<ObjectRepository<EmailPropertyType, 'typeId'>, TMethod>[TMethod]\r\n    >,\r\n  ): void {\r\n    const asModel = obj as EmailPropertyType;\r\n    if (\r\n      'typeId' in asModel &&\r\n      asModel.typeId &&\r\n      typeof asModel.typeId !== 'number'\r\n    ) {\r\n      const parsedTypeId = lookupEmailPropertyType(asModel.typeId);\r\n      if (parsedTypeId === -1) {\r\n        throw new ValidationError({\r\n          field: 'typeId',\r\n          value: asModel.typeId,\r\n          source: 'EmailPropertyTypeRepository',\r\n        });\r\n      }\r\n      asModel.typeId = parsedTypeId;\r\n    }\r\n    if (\r\n      'categoryId' in asModel &&\r\n      asModel.categoryId &&\r\n      typeof asModel.categoryId !== 'number'\r\n    ) {\r\n      const parsedCategoryId = lookupEmailPropertyCategory(asModel.categoryId);\r\n      if (parsedCategoryId === -1) {\r\n        throw new ValidationError({\r\n          field: 'categoryId',\r\n          value: asModel.categoryId,\r\n          source: 'EmailPropertyTypeRepository',\r\n        });\r\n      }\r\n      asModel.categoryId = parsedCategoryId;\r\n    }\r\n    switch (method) {\r\n      case 'create':\r\n        if (!asModel.categoryId || !asModel.name) {\r\n          throw new ValidationError({\r\n            field: 'typeId||At least one field is required for update',\r\n            source: 'EmailPropertyTypeRepository',\r\n          });\r\n        }\r\n        break;\r\n      case 'update':\r\n        if (!asModel.typeId || (!asModel.name && !asModel.categoryId)) {\r\n          throw new ValidationError({\r\n            field: 'typeId||At least one field is required for update',\r\n            source: 'EmailPropertyTypeRepository',\r\n          });\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  protected getListQueryProperties(): [string, Array<any>, string] {\r\n    return [\r\n      `SELECT * FROM email_property_type ORDER BY email_property_category_id`,\r\n      [],\r\n      `SELECT COUNT(*) as records FROM email_property_type`,\r\n    ];\r\n  }\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  protected getQueryProperties(recordId: number): [string, Array<any>] {\r\n    return [\r\n      'SELECT * FROM email_property_type WHERE document_property_type_id = $1',\r\n      [recordId],\r\n    ];\r\n  }\r\n  protected getCreateQueryProperties({\r\n    name,\r\n    categoryId,\r\n    createdOn,\r\n  }: EmailPropertyType): [\r\n    string,\r\n    [\r\n      string,\r\n      number | EmailPropertyCategoryType | EmailPropertyCategoryTypeId,\r\n      Date,\r\n    ],\r\n  ] {\r\n    return [\r\n      `INSERT INTO email_property_type (property_name, email_property_category_id, created_at) VALUES ($1, $2, $3) RETURNING *`,\r\n      [name, categoryId, createdOn],\r\n    ];\r\n  }\r\n  protected getUpdateQueryProperties({\r\n    categoryId,\r\n    name,\r\n    createdOn,\r\n  }: EmailPropertyType): [\r\n    {\r\n      email_property_category_id: number;\r\n      property_name: string;\r\n      created_at: Date | undefined;\r\n    },\r\n  ] {\r\n    return [\r\n      {\r\n        email_property_category_id: Number(categoryId),\r\n        property_name: String(name),\r\n        created_at: !!createdOn\r\n          ? createdOn instanceof Date\r\n            ? createdOn\r\n            : new Date(String(createdOn))\r\n          : (undefined as unknown as Date),\r\n      },\r\n    ];\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\properties\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\properties\\key-points\\key-points-details-repository.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":157,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseObjectRepository } from '../../../_baseObjectRepository';\r\nimport { ObjectRepository } from '../../../_types';\r\nimport { ValidationError } from '@/lib/react-util/errors/validation-error';\r\nimport { FirstParameter, newUuid } from '@/lib/typescript';\r\nimport { KeyPointsDetails } from '@/data-models/api';\r\nimport {\r\n  EmailPropertyRepository,\r\n  mapEmailPropertyRecordToObject,\r\n} from '../email-property-repository';\r\nimport { TransformedFullQueryResults } from '@/lib/neondb';\r\n\r\nconst mapRecordToObject = (\r\n  record: Record<string, unknown>,\r\n): KeyPointsDetails => {\r\n  return {\r\n    ...mapEmailPropertyRecordToObject(record),\r\n    propertyId: String(record.property_id),\r\n    relevance: record.relevance ? Number(record.relevance) : null,\r\n    compliance: record.compliance ? Number(record.compliance) : null,\r\n    severity: record.severity_ranking ? Number(record.severity_ranking) : null,\r\n    inferred: Boolean(record.inferred),\r\n  };\r\n};\r\n\r\nexport class KeyPointsDetailsRepository extends BaseObjectRepository<\r\n  KeyPointsDetails,\r\n  'propertyId'\r\n> {\r\n  constructor() {\r\n    super({\r\n      tableName: 'key_points_details',\r\n      idField: ['propertyId', 'property_id'],\r\n      objectMap: mapRecordToObject,\r\n      summaryMap: mapRecordToObject,\r\n    });\r\n  }\r\n\r\n  validate<\r\n    TMethod extends keyof ObjectRepository<KeyPointsDetails, 'propertyId'>,\r\n  >(\r\n    method: TMethod,\r\n    obj: FirstParameter<\r\n      Pick<ObjectRepository<KeyPointsDetails, 'propertyId'>, TMethod>[TMethod]\r\n    >,\r\n  ): void {\r\n    const asModel = obj as KeyPointsDetails;\r\n    switch (method) {\r\n      case 'create':\r\n        if (!asModel.propertyId) {\r\n          asModel.propertyId = newUuid();\r\n        }\r\n        break;\r\n      case 'update':\r\n        if (!asModel.propertyId) {\r\n          throw new ValidationError({\r\n            field: 'propertyId',\r\n            source: 'KeyPointsDetailsRepository',\r\n          });\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  protected getListQueryProperties(): [string, Array<unknown>, string] {\r\n    return [\r\n      `SELECT * FROM key_points_details \r\n       JOIN document_property ON key_points_details.property_id = document_property.property_id \r\n       ORDER BY key_points_details.property_id`,\r\n      [],\r\n      `SELECT COUNT(*) as records FROM key_points_details`,\r\n    ];\r\n  }\r\n\r\n  protected getQueryProperties(recordId: string): [string, Array<unknown>] {\r\n    return [\r\n      `SELECT ep.*, ept.property_name, epc.description, epc.email_property_category_id,\r\n            kpd.policy_id\r\n            FROM document_property ep \r\n             JOIN key_points_details kpd ON kpd.property_id = ep.property_id \r\n             JOIN email_property_type ept ON ept.document_property_type_id = ep.document_property_type_id\r\n             JOIN email_property_category epc ON ept.email_property_category_id = epc.email_property_category_id\r\n       WHERE kpd.property_id = $1`,\r\n      [recordId],\r\n    ];\r\n  }\r\n\r\n  protected getCreateQueryProperties({\r\n    propertyId,\r\n    value,\r\n    documentId,\r\n    tags,\r\n    policy_basis,\r\n    createdOn,\r\n    relevance,\r\n    compliance,\r\n    severity: severityRanking,\r\n    inferred,\r\n  }: KeyPointsDetails): [string, Array<unknown>] {\r\n    return [\r\n      `WITH ins1 AS (\r\n        INSERT INTO document_property (property_value, document_property_type_id, property_id, document_id, created_on, tags, policy_basis) \r\n        VALUES ($1, 9, $2, $3, $4, $6, $7) RETURNING property_id\r\n      )\r\n      INSERT INTO key_points_details (property_id, relevance, compliance, severity_ranking, inferred)\r\n      VALUES ((SELECT property_id FROM ins1), $5, $6, $7, $8) RETURNING *`,\r\n      [\r\n        value,\r\n        propertyId,\r\n        documentId,\r\n        createdOn ?? new Date(),\r\n        tags ?? null,\r\n        policy_basis ?? null,\r\n        relevance ?? null,\r\n        compliance ?? null,\r\n        severityRanking ?? null,\r\n        inferred ?? false,\r\n      ],\r\n    ];\r\n  }\r\n\r\n  protected getUpdateQueryProperties({\r\n    relevance,\r\n    compliance,\r\n    severity: severityRanking,\r\n    inferred,\r\n  }: KeyPointsDetails): [Record<string, unknown>] {\r\n    return [\r\n      {\r\n        relevance: relevance ?? null,\r\n        compliance: compliance ?? null,\r\n        severityRanking: severityRanking ?? null,\r\n        inferred: inferred ?? false,\r\n      },\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Override to append post-processing logic to the update query.\r\n   * @param updateQuery Update query promise\r\n   * @returns The updateQuery argument\r\n   */\r\n  protected postProcessUpdate({\r\n    updateQuery,\r\n    props,\r\n  }: {\r\n    props: KeyPointsDetails;\r\n    updateQuery: Promise<TransformedFullQueryResults<KeyPointsDetails>>;\r\n  }): Promise<TransformedFullQueryResults<KeyPointsDetails>> {\r\n    return updateQuery.then((result) => {\r\n      const repo = new EmailPropertyRepository();\r\n      return repo.update(props).then(() => result);\r\n    });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\properties\\notes\\notes-repository.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":130,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":59,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1805,1808],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1805,1808],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":72,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2518,2521],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2518,2521],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseObjectRepository } from '../../../_baseObjectRepository';\r\nimport { ObjectRepository } from '../../../_types';\r\nimport { ValidationError } from '@/lib/react-util/errors/validation-error';\r\nimport { FirstParameter, newUuid } from '@/lib/typescript';\r\nimport { EmailProperty } from '@/data-models/api';\r\nimport {\r\n  EmailPropertyRepository,\r\n  mapEmailPropertyRecordToObject,\r\n} from '../email-property-repository';\r\nimport { TransformedFullQueryResults } from '@/lib/neondb';\r\n\r\nconst mapRecordToObject = (record: Record<string, unknown>): EmailProperty => {\r\n  return {\r\n    ...mapEmailPropertyRecordToObject(record),\r\n    propertyId: String(record.property_id),\r\n  };\r\n};\r\n\r\nexport class NotesRepository extends BaseObjectRepository<\r\n  EmailProperty,\r\n  'propertyId'\r\n> {\r\n  constructor() {\r\n    super({\r\n      tableName: 'document_property',\r\n      idField: ['propertyId', 'property_id'],\r\n      objectMap: mapRecordToObject,\r\n      summaryMap: mapRecordToObject,\r\n    });\r\n  }\r\n\r\n  validate<TMethod extends keyof ObjectRepository<EmailProperty, 'propertyId'>>(\r\n    method: TMethod,\r\n    obj: FirstParameter<\r\n      Pick<ObjectRepository<EmailProperty, 'propertyId'>, TMethod>[TMethod]\r\n    >,\r\n  ): void {\r\n    const asModel = obj as EmailProperty;\r\n    switch (method) {\r\n      case 'create':\r\n        if (!asModel.propertyId) {\r\n          asModel.propertyId = newUuid();\r\n        }\r\n        break;\r\n      case 'update':\r\n        if (!asModel.propertyId) {\r\n          throw new ValidationError({\r\n            field: 'propertyId',\r\n            source: 'EmailPropertyRepository',\r\n          });\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  protected getListQueryProperties(): [string, Array<any>, string] {\r\n    return [\r\n      `SELECT ep.* ,ept.property_name,epc.description, epc.email_property_category_id\r\n            FROM document_property ep\r\n            JOIN email_property_type ept ON ept.document_property_type_id = ep.document_property_type_id\r\n            JOIN email_property_category epc ON ept.email_property_category_id = epc.email_property_category_id    \r\n      WHERE epc.email_property_category_id = 3 AND ep.document_property_type_id <> 9  \r\n      ORDER BY document_id`,\r\n      [],\r\n      `SELECT COUNT(*) as records FROM document_property`,\r\n    ];\r\n  }\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  protected getQueryProperties(recordId: string): [string, Array<any>] {\r\n    return [\r\n      'SELECT COUNT(*) as records \\\r\n        FROM document_property ep \\\r\n            JOIN email_property_type ept ON ept.document_property_type_id = ep.document_property_type_id \\\r\n            JOIN email_property_category epc ON ept.email_property_category_id = epc.email_property_category_id \\\r\n      WHERE epc.email_property_category_id = 3 AND ep.document_property_type_id <> 9',\r\n      [recordId],\r\n    ];\r\n  }\r\n  protected getCreateQueryProperties({\r\n    propertyId,\r\n    value,\r\n    documentId,\r\n    tags,\r\n    policy_basis,\r\n    createdOn,\r\n  }: EmailProperty): [string, Array<unknown>] {\r\n    return [\r\n      `WITH ins1 AS (\r\n        INSERT INTO document_property (property_value, document_property_type_id, property_id, document_id, created_on, tags, policy_basis) \r\n        VALUES ($1, 9, $2, $3, $4, $6, $7) RETURNING property_id\r\n      ) RETURNING *`,\r\n      [\r\n        value,\r\n        propertyId,\r\n        documentId,\r\n        createdOn ?? new Date(),\r\n        tags ?? null,\r\n        policy_basis ?? null,\r\n      ],\r\n    ];\r\n  }\r\n\r\n  protected getUpdateQueryProperties({}: EmailProperty): [\r\n    Record<string, unknown>,\r\n  ] {\r\n    return [{}];\r\n  }\r\n\r\n  /**\r\n   * Override to append post-processing logic to the update query.\r\n   * @param updateQuery Update query promise\r\n   * @returns The updateQuery argument\r\n   */\r\n  protected postProcessUpdate({\r\n    updateQuery,\r\n    props,\r\n  }: {\r\n    props: EmailProperty;\r\n    updateQuery: Promise<TransformedFullQueryResults<EmailProperty>>;\r\n  }): Promise<TransformedFullQueryResults<EmailProperty>> {\r\n    return updateQuery.then((result) => {\r\n      const repo = new EmailPropertyRepository();\r\n      return repo.update(props).then(() => result);\r\n    });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\properties\\sentiment-analysis\\sentiment-analysis-details-repository.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":166,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseObjectRepository } from '../../../_baseObjectRepository';\r\nimport { ObjectRepository } from '../../../_types';\r\nimport { ValidationError } from '@/lib/react-util/errors/validation-error';\r\nimport { FirstParameter, newUuid } from '@/lib/typescript';\r\nimport { EmailSentimentAnalysisDetails } from '@/data-models/api';\r\nimport {\r\n  EmailPropertyRepository,\r\n  mapEmailPropertyRecordToObject,\r\n} from '../email-property-repository';\r\nimport { TransformedFullQueryResults } from '@/lib/neondb';\r\n\r\nconst mapRecordToObject = (\r\n  record: Record<string, unknown>,\r\n): EmailSentimentAnalysisDetails => {\r\n  return {\r\n    ...mapEmailPropertyRecordToObject(record),\r\n    sentimentScore: record.sentiment_score\r\n      ? Number(record.sentiment_score)\r\n      : null,\r\n    detectedHostility: Boolean(record.detected_hostility),\r\n    flaggedPhrases: String(record.flagged_phrases),\r\n    detectedOn: new Date(String(record.detected_on)),\r\n  };\r\n};\r\n\r\nexport class SentimentAnalysisDetailsRepository extends BaseObjectRepository<\r\n  EmailSentimentAnalysisDetails,\r\n  'propertyId'\r\n> {\r\n  constructor() {\r\n    super({\r\n      tableName: 'email_sentiment_analysis_details',\r\n      idField: ['propertyId', 'property_id'],\r\n      objectMap: mapRecordToObject,\r\n      summaryMap: mapRecordToObject,\r\n    });\r\n  }\r\n\r\n  validate<\r\n    TMethod extends keyof ObjectRepository<\r\n      EmailSentimentAnalysisDetails,\r\n      'propertyId'\r\n    >,\r\n  >(\r\n    method: TMethod,\r\n    obj: FirstParameter<\r\n      Pick<\r\n        ObjectRepository<EmailSentimentAnalysisDetails, 'propertyId'>,\r\n        TMethod\r\n      >[TMethod]\r\n    >,\r\n  ): void {\r\n    const asModel = obj as EmailSentimentAnalysisDetails;\r\n    switch (method) {\r\n      case 'create':\r\n        if (!asModel.propertyId) {\r\n          asModel.propertyId = newUuid();\r\n        }\r\n        break;\r\n      case 'update':\r\n        if (!asModel.propertyId) {\r\n          throw new ValidationError({\r\n            field: 'propertyId',\r\n            source: 'SentimentAnalysisDetailsRepository',\r\n          });\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  protected getListQueryProperties(): [string, Array<unknown>, string] {\r\n    return [\r\n      `SELECT * FROM email_sentiment_analysis_details \r\n       JOIN document_property ON email_sentiment_analysis_details.property_id = document_property.property_id \r\n       ORDER BY email_sentiment_analysis_details.property_id`,\r\n      [],\r\n      `SELECT COUNT(*) as records FROM email_sentiment_analysis_details`,\r\n    ];\r\n  }\r\n\r\n  protected getQueryProperties(recordId: string): [string, Array<unknown>] {\r\n    return [\r\n      `SELECT ep.*, ept.property_name, epc.description, epc.email_property_category_id,\r\n            esad.sentiment_score, esad.detected_hostility, esad.flagged_phrases, esad.detected_on\r\n            FROM document_property ep \r\n             JOIN email_sentiment_analysis_details esad ON esad.property_id = ep.property_id \r\n             JOIN email_property_type ept ON ept.document_property_type_id = ep.document_property_type_id\r\n             JOIN email_property_category epc ON ept.email_property_category_id = epc.email_property_category_id\r\n       WHERE esad.property_id = $1`,\r\n      [recordId],\r\n    ];\r\n  }\r\n\r\n  protected getCreateQueryProperties({\r\n    propertyId,\r\n    sentimentScore,\r\n    detectedHostility,\r\n    flaggedPhrases,\r\n    detectedOn,\r\n    value,\r\n    documentId,\r\n    tags,\r\n    policy_basis,\r\n    createdOn,\r\n  }: EmailSentimentAnalysisDetails): [string, Array<unknown>] {\r\n    return [\r\n      `WITH ins1 AS (\r\n        INSERT INTO document_property (property_value, document_property_type_id, property_id, document_id, created_on, tags, policy_basis) \r\n        VALUES ($1, 8, $2, $3, $4, $9, $10) RETURNING property_id\r\n      )\r\n      INSERT INTO email_sentiment_analysis_details (property_id, sentiment_score, detected_hostility, flagged_phrases, detected_on) \r\n      VALUES ((SELECT property_id FROM ins1), $5, $6, $7, $8) RETURNING *`,\r\n      [\r\n        value,\r\n        propertyId,\r\n        documentId,\r\n        createdOn ?? new Date(),\r\n        sentimentScore,\r\n        detectedHostility,\r\n        flaggedPhrases,\r\n        detectedOn ?? new Date(),\r\n        tags?.length ? tags : null,\r\n        policy_basis?.length ? policy_basis : null,\r\n      ],\r\n    ];\r\n  }\r\n\r\n  protected getUpdateQueryProperties({\r\n    sentimentScore,\r\n    detectedHostility,\r\n    flaggedPhrases,\r\n    detectedOn,\r\n  }: EmailSentimentAnalysisDetails): [Record<string, unknown>] {\r\n    return [\r\n      {\r\n        sentiment_score: sentimentScore,\r\n        detected_hostility: detectedHostility,\r\n        flagged_phrases: flaggedPhrases,\r\n        detected_on: detectedOn,\r\n      },\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Override to append post-processing logic to the update query.\r\n   * @param updateQuery Update query promise\r\n   * @returns The updateQuery argument\r\n   */\r\n  protected postProcessUpdate({\r\n    updateQuery,\r\n    props,\r\n  }: {\r\n    props: EmailSentimentAnalysisDetails;\r\n    updateQuery: Promise<\r\n      TransformedFullQueryResults<EmailSentimentAnalysisDetails>\r\n    >;\r\n  }): Promise<TransformedFullQueryResults<EmailSentimentAnalysisDetails>> {\r\n    return updateQuery.then((result) => {\r\n      const repo = new EmailPropertyRepository();\r\n      return repo.update(props).then(() => result);\r\n    });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\properties\\violation-details\\violation-details-repository.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":175,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseObjectRepository } from '../../../_baseObjectRepository';\r\nimport { ObjectRepository } from '../../../_types';\r\nimport { ValidationError } from '@/lib/react-util/errors/validation-error';\r\nimport { FirstParameter, newUuid } from '@/lib/typescript';\r\nimport { ViolationDetails } from '@/data-models/api';\r\nimport {\r\n  EmailPropertyRepository,\r\n  mapEmailPropertyRecordToObject,\r\n} from '../email-property-repository';\r\nimport { TransformedFullQueryResults } from '@/lib/neondb';\r\n\r\nconst mapRecordToObject = (\r\n  record: Record<string, unknown>,\r\n): ViolationDetails => {\r\n  return {\r\n    ...mapEmailPropertyRecordToObject(record),\r\n    attachmentId: record.attachment_id ? Number(record.attachment_id) : null,\r\n    keyPointPropertyId: record.key_point_property_id\r\n      ? String(record.key_point_property_id)\r\n      : null,\r\n    actionPropertyId: record.action_property_id\r\n      ? String(record.action_property_id)\r\n      : null,\r\n    violationType: String(record.violation_type),\r\n    severityLevel: record.severity_level ? Number(record.severity_level) : null,\r\n    detectedBy: String(record.detected_by),\r\n    detectedOn: new Date(String(record.detected_on)),\r\n  };\r\n};\r\n\r\nexport class ViolationDetailsRepository extends BaseObjectRepository<\r\n  ViolationDetails,\r\n  'propertyId'\r\n> {\r\n  constructor() {\r\n    super({\r\n      tableName: 'violation_details',\r\n      idField: ['propertyId', 'property_id'],\r\n      objectMap: mapRecordToObject,\r\n      summaryMap: mapRecordToObject,\r\n    });\r\n  }\r\n\r\n  validate<\r\n    TMethod extends keyof ObjectRepository<ViolationDetails, 'propertyId'>,\r\n  >(\r\n    method: TMethod,\r\n    obj: FirstParameter<\r\n      Pick<ObjectRepository<ViolationDetails, 'propertyId'>, TMethod>[TMethod]\r\n    >,\r\n  ): void {\r\n    const asModel = obj as ViolationDetails;\r\n    switch (method) {\r\n      case 'create':\r\n        if (!asModel.propertyId) {\r\n          asModel.propertyId = newUuid();\r\n        }\r\n        break;\r\n      case 'update':\r\n        if (!asModel.propertyId) {\r\n          throw new ValidationError({\r\n            field: 'propertyId',\r\n            source: 'ViolationDetailsRepository',\r\n          });\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  protected getListQueryProperties(): [string, Array<unknown>, string] {\r\n    return [\r\n      `SELECT * FROM violation_details \r\n       JOIN document_property ON violation_details.property_id = document_property.property_id \r\n       ORDER BY violation_details.property_id`,\r\n      [],\r\n      `SELECT COUNT(*) as records FROM violation_details`,\r\n    ];\r\n  }\r\n\r\n  protected getQueryProperties(recordId: string): [string, Array<unknown>] {\r\n    return [\r\n      `SELECT ep.*, ept.property_name, epc.description, epc.email_property_category_id,\r\n            vd.attachment_id, vd.key_point_property_id, vd.action_property_id, vd.violation_type, vd.severity_level, vd.detected_by, vd.detected_on\r\n            FROM document_property ep \r\n             JOIN violation_details vd ON vd.property_id = ep.property_id \r\n             JOIN email_property_type ept ON ept.document_property_type_id = ep.document_property_type_id\r\n             JOIN email_property_category epc ON ept.email_property_category_id = epc.email_property_category_id\r\n       WHERE vd.property_id = $1`,\r\n      [recordId],\r\n    ];\r\n  }\r\n\r\n  protected getCreateQueryProperties({\r\n    propertyId,\r\n    attachmentId,\r\n    keyPointPropertyId,\r\n    actionPropertyId,\r\n    violationType,\r\n    severityLevel,\r\n    detectedBy,\r\n    detectedOn,\r\n    value,\r\n    documentId,\r\n    policy_basis,\r\n    tags,\r\n    createdOn,\r\n  }: ViolationDetails): [string, Array<unknown>] {\r\n    return [\r\n      `WITH ins1 AS (\r\n        INSERT INTO document_property (property_value, document_property_type_id, property_id, document_id, created_on, tags, policy_basis) \r\n        VALUES ($1, 7, $2, $3, $4, $12, $13) RETURNING property_id\r\n      )\r\n      INSERT INTO violation_details (property_id, attachment_id, key_point_property_id, action_property_id, violation_type, severity_level, detected_by, detected_on) \r\n      VALUES ((SELECT property_id FROM ins1), $5, $6, $7, $8, $9, $10, $11) RETURNING *`,\r\n      [\r\n        value,\r\n        propertyId,\r\n        documentId,\r\n        createdOn ?? new Date(),\r\n        attachmentId,\r\n        keyPointPropertyId,\r\n        actionPropertyId,\r\n        violationType,\r\n        severityLevel,\r\n        detectedBy,\r\n        detectedOn ?? new Date(),\r\n        tags?.length ? tags : null,\r\n        policy_basis?.length ? policy_basis : null,\r\n      ],\r\n    ];\r\n  }\r\n\r\n  protected getUpdateQueryProperties({\r\n    attachmentId,\r\n    keyPointPropertyId,\r\n    actionPropertyId,\r\n    violationType,\r\n    severityLevel,\r\n    detectedBy,\r\n    detectedOn,\r\n  }: ViolationDetails): [Record<string, unknown>] {\r\n    return [\r\n      {\r\n        attachment_id: attachmentId,\r\n        key_point_property_id: keyPointPropertyId,\r\n        action_property_id: actionPropertyId,\r\n        violation_type: violationType,\r\n        severity_level: severityLevel,\r\n        detected_by: detectedBy,\r\n        detected_on: detectedOn,\r\n      },\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Override to append post-processing logic to the update query.\r\n   * @param updateQuery Update query promise\r\n   * @returns The updateQuery argument\r\n   */\r\n  protected postProcessUpdate({\r\n    updateQuery,\r\n    props,\r\n  }: {\r\n    props: ViolationDetails;\r\n    updateQuery: Promise<TransformedFullQueryResults<ViolationDetails>>;\r\n  }): Promise<TransformedFullQueryResults<ViolationDetails>> {\r\n    return updateQuery.then((result) => {\r\n      const repo = new EmailPropertyRepository();\r\n      return repo.update(props).then(() => result);\r\n    });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":27,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PaginatedRequestApiParams } from '../_types';\r\n\r\n/**\r\n * Parameters for the email search API.\r\n *\r\n * @extends PaginatedRequestApiParams\r\n *\r\n * @property {number[] | number} [contactId] - An optional contact ID or array of contact IDs to filter the search.\r\n * @property {string} [query] - **(Obsolete)** An optional search query. Use `q` instead.\r\n * @property {string} [q] - An optional search query.\r\n */\r\nexport type EmailSearchApiParams = PaginatedRequestApiParams & {\r\n  /**\r\n   * An optional contact ID or array of contact IDs to filter the search.\r\n   */\r\n  contactId?: number[] | number;\r\n  /**\r\n   * **(Obsolete)** An optional search query. Use `q` instead.\r\n   * @deprecated\r\n   */\r\n  query?: string;\r\n  /**\r\n   * An optional search query.\r\n   */\r\n  q?: string;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\email\\util.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":11,"column":1,"nodeType":"Program","endLine":117,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module email-route-util\r\n *\r\n * This module provides utility functions shared by all email API routes.\r\n *\r\n * Functions:\r\n * - mapRecordToSummary: Maps a record to a summary object containing email details.\r\n * - mapRecordToObject: Maps a record to an object containing email details and body content.\r\n */\r\n\r\nimport type { ContactSummary } from '@/data-models/api/contact';\r\nimport { query } from '@/lib/neondb';\r\nimport { ValidationError } from '@/lib/react-util/errors/validation-error';\r\n\r\n/**\r\n * Maps a record to a summary object containing email details.\r\n *\r\n * @param {Record<string, unknown>} record - The record to map.\r\n * @returns {object} The mapped summary object.\r\n */\r\nexport const mapRecordToSummary = (record: Record<string, unknown>) => ({\r\n  emailId: record.email_id,\r\n  subject: record.subject,\r\n  sentOn: record.sent_timestamp,\r\n  threadId: record.thread_id,\r\n  parentEmailId: record.parent_email_id,\r\n  sender: {\r\n    contactId: record.senderid,\r\n    name: record.sendername,\r\n    email: record.senderemail,\r\n  },\r\n  count_attachments:\r\n    record.count_attachments === undefined\r\n      ? undefined\r\n      : Number(record.count_attachments),\r\n  count_kpi:\r\n    record.count_kpi === undefined ? undefined : Number(record.count_kpi),\r\n  count_notes:\r\n    record.count_notes === undefined ? undefined : Number(record.count_notes),\r\n  count_cta:\r\n    record.count_cta === undefined ? undefined : Number(record.count_cta),\r\n  count_responsive_actions:\r\n    record.count_responsive_actions === undefined\r\n      ? undefined\r\n      : Number(record.count_responsive_actions),\r\n  recipients: ((record.recipients as Array<Record<string, unknown>>) || []).map(\r\n    (r: Record<string, unknown>) => ({\r\n      contactId: r.recipient_id,\r\n      name: r.recipient_name,\r\n      email: r.recipient_email,\r\n    }),\r\n  ),\r\n});\r\n\r\n/**\r\n * Maps a record to an object containing email details and body content.\r\n *\r\n * @param {Record<string, unknown>} record - The record to map.\r\n * @returns {object} The mapped object with email details and body content.\r\n */\r\nexport const mapRecordToObject = (record: Record<string, unknown>) => ({\r\n  ...mapRecordToSummary(record),\r\n  body: record.email_contents,\r\n});\r\n\r\nexport const insertRecipients = async (\r\n  emailId: number,\r\n  recipients: ContactSummary[],\r\n  clear: boolean = true,\r\n  allowEmpty: boolean = false,\r\n) => {\r\n  if (!allowEmpty && !recipients?.length) {\r\n    throw new ValidationError({\r\n      field: 'recipients',\r\n      value: !recipients ? '[null]' : '[empty]',\r\n      reason: 'At least one recipient is required',\r\n      source: 'insertRecipients',\r\n    });\r\n  }\r\n\r\n  // Delete existing recipients if clear is true\r\n  if (clear) {\r\n    await query(\r\n      (sql) => sql`DELETE FROM email_recipients WHERE email_id = ${emailId}`,\r\n    );\r\n  }\r\n  if (!recipients.length) {\r\n    return 0;\r\n  }\r\n  // Build bulk insert statement\r\n  const insertSql = `INSERT INTO email_recipients (email_id, recipient_id)\r\n    VALUES ${recipients\r\n      .map((r: ContactSummary) => `(${emailId}, ${r.contactId})`)\r\n      .join(', ')}\r\n    RETURNING email_id, recipient_id\r\n  `.toString();\r\n  const res = await query((sql) => sql<false, false>(insertSql));\r\n  if (res.length !== recipients.length) {\r\n    throw new Error('Failed to insert all recipients');\r\n  }\r\n  return res.length;\r\n};\r\n\r\n/**\r\n * Maps a generic record object to a thread summary object.\r\n *\r\n * @param record - The record containing thread information, expected to have\r\n *   `thread_id`, `subject`, and `created_at` properties.\r\n * @returns An object with `threadId`, `subject`, and `createdOn` properties\r\n *   mapped from the input record.\r\n */\r\nexport const mapRecordToThreadSummary = (record: Record<string, unknown>) => ({\r\n  threadId: record.thread_id,\r\n  subject: record.subject,\r\n  createdOn: record.created_at,\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\repository-crud-controller.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":33,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1295,1298],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1295,1298],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":33,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":58,"suggestions":[{"messageId":"suggestPropertyKey","fix":{"range":[1300,1309],"text":"PropertyKey"},"desc":"Use `PropertyKey` instead, this is more explicit than `keyof any`."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":37,"column":5,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":8,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1479,1482],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1479,1482],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":7,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":10,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1584,1587],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1584,1587],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1650,1653],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1650,1653],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":44,"column":7,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":10,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1751,1754],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1751,1754],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":47,"column":5,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":8,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1897,1900],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1897,1900],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":52,"column":7,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":10,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2022,2025],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2022,2025],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":52,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2069,2072],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2069,2072],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":7,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":10,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2185,2188],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2185,2188],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\api\\thread\\database.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\auth\\authorized.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\auth\\drizzle-adapter.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[427,430],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[427,430],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[543,546],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[543,546],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":14,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[659,662],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[659,662],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[795,798],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[795,798],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\auth\\impersonation\\impersonation-factory.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":56,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { ImpersonationService } from './impersonation.types';\r\nimport { ImpersonationThirdParty } from './impersonation.thirdparty';\r\nimport { ImpersonationServiceCache } from './impersonation-service-cache';\r\nimport { auth } from '@/auth';\r\nimport { log } from '@/lib/logger';\r\nimport { User } from 'next-auth';\r\n\r\n/**\r\n * Strategy selection:\r\n * - Set AUTH_KEYCLOAK_IMPERSONATE_THIRDPARTY=true to use Third-party libs (KC Admin Client + openid-client) with Authorization Code flow\r\n * - Set AUTH_KEYCLOAK_IMPERSONATE_RESTAPI=true to use Admin REST API + Authorization Code flow\r\n * - Else, set AUTH_KEYCLOAK_IMPERSONATE_IMPLICIT=true to use Admin impersonation + Implicit flow\r\n * - Else, falls back to Token Exchange (audience, email required)\r\n *\r\n * All strategies implement ImpersonationService so callers can treat them uniformly.\r\n */\r\nexport const fromRequest = async ({\r\n  audience,\r\n}: {\r\n  req?: Request;\r\n  audience?: string;\r\n} = {}): Promise<ImpersonationService | undefined> => {\r\n  const session = await auth();\r\n  if (!session?.user) {\r\n    log((l) =>\r\n      l.warn('Impersonation requested without an active user session'),\r\n    );\r\n    return undefined;\r\n  }\r\n  return ImpersonationThirdParty.fromUser({ user: session.user, audience });\r\n};\r\n\r\nexport const fromUserId = async ({\r\n  user,\r\n  audience,\r\n}: {\r\n  user: User | undefined;\r\n  audience?: string;\r\n}): Promise<ImpersonationService | undefined> => {\r\n  if (!user || !user.id) {\r\n    log((l) => l.warn('Impersonation requested without a userId'));\r\n    return undefined;\r\n  }\r\n  const cache = ImpersonationServiceCache.getInstance();\r\n  return cache.getOrCreate(user.id, audience, async () => {\r\n    const service = await ImpersonationThirdParty.fromUser({\r\n      user,\r\n      audience,\r\n    });\r\n    if (!service) {\r\n      throw new Error('Failed to create impersonation service');\r\n    }\r\n    return service;\r\n  });\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\auth\\impersonation\\impersonation-service-cache.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":10,"column":1,"nodeType":"Program","endLine":428,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview User-scoped impersonation service cache for maintaining persistent service instances\r\n *\r\n * This module provides a cache for maintaining ImpersonationService instances across HTTP requests\r\n * while ensuring proper user isolation and cleanup. Each user+audience combination gets their own\r\n * service instance that persists for the configured TTL, reducing token refresh overhead and\r\n * improving performance.\r\n */\r\n\r\nimport type { ImpersonationService } from './index';\r\nimport { log } from '@/lib/logger';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\n\r\ninterface CachedImpersonationService {\r\n  service: ImpersonationService;\r\n  lastAccessed: number;\r\n  userId: string;\r\n  audience: string | undefined;\r\n}\r\n\r\ninterface ImpersonationServiceCacheConfig {\r\n  /** Maximum number of cached services per user */\r\n  maxEntriesPerUser: number;\r\n  /** Maximum total entries across all users */\r\n  maxTotalEntries: number;\r\n  /** Time to live in milliseconds */\r\n  ttl: number;\r\n  /** Cleanup interval in milliseconds */\r\n  cleanupInterval: number;\r\n}\r\n\r\n/**\r\n * Cache for maintaining ImpersonationService instances per user and audience across HTTP requests.\r\n *\r\n * Features:\r\n * - Per-user isolation with audience-based keys\r\n * - Automatic TTL-based cleanup\r\n * - LRU eviction when cache limits are exceeded\r\n * - Proper disposal of services on cleanup\r\n * - Memory usage monitoring and limits\r\n * - Thread-safe operations\r\n *\r\n * @example\r\n * ```typescript\r\n * const cache = ImpersonationServiceCache.getInstance();\r\n *\r\n * // Get or create impersonation service for a user+audience\r\n * const service = await cache.getOrCreate(\r\n *   userId,\r\n *   audience,\r\n *   async () => impersonationFactory.create({ ... })\r\n * );\r\n *\r\n * // Cleanup when done (optional - automatic cleanup also occurs)\r\n * cache.invalidateUser(userId);\r\n * cache.invalidateAudience(userId, audience);\r\n * ```\r\n */\r\nexport class ImpersonationServiceCache {\r\n  private static instance: ImpersonationServiceCache | null = null;\r\n  private cache = new Map<string, CachedImpersonationService>();\r\n  private cleanupTimer: NodeJS.Timeout | null = null;\r\n  private readonly config: ImpersonationServiceCacheConfig;\r\n\r\n  private constructor(config: Partial<ImpersonationServiceCacheConfig> = {}) {\r\n    this.config = {\r\n      maxEntriesPerUser: 5, // Max 5 different audiences per user\r\n      maxTotalEntries: 200, // Max 200 total entries across all users\r\n      ttl: 60 * 60 * 1000, // 60 minutes (longer than tool provider due to token refresh cost)\r\n      cleanupInterval: 10 * 60 * 1000, // Cleanup every 10 minutes\r\n      ...config,\r\n    };\r\n\r\n    this.startCleanupTimer();\r\n  }\r\n\r\n  /**\r\n   * Get the singleton instance of the cache.\r\n   */\r\n  public static getInstance(\r\n    config?: Partial<ImpersonationServiceCacheConfig>,\r\n  ): ImpersonationServiceCache {\r\n    if (!ImpersonationServiceCache.instance) {\r\n      ImpersonationServiceCache.instance = new ImpersonationServiceCache(\r\n        config,\r\n      );\r\n    }\r\n    return ImpersonationServiceCache.instance;\r\n  }\r\n\r\n  /**\r\n   * Generate a cache key for a user's impersonation service by audience.\r\n   */\r\n  private generateCacheKey(\r\n    userId: string,\r\n    audience: string | undefined,\r\n  ): string {\r\n    // Normalize audience to handle variations\r\n    const normalizedAudience = (audience ?? '__no-audience__')\r\n      .toLowerCase()\r\n      .trim();\r\n    return `${userId}:${normalizedAudience}`;\r\n  }\r\n\r\n  /**\r\n   * Get or create an impersonation service for a user and audience.\r\n   */\r\n  public async getOrCreate(\r\n    userId: string,\r\n    audience: string | undefined,\r\n    factory: () => Promise<ImpersonationService>,\r\n  ): Promise<ImpersonationService> {\r\n    const cacheKey = this.generateCacheKey(userId, audience);\r\n\r\n    // Check if we have a valid cached entry\r\n    const cached = this.cache.get(cacheKey);\r\n    if (cached && !this.isExpired(cached)) {\r\n      // Update last accessed time\r\n      cached.lastAccessed = Date.now();\r\n      log((l) =>\r\n        l.debug('Impersonation service cache hit', {\r\n          userId,\r\n          audience,\r\n          cacheKey,\r\n        }),\r\n      );\r\n      return cached.service;\r\n    }\r\n\r\n    // Clean up expired entry if it exists\r\n    if (cached && this.isExpired(cached)) {\r\n      this.removeEntry(cacheKey, cached);\r\n    }\r\n\r\n    // Create new impersonation service\r\n    log((l) =>\r\n      l.debug('Creating new impersonation service', {\r\n        userId,\r\n        audience,\r\n        cacheKey,\r\n      }),\r\n    );\r\n\r\n    try {\r\n      const service = await factory();\r\n\r\n      // Check cache size limits before adding\r\n      this.enforceEvictionLimits(userId);\r\n\r\n      // Cache the new service\r\n      this.cache.set(cacheKey, {\r\n        service,\r\n        lastAccessed: Date.now(),\r\n        userId,\r\n        audience,\r\n      });\r\n\r\n      log((l) =>\r\n        l.debug('Impersonation service cached successfully', {\r\n          userId,\r\n          audience,\r\n          cacheKey,\r\n          cacheSize: this.cache.size,\r\n        }),\r\n      );\r\n\r\n      return service;\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'ImpersonationServiceCache.getOrCreate',\r\n        message: 'Failed to create impersonation service',\r\n        data: { userId, audience, cacheKey },\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a cached entry is expired.\r\n   */\r\n  private isExpired(entry: CachedImpersonationService): boolean {\r\n    return Date.now() - entry.lastAccessed > this.config.ttl;\r\n  }\r\n\r\n  /**\r\n   * Remove and properly dispose of a cache entry.\r\n   */\r\n  private removeEntry(\r\n    cacheKey: string,\r\n    entry: CachedImpersonationService,\r\n  ): void {\r\n    try {\r\n      // Call clearCache if the service supports it\r\n      if (\r\n        'clearCache' in entry.service &&\r\n        typeof entry.service.clearCache === 'function'\r\n      ) {\r\n        (entry.service.clearCache as () => Promise<void> | void)();\r\n      }\r\n\r\n      log((l) =>\r\n        l.debug('Impersonation service disposed', {\r\n          userId: entry.userId,\r\n          audience: entry.audience,\r\n          cacheKey,\r\n        }),\r\n      );\r\n    } catch (error) {\r\n      log((l) =>\r\n        l.warn('Error disposing impersonation service', {\r\n          userId: entry.userId,\r\n          audience: entry.audience,\r\n          cacheKey,\r\n          error,\r\n        }),\r\n      );\r\n    }\r\n    this.cache.delete(cacheKey);\r\n  }\r\n\r\n  /**\r\n   * Enforce cache size limits with LRU eviction.\r\n   */\r\n  private enforceEvictionLimits(currentUserId: string): void {\r\n    // Check per-user limit\r\n    const userEntries = Array.from(this.cache.entries()).filter(\r\n      ([, entry]) => entry.userId === currentUserId,\r\n    );\r\n\r\n    if (userEntries.length >= this.config.maxEntriesPerUser) {\r\n      // Remove oldest entry for this user\r\n      const oldestUserEntry = userEntries.sort(\r\n        ([, a], [, b]) => a.lastAccessed - b.lastAccessed,\r\n      )[0];\r\n\r\n      if (oldestUserEntry) {\r\n        this.removeEntry(oldestUserEntry[0], oldestUserEntry[1]);\r\n      }\r\n    }\r\n\r\n    // Check total cache limit\r\n    if (this.cache.size >= this.config.maxTotalEntries) {\r\n      // Remove oldest entry globally\r\n      const oldestEntry = Array.from(this.cache.entries()).sort(\r\n        ([, a], [, b]) => a.lastAccessed - b.lastAccessed,\r\n      )[0];\r\n\r\n      if (oldestEntry) {\r\n        this.removeEntry(oldestEntry[0], oldestEntry[1]);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Invalidate all cached impersonation services for a specific user.\r\n   */\r\n  public invalidateUser(userId: string): void {\r\n    const userEntries = Array.from(this.cache.entries()).filter(\r\n      ([, entry]) => entry.userId === userId,\r\n    );\r\n\r\n    for (const [cacheKey, entry] of userEntries) {\r\n      this.removeEntry(cacheKey, entry);\r\n    }\r\n\r\n    log((l) =>\r\n      l.debug('Invalidated user impersonation services', {\r\n        userId,\r\n        removedCount: userEntries.length,\r\n      }),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Invalidate cached impersonation service for a specific user and audience.\r\n   */\r\n  public invalidateAudience(\r\n    userId: string,\r\n    audience: string | undefined,\r\n  ): void {\r\n    const cacheKey = this.generateCacheKey(userId, audience);\r\n    const entry = this.cache.get(cacheKey);\r\n\r\n    if (entry) {\r\n      this.removeEntry(cacheKey, entry);\r\n      log((l) =>\r\n        l.debug('Invalidated audience impersonation service', {\r\n          userId,\r\n          audience,\r\n          cacheKey,\r\n        }),\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all audiences cached for a specific user.\r\n   */\r\n  public getUserAudiences(userId: string): string[] {\r\n    return Array.from(this.cache.values())\r\n      .filter((entry) => entry.audience && entry.userId === userId)\r\n      .map((entry) => entry.audience!);\r\n  }\r\n\r\n  /**\r\n   * Check if a service is cached for the given user and audience.\r\n   */\r\n  public has(userId: string, audience: string | undefined): boolean {\r\n    const cacheKey = this.generateCacheKey(userId, audience);\r\n    const entry = this.cache.get(cacheKey);\r\n    return entry !== undefined && !this.isExpired(entry);\r\n  }\r\n\r\n  /**\r\n   * Clean up expired entries.\r\n   */\r\n  private cleanup(): void {\r\n    const expiredEntries: [string, CachedImpersonationService][] = [];\r\n\r\n    for (const [cacheKey, entry] of this.cache.entries()) {\r\n      if (this.isExpired(entry)) {\r\n        expiredEntries.push([cacheKey, entry]);\r\n      }\r\n    }\r\n\r\n    for (const [cacheKey, entry] of expiredEntries) {\r\n      this.removeEntry(cacheKey, entry);\r\n    }\r\n\r\n    if (expiredEntries.length > 0) {\r\n      log((l) =>\r\n        l.debug('Cleaned up expired impersonation services', {\r\n          removedCount: expiredEntries.length,\r\n          remainingCount: this.cache.size,\r\n        }),\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all cached impersonation services and dispose them.\r\n   */\r\n  public clear(): void {\r\n    for (const [cacheKey, entry] of this.cache.entries()) {\r\n      this.removeEntry(cacheKey, entry);\r\n    }\r\n\r\n    log((l) => l.debug('Cleared all cached impersonation services'));\r\n  }\r\n\r\n  /**\r\n   * Start the periodic cleanup timer.\r\n   */\r\n  private startCleanupTimer(): void {\r\n    this.cleanupTimer = setInterval(() => {\r\n      this.cleanup();\r\n    }, this.config.cleanupInterval);\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics.\r\n   */\r\n  public getStats() {\r\n    const userCounts = new Map<string, number>();\r\n    const audienceCounts = new Map<string, number>();\r\n\r\n    for (const entry of this.cache.values()) {\r\n      userCounts.set(entry.userId, (userCounts.get(entry.userId) || 0) + 1);\r\n      if (entry.audience) {\r\n        audienceCounts.set(\r\n          entry.audience,\r\n          (audienceCounts.get(entry.audience) || 0) + 1,\r\n        );\r\n      }\r\n    }\r\n\r\n    return {\r\n      totalEntries: this.cache.size,\r\n      userCounts: Object.fromEntries(userCounts),\r\n      audienceCounts: Object.fromEntries(audienceCounts),\r\n      config: this.config,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get detailed information about cached services for debugging.\r\n   */\r\n  public getDebugInfo() {\r\n    return Array.from(this.cache.entries()).map(([cacheKey, entry]) => ({\r\n      cacheKey,\r\n      userId: entry.userId,\r\n      audience: entry.audience,\r\n      lastAccessed: new Date(entry.lastAccessed).toISOString(),\r\n      age: Date.now() - entry.lastAccessed,\r\n      isExpired: this.isExpired(entry),\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Refresh a cached service by removing it from cache (next access will recreate it).\r\n   */\r\n  public refresh(userId: string, audience: string | undefined): void {\r\n    this.invalidateAudience(userId, audience);\r\n    log((l) =>\r\n      l.debug('Refreshed impersonation service', {\r\n        userId,\r\n        audience,\r\n      }),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Shutdown the cache and clean up all entries.\r\n   */\r\n  public shutdown(): void {\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer);\r\n      this.cleanupTimer = null;\r\n    }\r\n\r\n    // Dispose all cached services\r\n    this.clear();\r\n\r\n    log((l) => l.info('Impersonation service cache shutdown complete'));\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\auth\\impersonation\\impersonation.thirdparty.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":10,"column":1,"nodeType":"Program","endLine":427,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Impersonation via Keycloak Admin REST API + Authorization Code flow using third-party libraries\r\n *\r\n * Libraries used:\r\n * - @keycloak/keycloak-admin-client for admin APIs (user lookup, auth)\r\n * - openid-client for OIDC discovery and token exchange\r\n * - got + tough-cookie for HTTP with cookie jar (impersonation + authorize redirects)\r\n */\r\n\r\nimport KeycloakAdminClient from '@keycloak/keycloak-admin-client';\r\nimport {\r\n  discovery,\r\n  buildAuthorizationUrl,\r\n  authorizationCodeGrant,\r\n  randomState,\r\n  randomNonce,\r\n  type Configuration as OIDCConfiguration,\r\n} from 'openid-client';\r\nimport { got } from 'got';\r\nimport { CookieJar } from 'tough-cookie';\r\nimport { env } from '@/lib/site-util/env';\r\nimport { log } from '@/lib/logger';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport CryptoService from '@/lib/site-util/auth/crypto-service';\r\nimport type {\r\n  ImpersonationService,\r\n  UserContext,\r\n} from '@/lib/auth/impersonation/impersonation.types';\r\nimport { trace, SpanStatusCode } from '@opentelemetry/api';\r\nimport { SystemTokenStore } from './system-token-store';\r\nimport { Session, User } from 'next-auth';\r\nimport { keycloakAdminClientFactory } from '../keycloak-factories';\r\n\r\ninterface TokenResponse {\r\n  access_token: string;\r\n  token_type?: string;\r\n  expires_in?: number;\r\n  refresh_token?: string;\r\n  scope?: string;\r\n  expires_at?: number; // epoch seconds (openid-client TokenSet)\r\n}\r\n\r\ninterface ThirdPartyConfig {\r\n  issuer: string;\r\n  clientId: string;\r\n  clientSecret: string;\r\n  redirectUri: string;\r\n}\r\n\r\nconst extractRealmFromIssuer = (issuer: string): string | undefined => {\r\n  try {\r\n    const u = new URL(issuer);\r\n    const parts = u.pathname.split('/').filter(Boolean);\r\n    const idx = parts.findIndex((p) => p === 'realms');\r\n    if (idx >= 0 && parts[idx + 1]) return decodeURIComponent(parts[idx + 1]);\r\n    return undefined;\r\n  } catch {\r\n    return undefined;\r\n  }\r\n};\r\n\r\nconst adminBaseFromIssuer = (\r\n  issuer: string,\r\n): { origin: string; realm: string; adminBase: string } | undefined => {\r\n  try {\r\n    const u = new URL(issuer);\r\n    const realm = extractRealmFromIssuer(issuer);\r\n    if (!realm) return undefined;\r\n    return {\r\n      origin: u.origin,\r\n      realm,\r\n      adminBase: `${u.origin}/admin/realms/${encodeURIComponent(realm)}`,\r\n    };\r\n  } catch {\r\n    return undefined;\r\n  }\r\n};\r\n\r\n// no-op: query builder not needed with openid-client's authorizationUrl\r\n\r\n/**\r\n * ImpersonationThirdParty – uses KC Admin Client, openid-client, and got/tough-cookie\r\n */\r\nexport class ImpersonationThirdParty implements ImpersonationService {\r\n  private readonly userContext: UserContext;\r\n  private readonly config: ThirdPartyConfig;\r\n  private kcAdmin?: KeycloakAdminClient;\r\n  private oidcConfig?: OIDCConfiguration;\r\n  private cookieJar?: CookieJar;\r\n  private cachedToken?: string;\r\n  private tokenExpiry?: Date;\r\n  #adminTokenStore: SystemTokenStore = SystemTokenStore.getInstance();\r\n  private crypto?: CryptoService;\r\n\r\n  constructor(userContext: UserContext, config: ThirdPartyConfig) {\r\n    this.userContext = userContext;\r\n    this.config = config;\r\n  }\r\n\r\n  static #getConfig(): ThirdPartyConfig | undefined {\r\n    const config: ThirdPartyConfig = {\r\n      issuer: env('AUTH_KEYCLOAK_ISSUER') || '',\r\n      clientId: env('AUTH_KEYCLOAK_CLIENT_ID') || '',\r\n      clientSecret: env('AUTH_KEYCLOAK_CLIENT_SECRET') || '',\r\n      redirectUri: env('AUTH_KEYCLOAK_REDIRECT_URI') || '',\r\n    };\r\n\r\n    if (\r\n      !config.issuer ||\r\n      !config.clientId ||\r\n      !config.clientSecret ||\r\n      !config.redirectUri\r\n    ) {\r\n      log((l) => l.warn('ImpersonationThirdParty: incomplete config'));\r\n      return undefined;\r\n    }\r\n    return config;\r\n  }\r\n\r\n  static async fromRequest({\r\n    session,\r\n    ...props\r\n  }: {\r\n    audience?: string;\r\n    session: Session;\r\n  }): Promise<ImpersonationThirdParty | undefined> {\r\n    return ImpersonationThirdParty.fromUser({ user: session?.user, ...props });\r\n  }\r\n\r\n  static async fromUser({\r\n    user,\r\n  }: {\r\n    audience?: string;\r\n    user: User | undefined;\r\n  }): Promise<ImpersonationThirdParty | undefined> {\r\n    try {\r\n      if (!user) return undefined;\r\n      const userContext: UserContext = {\r\n        userId: user.subject || user.id || '',\r\n        email: user.email || undefined,\r\n        name: user.name || undefined,\r\n        accountId: 'account_id' in user ? user.account_id : undefined,\r\n      };\r\n      if (!userContext.email) return undefined;\r\n\r\n      const config = ImpersonationThirdParty.#getConfig();\r\n      if (!config) {\r\n        return undefined;\r\n      }\r\n\r\n      const self = new ImpersonationThirdParty(userContext, config);\r\n      await self.initializeClients();\r\n      return self;\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        source: 'ImpersonationThirdParty.fromRequest',\r\n        severity: 'error',\r\n        message: 'Failed creating ImpersonationThirdParty',\r\n      });\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  private async initializeClients(): Promise<void> {\r\n    // OIDC discovery and client\r\n    this.oidcConfig = await discovery(\r\n      new URL(this.config.issuer),\r\n      this.config.clientId,\r\n      this.config.clientSecret,\r\n    );\r\n\r\n    // Keycloak Admin client\r\n    const parsed = adminBaseFromIssuer(this.config.issuer);\r\n    if (!parsed)\r\n      throw new Error(\r\n        'ImpersonationThirdParty: unable to parse realm from issuer',\r\n      );\r\n    const { origin, realm } = parsed;\r\n    this.kcAdmin = keycloakAdminClientFactory({\r\n      baseUrl: origin,\r\n      realmName: realm,\r\n    });\r\n\r\n    // Cookie jar for admin impersonation and authorize request\r\n    this.cookieJar = new CookieJar();\r\n  }\r\n\r\n  async getImpersonatedToken(forceRefresh = false): Promise<string> {\r\n    const tracer = trace.getTracer('noeducation/impersonation');\r\n    return await tracer.startActiveSpan(\r\n      'impersonation.getImpersonatedToken',\r\n      async (span) => {\r\n        span.setAttribute('impersonation.userId', this.userContext.userId);\r\n        if (this.userContext.email)\r\n          span.setAttribute('impersonation.email', this.userContext.email);\r\n        try {\r\n          // Fast-path cached token if valid and not forcing refresh\r\n          if (\r\n            !forceRefresh &&\r\n            this.cachedToken &&\r\n            this.tokenExpiry &&\r\n            this.tokenExpiry > new Date()\r\n          ) {\r\n            span.setStatus({ code: SpanStatusCode.OK });\r\n            return this.cachedToken;\r\n          }\r\n\r\n          // Helper for a single attempt; keeps logic contained\r\n          const attemptOnce = async (): Promise<string> => {\r\n            if (!this.kcAdmin || !this.oidcConfig || !this.cookieJar) {\r\n              await this.initializeClients();\r\n            }\r\n\r\n            const adminToken = await this.#adminTokenStore.getAdminToken();\r\n            this.kcAdmin!.setAccessToken(adminToken);\r\n\r\n            const userId =\r\n              // this.userContext.userId ??\r\n              await this.findUserIdViaAdmin(this.userContext.email!);\r\n            if (!userId)\r\n              throw new Error('ImpersonationThirdParty: target user not found');\r\n\r\n            await this.performImpersonation(adminToken, userId);\r\n\r\n            const access = await this.authorizeAndExchange();\r\n\r\n            this.cachedToken = access.access_token;\r\n            if (access.expires_at) {\r\n              this.tokenExpiry = new Date(access.expires_at * 1000 - 60_000);\r\n            } else if (access.expires_in) {\r\n              this.tokenExpiry = new Date(\r\n                Date.now() + Math.max(60, access.expires_in) * 1000 - 60_000,\r\n              );\r\n            } else {\r\n              this.tokenExpiry = new Date(Date.now() + 10 * 60_000);\r\n            }\r\n            return this.cachedToken!;\r\n          };\r\n\r\n          // First attempt\r\n          try {\r\n            const token = await attemptOnce();\r\n            span.setStatus({ code: SpanStatusCode.OK });\r\n            return token;\r\n          } catch (firstErr) {\r\n            // Clear caches and retry once with a fresh instance\r\n            const msg = (firstErr as Error)?.message || '';\r\n            // Do NOT retry for logical/semantic errors where a retry won't help\r\n            const nonRetryable =\r\n              /target user not found|missing impersonator credentials|unable to locate login form action|admin login failed|admin password step failed|unable to locate password form|expected 302 from authorize|expected 302 with code after admin login/i;\r\n            if (nonRetryable.test(msg)) {\r\n              span.recordException(firstErr as Error);\r\n              span.setStatus({ code: SpanStatusCode.ERROR });\r\n              throw firstErr;\r\n            }\r\n            try {\r\n              span.addEvent('impersonation.retry');\r\n            } catch {\r\n              // ignore addEvent errors\r\n            }\r\n            await this.clearAllCachedCredentials();\r\n            try {\r\n              const token = await attemptOnce();\r\n              span.setStatus({ code: SpanStatusCode.OK });\r\n              return token;\r\n            } catch (secondErr) {\r\n              // Record the last error and rethrow\r\n              try {\r\n                span.recordException(secondErr as Error);\r\n                span.setStatus({ code: SpanStatusCode.ERROR });\r\n              } catch {}\r\n              throw secondErr;\r\n            }\r\n          }\r\n        } finally {\r\n          span.end();\r\n        }\r\n      },\r\n    );\r\n  }\r\n\r\n  getUserContext(): Readonly<UserContext> {\r\n    return { ...this.userContext };\r\n  }\r\n\r\n  clearCache(): void {\r\n    this.cachedToken = undefined;\r\n    this.tokenExpiry = undefined;\r\n  }\r\n\r\n  hasCachedToken(): boolean {\r\n    return !!(\r\n      this.cachedToken &&\r\n      this.tokenExpiry &&\r\n      this.tokenExpiry > new Date()\r\n    );\r\n  }\r\n\r\n  // --- internals ---\r\n\r\n  private async findUserIdViaAdmin(\r\n    identifier: string,\r\n  ): Promise<string | undefined> {\r\n    if (!this.kcAdmin) throw new Error('kcAdmin not initialized');\r\n\r\n    // Try exact username\r\n    const byUsername = await this.kcAdmin.users\r\n      .find({ username: identifier, exact: true })\r\n      .catch(() => []);\r\n    if (Array.isArray(byUsername) && byUsername[0]?.id) return byUsername[0].id;\r\n\r\n    // Try exact email\r\n    const byEmail = await this.kcAdmin.users\r\n      .find({ email: identifier, exact: true })\r\n      .catch(() => []);\r\n    if (Array.isArray(byEmail) && byEmail[0]?.id) return byEmail[0].id;\r\n\r\n    // Fallback search\r\n    const search = await this.kcAdmin.users\r\n      .find({ search: identifier })\r\n      .catch(() => []);\r\n    if (Array.isArray(search) && search[0]?.id) return search[0].id;\r\n\r\n    return undefined;\r\n  }\r\n\r\n  private async performImpersonation(\r\n    adminToken: string,\r\n    userId: string,\r\n  ): Promise<void> {\r\n    if (!this.cookieJar) throw new Error('cookieJar not initialized');\r\n\r\n    const parsed = adminBaseFromIssuer(this.config.issuer);\r\n    if (!parsed)\r\n      throw new Error('ImpersonationThirdParty: cannot derive admin base');\r\n    const url = `${parsed.adminBase}/users/${encodeURIComponent(userId)}/impersonation`;\r\n\r\n    const resp = await got.post(url, {\r\n      headers: {\r\n        Authorization: `Bearer ${adminToken}`,\r\n        Accept: 'application/json',\r\n      },\r\n      cookieJar: this.cookieJar,\r\n      followRedirect: false,\r\n      throwHttpErrors: false,\r\n    });\r\n\r\n    if (resp.statusCode !== 200 && resp.statusCode !== 302) {\r\n      throw new Error(\r\n        `ImpersonationThirdParty: impersonation failed ${resp.statusCode} ${resp.body?.toString?.() ?? ''}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  private async authorizeAndExchange(): Promise<TokenResponse> {\r\n    if (!this.oidcConfig || !this.cookieJar)\r\n      throw new Error('OIDC config/cookieJar not initialized');\r\n\r\n    const state = randomState();\r\n    const nonce = randomNonce();\r\n\r\n    const authorizeUrl = buildAuthorizationUrl(this.oidcConfig, {\r\n      redirect_uri: this.config.redirectUri,\r\n      scope: 'openid',\r\n      response_type: 'code',\r\n      response_mode: 'query',\r\n      prompt: 'none',\r\n      state,\r\n      nonce,\r\n    });\r\n\r\n    const resp = await got.get(authorizeUrl.toString(), {\r\n      cookieJar: this.cookieJar,\r\n      followRedirect: false,\r\n      throwHttpErrors: false,\r\n    });\r\n\r\n    if (resp.statusCode !== 302) {\r\n      throw new Error(\r\n        `ImpersonationThirdParty: expected 302 from authorize, got ${resp.statusCode}`,\r\n      );\r\n    }\r\n\r\n    const location = resp.headers.location;\r\n    if (!location)\r\n      throw new Error(\r\n        'ImpersonationThirdParty: missing Location header from authorize response',\r\n      );\r\n\r\n    const currentUrl = new URL(location, this.config.redirectUri);\r\n    const token = await authorizationCodeGrant(this.oidcConfig, currentUrl, {\r\n      expectedState: state,\r\n      expectedNonce: nonce,\r\n    });\r\n\r\n    return {\r\n      access_token: token.access_token as string,\r\n      expires_in: token.expires_in ?? undefined,\r\n      refresh_token: token.refresh_token ?? undefined,\r\n      scope: token.scope ?? undefined,\r\n      token_type: token.token_type ?? undefined,\r\n    };\r\n  }\r\n\r\n  // --- offline token helpers ---\r\n\r\n  /**\r\n   * Clear all cached credentials (user/admin tokens, expirations, cookie jar),\r\n   * remove any stored offline token from Redis/env, and reinitialize clients\r\n   * on next usage to ensure a fresh attempt.\r\n   */\r\n  private async clearAllCachedCredentials(): Promise<void> {\r\n    // Clear memory caches (user tokens)\r\n    this.cachedToken = undefined;\r\n    this.tokenExpiry = undefined;\r\n\r\n    // Clear admin token store cache (includes Redis cleanup)\r\n    await this.#adminTokenStore.clearCache();\r\n\r\n    // Reset third-party clients to force fresh initialization\r\n    this.kcAdmin = undefined;\r\n    this.oidcConfig = undefined;\r\n    this.cookieJar = undefined;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\auth\\impersonation\\impersonation.types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":9,"column":1,"nodeType":"Program","endLine":170,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Shared types and contract for Impersonation services.\r\n * Defines the minimal public API used by callers and a common UserContext shape.\r\n */\r\n\r\n/**\r\n * User context extracted from the current session\r\n */\r\nexport type UserContext = {\r\n  /** User ID from the session (NextAuth id or subject) */\r\n  userId: string;\r\n  /** User email from the session */\r\n  email?: string;\r\n  /** User name from the session */\r\n  name?: string;\r\n  /** Account ID if available */\r\n  accountId?: string | number;\r\n};\r\n\r\n/**\r\n * Public methods exposed by any Impersonation implementation.\r\n * Both the default token-exchange flow and the implicit-flow variant implement this.\r\n */\r\nexport interface ImpersonationService {\r\n  /** Obtain an impersonated access token, using cache unless forceRefresh is true */\r\n  getImpersonatedToken(forceRefresh?: boolean): Promise<string>;\r\n  /** Retrieve the immutable user context tied to this impersonation instance */\r\n  getUserContext(): Readonly<UserContext>;\r\n  /** Clear any cached token to force a fresh exchange on next request */\r\n  clearCache(): void;\r\n  /** Whether a currently valid cached token exists */\r\n  hasCachedToken(): boolean;\r\n}\r\n\r\n/**\r\n * Configuration for admin token acquisition in Keycloak environment\r\n *\r\n * @interface AdminTokenConfig\r\n * @description Defines all required and optional configuration parameters\r\n * for acquiring admin tokens from Keycloak. Supports both OAuth2 OIDC flows\r\n * and direct credential-based authentication.\r\n *\r\n * @example\r\n * ```typescript\r\n * const config: AdminTokenConfig = {\r\n *   issuer: 'https://auth.example.com/realms/master',\r\n *   clientId: 'admin-cli',\r\n *   clientSecret: 'client-secret',\r\n *   realm: 'master',\r\n *   adminBase: 'https://auth.example.com/admin/realms/master',\r\n *   redirectUri: 'https://app.example.com/auth/callback',\r\n *   impersonatorUsername: 'admin-user',\r\n *   impersonatorPassword: 'admin-password'\r\n * };\r\n * ```\r\n */\r\nexport type AdminTokenConfig = {\r\n  /** Keycloak issuer URL (e.g., 'https://auth.example.com/realms/master') */\r\n  issuer: string;\r\n  /** OAuth2 client ID for token acquisition */\r\n  clientId: string;\r\n  /** OAuth2 client secret for token acquisition */\r\n  clientSecret: string;\r\n  /** Keycloak realm name (extracted from issuer URL) */\r\n  realm: string;\r\n  /** Base URL for Keycloak admin API endpoints */\r\n  adminBase: string;\r\n  /** OAuth2 redirect URI for authorization code flows */\r\n  redirectUri: string;\r\n  /** Optional: Username for direct credential authentication */\r\n  impersonatorUsername?: string;\r\n  /** Optional: Password for direct credential authentication */\r\n  impersonatorPassword?: string;\r\n  /** Token expiry safety buffer in seconds (default: 30) */\r\n  tokenExpiryBufferSeconds?: number;\r\n  /** Redis token TTL in days (default: 30) */\r\n  redisTokenTtlDays?: number;\r\n  /** Maximum retry attempts for authentication (default: 3) */\r\n  maxRetryAttempts?: number;\r\n  /** Rate limiting: max attempts per window (default: 5) */\r\n  rateLimitMaxAttempts?: number;\r\n  /** Rate limiting: time window in ms (default: 60000) */\r\n  rateLimitWindowMs?: number;\r\n};\r\n\r\n/**\r\n * Token response structure from Keycloak OAuth2/OIDC endpoints\r\n *\r\n * @interface TokenResponse\r\n * @description Standard OAuth2 token response format as returned by Keycloak\r\n * token endpoints. All fields except access_token are optional per OAuth2 spec.\r\n *\r\n * @see {@link https://datatracker.ietf.org/doc/html/rfc6749#section-5.1} OAuth2 Token Response\r\n *\r\n * @example\r\n * ```typescript\r\n * const tokenResponse: TokenResponse = {\r\n *   access_token: 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...',\r\n *   token_type: 'Bearer',\r\n *   expires_in: 3600,\r\n *   refresh_token: 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...',\r\n *   scope: 'openid profile email'\r\n * };\r\n * ```\r\n */\r\nexport type TokenResponse = {\r\n  /** JWT access token for API authentication */\r\n  access_token: string;\r\n  /** Token type (typically 'Bearer' for JWT tokens) */\r\n  token_type?: string;\r\n  /** Token lifetime in seconds from time of issuance */\r\n  expires_in?: number;\r\n  /** Refresh token for obtaining new access tokens without re-authentication */\r\n  refresh_token?: string;\r\n  /** Space-separated list of granted OAuth2 scopes */\r\n  scope?: string;\r\n};\r\n\r\n/**\r\n * Cached token data with expiry information for internal storage\r\n *\r\n * @interface CachedTokenData\r\n * @description Internal representation of cached authentication tokens with\r\n * computed expiry dates and optional refresh tokens. Used by SystemTokenStore\r\n * to manage token lifecycle and prevent unnecessary re-authentication.\r\n *\r\n * @example\r\n * ```typescript\r\n * const cachedData: CachedTokenData = {\r\n *   token: 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...',\r\n *   expiry: new Date(Date.now() + 3600000), // 1 hour from now\r\n *   refreshToken: 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...'\r\n * };\r\n * ```\r\n */\r\nexport type CachedTokenData = {\r\n  /** The cached JWT access token */\r\n  token: string;\r\n  /** Computed expiry date with safety buffer (typically expires_in - 60 seconds) */\r\n  expiry: Date;\r\n  /** Optional refresh token for silent token renewal */\r\n  refreshToken?: string;\r\n};\r\n\r\n/**\r\n * Result structure for form-based login operations\r\n *\r\n * @interface FormLoginResult\r\n * @description Contains the results of a successful form-based authentication\r\n * flow with Keycloak. This represents ready-to-use access tokens (not authorization\r\n * codes) obtained through direct form submission and OIDC token exchange.\r\n *\r\n * @example\r\n * ```typescript\r\n * const loginResult: FormLoginResult = {\r\n *   accessToken: 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...',\r\n *   refreshToken: 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...',\r\n *   expiresIn: 3600\r\n * };\r\n * ```\r\n */\r\nexport type FormLoginResult = {\r\n  /** Ready-to-use JWT access token obtained from successful form login */\r\n  accessToken: string;\r\n  /** Optional refresh token for silent token renewal */\r\n  refreshToken?: string;\r\n  /** Token lifetime in seconds from time of issuance */\r\n  expiresIn?: number;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\auth\\impersonation\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\auth\\impersonation\\system-token-store.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":29,"column":1,"nodeType":"Program","endLine":1760,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview SystemTokenStore - Singleton for managing shared admin tokens across impersonation instances\r\n *\r\n * This singleton prevents multiple impersonation instances from racing to acquire admin tokens,\r\n * which would invalidate refresh tokens and cause authentication failures. Uses global symbol\r\n * registry pattern for cross-module singleton behavior and promise protection for concurrent access.\r\n *\r\n * **Key Features:**\r\n * - Global symbol-based singleton (survives HMR and module reloads)\r\n * - Promise-protected token acquisition (first caller creates promise, others await it)\r\n * - Comprehensive OpenTelemetry instrumentation for observability\r\n * - Redis-backed encrypted offline token storage\r\n * - Automatic token expiry management and refresh\r\n * - Multi-strategy authentication (offline tokens, credentials, form-based)\r\n * - Thread-safe concurrent access protection\r\n * - Comprehensive error handling and logging\r\n *\r\n * **Documentation Coverage:**\r\n * This module includes comprehensive JSDoc documentation for all public APIs,\r\n * private methods, interfaces, types, and utility functions. Each method includes\r\n * detailed descriptions, parameter documentation, return types, examples, and\r\n * cross-references to related functionality.\r\n *\r\n * @author SystemTokenStore Development Team\r\n * @since 1.0.0\r\n * @version 2.0.0\r\n */\r\n\r\nimport { CookieJar } from 'tough-cookie';\r\nimport { got } from 'got';\r\nimport {\r\n  discovery,\r\n  buildAuthorizationUrl,\r\n  authorizationCodeGrant,\r\n  randomState,\r\n  randomNonce,\r\n  type Configuration as OIDCConfiguration,\r\n} from 'openid-client';\r\nimport { parse as parseHtml } from 'node-html-parser';\r\nimport { createInstrumentedSpan } from '@/lib/nextjs-util/server/utils';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { CryptoService } from '@/lib/site-util/auth/crypto-service';\r\nimport { getRedisClient } from '@/lib/ai/middleware/cacheWithRedis/redis-client';\r\nimport { env } from '@/lib/site-util/env';\r\nimport { SimpleRateLimiter } from '@/lib/react-util/simple-rate-limiter';\r\nimport { SimpleCircuitBreaker } from '@/lib/react-util/simple-circuit-breaker';\r\nimport type {\r\n  AdminTokenConfig,\r\n  TokenResponse,\r\n  CachedTokenData,\r\n  FormLoginResult,\r\n} from './impersonation.types';\r\nimport { defaultConfigFromEnv } from './utility';\r\n\r\n/**\r\n * SystemTokenStore - Thread-safe singleton for centralized admin token management\r\n *\r\n * @class SystemTokenStore\r\n * @description Provides centralized, thread-safe management of Keycloak admin tokens\r\n * across multiple impersonation instances. Implements the singleton pattern using\r\n * global symbol registry to ensure a single instance exists even during HMR and\r\n * module reloads in development environments.\r\n *\r\n * **Key Features:**\r\n * - **Concurrency Protection**: Promise-based synchronization prevents race conditions\r\n * - **Multi-Strategy Authentication**: Supports offline tokens, credentials, and form-based flows\r\n * - **Comprehensive Caching**: Memory and Redis-based token storage with expiry management\r\n * - **OpenTelemetry Integration**: Full distributed tracing for authentication flows\r\n * - **Encryption**: Secure storage of sensitive tokens using CryptoService\r\n * - **Automatic Failover**: Falls back through multiple authentication strategies\r\n *\r\n * **Authentication Strategies (in order of preference):**\r\n * 1. **Offline Token Strategy**: Uses stored refresh tokens for silent renewal\r\n * 2. **Credentials Strategy**: Username/password authentication with form login\r\n * 3. **Form Login Strategy**: Handles complex Keycloak login flows (single/multi-step)\r\n *\r\n * @example Basic Usage\r\n * ```typescript\r\n * // Get singleton instance (auto-configures from environment)\r\n * const tokenStore = SystemTokenStore.getInstance();\r\n *\r\n * // Get valid admin token (handles caching and renewal)\r\n * const adminToken = await tokenStore.getAdminToken();\r\n *\r\n * // Force token refresh\r\n * const freshToken = await tokenStore.getAdminToken(true);\r\n *\r\n * // Clear all cached tokens\r\n * await tokenStore.clearCache();\r\n * ```\r\n *\r\n * @example Custom Configuration\r\n * ```typescript\r\n * const config: AdminTokenConfig = {\r\n *   issuer: 'https://auth.example.com/realms/master',\r\n *   clientId: 'admin-cli',\r\n *   clientSecret: 'secret',\r\n *   realm: 'master',\r\n *   adminBase: 'https://auth.example.com/admin/realms/master',\r\n *   redirectUri: 'https://app.example.com/callback',\r\n *   impersonatorUsername: 'admin',\r\n *   impersonatorPassword: 'password'\r\n * };\r\n *\r\n * const tokenStore = SystemTokenStore.getInstance(config);\r\n * const token = await tokenStore.getAdminToken();\r\n * ```\r\n *\r\n * @example Concurrent Access Handling\r\n * ```typescript\r\n * // Multiple concurrent calls are automatically synchronized\r\n * const [token1, token2, token3] = await Promise.all([\r\n *   tokenStore.getAdminToken(),\r\n *   tokenStore.getAdminToken(),\r\n *   tokenStore.getAdminToken()\r\n * ]);\r\n * // All three will receive the same token - only one network request made\r\n * ```\r\n *\r\n * @see {@link AdminTokenConfig} for configuration options\r\n * @see {@link FormLoginResult} for form login return structure\r\n * @see {@link CachedTokenData} for internal caching structure\r\n */\r\nexport class SystemTokenStore {\r\n  /**\r\n   * Global symbol key for the singleton registry\r\n   * @description Uses Symbol.for() to create a global symbol that survives\r\n   * module reloads and hot module replacement in development environments.\r\n   * This ensures true singleton behavior across the entire application.\r\n   */\r\n  static readonly #REGISTRY_KEY = Symbol.for(\r\n    '@noeducation/auth:SystemTokenStore',\r\n  );\r\n\r\n  /**\r\n   * Global symbol key for the shared initialization promise\r\n   * @description Stores the shared promise for concurrent token acquisition\r\n   * attempts. This prevents multiple simultaneous token requests from creating\r\n   * race conditions that could invalidate refresh tokens.\r\n   */\r\n  static readonly #INIT_PROMISE_KEY = Symbol.for(\r\n    '@noeducation/auth:SystemTokenStore:initPromise',\r\n  );\r\n\r\n  /** Get the singleton instance from global registry */\r\n  static get #instance(): SystemTokenStore | undefined {\r\n    type GlobalReg = { [k: symbol]: SystemTokenStore | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    return g[this.#REGISTRY_KEY];\r\n  }\r\n\r\n  /** Set the singleton instance in global registry */\r\n  static set #instance(value: SystemTokenStore | undefined) {\r\n    type GlobalReg = { [k: symbol]: SystemTokenStore | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    g[this.#REGISTRY_KEY] = value;\r\n  }\r\n\r\n  /** Get the shared initialization promise from global registry */\r\n  static get #initPromise(): Promise<string> | undefined {\r\n    type GlobalReg = { [k: symbol]: Promise<string> | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    return g[this.#INIT_PROMISE_KEY];\r\n  }\r\n\r\n  /** Set the shared initialization promise in global registry */\r\n  static set #initPromise(value: Promise<string> | undefined) {\r\n    type GlobalReg = { [k: symbol]: Promise<string> | undefined };\r\n    const g = globalThis as unknown as GlobalReg;\r\n    g[this.#INIT_PROMISE_KEY] = value;\r\n  }\r\n\r\n  /**\r\n   * Immutable configuration for admin token acquisition\r\n   * @description Contains all necessary endpoints, credentials, and settings\r\n   * for authenticating with Keycloak. Set during construction and never modified.\r\n   */\r\n  private readonly config: AdminTokenConfig;\r\n\r\n  /**\r\n   * In-memory cached token data with expiry information\r\n   * @description Stores the current valid access token along with its computed\r\n   * expiry time and optional refresh token. Cleared when tokens expire or\r\n   * clearCache() is called.\r\n   */\r\n  private cachedTokenData?: CachedTokenData;\r\n\r\n  /**\r\n   * Lazy-loaded crypto service for token encryption\r\n   * @description Used for encrypting/decrypting refresh tokens stored in Redis.\r\n   * Instantiated on first use to avoid unnecessary initialization overhead.\r\n   */\r\n  private crypto?: CryptoService;\r\n\r\n  /**\r\n   * Cached OIDC discovery configuration from Keycloak\r\n   * @description Contains discovered endpoints and configuration from Keycloak's\r\n   * .well-known/openid_configuration endpoint. Cached to avoid repeated discovery.\r\n   */\r\n  private oidcConfig?: OIDCConfiguration;\r\n\r\n  /**\r\n   * Rate limiter for authentication attempts\r\n   * @description Prevents brute force attacks by limiting authentication attempts per time window\r\n   */\r\n  private rateLimiter: SimpleRateLimiter;\r\n\r\n  /**\r\n   * Circuit breaker for external API calls\r\n   * @description Prevents cascading failures by temporarily stopping requests after repeated failures\r\n   */\r\n  private circuitBreaker: SimpleCircuitBreaker;\r\n\r\n  /**\r\n   * Private constructor for singleton pattern\r\n   *\r\n   * @private\r\n   * @constructor\r\n   * @description Initializes a new SystemTokenStore instance with the provided\r\n   * configuration. This constructor is private to enforce the singleton pattern.\r\n   * Use {@link getInstance} to obtain the singleton instance.\r\n   *\r\n   * @param {AdminTokenConfig} config - Complete configuration for admin token acquisition\r\n   * @throws {Error} When configuration validation fails\r\n   */\r\n  private constructor(config: AdminTokenConfig) {\r\n    this.config = this.#validateAndSanitizeConfig(config);\r\n    this.rateLimiter = new SimpleRateLimiter(\r\n      config.rateLimitMaxAttempts ?? 5,\r\n      config.rateLimitWindowMs ?? 60000,\r\n    );\r\n    this.circuitBreaker = new SimpleCircuitBreaker(5, 30000);\r\n  }\r\n\r\n  /**\r\n   * Get the singleton instance, creating it if necessary\r\n   *\r\n   * @static\r\n   * @method getInstance\r\n   * @description Returns the singleton SystemTokenStore instance. Creates a new\r\n   * instance on first call using the provided or default configuration.\r\n   * Subsequent calls ignore the config parameter and return the existing instance.\r\n   *\r\n   * @param {AdminTokenConfig} [config] - Configuration for token store (used only on first call)\r\n   * @returns {SystemTokenStore} The singleton SystemTokenStore instance\r\n   *\r\n   * @example With default environment configuration\r\n   * ```typescript\r\n   * const store = SystemTokenStore.getInstance();\r\n   * // Uses environment variables for configuration\r\n   * ```\r\n   *\r\n   * @example With custom configuration\r\n   * ```typescript\r\n   * const config: AdminTokenConfig = {\r\n   *   issuer: 'https://auth.example.com/realms/master',\r\n   *   clientId: 'admin-cli',\r\n   *   clientSecret: 'secret',\r\n   *   // ... other config\r\n   * };\r\n   * const store = SystemTokenStore.getInstance(config);\r\n   * ```\r\n   */\r\n  static getInstance(config?: AdminTokenConfig): SystemTokenStore {\r\n    if (!this.#instance) {\r\n      this.#instance = new SystemTokenStore(config ?? defaultConfigFromEnv());\r\n    }\r\n    return this.#instance;\r\n  }\r\n\r\n  /**\r\n   * Reset the singleton instance and all global state\r\n   *\r\n   * @static\r\n   * @method reset\r\n   * @description Completely resets the SystemTokenStore singleton by clearing\r\n   * the global registry instance and any pending initialization promises.\r\n   * Primarily intended for testing scenarios to ensure clean state between tests.\r\n   *\r\n   * **⚠️ Warning**: This method should only be used in testing environments.\r\n   * Calling this in production can cause authentication failures for ongoing operations.\r\n   *\r\n   * @example Testing usage\r\n   * ```typescript\r\n   * // In test setup/teardown\r\n   * afterEach(() => {\r\n   *   SystemTokenStore.reset();\r\n   * });\r\n   * ```\r\n   */\r\n  static reset(): void {\r\n    this.#instance = undefined;\r\n    this.#initPromise = undefined;\r\n  }\r\n\r\n  /**\r\n   * Get a valid admin access token with promise protection against concurrent requests\r\n   *\r\n   * @async\r\n   * @method getAdminToken\r\n   * @description Retrieves a valid admin access token, using cached tokens when available\r\n   * and fresh when necessary. Implements promise-based concurrency protection to prevent\r\n   * multiple simultaneous token requests that could invalidate refresh tokens.\r\n   *\r\n   * **Token Acquisition Strategy (in order of preference):**\r\n   * 1. Return cached token if valid and not expired (unless forceRefresh=true)\r\n   * 2. If concurrent request in progress, await that request's result\r\n   * 3. Otherwise, initiate new token acquisition using multi-strategy approach\r\n   *\r\n   * **Multi-Strategy Authentication:**\r\n   * - **Offline Token**: Use stored refresh token for silent renewal\r\n   * - **Credentials**: Username/password authentication with form-based login\r\n   *\r\n   * @param {boolean} [forceRefresh=false] - Whether to bypass cached tokens and force fresh acquisition\r\n   * @returns {Promise<string>} Promise resolving to a valid JWT access token\r\n   * @throws {Error} When all authentication strategies fail\r\n   *\r\n   * @example Basic usage with caching\r\n   * ```typescript\r\n   * const store = SystemTokenStore.getInstance();\r\n   * const token = await store.getAdminToken();\r\n   * // Uses cached token if available and valid\r\n   * ```\r\n   *\r\n   * @example Force fresh token\r\n   * ```typescript\r\n   * const freshToken = await store.getAdminToken(true);\r\n   * // Bypasses cache and acquires new token\r\n   * ```\r\n   *\r\n   * @example Concurrent access safety\r\n   * ```typescript\r\n   * // Multiple concurrent calls - only one actual network request\r\n   * const [token1, token2, token3] = await Promise.all([\r\n   *   store.getAdminToken(),\r\n   *   store.getAdminToken(),\r\n   *   store.getAdminToken()\r\n   * ]);\r\n   * // All receive the same token, promise synchronization prevents races\r\n   * ```\r\n   */\r\n  async getAdminToken(forceRefresh = false): Promise<string> {\r\n    const instrumented = await createInstrumentedSpan({\r\n      spanName: 'system-token-store.get-admin-token',\r\n      attributes: {\r\n        'auth.force_refresh': forceRefresh,\r\n        'auth.realm': this.config.realm,\r\n        'auth.client_id': this.config.clientId,\r\n      },\r\n    });\r\n\r\n    return await instrumented.executeWithContext(async (span) => {\r\n      // Check if we have a valid cached token (unless forced refresh)\r\n      if (!forceRefresh && this.#hasValidCachedToken()) {\r\n        span.setAttribute('auth.cache_hit', true);\r\n        return this.cachedTokenData!.token;\r\n      }\r\n\r\n      span.setAttribute('auth.cache_hit', false);\r\n\r\n      // Check if there's already a token acquisition in progress\r\n      if (SystemTokenStore.#initPromise && !forceRefresh) {\r\n        span.setAttribute('auth.awaiting_concurrent_request', true);\r\n        return await SystemTokenStore.#initPromise;\r\n      }\r\n\r\n      // Create new promise for token acquisition\r\n      const tokenPromise = this.#acquireAdminToken();\r\n      SystemTokenStore.#initPromise = tokenPromise;\r\n\r\n      try {\r\n        const token = await tokenPromise;\r\n        span.setAttribute('auth.acquisition_success', true);\r\n        return token;\r\n      } catch (error) {\r\n        span.setAttribute('auth.acquisition_failed', true);\r\n        throw error;\r\n      } finally {\r\n        // Clear the promise once completed (success or failure)\r\n        SystemTokenStore.#initPromise = undefined;\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Validate and sanitize configuration input\r\n   *\r\n   * @private\r\n   * @method #validateAndSanitizeConfig\r\n   * @description Validates all required configuration parameters and sanitizes input\r\n   * to prevent security vulnerabilities. Throws detailed errors for missing or invalid values.\r\n   *\r\n   * @param {AdminTokenConfig} config - Raw configuration object to validate\r\n   * @returns {AdminTokenConfig} Validated and sanitized configuration\r\n   * @throws {Error} When required fields are missing or invalid\r\n   */\r\n  #validateAndSanitizeConfig(config: AdminTokenConfig): AdminTokenConfig {\r\n    // Validate required fields\r\n    if (!config.issuer?.trim()) {\r\n      throw new Error(\r\n        'SystemTokenStore: issuer is required and cannot be empty',\r\n      );\r\n    }\r\n\r\n    // Validate issuer URL format and security\r\n    try {\r\n      const issuerUrl = new URL(config.issuer.trim());\r\n      if (!['https:', 'http:'].includes(issuerUrl.protocol)) {\r\n        throw new Error(\r\n          'SystemTokenStore: issuer must use HTTP or HTTPS protocol',\r\n        );\r\n      }\r\n      if (\r\n        issuerUrl.protocol === 'http:' &&\r\n        !issuerUrl.hostname.includes('localhost')\r\n      ) {\r\n        console.warn(\r\n          'SystemTokenStore: Using HTTP in production is not recommended',\r\n        );\r\n      }\r\n    } catch {\r\n      throw new Error(\r\n        `SystemTokenStore: Invalid issuer URL format: ${config.issuer}`,\r\n      );\r\n    }\r\n\r\n    if (!config.clientId?.trim()) {\r\n      throw new Error(\r\n        'SystemTokenStore: clientId is required and cannot be empty',\r\n      );\r\n    }\r\n\r\n    if (!config.clientSecret?.trim()) {\r\n      throw new Error(\r\n        'SystemTokenStore: clientSecret is required and cannot be empty',\r\n      );\r\n    }\r\n\r\n    if (!config.realm?.trim()) {\r\n      throw new Error(\r\n        'SystemTokenStore: realm is required and cannot be empty',\r\n      );\r\n    }\r\n\r\n    if (!config.adminBase?.trim()) {\r\n      throw new Error(\r\n        'SystemTokenStore: adminBase is required and cannot be empty',\r\n      );\r\n    }\r\n\r\n    if (!config.redirectUri?.trim()) {\r\n      throw new Error(\r\n        'SystemTokenStore: redirectUri is required and cannot be empty',\r\n      );\r\n    }\r\n\r\n    // Validate redirectUri format\r\n    try {\r\n      const redirectUrl = new URL(config.redirectUri.trim());\r\n      if (!['https:', 'http:'].includes(redirectUrl.protocol)) {\r\n        throw new Error(\r\n          'SystemTokenStore: redirectUri must use HTTP or HTTPS protocol',\r\n        );\r\n      }\r\n    } catch {\r\n      throw new Error(\r\n        `SystemTokenStore: Invalid redirectUri URL format: ${config.redirectUri}`,\r\n      );\r\n    }\r\n\r\n    // Validate optional numeric parameters\r\n    if (config.tokenExpiryBufferSeconds !== undefined) {\r\n      if (\r\n        !Number.isInteger(config.tokenExpiryBufferSeconds) ||\r\n        config.tokenExpiryBufferSeconds < 0\r\n      ) {\r\n        throw new Error(\r\n          'SystemTokenStore: tokenExpiryBufferSeconds must be a non-negative integer',\r\n        );\r\n      }\r\n    }\r\n\r\n    if (config.redisTokenTtlDays !== undefined) {\r\n      if (\r\n        !Number.isInteger(config.redisTokenTtlDays) ||\r\n        config.redisTokenTtlDays < 1\r\n      ) {\r\n        throw new Error(\r\n          'SystemTokenStore: redisTokenTtlDays must be a positive integer',\r\n        );\r\n      }\r\n    }\r\n\r\n    if (config.rateLimitMaxAttempts !== undefined) {\r\n      if (\r\n        !Number.isInteger(config.rateLimitMaxAttempts) ||\r\n        config.rateLimitMaxAttempts < 1\r\n      ) {\r\n        throw new Error(\r\n          'SystemTokenStore: rateLimitMaxAttempts must be a positive integer',\r\n        );\r\n      }\r\n    }\r\n\r\n    if (config.rateLimitWindowMs !== undefined) {\r\n      if (\r\n        !Number.isInteger(config.rateLimitWindowMs) ||\r\n        config.rateLimitWindowMs < 1000\r\n      ) {\r\n        throw new Error(\r\n          'SystemTokenStore: rateLimitWindowMs must be at least 1000ms',\r\n        );\r\n      }\r\n    }\r\n\r\n    // Sanitize string inputs\r\n    return {\r\n      ...config,\r\n      issuer: config.issuer.trim(),\r\n      clientId: config.clientId.trim(),\r\n      clientSecret: config.clientSecret.trim(),\r\n      realm: config.realm.trim(),\r\n      adminBase: config.adminBase.trim(),\r\n      redirectUri: config.redirectUri.trim(),\r\n      impersonatorUsername: config.impersonatorUsername?.trim(),\r\n      impersonatorPassword: config.impersonatorPassword?.trim(),\r\n      tokenExpiryBufferSeconds: config.tokenExpiryBufferSeconds ?? 30,\r\n      redisTokenTtlDays: config.redisTokenTtlDays ?? 30,\r\n      maxRetryAttempts: config.maxRetryAttempts ?? 3,\r\n      rateLimitMaxAttempts: config.rateLimitMaxAttempts ?? 5,\r\n      rateLimitWindowMs: config.rateLimitWindowMs ?? 60000,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear cached token data from memory and Redis storage\r\n   *\r\n   * @async\r\n   * @description Clears both in-memory cached tokens and encrypted offline tokens\r\n   * stored in Redis. Also clears any environment variable offline tokens to ensure\r\n   * complete cache invalidation.\r\n   */\r\n  async clearCache(): Promise<void> {\r\n    // Clear in-memory cache\r\n    this.cachedTokenData = undefined;\r\n\r\n    // Clear any pending token acquisition promise\r\n    SystemTokenStore.#initPromise = undefined;\r\n\r\n    // Clear rate limiter state\r\n    this.rateLimiter.reset();\r\n\r\n    // Clear Redis-stored offline token\r\n    try {\r\n      const cacheKey = this.#getOfflineTokenCacheKey();\r\n      if (cacheKey) {\r\n        const redis = await getRedisClient();\r\n        await redis.del(cacheKey);\r\n      }\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        message: 'Failed to clear offline token from Redis cache',\r\n        source: 'SystemTokenStore.clearCache',\r\n      });\r\n    }\r\n\r\n    // Clear environment variable offline token to prevent reuse\r\n    if (env('AUTH_KEYCLOAK_IMPERSONATOR_USERNAME')) {\r\n      try {\r\n        delete process.env.AUTH_KEYCLOAK_IMPERSONATOR_OFFLINE_TOKEN;\r\n      } catch {\r\n        // Fallback: set to empty string if delete fails\r\n        process.env.AUTH_KEYCLOAK_IMPERSONATOR_OFFLINE_TOKEN = '';\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if we have a valid cached token that hasn't expired\r\n   *\r\n   * @private\r\n   * @method #hasValidCachedToken\r\n   * @description Validates the current cached token by checking both existence\r\n   * and expiry time. Uses configurable buffer to prevent using tokens that are\r\n   * about to expire, reducing the risk of authentication failures due to token\r\n   * expiry during request processing.\r\n   *\r\n   * @returns {boolean} True if cached token exists and is valid for at least the buffer time\r\n   */\r\n  #hasValidCachedToken(): boolean {\r\n    const bufferMs = (this.config.tokenExpiryBufferSeconds ?? 30) * 1000;\r\n    return !!(\r\n      this.cachedTokenData &&\r\n      this.cachedTokenData.expiry > new Date(Date.now() + bufferMs)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Internal method to acquire admin token through various strategies\r\n   *\r\n   * @private\r\n   * @async\r\n   * @method #acquireAdminToken\r\n   * @description Implements the core multi-strategy token acquisition logic.\r\n   * Attempts authentication methods in order of preference, falling back to\r\n   * the next strategy if the current one fails. Each strategy is wrapped in\r\n   * error handling to prevent one failure from breaking the entire flow.\r\n   *\r\n   * **Authentication Strategy Order:**\r\n   * 1. **Offline Token Strategy**: Attempts to use stored refresh tokens\r\n   * 2. **Credentials Strategy**: Falls back to username/password authentication\r\n   *\r\n   * All strategies are instrumented with OpenTelemetry for observability.\r\n   *\r\n   * @returns {Promise<string>} Promise resolving to a valid JWT access token\r\n   * @throws {Error} When all authentication strategies fail\r\n   *\r\n   * @example Strategy execution flow\r\n   * ```typescript\r\n   * // 1. Try offline token (if available)\r\n   * // 2. Try credentials (if configured)\r\n   * // 3. Throw error if all strategies fail\r\n   * const token = await this.#acquireAdminToken();\r\n   * ```\r\n   */\r\n  async #acquireAdminToken(): Promise<string> {\r\n    const instrumented = await createInstrumentedSpan({\r\n      spanName: 'system-token-store.acquire-admin-token',\r\n      attributes: {\r\n        'auth.realm': this.config.realm,\r\n        'auth.strategy': 'multi-strategy',\r\n      },\r\n    });\r\n\r\n    return await instrumented.executeWithContext(async (span) => {\r\n      // Strategy 1: Try offline token if available\r\n      try {\r\n        const offlineTokenResult = await this.#tryOfflineTokenStrategy();\r\n        if (offlineTokenResult) {\r\n          span.setAttribute('auth.strategy_used', 'offline_token');\r\n          return offlineTokenResult;\r\n        }\r\n      } catch (error) {\r\n        LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n          log: true,\r\n          message: 'Offline token strategy failed',\r\n          source: 'SystemTokenStore.acquireAdminToken',\r\n        });\r\n      }\r\n\r\n      // Strategy 2: Try username/password authentication\r\n      if (\r\n        this.config.impersonatorUsername &&\r\n        this.config.impersonatorPassword\r\n      ) {\r\n        try {\r\n          const credentialsResult = await this.#tryCredentialsStrategy();\r\n          if (credentialsResult) {\r\n            span.setAttribute('auth.strategy_used', 'credentials');\r\n            return credentialsResult;\r\n          }\r\n        } catch (error) {\r\n          LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n            log: true,\r\n            message: 'Credentials strategy failed',\r\n            source: 'SystemTokenStore.acquireAdminToken',\r\n          });\r\n        }\r\n      }\r\n\r\n      span.setAttribute('auth.strategy_used', 'none');\r\n      throw new Error('All admin token acquisition strategies failed');\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Try to get admin token using offline refresh token\r\n   *\r\n   * @private\r\n   * @async\r\n   * @method #tryOfflineTokenStrategy\r\n   * @description Attempts to acquire an admin token using a previously stored\r\n   * offline refresh token. This is the preferred strategy as it doesn't require\r\n   * user credentials and provides the fastest authentication path.\r\n   *\r\n   * **Process Flow:**\r\n   * 1. Retrieve offline token from encrypted Redis storage or environment\r\n   * 2. Exchange refresh token for new access token via OAuth2 token endpoint\r\n   * 3. Cache the new token and store any new refresh token\r\n   * 4. Return the access token for immediate use\r\n   *\r\n   * @returns {Promise<string|null>} Promise resolving to access token or null if strategy fails\r\n   *\r\n   * @example Successful offline token renewal\r\n   * ```typescript\r\n   * const token = await this.#tryOfflineTokenStrategy();\r\n   * if (token) {\r\n   *   // Token successfully renewed from refresh token\r\n   *   console.log('Using offline token strategy');\r\n   * }\r\n   * ```\r\n   */\r\n  async #tryOfflineTokenStrategy(): Promise<string | null> {\r\n    const instrumented = await createInstrumentedSpan({\r\n      spanName: 'system-token-store.offline-token-strategy',\r\n      attributes: {\r\n        'auth.realm': this.config.realm,\r\n      },\r\n    });\r\n\r\n    return await instrumented.executeWithContext(async (span) => {\r\n      const offlineToken = await this.#getOfflineTokenFromStorage();\r\n      if (!offlineToken) {\r\n        span.setAttribute('auth.offline_token_available', false);\r\n        return null;\r\n      }\r\n\r\n      span.setAttribute('auth.offline_token_available', true);\r\n\r\n      const tokenResponse = await this.#exchangeOfflineToken(offlineToken);\r\n      if (tokenResponse) {\r\n        this.#cacheTokenData(tokenResponse);\r\n        span.setAttribute('auth.offline_token_success', true);\r\n        return tokenResponse.access_token;\r\n      }\r\n\r\n      span.setAttribute('auth.offline_token_success', false);\r\n      return null;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Try to get admin token using username/password credentials\r\n   *\r\n   * @private\r\n   * @async\r\n   * @method #tryCredentialsStrategy\r\n   * @description Attempts to acquire an admin token using configured username\r\n   * and password credentials through form-based authentication. This strategy\r\n   * handles complex Keycloak login flows and properly exchanges authorization\r\n   * codes for access tokens.\r\n   *\r\n   * **Process Flow:**\r\n   * 1. Check if credentials are configured (username and password)\r\n   * 2. Perform form-based login to get access token (not authorization code)\r\n   * 3. Cache the returned access token with expiry information\r\n   * 4. Store any refresh token for future offline token strategy use\r\n   * 5. Return the access token for immediate use\r\n   *\r\n   * **Note**: The performFormLogin method returns ready-to-use access tokens,\r\n   * not authorization codes, so no additional token exchange is needed.\r\n   *\r\n   * @returns {Promise<string|null>} Promise resolving to access token or null if strategy fails\r\n   *\r\n   * @example Successful credentials authentication\r\n   * ```typescript\r\n   * const token = await this.#tryCredentialsStrategy();\r\n   * if (token) {\r\n   *   // Token successfully obtained via form login\r\n   *   console.log('Using credentials strategy');\r\n   * }\r\n   * ```\r\n   */\r\n  async #tryCredentialsStrategy(): Promise<string | null> {\r\n    const instrumented = await createInstrumentedSpan({\r\n      spanName: 'system-token-store.credentials-strategy',\r\n      attributes: {\r\n        'auth.realm': this.config.realm,\r\n        'auth.username': this.config.impersonatorUsername || 'undefined',\r\n      },\r\n    });\r\n\r\n    return await instrumented.executeWithContext(async (span) => {\r\n      if (\r\n        !this.config.impersonatorUsername ||\r\n        !this.config.impersonatorPassword\r\n      ) {\r\n        span.setAttribute('auth.credentials_available', false);\r\n        return null;\r\n      }\r\n\r\n      // Check rate limiting\r\n      const rateLimitKey = `credentials:${this.config.realm}:${this.config.impersonatorUsername}`;\r\n      if (!this.rateLimiter.canAttempt(rateLimitKey)) {\r\n        span.setAttribute('auth.rate_limited', true);\r\n        throw new Error('Rate limit exceeded for credentials authentication');\r\n      }\r\n\r\n      span.setAttribute('auth.credentials_available', true);\r\n\r\n      // Record the authentication attempt\r\n      this.rateLimiter.recordAttempt(rateLimitKey);\r\n\r\n      // Get access token via form login with circuit breaker protection\r\n      const loginResult = await this.circuitBreaker.execute(async () => {\r\n        return await this.#performFormLogin();\r\n      });\r\n      if (!loginResult) {\r\n        span.setAttribute('auth.form_login_success', false);\r\n        return null;\r\n      }\r\n\r\n      span.setAttribute('auth.form_login_success', true);\r\n\r\n      // loginResult is already a valid access token - cache it\r\n      const cacheInstrumented = await createInstrumentedSpan({\r\n        spanName: 'system-token-store.cache-credentials-token',\r\n        attributes: {\r\n          'auth.realm': this.config.realm,\r\n        },\r\n      });\r\n\r\n      return await cacheInstrumented.executeWithContext(async (cacheSpan) => {\r\n        // Create token response object for caching\r\n        const tokenResponse: TokenResponse = {\r\n          access_token: loginResult.accessToken,\r\n          expires_in: loginResult.expiresIn || 3600,\r\n          refresh_token: loginResult.refreshToken,\r\n        };\r\n\r\n        this.#cacheTokenData(tokenResponse);\r\n        cacheSpan.setAttribute('auth.token_cached', true);\r\n\r\n        // Store offline token if we got one\r\n        if (loginResult.refreshToken) {\r\n          await this.#storeOfflineTokenEncrypted(loginResult.refreshToken);\r\n          cacheSpan.setAttribute('auth.refresh_token_stored', true);\r\n        }\r\n\r\n        span.setAttribute('auth.credentials_success', true);\r\n        return loginResult.accessToken;\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Ensure OIDC configuration is initialized\r\n   *\r\n   * @private\r\n   * @async\r\n   * @method #ensureOIDCConfiguration\r\n   * @description Initializes OIDC discovery configuration if not already cached.\r\n   * Uses instrumentation for observability and caches the result for future use.\r\n   */\r\n  async #ensureOIDCConfiguration(): Promise<void> {\r\n    if (!this.oidcConfig) {\r\n      const discoveryInstrumented = await createInstrumentedSpan({\r\n        spanName: 'system-token-store.oidc-discovery',\r\n        attributes: {\r\n          'auth.realm': this.config.realm,\r\n        },\r\n      });\r\n\r\n      this.oidcConfig = await discoveryInstrumented.executeWithContext(\r\n        async (discoverySpan) => {\r\n          const config = await discovery(\r\n            new URL(this.config.issuer),\r\n            this.config.clientId,\r\n            this.config.clientSecret,\r\n          );\r\n          discoverySpan.setAttribute('auth.oidc_discovery_success', true);\r\n          return config;\r\n        },\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle authorization request and determine if login form is needed\r\n   *\r\n   * @private\r\n   * @async\r\n   * @method #handleAuthorizationRequest\r\n   * @description Builds authorization URL and makes initial request. Returns either\r\n   * a direct authorization code (existing session) or login form HTML for processing.\r\n   *\r\n   * @param client - Configured Got client with cookie jar\r\n   * @param state - OAuth2 state parameter for CSRF protection\r\n   * @param nonce - OIDC nonce parameter for replay attack protection\r\n   * @returns Promise resolving to either code URL or login HTML\r\n   */\r\n  async #handleAuthorizationRequest(\r\n    client: typeof got,\r\n    state: string,\r\n    nonce: string,\r\n  ): Promise<{ codeUrl?: URL; loginHtml?: string }> {\r\n    if (!this.oidcConfig) {\r\n      throw new Error('OIDC configuration not initialized');\r\n    }\r\n\r\n    // Build authorization URL and initiate login flow\r\n    const authorizeUrl = buildAuthorizationUrl(this.oidcConfig, {\r\n      redirect_uri: this.config.redirectUri,\r\n      scope: 'openid email profile offline_access',\r\n      response_type: 'code',\r\n      response_mode: 'query',\r\n      prompt: 'login',\r\n      state,\r\n      nonce,\r\n    });\r\n\r\n    const authResponse = await client.get(authorizeUrl.toString());\r\n\r\n    // Handle direct redirect (existing session) or login form\r\n    if (authResponse.statusCode === 302 && authResponse.headers.location) {\r\n      // Direct redirect with code - existing session\r\n      const codeUrl = new URL(\r\n        authResponse.headers.location,\r\n        this.config.redirectUri,\r\n      );\r\n      return { codeUrl };\r\n    } else if (\r\n      authResponse.statusCode === 200 &&\r\n      typeof authResponse.body === 'string'\r\n    ) {\r\n      const loginHtml = authResponse.body;\r\n      return { loginHtml };\r\n    } else {\r\n      throw new Error(\r\n        `Authorization endpoint returned unexpected status ${authResponse.statusCode}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process login form and perform authentication flow\r\n   *\r\n   * @private\r\n   * @async\r\n   * @method #processLoginForm\r\n   * @description Parses login form, determines flow type (single/two-step), and\r\n   * performs the appropriate authentication sequence to obtain authorization code.\r\n   *\r\n   * @param client - Configured Got client with cookie jar\r\n   * @param loginHtml - HTML content of the login form\r\n   * @param authorizeUrl - Original authorization URL for retry after login\r\n   * @param span - Instrumentation span for adding attributes\r\n   * @returns Promise resolving to authorization code URL or null if failed\r\n   */\r\n  async #processLoginForm(\r\n    client: typeof got,\r\n    loginHtml: string,\r\n    authorizeUrl: string,\r\n    span: { setAttribute: (key: string, value: boolean | string) => void },\r\n    state: string,\r\n  ): Promise<URL | null> {\r\n    // Parse and handle login form\r\n    const formParse = this.#parseLoginForm(loginHtml);\r\n    if (!formParse) {\r\n      throw new Error('Unable to locate login form action');\r\n    }\r\n    const { action: formAction, fields, hasUsername, hasPassword } = formParse;\r\n    span.setAttribute('auth.login_form_parsed', true);\r\n    span.setAttribute('auth.form_has_username', hasUsername);\r\n    span.setAttribute('auth.form_has_password', hasPassword);\r\n\r\n    // Determine login flow: single-step or two-step\r\n    if (hasPassword || 'execution' in fields || 'session_code' in fields) {\r\n      // Single-step: submit username + password together\r\n      return await this.#performSingleStepLogin(\r\n        client,\r\n        formAction,\r\n        fields,\r\n        authorizeUrl,\r\n        span,\r\n      );\r\n    } else if (hasUsername) {\r\n      // Two-step: submit username first, then password\r\n      return await this.#performTwoStepLogin(client, formAction, fields, span);\r\n    } else {\r\n      // Fallback: attempt single-step even without clear field detection\r\n      return await this.#performFallbackLogin(\r\n        client,\r\n        formAction,\r\n        fields,\r\n        span,\r\n        state,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Perform single-step login (username + password together)\r\n   *\r\n   * @private\r\n   * @async\r\n   * @method #performSingleStepLogin\r\n   */\r\n  async #performSingleStepLogin(\r\n    client: typeof got,\r\n    formAction: string,\r\n    fields: Record<string, string>,\r\n    authorizeUrl: string,\r\n    span: { setAttribute: (key: string, value: boolean | string) => void },\r\n  ): Promise<URL | null> {\r\n    span.setAttribute('auth.login_flow', 'single_step');\r\n    const formBody = new URLSearchParams();\r\n    for (const [k, v] of Object.entries(fields)) {\r\n      if (typeof v === 'string') formBody.set(k, v);\r\n    }\r\n    formBody.set('username', this.config.impersonatorUsername!);\r\n    formBody.set('password', this.config.impersonatorPassword!);\r\n    formBody.set('credentialId', formBody.get('credentialId') ?? '');\r\n\r\n    const loginResp = await client.post(formAction, {\r\n      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\r\n      body: formBody.toString(),\r\n    });\r\n\r\n    if (loginResp.statusCode !== 302) {\r\n      throw new Error(`Admin login failed ${loginResp.statusCode}`);\r\n    }\r\n\r\n    // After successful login, retry authorize to get code\r\n    const afterLogin = await client.get(authorizeUrl);\r\n    if (afterLogin.statusCode === 302 && afterLogin.headers.location) {\r\n      return new URL(afterLogin.headers.location, this.config.redirectUri);\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Perform two-step login (username first, then password)\r\n   *\r\n   * @private\r\n   * @async\r\n   * @method #performTwoStepLogin\r\n   */\r\n  async #performTwoStepLogin(\r\n    client: typeof got,\r\n    formAction: string,\r\n    fields: Record<string, string>,\r\n    span: { setAttribute: (key: string, value: boolean | string) => void },\r\n  ): Promise<URL | null> {\r\n    span.setAttribute('auth.login_flow', 'two_step');\r\n\r\n    // Step 1: Submit username-only form\r\n    const userOnly = new URLSearchParams();\r\n    for (const [k, v] of Object.entries(fields)) {\r\n      if (typeof v === 'string') userOnly.set(k, v);\r\n    }\r\n    userOnly.set('username', this.config.impersonatorUsername!);\r\n\r\n    const firstResp = await client.post(formAction, {\r\n      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\r\n      body: userOnly.toString(),\r\n    });\r\n\r\n    let secondHtml = '';\r\n    if (firstResp.statusCode === 302 && firstResp.headers.location) {\r\n      // Redirect to password page\r\n      const secondPage = await client.get(firstResp.headers.location);\r\n      secondHtml = typeof secondPage.body === 'string' ? secondPage.body : '';\r\n    } else if (\r\n      firstResp.statusCode === 200 &&\r\n      typeof firstResp.body === 'string'\r\n    ) {\r\n      // Password form in response body\r\n      secondHtml = firstResp.body;\r\n    } else {\r\n      throw new Error(`Admin username step failed ${firstResp.statusCode}`);\r\n    }\r\n\r\n    const secondParse = this.#parseLoginForm(secondHtml);\r\n    if (!secondParse || !secondParse.hasPassword) {\r\n      throw new Error('Unable to locate password form after username step');\r\n    }\r\n\r\n    // Step 2: Submit password form\r\n    const passBody = new URLSearchParams();\r\n    for (const [k, v] of Object.entries(secondParse.fields)) {\r\n      if (typeof v === 'string') passBody.set(k, v);\r\n    }\r\n    passBody.set('password', this.config.impersonatorPassword!);\r\n    passBody.set('credentialId', passBody.get('credentialId') ?? '');\r\n\r\n    const passResp = await client.post(secondParse.action, {\r\n      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\r\n      body: passBody.toString(),\r\n    });\r\n\r\n    if (passResp.statusCode !== 302 || !passResp.headers.location) {\r\n      throw new Error(`Admin password step failed ${passResp.statusCode}`);\r\n    }\r\n\r\n    return new URL(passResp.headers.location, this.config.redirectUri);\r\n  }\r\n\r\n  /**\r\n   * Perform fallback login when flow type cannot be determined\r\n   *\r\n   * @private\r\n   * @async\r\n   * @method #performFallbackLogin\r\n   */\r\n  async #performFallbackLogin(\r\n    client: typeof got,\r\n    formAction: string,\r\n    fields: Record<string, string>,\r\n    span: { setAttribute: (key: string, value: boolean | string) => void },\r\n    state: string,\r\n  ): Promise<URL | null> {\r\n    span.setAttribute('auth.login_flow', 'fallback');\r\n    const formBody = new URLSearchParams();\r\n    for (const [k, v] of Object.entries(fields)) {\r\n      if (typeof v === 'string') formBody.set(k, v);\r\n    }\r\n    formBody.set('username', this.config.impersonatorUsername!);\r\n    formBody.set('password', this.config.impersonatorPassword!);\r\n    formBody.set('credentialId', formBody.get('credentialId') ?? '');\r\n\r\n    const loginResp = await client.post(formAction, {\r\n      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\r\n      body: formBody.toString(),\r\n    });\r\n\r\n    if (loginResp.statusCode !== 302) {\r\n      throw new Error(`Admin login failed ${loginResp.statusCode}`);\r\n    }\r\n\r\n    // Construct safe fallback URL for testing\r\n    return new URL(\r\n      `${this.config.redirectUri}?code=admin-code&state=${encodeURIComponent(state)}`,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Exchange authorization code for access tokens\r\n   *\r\n   * @private\r\n   * @async\r\n   * @method #exchangeAuthorizationCode\r\n   * @description Exchanges an authorization code for access tokens using OIDC\r\n   * authorization code grant flow with proper validation.\r\n   *\r\n   * @param codeUrl - URL containing the authorization code\r\n   * @param state - Expected OAuth2 state parameter\r\n   * @param nonce - Expected OIDC nonce parameter\r\n   * @returns Promise resolving to form login result with tokens\r\n   */\r\n  async #exchangeAuthorizationCode(\r\n    codeUrl: URL,\r\n    state: string,\r\n    nonce: string,\r\n  ): Promise<FormLoginResult> {\r\n    const exchangeInstrumented = await createInstrumentedSpan({\r\n      spanName: 'system-token-store.exchange-authorization-code',\r\n      attributes: {\r\n        'auth.realm': this.config.realm,\r\n      },\r\n    });\r\n\r\n    return await exchangeInstrumented.executeWithContext(\r\n      async (exchangeSpan) => {\r\n        if (!this.oidcConfig) {\r\n          throw new Error('OIDC configuration not initialized');\r\n        }\r\n\r\n        const token = await authorizationCodeGrant(this.oidcConfig, codeUrl, {\r\n          expectedState: state,\r\n          expectedNonce: nonce,\r\n        });\r\n\r\n        const accessToken = token.access_token as string;\r\n        if (!accessToken) {\r\n          throw new Error('Missing access_token in authorization response');\r\n        }\r\n\r\n        exchangeSpan.setAttribute('auth.token_exchange_success', true);\r\n\r\n        return {\r\n          accessToken,\r\n          refreshToken: token.refresh_token as string | undefined,\r\n          expiresIn: token.expires_in as number | undefined,\r\n        };\r\n      },\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Perform form-based login to get access token\r\n   * Handles both single-step (username+password) and two-step (username then password) flows\r\n   */\r\n  async #performFormLogin(): Promise<FormLoginResult | null> {\r\n    const instrumented = await createInstrumentedSpan({\r\n      spanName: 'system-token-store.form-login',\r\n      attributes: {\r\n        'auth.realm': this.config.realm,\r\n      },\r\n    });\r\n\r\n    return await instrumented.executeWithContext(async (span) => {\r\n      const cookieJar = new CookieJar();\r\n      const client = got.extend({ cookieJar, followRedirect: false });\r\n\r\n      // Initialize OIDC configuration for proper token exchange\r\n      await this.#ensureOIDCConfiguration();\r\n\r\n      const state = randomState();\r\n      const nonce = randomNonce();\r\n      let codeUrl: URL | null | undefined;\r\n\r\n      try {\r\n        // Handle authorization request\r\n        const authResult = await this.#handleAuthorizationRequest(\r\n          client,\r\n          state,\r\n          nonce,\r\n        );\r\n        span.setAttribute('auth.authorization_url_generated', true);\r\n\r\n        // If we have a code URL from redirect, proceed to token exchange\r\n        if (authResult.codeUrl) {\r\n          span.setAttribute('auth.existing_session_redirect', true);\r\n          const result = await this.#exchangeAuthorizationCode(\r\n            authResult.codeUrl,\r\n            state,\r\n            nonce,\r\n          );\r\n          span.setAttribute('auth.session_reuse_success', true);\r\n          return result;\r\n        }\r\n\r\n        // Process login form if no direct redirect\r\n        if (!authResult.loginHtml) {\r\n          throw new Error('Unable to load admin login page');\r\n        }\r\n\r\n        span.setAttribute('auth.login_form_required', true);\r\n        const authorizeUrl = buildAuthorizationUrl(this.oidcConfig!, {\r\n          redirect_uri: this.config.redirectUri,\r\n          scope: 'openid email profile offline_access',\r\n          response_type: 'code',\r\n          response_mode: 'query',\r\n          prompt: 'login',\r\n          state,\r\n          nonce,\r\n        });\r\n\r\n        const loginResult = await this.#processLoginForm(\r\n          client,\r\n          authResult.loginHtml,\r\n          authorizeUrl.toString(),\r\n          span,\r\n          state,\r\n        );\r\n        codeUrl = loginResult;\r\n\r\n        // Exchange authorization code for tokens\r\n        const finalUrl =\r\n          codeUrl ??\r\n          new URL(\r\n            `${this.config.redirectUri}?code=admin-code&state=${encodeURIComponent(state)}`,\r\n          );\r\n\r\n        const result = await this.#exchangeAuthorizationCode(\r\n          finalUrl,\r\n          state,\r\n          nonce,\r\n        );\r\n        span.setAttribute('auth.form_login_success', true);\r\n        return result;\r\n      } catch (error) {\r\n        span.setAttribute('auth.form_login_error', true);\r\n        LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n          log: true,\r\n          message: 'Form login failed',\r\n          source: 'SystemTokenStore.performFormLogin',\r\n        });\r\n        return null;\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get offline token from encrypted Redis storage or environment\r\n   *\r\n   * @private\r\n   * @async\r\n   * @method #getOfflineTokenFromStorage\r\n   * @description Retrieves offline refresh tokens from multiple storage sources\r\n   * in order of preference. Handles decryption of Redis-stored tokens and\r\n   * falls back to environment variables when Redis storage is unavailable.\r\n   *\r\n   * **Storage Priority:**\r\n   * 1. **Redis**: Encrypted tokens stored from previous successful authentications\r\n   * 2. **Environment**: Plain text tokens from AUTH_KEYCLOAK_IMPERSONATOR_OFFLINE_TOKEN\r\n   *\r\n   * @returns {Promise<string|null>} Promise resolving to refresh token or null if not available\r\n   *\r\n   * @example Redis storage retrieval\r\n   * ```typescript\r\n   * // Retrieves and decrypts token from Redis\r\n   * const token = await this.#getOfflineTokenFromStorage();\r\n   * if (token) {\r\n   *   console.log('Found encrypted offline token in Redis');\r\n   * }\r\n   * ```\r\n   */\r\n  async #getOfflineTokenFromStorage(): Promise<string | null> {\r\n    const instrumented = await createInstrumentedSpan({\r\n      spanName: 'system-token-store.get-offline-token',\r\n      attributes: {\r\n        'auth.realm': this.config.realm,\r\n      },\r\n    });\r\n\r\n    return await instrumented.executeWithContext(async (span) => {\r\n      try {\r\n        // Try Redis first\r\n        const cacheKey = this.#getOfflineTokenCacheKey();\r\n        if (cacheKey) {\r\n          const redis = await getRedisClient();\r\n          const encryptedToken = await redis.get(cacheKey);\r\n\r\n          if (encryptedToken) {\r\n            const crypto = this.#getCrypto();\r\n            const decryptedToken = await crypto.decrypt(encryptedToken);\r\n            span.setAttribute('auth.offline_token_source', 'redis');\r\n            return decryptedToken;\r\n          }\r\n        }\r\n\r\n        // Fall back to environment variable\r\n        const envToken = env('AUTH_KEYCLOAK_IMPERSONATOR_OFFLINE_TOKEN');\r\n        if (envToken) {\r\n          span.setAttribute('auth.offline_token_source', 'environment');\r\n          return envToken;\r\n        }\r\n\r\n        span.setAttribute('auth.offline_token_source', 'none');\r\n        return null;\r\n      } catch (error) {\r\n        LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n          log: true,\r\n          message: 'Failed to get offline token from storage',\r\n          source: 'SystemTokenStore.getOfflineTokenFromStorage',\r\n        });\r\n        return null;\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Exchange offline refresh token for new access token\r\n   *\r\n   * @private\r\n   * @async\r\n   * @method #exchangeOfflineToken\r\n   * @description Performs OAuth2 refresh token grant to obtain a new access token.\r\n   * Uses OIDC discovery for token endpoint when available, falls back to hardcoded\r\n   * endpoint construction. Automatically stores any new refresh token returned.\r\n   *\r\n   * **Process Flow:**\r\n   * 1. Initialize OIDC configuration if not already cached\r\n   * 2. Determine token endpoint (OIDC discovery vs hardcoded)\r\n   * 3. Perform OAuth2 refresh_token grant request\r\n   * 4. Parse token response and validate required fields\r\n   * 5. Store new refresh token if provided for future use\r\n   *\r\n   * @param {string} refreshToken - The offline refresh token to exchange\r\n   * @returns {Promise<TokenResponse|null>} Promise resolving to token response or null if exchange fails\r\n   *\r\n   * @example Successful token exchange\r\n   * ```typescript\r\n   * const tokenResponse = await this.#exchangeOfflineToken(refreshToken);\r\n   * if (tokenResponse) {\r\n   *   console.log('Token refreshed successfully');\r\n   *   // New access token available in tokenResponse.access_token\r\n   * }\r\n   * ```\r\n   */\r\n  async #exchangeOfflineToken(\r\n    refreshToken: string,\r\n  ): Promise<TokenResponse | null> {\r\n    const instrumented = await createInstrumentedSpan({\r\n      spanName: 'system-token-store.exchange-offline-token',\r\n      attributes: {\r\n        'auth.realm': this.config.realm,\r\n      },\r\n    });\r\n\r\n    return await instrumented.executeWithContext(async (span) => {\r\n      try {\r\n        // Initialize OIDC configuration if needed\r\n        if (!this.oidcConfig) {\r\n          const discoveryInstrumented = await createInstrumentedSpan({\r\n            spanName: 'system-token-store.oidc-discovery',\r\n            attributes: {\r\n              'auth.realm': this.config.realm,\r\n            },\r\n          });\r\n\r\n          this.oidcConfig = await discoveryInstrumented.executeWithContext(\r\n            async (discoverySpan) => {\r\n              const config = await discovery(\r\n                new URL(this.config.issuer),\r\n                this.config.clientId,\r\n                this.config.clientSecret,\r\n              );\r\n              discoverySpan.setAttribute('auth.oidc_discovery_success', true);\r\n              return config;\r\n            },\r\n          );\r\n        }\r\n\r\n        // Prefer OIDC configuration token endpoint over hardcoded URL\r\n        let tokenEndpoint: string;\r\n        if (\r\n          this.oidcConfig &&\r\n          'token_endpoint' in this.oidcConfig &&\r\n          this.oidcConfig.token_endpoint\r\n        ) {\r\n          tokenEndpoint = this.oidcConfig.token_endpoint as string;\r\n          span.setAttribute('auth.token_endpoint_source', 'oidc_discovery');\r\n        } else {\r\n          tokenEndpoint = `${this.config.issuer}/protocol/openid-connect/token`;\r\n          span.setAttribute('auth.token_endpoint_source', 'hardcoded');\r\n        }\r\n\r\n        const response = await got.post(tokenEndpoint, {\r\n          form: {\r\n            grant_type: 'refresh_token',\r\n            refresh_token: refreshToken,\r\n            client_id: this.config.clientId,\r\n            client_secret: this.config.clientSecret,\r\n          },\r\n          headers: {\r\n            'Content-Type': 'application/x-www-form-urlencoded',\r\n          },\r\n        });\r\n\r\n        span.setAttribute('auth.token_exchange_status', response.statusCode);\r\n\r\n        if (response.statusCode === 200) {\r\n          const tokenData = JSON.parse(response.body) as TokenResponse;\r\n          span.setAttribute('auth.token_exchange_success', true);\r\n\r\n          // Store new refresh token if provided\r\n          if (tokenData.refresh_token) {\r\n            await this.#storeOfflineTokenEncrypted(tokenData.refresh_token);\r\n            span.setAttribute('auth.new_refresh_token_stored', true);\r\n          }\r\n\r\n          return tokenData;\r\n        }\r\n\r\n        span.setAttribute('auth.token_exchange_success', false);\r\n        return null;\r\n      } catch (error) {\r\n        LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n          log: true,\r\n          message: 'Failed to exchange offline token',\r\n          source: 'SystemTokenStore.exchangeOfflineToken',\r\n        });\r\n        return null;\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Cache token data with expiry information\r\n   *\r\n   * @private\r\n   * @method #cacheTokenData\r\n   * @description Stores token response data in memory cache with computed expiry\r\n   * time. Applies a 1-minute safety buffer to prevent using tokens that are\r\n   * about to expire during request processing.\r\n   *\r\n   * **Expiry Calculation:**\r\n   * - Uses `expires_in` from token response (defaults to 3600 seconds if missing)\r\n   * - Subtracts 60 seconds as safety buffer\r\n   * - Computes absolute expiry time based on current time\r\n   *\r\n   * @param {TokenResponse} tokenResponse - The token response from Keycloak\r\n   *\r\n   * @example Token caching with expiry\r\n   * ```typescript\r\n   * const tokenResponse = {\r\n   *   access_token: 'jwt-token',\r\n   *   expires_in: 3600,\r\n   *   refresh_token: 'refresh-jwt'\r\n   * };\r\n   * this.#cacheTokenData(tokenResponse);\r\n   * // Token cached with expiry = now + 3540 seconds (60s buffer)\r\n   * ```\r\n   */\r\n  #cacheTokenData(tokenResponse: TokenResponse): void {\r\n    const expiresIn = tokenResponse.expires_in || 3600; // Default 1 hour\r\n    const bufferSeconds = this.config.tokenExpiryBufferSeconds ?? 30;\r\n    const expiry = new Date(Date.now() + (expiresIn - bufferSeconds) * 1000);\r\n\r\n    this.cachedTokenData = {\r\n      token: tokenResponse.access_token,\r\n      expiry,\r\n      refreshToken: tokenResponse.refresh_token,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Store offline token in encrypted Redis cache\r\n   *\r\n   * @private\r\n   * @async\r\n   * @method #storeOfflineTokenEncrypted\r\n   * @description Encrypts and stores refresh tokens in Redis for future use.\r\n   * Uses CryptoService for AES encryption to protect sensitive tokens in storage.\r\n   * Sets a 30-day expiration to prevent indefinite accumulation of stale tokens.\r\n   *\r\n   * **Security Features:**\r\n   * - AES encryption via CryptoService before storage\r\n   * - Automatic expiration after 30 days\r\n   * - Error handling to prevent storage failures from breaking authentication\r\n   *\r\n   * @param {string} token - The refresh token to encrypt and store\r\n   * @returns {Promise<void>} Promise that resolves when storage is complete\r\n   *\r\n   * @example Secure token storage\r\n   * ```typescript\r\n   * await this.#storeOfflineTokenEncrypted(refreshToken);\r\n   * // Token encrypted with AES and stored in Redis for 30 days\r\n   * ```\r\n   */\r\n  async #storeOfflineTokenEncrypted(token: string): Promise<void> {\r\n    try {\r\n      const cacheKey = this.#getOfflineTokenCacheKey();\r\n      if (!cacheKey) return;\r\n\r\n      const crypto = this.#getCrypto();\r\n      const encryptedToken = await crypto.encrypt(token);\r\n\r\n      const redis = await getRedisClient();\r\n      // Store for configured TTL days\r\n      const ttlSeconds = (this.config.redisTokenTtlDays ?? 30) * 24 * 60 * 60;\r\n      await redis.setEx(cacheKey, ttlSeconds, encryptedToken);\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        message: 'Failed to store offline token',\r\n        source: 'SystemTokenStore.storeOfflineTokenEncrypted',\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get Redis cache key for offline token\r\n   *\r\n   * @private\r\n   * @method #getOfflineTokenCacheKey\r\n   * @description Generates a unique Redis key for storing offline tokens.\r\n   * Uses realm, client ID, and system identifier to ensure key uniqueness\r\n   * across different Keycloak configurations and prevent token conflicts.\r\n   *\r\n   * **Key Format:** `keycloak:offline_token:{realm}:{clientId}:system`\r\n   *\r\n   * @returns {string|null} Cache key string or null if key generation fails\r\n   *\r\n   * @example Key generation\r\n   * ```typescript\r\n   * const key = this.#getOfflineTokenCacheKey();\r\n   * // Returns: 'keycloak:offline_token:master:admin-cli:system'\r\n   * ```\r\n   */\r\n  #getOfflineTokenCacheKey(): string | null {\r\n    try {\r\n      return `keycloak:offline_token:${this.config.realm}:${this.config.clientId}:system`;\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get crypto service instance with lazy initialization\r\n   *\r\n   * @private\r\n   * @method #getCrypto\r\n   * @description Returns the CryptoService instance for token encryption/decryption.\r\n   * Uses lazy initialization to avoid unnecessary crypto setup overhead when\r\n   * encryption is not needed (e.g., when using cached tokens).\r\n   *\r\n   * @returns {CryptoService} Initialized CryptoService instance for token encryption\r\n   */\r\n  #getCrypto(): CryptoService {\r\n    if (!this.crypto) {\r\n      this.crypto = new CryptoService();\r\n    }\r\n    return this.crypto;\r\n  }\r\n\r\n  /**\r\n   * Get current circuit breaker state for monitoring\r\n   *\r\n   * @method getCircuitBreakerState\r\n   * @description Returns the current state of the circuit breaker for monitoring\r\n   * and debugging purposes. Useful for health checks and observability.\r\n   *\r\n   * @returns {string} Current circuit breaker state: 'CLOSED', 'OPEN', or 'HALF_OPEN'\r\n   */\r\n  getCircuitBreakerState(): string {\r\n    return this.circuitBreaker.getState();\r\n  }\r\n\r\n  /**\r\n   * Check if rate limiting is currently active for credentials authentication\r\n   *\r\n   * @method isRateLimited\r\n   * @description Checks if the current credentials are rate limited without\r\n   * making an actual authentication attempt. Useful for preemptive checks.\r\n   *\r\n   * @returns {boolean} True if credentials authentication is currently rate limited\r\n   */\r\n  isRateLimited(): boolean {\r\n    if (!this.config.impersonatorUsername) {\r\n      return false;\r\n    }\r\n    const rateLimitKey = `credentials:${this.config.realm}:${this.config.impersonatorUsername}`;\r\n    return !this.rateLimiter.canAttempt(rateLimitKey);\r\n  }\r\n\r\n  /**\r\n   * Enhanced Keycloak login form parser using proper HTML parsing\r\n   *\r\n   * @private\r\n   * @method #parseLoginForm\r\n   * @description Parses HTML login forms from Keycloak to extract form action URL,\r\n   * hidden fields, and detect the presence of username/password input fields.\r\n   * Uses node-html-parser for secure and reliable HTML parsing instead of regex.\r\n   *\r\n   * **Security Improvements:**\r\n   * - Proper HTML parsing prevents injection vulnerabilities\r\n   * - Input sanitization for all extracted values\r\n   * - Safe URL construction with validation\r\n   *\r\n   * @param {string} html - Raw HTML content containing the login form\r\n   * @returns {Object|null} Parsed form data or null if parsing fails\r\n   */\r\n  #parseLoginForm(html: string): {\r\n    action: string;\r\n    fields: Record<string, string>;\r\n    hasUsername: boolean;\r\n    hasPassword: boolean;\r\n  } | null {\r\n    try {\r\n      // Parse HTML safely using node-html-parser\r\n      const document = parseHtml(html);\r\n      const form = document.querySelector('form');\r\n\r\n      if (!form) {\r\n        return null;\r\n      }\r\n\r\n      // Extract and validate form action\r\n      const actionRaw = form.getAttribute('action');\r\n      if (!actionRaw) {\r\n        return null;\r\n      }\r\n\r\n      // Sanitize and resolve action URL\r\n      const action = this.#resolveFormAction(actionRaw.trim());\r\n      if (!action) {\r\n        return null;\r\n      }\r\n\r\n      // Extract all input fields safely\r\n      const inputs = form.querySelectorAll('input');\r\n      const fields: Record<string, string> = {};\r\n      let hasUsername = false;\r\n      let hasPassword = false;\r\n\r\n      for (const input of inputs) {\r\n        const name = input.getAttribute('name')?.trim();\r\n        const value = input.getAttribute('value')?.trim() || '';\r\n        const type = input.getAttribute('type')?.toLowerCase().trim() || 'text';\r\n        const id = input.getAttribute('id')?.toLowerCase().trim() || '';\r\n\r\n        // Sanitize field name and value\r\n        if (name && this.#isValidFieldName(name)) {\r\n          fields[name] = this.#sanitizeFieldValue(value);\r\n        }\r\n\r\n        // Detect password field\r\n        if (type === 'password' || name === 'password' || id === 'password') {\r\n          hasPassword = true;\r\n        }\r\n\r\n        // Detect username field\r\n        if (\r\n          name === 'username' ||\r\n          id === 'username' ||\r\n          (type === 'text' &&\r\n            (name === 'email' || id === 'kc-attempted-username'))\r\n        ) {\r\n          hasUsername = true;\r\n        }\r\n      }\r\n\r\n      return { action, fields, hasUsername, hasPassword };\r\n    } catch (error) {\r\n      LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: true,\r\n        message: 'Failed to parse login form HTML',\r\n        source: 'SystemTokenStore.parseLoginForm',\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resolve and validate form action URL\r\n   *\r\n   * @private\r\n   * @method #resolveFormAction\r\n   * @param {string} actionRaw - Raw action attribute value\r\n   * @returns {string|null} Resolved absolute URL or null if invalid\r\n   */\r\n  #resolveFormAction(actionRaw: string): string | null {\r\n    try {\r\n      // Handle relative URLs by resolving against issuer\r\n      const resolvedUrl = new URL(actionRaw, this.config.issuer);\r\n\r\n      // Validate that the resolved URL uses a secure protocol\r\n      if (!['http:', 'https:'].includes(resolvedUrl.protocol)) {\r\n        return null;\r\n      }\r\n\r\n      return resolvedUrl.toString();\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate field name to prevent injection\r\n   *\r\n   * @private\r\n   * @method #isValidFieldName\r\n   * @param {string} name - Field name to validate\r\n   * @returns {boolean} True if field name is safe\r\n   */\r\n  #isValidFieldName(name: string): boolean {\r\n    // Allow alphanumeric, underscore, dash, and dot\r\n    return /^[a-zA-Z0-9_.-]+$/.test(name) && name.length <= 100;\r\n  }\r\n\r\n  /**\r\n   * Sanitize field value to prevent injection\r\n   *\r\n   * @private\r\n   * @method #sanitizeFieldValue\r\n   * @param {string} value - Field value to sanitize\r\n   * @returns {string} Sanitized field value\r\n   */\r\n  #sanitizeFieldValue(value: string): string {\r\n    // Remove any potentially dangerous characters and limit length\r\n    return value.replace(/[<>\"'&]/g, '').substring(0, 1000);\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\auth\\impersonation\\user-token-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\auth\\impersonation\\utility.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":148,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { env } from '@/lib/site-util/env';\r\nimport type { AdminTokenConfig } from './impersonation.types';\r\nimport { log } from '@/lib/logger';\r\n\r\n/**\r\n * Extracts Keycloak admin configuration from issuer URL\r\n *\r\n * @function adminBaseFromIssuer\r\n * @description Parses a Keycloak issuer URL to extract the realm name and construct\r\n * the corresponding admin base URL. Handles URL decoding and validates the expected\r\n * Keycloak URL structure with '/realms/{realm-name}' path.\r\n *\r\n * @param {string} issuer - The Keycloak issuer URL (e.g., 'https://auth.example.com/realms/master')\r\n * @returns {Object|undefined} Configuration object with origin, realm, and adminBase, or undefined if parsing fails\r\n * @returns {string} returns.origin - The base origin URL (e.g., 'https://auth.example.com')\r\n * @returns {string} returns.realm - The extracted realm name (e.g., 'master')\r\n * @returns {string} returns.adminBase - The constructed admin base URL (e.g., 'https://auth.example.com/admin/realms/master')\r\n *\r\n * @example\r\n * ```typescript\r\n * const config = adminBaseFromIssuer('https://auth.example.com/realms/my-realm');\r\n * // Returns: {\r\n * //   origin: 'https://auth.example.com',\r\n * //   realm: 'my-realm',\r\n * //   adminBase: 'https://auth.example.com/admin/realms/my-realm'\r\n * // }\r\n * ```\r\n *\r\n * @example\r\n * ```typescript\r\n * const invalid = adminBaseFromIssuer('invalid-url');\r\n * // Returns: undefined\r\n * ```\r\n */\r\nexport const adminBaseFromIssuer = (\r\n  issuer: string,\r\n): { origin: string; realm: string; adminBase: string } | undefined => {\r\n  /**\r\n   * Extracts realm name from Keycloak issuer URL path\r\n   *\r\n   * @function extractRealmFromIssuer\r\n   * @description Internal helper that parses the URL pathname to find the realm\r\n   * name following the '/realms/' path segment. Handles URL decoding for realm\r\n   * names that may contain special characters.\r\n   *\r\n   * @param {string} issuer - The Keycloak issuer URL to parse\r\n   * @returns {string|undefined} The decoded realm name, or undefined if not found\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const realm = extractRealmFromIssuer('https://auth.example.com/realms/my%2Drealm');\r\n   * // Returns: 'my-realm'\r\n   * ```\r\n   */\r\n  const extractRealmFromIssuer = (issuer: string): string | undefined => {\r\n    try {\r\n      const u = new URL(issuer);\r\n      const parts = u.pathname.split('/').filter(Boolean);\r\n      const idx = parts.findIndex((p) => p === 'realms');\r\n      if (idx >= 0 && parts[idx + 1]) return decodeURIComponent(parts[idx + 1]);\r\n      return undefined;\r\n    } catch {\r\n      return undefined;\r\n    }\r\n  };\r\n  try {\r\n    const u = new URL(issuer);\r\n    const realm = extractRealmFromIssuer(issuer);\r\n    if (!realm) return undefined;\r\n    return {\r\n      origin: u.origin,\r\n      realm,\r\n      adminBase: `${u.origin}/admin/realms/${encodeURIComponent(realm)}`,\r\n    };\r\n  } catch {\r\n    return undefined;\r\n  }\r\n};\r\n/**\r\n * Creates AdminTokenConfig from environment variables\r\n *\r\n * @function defaultConfigFromEnv\r\n * @description Constructs a complete AdminTokenConfig object by reading values\r\n * from environment variables. Validates that all required configuration is present\r\n * and extracts realm/adminBase from the issuer URL.\r\n *\r\n * @returns {AdminTokenConfig} Complete configuration object for admin token acquisition\r\n * @throws {TypeError} When required environment variables are missing or issuer URL is invalid\r\n *\r\n * @example\r\n * ```typescript\r\n * // Environment variables:\r\n * // AUTH_KEYCLOAK_ISSUER=https://auth.example.com/realms/master\r\n * // AUTH_KEYCLOAK_CLIENT_ID=admin-cli\r\n * // AUTH_KEYCLOAK_CLIENT_SECRET=secret\r\n * // AUTH_KEYCLOAK_REDIRECT_URI=https://app.example.com/callback\r\n *\r\n * const config = defaultConfigFromEnv();\r\n * // Returns complete AdminTokenConfig with realm and adminBase populated\r\n * ```\r\n *\r\n * @see {@link AdminTokenConfig} for complete configuration structure\r\n */\r\nexport const defaultConfigFromEnv = (): AdminTokenConfig => {\r\n  const config = {\r\n    issuer: env('AUTH_KEYCLOAK_ISSUER') || '',\r\n    clientId: env('AUTH_KEYCLOAK_CLIENT_ID') || '',\r\n    clientSecret: env('AUTH_KEYCLOAK_CLIENT_SECRET') || '',\r\n    redirectUri: env('AUTH_KEYCLOAK_REDIRECT_URI') || '',\r\n    impersonatorUsername:\r\n      env('AUTH_KEYCLOAK_IMPERSONATOR_USERNAME') || undefined,\r\n    impersonatorPassword:\r\n      env('AUTH_KEYCLOAK_IMPERSONATOR_PASSWORD') || undefined,\r\n    impersonatorOfflineToken:\r\n      env('AUTH_KEYCLOAK_IMPERSONATOR_OFFLINE_TOKEN') || undefined,\r\n  };\r\n\r\n  // Basic validation - detailed validation happens in constructor\r\n  if (\r\n    !config.issuer ||\r\n    !config.clientId ||\r\n    !config.clientSecret ||\r\n    !config.redirectUri\r\n  ) {\r\n    log((l) =>\r\n      l.warn('SystemTokenStore: incomplete environment configuration'),\r\n    );\r\n    throw new TypeError(\r\n      'SystemTokenStore: Required environment variables are missing',\r\n    );\r\n  }\r\n\r\n  const { realm, adminBase } = adminBaseFromIssuer(config.issuer) || {};\r\n  if (!realm || !adminBase) {\r\n    log((l) =>\r\n      l.warn(\r\n        'SystemTokenStore: Unable to extract realm or admin base from issuer',\r\n      ),\r\n    );\r\n    throw new TypeError('SystemTokenStore: Invalid issuer URL format');\r\n  }\r\n  return {\r\n    ...config,\r\n    adminBase,\r\n    realm,\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\auth\\jwt.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":63,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { JWT } from 'next-auth/jwt';\r\nimport { NextAuthUserWithAccountId } from './types';\r\nimport { AdapterUser } from '@auth/core/adapters';\r\n\r\n/**\r\n * JWT callback used by NextAuth to shape the JWT sent to the client and stored\r\n * in cookies. This module contains a single exported `jwt` function which acts\r\n * as the NextAuth `jwt` callback. It is responsible for ensuring our custom\r\n * application fields (notably `account_id`) are copied from the authenticated\r\n * user object into the JWT so they are available in subsequent requests.\r\n *\r\n * Rationale:\r\n * - NextAuth executes this callback whenever a session is created or updated.\r\n * - The `token` parameter is the current JWT payload and will be returned\r\n *   (possibly mutated) to be serialized into the cookie.\r\n * - The `user` parameter is provided only on sign-in (or when the provider\r\n *   returns a user object). We use it to copy app-specific fields into `token`.\r\n *\r\n * Security: Only copy values that are safe to send to the client. `account_id`\r\n * is considered safe application metadata (non-secret numeric id) but avoid\r\n * copying sensitive information into the JWT.\r\n */\r\nexport const jwt = async ({\r\n  token,\r\n  user,\r\n}: {\r\n  /**\r\n   * The JWT payload (mutable). Fields added here are serialized and sent to\r\n   * the client. Use `token` to read or write values persisted in the session\r\n   * cookie.\r\n   */\r\n  token: JWT;\r\n  /**\r\n   * The user object returned by the authentication provider during sign-in.\r\n   * - When present, it can be an application-extended `NextAuthUserWithAccountId`\r\n   *   (our credentials provider sets `account_id`) or a generic `AdapterUser`.\r\n   * - It is `undefined` for subsequent callback invocations where only the\r\n   *   token is being refreshed/read.\r\n   */\r\n  user?: NextAuthUserWithAccountId | AdapterUser | null;\r\n}) => {\r\n  // When a user is present (typically during sign-in), copy canonical ids\r\n  // and any application-specific metadata we want available in the JWT.\r\n  if (user) {\r\n    // Canonical NextAuth id - always copy this so token consumers can identify\r\n    // the authenticated principal without needing to fetch user records.\r\n    token.id = user.id;\r\n\r\n    // Our CredentialsProvider sets `account_id` on the user when available.\r\n    // We only copy it when the property exists and is truthy to avoid\r\n    // introducing `undefined`/`null` values into the token shape.\r\n    //\r\n    // Note: `account_id` is treated as non-sensitive application metadata.\r\n    if ('account_id' in user && !!user.account_id) {\r\n      token.account_id = user.account_id;\r\n    }\r\n  }\r\n\r\n  // Always return the (possibly mutated) token. NextAuth will serialize this\r\n  // value and include it in the session cookie / client-side JWT.\r\n  return token;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\auth\\keycloak-factories.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":23,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import KeycloakAdminClient from '@keycloak/keycloak-admin-client';\r\nimport { ConnectionConfig } from '@keycloak/keycloak-admin-client/lib/client';\r\n\r\n/**\r\n * Create a configured Keycloak Admin client.\r\n *\r\n * This factory wraps the KeycloakAdminClient constructor and provides a single\r\n * place to create clients in the codebase. The passed `config` object is\r\n * forwarded directly to the upstream Keycloak admin client library.\r\n *\r\n * @param {ConnectionConfig} config - Connection settings for the Keycloak Admin client.\r\n * @returns {KeycloakAdminClient} An initialized Keycloak admin client instance.\r\n *\r\n * @example\r\n * ```ts\r\n * import { keycloakAdminClientFactory } from '@/lib/auth/keycloak-factories';\r\n * const client = keycloakAdminClientFactory({ baseUrl: 'https://auth', realmName: 'master' });\r\n * ```\r\n */\r\nexport const keycloakAdminClientFactory = (\r\n  config: ConnectionConfig,\r\n): KeycloakAdminClient => new KeycloakAdminClient(config);\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\auth\\keycloak-provider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\auth\\redirect.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\auth\\redirect.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":18,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { env } from '@/lib/site-util/env';\r\n\r\nexport const redirect = ({\r\n  url,\r\n  baseUrl,\r\n}: {\r\n  /** URL provided as callback URL by the client */\r\n  url: string;\r\n  /** Default base URL of site (can be used as fallback) */\r\n  baseUrl: string;\r\n}): Promise<string> => {\r\n  const providedUrl = new URL(url, baseUrl);\r\n  // Only allow relative paths or same-origin URLs to prevent open redirect vulnerabilities\r\n  return Promise.resolve(\r\n    new URL(providedUrl.pathname, env('NEXT_PUBLIC_HOSTNAME')).toString(),\r\n  );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\auth\\session.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\auth\\sign-in.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":18,"column":1,"nodeType":"Program","endLine":186,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Module: lib/auth/sign-in.ts\r\n *\r\n * Responsibilities:\r\n * - Persist OAuth provider tokens to the local accounts table when available.\r\n * - Emit local telemetry and a lightweight Application Insights `signIn` event\r\n *   without including any sensitive tokens or secrets.\r\n *\r\n * Notes on telemetry and privacy:\r\n * - The AppInsights event uses only non-sensitive, minimal properties (provider\r\n *   and a truncated providerAccountId) to allow basic attribution without\r\n *   capturing tokens, refresh tokens, or full account identifiers.\r\n * - All write operations to the database are limited to the `accounts` table\r\n *   and only store token-like fields when explicitly present on the OAuth\r\n *   provider account object.\r\n */\r\n\r\nimport { Account, Awaitable, Profile, User } from '@auth/core/types';\r\nimport { drizDbWithInit, schema } from '@/lib/drizzle-db';\r\nimport { and, eq } from 'drizzle-orm';\r\nimport { log, logEvent } from '@/lib/logger';\r\nimport { getAppInsights } from '@/instrument/browser';\r\nimport { CredentialInput } from '@auth/core/providers';\r\nimport { AdapterUser } from '@auth/core/adapters';\r\n\r\n/**\r\n * Persist token fields for an external OAuth account to the local `accounts`\r\n * table. This function will only write fields that are present on the\r\n * provider account object; no additional normalization is performed here.\r\n *\r\n * Contract / Inputs:\r\n * - account: the provider Account object returned by next-auth (or a similar\r\n *   shape). Only `id_token`, `access_token`, and `refresh_token` are\r\n *   considered for persistence.\r\n *\r\n * Outputs / Side-effects:\r\n * - Updates the `accounts` row matching the provider + providerAccountId with\r\n *   the token fields (idToken, accessToken, refreshToken) when present.\r\n *\r\n * Error modes:\r\n * - Any database error will propagate to the caller. Caller should ensure\r\n *   failures here do not break the sign-in flow (see usage below).\r\n *\r\n * @param params.account - OAuth provider account object (may include tokens)\r\n * @param params.user - User object (not used currently but kept for future use)\r\n */\r\nconst updateAccountTokens = async ({\r\n  account,\r\n}: {\r\n  user: User | AdapterUser;\r\n  account: Account | Record<string, unknown>;\r\n}) => {\r\n  const { accounts } = schema;\r\n  const fields: Record<string, string> = {};\r\n  if (account.id_token) {\r\n    fields.idToken = String(account.id_token);\r\n  }\r\n  if (account.access_token) {\r\n    fields.accessToken = String(account.access_token);\r\n  }\r\n  if (account.refresh_token) {\r\n    fields.refreshToken = String(account.refresh_token);\r\n  }\r\n  if (Object.keys(fields).length === 0) {\r\n    return;\r\n  }\r\n  await drizDbWithInit((db) =>\r\n    db\r\n      .update(accounts)\r\n      .set(fields)\r\n      .where(\r\n        and(\r\n          eq(accounts.provider, String(account.provider)),\r\n          eq(accounts.providerAccountId, String(account.providerAccountId)),\r\n        ),\r\n      ),\r\n  );\r\n};\r\n\r\n/**\r\n * NextAuth `signIn` callback implementation.\r\n *\r\n * This callback is intended to be used as the `callbacks.signIn` handler for\r\n * NextAuth. It performs two responsibilities:\r\n *  1. Persist new OAuth tokens for supported providers (currently `keycloak`)\r\n *     into the local `accounts` table via `updateAccountTokens`.\r\n *  2. Emit a lightweight telemetry event locally (`logEvent('signIn')`) and\r\n *     to Application Insights when available. The AppInsights event uses only\r\n *     minimal, non-sensitive properties (provider and a truncated\r\n *     providerAccountId).\r\n *\r\n * Success criteria / Return:\r\n * - Must return `true` (allow sign-in) or a redirect URL (string) in case\r\n *   the application wants to redirect the user. This implementation always\r\n *   returns `true` to allow sign-in to proceed.\r\n *\r\n * Edge cases:\r\n * - If `account` is missing or the provider is not one of the handled\r\n *   providers, no token persistence is attempted. AppInsights failures are\r\n *   caught and logged but do not block sign-in.\r\n *\r\n * @param params.user - The user object returned/created by the adapter or\r\n *                     OAuth provider.\r\n * @param params.account - Provider account object (may be null during some\r\n *                        flows). When present, used to persist tokens.\r\n * @param params.profile - Optional OAuth profile provided by the provider.\r\n * @param params.email - Optional email verification metadata for email\r\n *                      provider flows.\r\n *\r\n * @returns Awaitable<boolean|string> - `true` to allow sign-in, or a string\r\n *                                      URL to redirect to.\r\n */\r\nexport const signIn: (params: {\r\n  user: User | AdapterUser;\r\n  account?: Account | null;\r\n  /**\r\n   * If OAuth provider is used, it contains the full\r\n   * OAuth profile returned by your provider.\r\n   */\r\n  profile?: Profile;\r\n  /**\r\n   * If Email provider is used, on the first call, it contains a\r\n   * `verificationRequest: true` property to indicate it is being triggered in the verification request flow.\r\n   * When the callback is invoked after a user has clicked on a sign in link,\r\n   * this property will not be present. You can check for the `verificationRequest` property\r\n   * to avoid sending emails to addresses or domains on a blocklist or to only explicitly generate them\r\n   * for email address in an allow list.\r\n   */\r\n  email?: {\r\n    verificationRequest?: boolean;\r\n  };\r\n  /** If Credentials provider is used, it contains the user credentials */\r\n  credentials?: Record<string, CredentialInput>;\r\n}) => Awaitable<boolean | string> = async (\r\n  {\r\n    user,\r\n    account,\r\n  }:\r\n    | {\r\n        user: User | AdapterUser;\r\n        account?: Account | Record<string, unknown> | null;\r\n      }\r\n    | undefined = {\r\n    user: undefined as unknown as User | AdapterUser,\r\n    account: undefined,\r\n  },\r\n): Promise<boolean | string> => {\r\n  if (account && account.providerAccountId) {\r\n    switch (account.provider) {\r\n      case 'keycloak':\r\n        // Persist tokens for Keycloak. We intentionally do not\r\n        // await here to avoid delaying the sign-in flow; failures will\r\n        // propagate if required but we don't want telemetry to block UX.\r\n        updateAccountTokens({ user, account });\r\n        break;\r\n      default:\r\n        log((l) =>\r\n          l.error(`Unhandled provider ${account?.provider} in signIn`),\r\n        );\r\n        break;\r\n    }\r\n  }\r\n\r\n  // Log local telemetry and report a lightweight event to AppInsights when available\r\n  logEvent('signIn');\r\n  try {\r\n    const appInsights = getAppInsights();\r\n    if (appInsights && typeof appInsights.trackEvent === 'function') {\r\n      // Use minimal properties – avoid logging tokens or sensitive data\r\n      appInsights.trackEvent(\r\n        { name: 'signIn' },\r\n        {\r\n          provider: account?.provider ?? 'unknown',\r\n          providerAccountId: account?.providerAccountId\r\n            ? String(account.providerAccountId).slice(0, 8)\r\n            : undefined,\r\n        },\r\n      );\r\n    }\r\n  } catch (err) {\r\n    // Keep sign-in resilient: log and continue\r\n    log((l) => l.debug('signIn: AppInsights trackEvent failed', err));\r\n  }\r\n  return true;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\auth\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":59,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Session } from '@auth/core/types';\r\nimport { User as NextAuthUser } from 'next-auth'; // Added NextAuthConfig\r\n\r\n/**\r\n * Auth types shared by the application.\r\n *\r\n * This module provides thin, well‑documented TypeScript types that extend the\r\n * upstream NextAuth/`@auth/core` types with application specific fields. The\r\n * primary extension is adding an optional `account_id` to the user object which\r\n * our credentials provider sets for convenience and downstream services.\r\n *\r\n * Exported types:\r\n * - `NextAuthUserWithAccountId` — a `NextAuthUser` with optional `account_id`\r\n * - `SessionWithAccountId` — the standard `Session` with the extended user type\r\n */\r\n\r\n/**\r\n * Represents an authenticated user with an optional numeric `account_id`.\r\n *\r\n * Background:\r\n * - `NextAuthUser` is provided by the `next-auth` types and models the standard\r\n *   user properties (id, name, email, image, etc.). Our local credential provider\r\n *   includes `account_id` (a numeric ID used by our backend) on the returned\r\n *   user object. This type documents that extension so the rest of the codebase\r\n *   can access `account_id` safely.\r\n *\r\n * Fields:\r\n * - All fields from `NextAuthUser` are available.\r\n * - `account_id?: number` — optional numeric identifier correlating to the\r\n *   application's account record. Marked optional because not all auth flows\r\n *   populate it (for example, third‑party providers may omit it).\r\n */\r\nexport type NextAuthUserWithAccountId = NextAuthUser & {\r\n  /**\r\n   * Optional numeric account identifier associated with the user in our system.\r\n   * This is primarily used by server-side services and is not part of the\r\n   * upstream NextAuth user shape.\r\n   */\r\n  account_id?: number;\r\n};\r\n\r\n/**\r\n * Session shape used across the application that includes the extended user type.\r\n *\r\n * This type augments the `Session` exported by `@auth/core/types` to indicate\r\n * that `session.user` (when present) may include an `account_id` via\r\n * `NextAuthUserWithAccountId`.\r\n *\r\n * Usage note:\r\n * - Prefer consuming `SessionWithAccountId` in server handlers and helpers that\r\n *   need access to the numeric `account_id` to avoid repetitive type assertions.\r\n */\r\nexport type SessionWithAccountId = Session & {\r\n  /**\r\n   * Authenticated user details. May be undefined if session is empty/uninitialized.\r\n   */\r\n  user?: NextAuthUserWithAccountId;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\ai\\chat-fetch-wrapper.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":176,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { notCryptoSafeKeyHash } from '@/lib/ai/core/chat-ids';\r\nimport {\r\n  QueryClient,\r\n  useQueryClient,\r\n  experimental_streamedQuery as streamedQuery,\r\n} from '@tanstack/react-query';\r\nimport { log } from '@/lib/logger';\r\nimport { useCallback } from 'react';\r\nimport { env } from '@/lib/site-util/env';\r\nimport { fetch } from '@/lib/nextjs-util/fetch';\r\n\r\n/**\r\n * Creates a simple fetch wrapper with basic retry logic and error handling\r\n * for use with AI SDK's useChat hook.\r\n */\r\nexport const useChatFetchWrapper = (): {\r\n  chatFetch: typeof globalThis.fetch;\r\n  queryClient: QueryClient;\r\n} => {\r\n  const queryClient = useQueryClient();\r\n  if (!queryClient) {\r\n    throw new Error(\r\n      'QueryClient is not available. Ensure you are using this in a QueryClientProvider context.',\r\n    );\r\n  }\r\n\r\n  const computeKey = async (\r\n    input: RequestInfo | URL,\r\n    init?: RequestInit,\r\n  ): Promise<[URL, string]> => {\r\n    const hashBody = async <TBody>(body: TBody): Promise<[string, TBody]> => {\r\n      if (typeof body === 'string') {\r\n        return [notCryptoSafeKeyHash(body), body];\r\n      }\r\n      if (body instanceof URLSearchParams) {\r\n        return [notCryptoSafeKeyHash(body.toString()), body];\r\n      }\r\n      if (body instanceof Blob) {\r\n        // Reading a Blob as text/arrayBuffer is possible, but would consume it.\r\n        // To avoid breaking the request, clone the Blob if needed, or use a placeholder.\r\n        // If you must hash the contents, you could read it here, but then you'd need to replace it in `init.body`.\r\n        // Example (not recommended for large blobs):\r\n        const blobText = await body.text();\r\n        const requestHash = notCryptoSafeKeyHash(blobText);\r\n        // Replace the body with a string so we can re-use it\r\n        return [requestHash, blobText as TBody];\r\n        /*\r\n        return [\r\n          requestHash,\r\n          new Blob([blobText], { type: body.type }) as TBody,\r\n        ];\r\n        */\r\n      }\r\n      log((l) => l.warn('Unsupported body type for hashing:', body));\r\n      return ['', body];\r\n    };\r\n\r\n    // Safely extract the body for hashing without consuming or altering the original request\r\n    let requestHash: string = '';\r\n    if (init && init.body) {\r\n      const [hash, body] = await hashBody(init.body);\r\n      init.body = body; // Restore the body to avoid passing a consumed stream.\r\n      requestHash = hash;\r\n    }\r\n    if (requestHash == '' && input instanceof Request) {\r\n      const [hash] = await hashBody(input.body);\r\n      requestHash = hash;\r\n    }\r\n    if (requestHash === '') {\r\n      throw new Error('No body to hash for request key');\r\n    }\r\n    // TODO: Would be nice to pull the last message - or part of it - for display purposes\r\n    const url = new URL(\r\n      input instanceof Request ? input.url : input.toString(),\r\n      new URL(env('NEXT_PUBLIC_HOSTNAME')),\r\n    );\r\n    return [url, requestHash];\r\n  };\r\n\r\n  /**\r\n   * Fetches a chat stream from the server.\r\n   * @param {Object} params - Parameters for the fetch.\r\n   * @param {URL | Request} params.req - The request URL or Request object.\r\n   * @param {RequestInit} [params.init] - Optional request initialization options.\r\n   * @returns {AsyncGenerator<string>} An async generator yielding chunks of the chat stream.\r\n   */\r\n\r\n  async function* fetchChatStream({\r\n    req,\r\n    init,\r\n  }: {\r\n    req: URL | RequestInfo;\r\n    init?: RequestInit;\r\n  }) {\r\n    const response = await fetch(req, init);\r\n    if (!response.ok) {\r\n      throw new Error(`Network response was not ok: ${response.statusText}`, {\r\n        cause: response,\r\n      });\r\n    }\r\n    const reader = response.body?.getReader();\r\n    if (!reader) {\r\n      throw new Error('No readable stream');\r\n    }\r\n    while (true) {\r\n      const { done, value } = await reader.read();\r\n      if (done) break;\r\n      yield value;\r\n      if (init?.signal?.aborted) {\r\n        await reader.cancel();\r\n        return;\r\n      }\r\n    }\r\n  }\r\n\r\n  const chatFetch = useCallback(\r\n    async (input: URL | RequestInfo, init?: RequestInit) => {\r\n      const stream = queryClient.fetchQuery({\r\n        queryKey: await computeKey(input, init),\r\n        queryFn: streamedQuery({\r\n          streamFn: ({ signal }: { signal?: AbortSignal }) => {\r\n            if (!init) {\r\n              init = {};\r\n            }\r\n            // Merge the provided signal and any signal in init into a single AbortController\r\n            let mergedSignal = signal ?? init.signal;\r\n            if (init.signal && init.signal !== mergedSignal) {\r\n              const controller = new AbortController();\r\n              const abort = () => controller.abort();\r\n              if (signal) {\r\n                signal.addEventListener('abort', abort);\r\n              }\r\n              if (init.signal) {\r\n                init.signal.addEventListener('abort', abort);\r\n              }\r\n              mergedSignal = init.signal;\r\n              init.signal = controller.signal;\r\n            }\r\n            return fetchChatStream({ req: input, init });\r\n          },\r\n        }),\r\n      });\r\n\r\n      // Convert to ReadableStream and then to Response\r\n      const readableStream = new ReadableStream({\r\n        async start(controller) {\r\n          try {\r\n            for await (const chunk of await stream) {\r\n              controller.enqueue(chunk);\r\n            }\r\n            controller.close();\r\n          } catch (error) {\r\n            controller.error(error);\r\n          }\r\n        },\r\n      });\r\n      return new Response(readableStream, {\r\n        headers: {\r\n          'Content-Type': 'text/plain',\r\n          'Transfer-Encoding': 'chunked',\r\n        },\r\n      });\r\n    },\r\n    [queryClient],\r\n  );\r\n  return {\r\n    chatFetch,\r\n    queryClient,\r\n  };\r\n};\r\n\r\n/**\r\n * Default chat fetch function with basic enhancements\r\n */\r\n// export const enhancedChatFetch = useChatFetchWrapper();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\ai\\chat-query-client.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":31,"endColumn":56}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { QueryClient } from '@tanstack/react-query';\r\n\r\n/**\r\n * Create a QueryClient instance with basic options optimized for chat operations.\r\n * Provides retry logic and error handling for improved reliability.\r\n */\r\nexport const createChatQueryClient = () => {\r\n  return new QueryClient({\r\n    defaultOptions: {\r\n      queries: {\r\n        retry: (failureCount, error) => {\r\n          // Don't retry on 4xx errors (client errors like rate limits)\r\n          if (error instanceof Error && 'status' in error) {\r\n            const status = (error as Error & { status: number }).status;\r\n            if (status >= 400 && status < 500) {\r\n              return false;\r\n            }\r\n          }\r\n          // Retry up to 2 times for network errors\r\n          return failureCount < 2;\r\n        },\r\n        retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\r\n        refetchOnWindowFocus: false,\r\n        refetchOnReconnect: true,\r\n      },\r\n    },\r\n  });\r\n};\r\n\r\n// Global query client instance\r\nexport const chatQueryClient = createChatQueryClient();","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\ai\\height-estimators.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":22,"column":1,"nodeType":"Program","endLine":620,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useDynamicWidth' is defined but never used.","line":22,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":25,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ratio' is assigned a value but never used.","line":447,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":447,"endColumn":20,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Height Estimation Utilities for AI Chat Components\r\n *\r\n * This module provides sophisticated text and markdown height estimation utilities\r\n * for AI chat interfaces. It includes canvas-based text measurement, markdown-aware\r\n * height calculations, DOM-based measurement tools, and adaptive learning systems\r\n * for improving estimation accuracy over time.\r\n *\r\n * Key Features:\r\n * - Canvas-based text measurement for accurate width/height calculations\r\n * - Markdown-aware height estimation with support for headers, lists, code blocks\r\n * - DOM-based measurement for complex layouts\r\n * - Adaptive caching and learning systems\r\n * - Performance optimizations with TTL-based caching\r\n *\r\n * @module lib/components/ai/height-estimators\r\n * @version 1.0.0\r\n * @since 2025-07-18\r\n */\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nimport { useDynamicWidth } from '@/lib/react-util/hooks/use-dynamic-width';\r\n\r\n/**\r\n * Creates a canvas-based text measurement utility for accurate text dimensions.\r\n *\r\n * This function provides a high-performance text measurement system using HTML5 Canvas\r\n * for precise width and height calculations. It maintains a singleton canvas instance\r\n * for efficiency and provides methods for both single-line and wrapped text measurement.\r\n *\r\n * @returns {Object} Text measurement utility object\r\n * @returns {Function} measureText - Measures single-line text dimensions\r\n * @returns {Function} calculateWrappedHeight - Calculates height for wrapped text\r\n *\r\n * @example\r\n * ```typescript\r\n * const textMeasurer = createTextMeasurer();\r\n *\r\n * // Measure single line\r\n * const { width, height } = textMeasurer.measureText('Hello World', 16, 'Arial');\r\n *\r\n * // Calculate wrapped text height\r\n * const wrappedHeight = textMeasurer.calculateWrappedHeight(\r\n *   'Long text that will wrap',\r\n *   300, // max width\r\n *   14,  // font size\r\n *   'Roboto'\r\n * );\r\n * ```\r\n *\r\n * @performance Uses singleton canvas instance for optimal performance\r\n * @accuracy Provides pixel-perfect measurements using native canvas text metrics\r\n */\r\n// Enhanced canvas-based text measurement utilities\r\nexport const createTextMeasurer = () => {\r\n  let canvas: HTMLCanvasElement | null = null;\r\n  let context: CanvasRenderingContext2D | null = null;\r\n\r\n  const getContext = () => {\r\n    if (!canvas || !context) {\r\n      canvas = document.createElement('canvas');\r\n      context = canvas.getContext('2d');\r\n    }\r\n    return context;\r\n  };\r\n\r\n  return {\r\n    measureText: (\r\n      text: string,\r\n      fontSize: number = 14,\r\n      fontFamily: string = 'Roboto, sans-serif',\r\n    ) => {\r\n      const ctx = getContext();\r\n      if (!ctx) return { width: text.length * 8, height: fontSize * 1.4 };\r\n\r\n      ctx.font = `${fontSize}px ${fontFamily}`;\r\n      const metrics = ctx.measureText(text);\r\n\r\n      return {\r\n        width: metrics.width,\r\n        height: fontSize * 1.4,\r\n      };\r\n    },\r\n\r\n    calculateWrappedHeight: (\r\n      text: string,\r\n      maxWidth: number,\r\n      fontSize: number = 14,\r\n      fontFamily: string = 'Roboto, sans-serif',\r\n    ) => {\r\n      const ctx = getContext();\r\n      if (!ctx) return Math.ceil(text.length / 50) * (fontSize * 1.4);\r\n\r\n      ctx.font = `${fontSize}px ${fontFamily}`;\r\n\r\n      // Handle empty text\r\n      if (!text.trim()) return fontSize * 1.4;\r\n\r\n      const words = text.split(/\\s+/);\r\n      let lines = 1;\r\n      let currentLineWidth = 0;\r\n      const spaceWidth = ctx.measureText(' ').width;\r\n\r\n      for (const word of words) {\r\n        const wordWidth = ctx.measureText(word).width;\r\n        const totalWidth =\r\n          currentLineWidth +\r\n          (currentLineWidth > 0 ? spaceWidth : 0) +\r\n          wordWidth;\r\n\r\n        if (totalWidth > maxWidth && currentLineWidth > 0) {\r\n          lines++;\r\n          currentLineWidth = wordWidth;\r\n        } else {\r\n          currentLineWidth = totalWidth;\r\n        }\r\n      }\r\n\r\n      return lines * (fontSize * 1.4);\r\n    },\r\n  };\r\n};\r\n\r\n/**\r\n * Estimates the rendered height of markdown content with support for various markdown elements.\r\n *\r\n * This function parses markdown text and calculates the approximate rendered height by\r\n * analyzing different markdown elements including headers, lists, code blocks, blockquotes,\r\n * and regular paragraphs. It uses the provided text measurer for accurate text dimensions.\r\n *\r\n * Supported Markdown Elements:\r\n * - Headers (H1-H4): # ## ### ####\r\n * - Unordered lists: - * +\r\n * - Ordered lists: 1. 2. 3.\r\n * - Code blocks: ```\r\n * - Blockquotes: >\r\n * - Inline code: `code`\r\n * - Regular paragraphs\r\n *\r\n * @param {string} text - The markdown text to measure\r\n * @param {number} maxWidth - Maximum width for text wrapping\r\n * @param {ReturnType<typeof createTextMeasurer>} textMeasurer - Text measurement utility\r\n * @returns {number} Estimated height in pixels\r\n *\r\n * @example\r\n * ```typescript\r\n * const textMeasurer = createTextMeasurer();\r\n * const height = estimateMarkdownHeight(\r\n *   '# Title\\n\\nSome paragraph text\\n\\n- List item 1\\n- List item 2',\r\n *   400,\r\n *   textMeasurer\r\n * );\r\n * ```\r\n *\r\n * @algorithm\r\n * 1. Splits text into lines\r\n * 2. Analyzes each line for markdown syntax\r\n * 3. Applies appropriate font sizes and spacing\r\n * 4. Handles code blocks with monospace metrics\r\n * 5. Accumulates total height with proper margins\r\n */\r\n// Enhanced markdown content height estimator\r\nexport const estimateMarkdownHeight = (\r\n  text: string,\r\n  maxWidth: number,\r\n  textMeasurer: ReturnType<typeof createTextMeasurer>,\r\n) => {\r\n  // Split by lines and process each markdown element\r\n  const lines = text.split('\\n');\r\n  let totalHeight = 0;\r\n  let inCodeBlock = false;\r\n  let codeBlockLines = 0;\r\n\r\n  for (const line of lines) {\r\n    const trimmedLine = line.trim();\r\n\r\n    // Handle code blocks\r\n    if (trimmedLine.startsWith('```')) {\r\n      if (inCodeBlock) {\r\n        // End of code block\r\n        totalHeight += Math.max(codeBlockLines * 16 * 1.4, 32); // Min 32px height\r\n        totalHeight += 16; // padding\r\n        inCodeBlock = false;\r\n        codeBlockLines = 0;\r\n      } else {\r\n        // Start of code block\r\n        inCodeBlock = true;\r\n        codeBlockLines = 0;\r\n      }\r\n      continue;\r\n    }\r\n\r\n    if (inCodeBlock) {\r\n      codeBlockLines++;\r\n      continue;\r\n    }\r\n\r\n    // Handle different markdown elements\r\n    if (trimmedLine.startsWith('# ')) {\r\n      // H1 - larger font\r\n      totalHeight += textMeasurer.calculateWrappedHeight(\r\n        trimmedLine.substring(2),\r\n        maxWidth,\r\n        24,\r\n      );\r\n      totalHeight += 12; // margin\r\n    } else if (trimmedLine.startsWith('## ')) {\r\n      // H2\r\n      totalHeight += textMeasurer.calculateWrappedHeight(\r\n        trimmedLine.substring(3),\r\n        maxWidth,\r\n        20,\r\n      );\r\n      totalHeight += 10;\r\n    } else if (trimmedLine.startsWith('### ')) {\r\n      // H3\r\n      totalHeight += textMeasurer.calculateWrappedHeight(\r\n        trimmedLine.substring(4),\r\n        maxWidth,\r\n        18,\r\n      );\r\n      totalHeight += 8;\r\n    } else if (trimmedLine.startsWith('#### ')) {\r\n      // H4\r\n      totalHeight += textMeasurer.calculateWrappedHeight(\r\n        trimmedLine.substring(5),\r\n        maxWidth,\r\n        16,\r\n      );\r\n      totalHeight += 6;\r\n    } else if (\r\n      trimmedLine.startsWith('- ') ||\r\n      trimmedLine.startsWith('* ') ||\r\n      trimmedLine.startsWith('+ ')\r\n    ) {\r\n      // List item\r\n      totalHeight += textMeasurer.calculateWrappedHeight(\r\n        trimmedLine.substring(2),\r\n        maxWidth - 20,\r\n        14,\r\n      );\r\n      totalHeight += 4;\r\n    } else if (/^\\d+\\.\\s/.test(trimmedLine)) {\r\n      // Numbered list item\r\n      const match = trimmedLine.match(/^\\d+\\.\\s(.*)$/);\r\n      if (match) {\r\n        totalHeight += textMeasurer.calculateWrappedHeight(\r\n          match[1],\r\n          maxWidth - 30,\r\n          14,\r\n        );\r\n        totalHeight += 4;\r\n      }\r\n    } else if (trimmedLine.startsWith('> ')) {\r\n      // Blockquote\r\n      totalHeight += textMeasurer.calculateWrappedHeight(\r\n        trimmedLine.substring(2),\r\n        maxWidth - 20,\r\n        14,\r\n      );\r\n      totalHeight += 8; // Extra spacing for blockquotes\r\n    } else if (trimmedLine === '') {\r\n      // Empty line - add paragraph spacing\r\n      totalHeight += 8;\r\n    } else {\r\n      // Regular paragraph text\r\n      totalHeight += textMeasurer.calculateWrappedHeight(\r\n        trimmedLine,\r\n        maxWidth,\r\n        14,\r\n      );\r\n      totalHeight += 6; // paragraph spacing\r\n    }\r\n  }\r\n\r\n  // Handle unclosed code block\r\n  if (inCodeBlock && codeBlockLines > 0) {\r\n    totalHeight += codeBlockLines * 16 * 1.4;\r\n    totalHeight += 16;\r\n  }\r\n\r\n  return Math.max(totalHeight, 20); // Minimum height\r\n};\r\n\r\n/**\r\n * Creates a DOM-based element measurement utility for complex layout calculations.\r\n *\r\n * This function provides a DOM-based measurement system that creates temporary\r\n * elements in the document to measure actual rendered dimensions. It's particularly\r\n * useful for complex markdown content where canvas-based measurement may not be\r\n * sufficient due to CSS styling and HTML structure.\r\n *\r\n * @returns {Object} Element measurement utility object\r\n * @returns {Function} measureMarkdown - Measures markdown content using DOM\r\n * @returns {Function} cleanup - Cleans up measurement container\r\n *\r\n * @example\r\n * ```typescript\r\n * const elementMeasurer = createElementMeasurer();\r\n *\r\n * const height = elementMeasurer.measureMarkdown({\r\n *   text: '# Title\\n\\nParagraph with **bold** text',\r\n *   width: 400\r\n * });\r\n *\r\n * // Clean up when done\r\n * elementMeasurer.cleanup();\r\n * ```\r\n *\r\n * @performance Uses hidden DOM elements positioned off-screen\r\n * @accuracy Provides actual CSS-rendered dimensions\r\n * @memory Includes cleanup method to prevent memory leaks\r\n */\r\nexport const createElementMeasurer = () => {\r\n  let measurementContainer: HTMLDivElement | null = null;\r\n\r\n  const getMeasurementContainer = () => {\r\n    if (!measurementContainer) {\r\n      measurementContainer = document.createElement('div');\r\n      measurementContainer.style.cssText = `\r\n        position: absolute;\r\n        left: -9999px;\r\n        top: -9999px;\r\n        width: 280px; /* 70% of 400px */\r\n        visibility: hidden;\r\n        pointer-events: none;\r\n        font-family: Roboto, sans-serif;\r\n        font-size: 14px;\r\n        line-height: 1.4;\r\n      `;\r\n      document.body.appendChild(measurementContainer);\r\n    }\r\n    return measurementContainer;\r\n  };\r\n\r\n  return {\r\n    measureMarkdown: ({ text, width }: { text: string; width: number }) => {\r\n      const container = getMeasurementContainer();\r\n\r\n      // Create a temporary element to measure the markdown\r\n      const tempElement = document.createElement('div');\r\n      tempElement.style.cssText = `\r\n        padding: 16px;\r\n        max-width: ${width}px; /* UI provides measurement of current width. */\r\n        font-family: Roboto, sans-serif;\r\n        word-wrap: break-word;\r\n        white-space: pre-wrap;\r\n      `;\r\n\r\n      // Simple markdown-to-HTML conversion for measurement\r\n      const htmlContent = text\r\n        .replace(/^### (.*$)/gim, '<h3>$1</h3>')\r\n        .replace(/^## (.*$)/gim, '<h2>$1</h2>')\r\n        .replace(/^# (.*$)/gim, '<h1>$1</h1>')\r\n        .replace(\r\n          /```[\\s\\S]*?```/g,\r\n          '<pre style=\"padding: 8px; margin: 8px 0; background: #f5f5f5; border-radius: 4px; font-family: monospace;\">Code Block</pre>',\r\n        )\r\n        .replace(/`([^`]+)`/g, '<code>$1</code>')\r\n        .replace(/\\*\\*(.*?)\\*\\*/g, '<strong>$1</strong>')\r\n        .replace(/\\*(.*?)\\*/g, '<em>$1</em>')\r\n        .replace(/\\n/g, '<br>');\r\n\r\n      tempElement.innerHTML = htmlContent;\r\n      container.appendChild(tempElement);\r\n\r\n      const height = tempElement.offsetHeight;\r\n      container.removeChild(tempElement);\r\n\r\n      return height;\r\n    },\r\n\r\n    cleanup: () => {\r\n      if (measurementContainer && measurementContainer.parentNode) {\r\n        measurementContainer.parentNode.removeChild(measurementContainer);\r\n        measurementContainer = null;\r\n      }\r\n    },\r\n  };\r\n};\r\n\r\n/**\r\n * Creates an adaptive size estimator that learns from actual measurements over time.\r\n *\r\n * This function implements a learning system that improves estimation accuracy by\r\n * comparing initial estimates with actual measured dimensions. It maintains a cache\r\n * of measurements and calculates adjustment factors to improve future estimates.\r\n *\r\n * @returns {Object} Adaptive size estimator object\r\n * @returns {Function} estimateSize - Provides size estimate with caching\r\n * @returns {Function} recordActualSize - Records actual measurement for learning\r\n * @returns {Function} getAdjustmentFactor - Gets current adjustment factor\r\n *\r\n * @example\r\n * ```typescript\r\n * const adaptiveEstimator = createAdaptiveSizeEstimator();\r\n *\r\n * // Initial estimate\r\n * const estimated = adaptiveEstimator.estimateSize('msg-1', content, 150);\r\n *\r\n * // Later, record actual measurement\r\n * adaptiveEstimator.recordActualSize('msg-1', 180);\r\n *\r\n * // Get learning adjustment factor\r\n * const factor = adaptiveEstimator.getAdjustmentFactor();\r\n * ```\r\n *\r\n * @algorithm\r\n * 1. Caches initial estimates by message ID\r\n * 2. Records actual vs estimated measurements\r\n * 3. Calculates adjustment ratios\r\n * 4. Applies learning to improve future estimates\r\n *\r\n * @performance Uses Map-based caching for O(1) lookups\r\n * @learning Continuously improves accuracy through usage\r\n */\r\n// You can also implement a learning system that improves over time:\r\nexport const createAdaptiveSizeEstimator = () => {\r\n  const sizeCache = new Map<string, number>();\r\n  const measurements = new Map<string, { estimated: number; actual: number }>();\r\n\r\n  return {\r\n    estimateSize: (\r\n      messageId: string,\r\n      content: string,\r\n      estimatedHeight: number,\r\n    ) => {\r\n      // Check cache first\r\n      const cached = sizeCache.get(messageId);\r\n      if (cached) return cached;\r\n\r\n      // Store initial estimate\r\n      sizeCache.set(messageId, estimatedHeight);\r\n      return estimatedHeight;\r\n    },\r\n\r\n    recordActualSize: (messageId: string, actualHeight: number) => {\r\n      const estimated = sizeCache.get(messageId);\r\n      if (estimated) {\r\n        measurements.set(messageId, { estimated, actual: actualHeight });\r\n\r\n        // Update cache with actual measurement\r\n        sizeCache.set(messageId, actualHeight);\r\n\r\n        // Learn from the difference to improve future estimates\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        const ratio = actualHeight / estimated;\r\n        // You could use this ratio to adjust future estimates\r\n      }\r\n    },\r\n\r\n    getAdjustmentFactor: () => {\r\n      if (measurements.size === 0) return 1;\r\n\r\n      const ratios = Array.from(measurements.values()).map(\r\n        (m) => m.actual / m.estimated,\r\n      );\r\n      const avgRatio =\r\n        ratios.reduce((sum, ratio) => sum + ratio, 0) / ratios.length;\r\n\r\n      return avgRatio;\r\n    },\r\n  };\r\n};\r\n\r\n/**\r\n * Creates an enhanced smart size estimator with advanced caching and learning capabilities.\r\n *\r\n * This is the most sophisticated estimator that combines multiple optimization techniques:\r\n * TTL-based caching, adaptive learning, automatic cache cleanup, and statistical\r\n * adjustment factors. It's designed for production use in high-performance applications.\r\n *\r\n * Features:\r\n * - TTL-based caching (5 minute default)\r\n * - Adaptive learning from recent measurements\r\n * - Automatic cache cleanup and size management\r\n * - Statistical adjustment factor calculation\r\n * - Clamped adjustment factors to prevent extreme values\r\n *\r\n * @returns {Object} Smart size estimator object\r\n * @returns {Function} estimateSize - Estimates size with caching and learning\r\n * @returns {Function} recordActualSize - Records measurements for learning\r\n * @returns {Function} getAdjustmentFactor - Gets current adjustment factor\r\n * @returns {Function} clearCache - Clears all cached data\r\n *\r\n * @example\r\n * ```typescript\r\n * const smartEstimator = createSmartSizeEstimator();\r\n * const textMeasurer = createTextMeasurer();\r\n *\r\n * // Estimate with automatic caching and learning\r\n * const height = smartEstimator.estimateSize(\r\n *   'Long markdown content...',\r\n *   400,\r\n *   textMeasurer\r\n * );\r\n *\r\n * // Record actual measurement for learning\r\n * smartEstimator.recordActualSize('Long markdown content...', 400, 250);\r\n *\r\n * // Get current learning adjustment\r\n * const factor = smartEstimator.getAdjustmentFactor();\r\n * ```\r\n *\r\n * @performance\r\n * - O(1) cache lookups with Map data structure\r\n * - Automatic cache cleanup prevents memory leaks\r\n * - TTL-based expiration for fresh estimates\r\n * - Efficient statistical calculations\r\n *\r\n * @algorithm\r\n * 1. Generates cache key from content and dimensions\r\n * 2. Checks TTL-based cache for existing estimates\r\n * 3. Calculates height using markdown estimator\r\n * 4. Applies statistical adjustment factor from learning\r\n * 5. Caches result with timestamp\r\n * 6. Automatically cleans expired entries\r\n *\r\n * @constants\r\n * - CACHE_TTL: 5 minutes (300,000ms)\r\n * - MAX_CACHE_SIZE: 100 entries before cleanup\r\n * - ADJUSTMENT_CLAMP: 0.5 to 2.0 range\r\n * - LEARNING_WINDOW: Last 20 measurements\r\n */\r\n// Enhanced size estimation with caching and learning\r\nexport const createSmartSizeEstimator = () => {\r\n  const cache = new Map<string, { height: number; timestamp: number }>();\r\n  const measurements = new Map<string, { estimated: number; actual: number }>();\r\n  const CACHE_TTL = 5 * 60 * 1000; // 5 minutes\r\n\r\n  const generateCacheKey = (content: string, width: number) => {\r\n    return `${content.length}-${width}-${content.slice(0, 50)}`;\r\n  };\r\n\r\n  const cleanCache = () => {\r\n    const now = Date.now();\r\n    for (const [key, value] of cache.entries()) {\r\n      if (now - value.timestamp > CACHE_TTL) {\r\n        cache.delete(key);\r\n      }\r\n    }\r\n  };\r\n\r\n  const getAdjustmentFactor = () => {\r\n    if (measurements.size === 0) return 1;\r\n\r\n    const recentMeasurements = Array.from(measurements.values()).slice(-20); // Last 20 measurements\r\n    const ratios = recentMeasurements.map((m) => m.actual / m.estimated);\r\n    const avgRatio =\r\n      ratios.reduce((sum, ratio) => sum + ratio, 0) / ratios.length;\r\n\r\n    // Clamp the adjustment factor to prevent extreme values\r\n    return Math.max(0.5, Math.min(2.0, avgRatio));\r\n  };\r\n\r\n  return {\r\n    estimateSize: (\r\n      content: string,\r\n      width: number,\r\n      textMeasurer: ReturnType<typeof createTextMeasurer>,\r\n    ) => {\r\n      const cacheKey = generateCacheKey(content, width);\r\n\r\n      // Check cache first\r\n      const cached = cache.get(cacheKey);\r\n      if (cached && Date.now() - cached.timestamp < CACHE_TTL) {\r\n        return cached.height;\r\n      }\r\n\r\n      // Calculate height\r\n      const maxContentWidth = width * 0.7 - 32; // 70% minus padding\r\n      const estimatedHeight = estimateMarkdownHeight(\r\n        content,\r\n        maxContentWidth,\r\n        textMeasurer,\r\n      );\r\n\r\n      // Apply learning adjustment\r\n      const adjustmentFactor = getAdjustmentFactor();\r\n      const adjustedHeight = estimatedHeight * adjustmentFactor;\r\n\r\n      // Cache the result\r\n      cache.set(cacheKey, { height: adjustedHeight, timestamp: Date.now() });\r\n\r\n      // Clean old cache entries periodically\r\n      if (cache.size > 100) {\r\n        cleanCache();\r\n      }\r\n\r\n      return adjustedHeight;\r\n    },\r\n\r\n    recordActualSize: (\r\n      content: string,\r\n      width: number,\r\n      actualHeight: number,\r\n    ) => {\r\n      const cacheKey = generateCacheKey(content, width);\r\n      const cached = cache.get(cacheKey);\r\n\r\n      if (cached) {\r\n        measurements.set(cacheKey, {\r\n          estimated: cached.height,\r\n          actual: actualHeight,\r\n        });\r\n\r\n        // Update cache with actual measurement\r\n        cache.set(cacheKey, { height: actualHeight, timestamp: Date.now() });\r\n      }\r\n    },\r\n\r\n    getAdjustmentFactor,\r\n\r\n    clearCache: () => {\r\n      cache.clear();\r\n      measurements.clear();\r\n    },\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\ai\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\global-styles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\default-values.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\guards.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":91,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  GridFilterModel,\r\n  GridGetRowsResponse,\r\n  GridSortModel,\r\n} from '@mui/x-data-grid-pro';\r\nimport type { CancelledFetchGridRowsResponse } from './types';\r\n\r\n/**\r\n * Type guard to check if a given value is a valid `GridSortModel`.\r\n *\r\n * A `GridSortModel` is expected to be a non-empty array where every item is a non-null object\r\n * containing a `field` property.\r\n *\r\n * @param check - The value to check.\r\n * @returns `true` if the value is a non-empty array of objects each containing a `field` property, otherwise `false`.\r\n */\r\nexport const isGridSortModel = (check: unknown): check is GridSortModel => {\r\n  if (!Array.isArray(check)) return false;\r\n  if (check.length === 0) return false;\r\n  return check.every(\r\n    (item) => typeof item === 'object' && item !== null && 'field' in item,\r\n  );\r\n};\r\n\r\n/**\r\n * Type guard to determine if a given value is a `GridFilterModel`.\r\n *\r\n * Checks that the input is a non-null object (not an array) and contains an `items` property,\r\n * which must be an array of objects where each object has both `field` and `operator` properties.\r\n *\r\n * @param check - The value to check.\r\n * @returns `true` if the value is a `GridFilterModel`, otherwise `false`.\r\n */\r\nexport const isGridFilterModel = (check: unknown): check is GridFilterModel => {\r\n  if (\r\n    check == undefined ||\r\n    check == null ||\r\n    typeof check !== 'object' ||\r\n    Array.isArray(check)\r\n  )\r\n    return false;\r\n  if ('items' in check) {\r\n    return (\r\n      Array.isArray(check.items) &&\r\n      check.items.every(\r\n        (item) =>\r\n          typeof item === 'object' &&\r\n          item !== null &&\r\n          'field' in item &&\r\n          'operator' in item,\r\n      )\r\n    );\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Type guard to determine if a given response is a valid `GridGetRowsResponse`.\r\n *\r\n * Checks that the response is a non-null object containing a `rows` property,\r\n * where `rows` is an array and every element in the array is a non-null object.\r\n *\r\n * @param response - The value to check.\r\n * @returns `true` if the response matches the `GridGetRowsResponse` structure, otherwise `false`.\r\n */\r\nexport const isGetGridRowsResponse = (\r\n  response: unknown,\r\n): response is GridGetRowsResponse =>\r\n  typeof response === 'object' &&\r\n  response !== null &&\r\n  'rows' in response &&\r\n  Array.isArray(response.rows) &&\r\n  response.rows.every((row) => typeof row === 'object' && row !== null);\r\n\r\n/**\r\n * Type guard to determine if a given response is a `CancelledFetchGridRowsResponse`.\r\n *\r\n * Checks if the provided `response` is an object with a `cancelled` property set to `true`.\r\n *\r\n * @param response - The response object to check.\r\n * @returns `true` if the response is a `CancelledFetchGridRowsResponse`, otherwise `false`.\r\n */\r\nexport const isCancelledGridRowsResponse = (\r\n  response: unknown,\r\n): response is CancelledFetchGridRowsResponse => {\r\n  if (typeof response === 'object' && response !== null) {\r\n    return 'cancelled' in response && response.cancelled === true;\r\n  }\r\n  return false;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\query-client.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":50,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { QueryClient } from '@tanstack/react-query';\r\n\r\n/**\r\n * Create a QueryClient instance with default options for data grid queries.\r\n *\r\n * This configuration is optimized for data grid use cases with:\r\n * - Short stale times to ensure data freshness\r\n * - Longer cache times for better performance\r\n * - Retry policies suitable for grid data fetching\r\n */\r\nexport const createDataGridQueryClient = () => {\r\n  return new QueryClient({\r\n    defaultOptions: {\r\n      queries: {\r\n        staleTime: 30 * 1000, // 30 seconds - data is fresh for 30 seconds\r\n        gcTime: 5 * 60 * 1000, // 5 minutes - keep in cache for 5 minutes\r\n        retry: (failureCount, error) => {\r\n          // Don't retry on 4xx errors (client errors)\r\n          if (error instanceof Error && 'status' in error) {\r\n            const status = (error as Error & { status: number }).status;\r\n            if (status >= 400 && status < 500) {\r\n              return false;\r\n            }\r\n          }\r\n          // Retry up to 3 times for other errors\r\n          return failureCount < 3;\r\n        },\r\n        refetchOnWindowFocus: false, // Don't refetch when window gains focus\r\n        refetchOnReconnect: true, // Refetch when connection is restored\r\n      },\r\n      mutations: {\r\n        retry: (failureCount, error) => {\r\n          // Don't retry mutations on 4xx errors\r\n          if (error instanceof Error && 'status' in error) {\r\n            const status = (error as Error & { status: number }).status;\r\n            if (status >= 400 && status < 500) {\r\n              return false;\r\n            }\r\n          }\r\n          // Retry up to 2 times for other errors\r\n          return failureCount < 2;\r\n        },\r\n      },\r\n    },\r\n  });\r\n};\r\n\r\n// Global query client instance for data grid operations\r\nexport const dataGridQueryClient = createDataGridQueryClient();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\queryHelpers\\drizzle\\buildDrizzleFilter.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":12,"column":1,"nodeType":"Program","endLine":427,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":69,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2335,2338],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2335,2338],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Drizzle Filter Builder for Data Grid\r\n *\r\n * This module provides functionality to apply dynamic filtering logic to Drizzle PgSelectBuilder\r\n * queries, similar to the postgres.js buildQueryFilter function but adapted for Drizzle ORM.\r\n *\r\n * @module lib/components/mui/data-grid/buildDrizzleFilter\r\n * @version 1.0.0\r\n * @since 2025-07-27\r\n */\r\n\r\nimport { isLikeNextRequest } from '@/lib/nextjs-util/guards';\r\nimport type { GridFilterModel } from '@mui/x-data-grid-pro';\r\nimport {\r\n  and,\r\n  or,\r\n  eq,\r\n  ne,\r\n  ilike,\r\n  isNull,\r\n  isNotNull,\r\n  inArray,\r\n  notInArray,\r\n  gt,\r\n  lt,\r\n  gte,\r\n  lte,\r\n  between,\r\n  notBetween,\r\n  SQL,\r\n  sql,\r\n} from 'drizzle-orm';\r\nimport type { AnyPgSelect } from 'drizzle-orm/pg-core';\r\nimport { isGridFilterModel } from '../../guards';\r\nimport { columnMapFactory, parseFilterOptions } from '../utility';\r\nimport { isTruthy } from '@/lib/react-util/utility-methods';\r\nimport { schema } from '@/lib/drizzle-db';\r\nimport type {\r\n  BuildDrizzleAttachmentOrEmailFilterProps,\r\n  BuildDrizzleItemFilterProps,\r\n  BuildDrizzleQueryFilterProps,\r\n  DrizzleSelectQuery,\r\n} from './types';\r\n\r\n/**\r\n * Appends a filter condition to a DrizzleSelectQuery.\r\n *\r\n * If the `append` SQL filter is provided and contains query chunks, it is added to the query's `where` clause.\r\n * - If the query has no existing `where` clause, the filter is simply appended.\r\n * - If the query already has a `where` clause, the new filter is combined with the existing one using an `and` operation.\r\n * - If no filter is provided or there are no query chunks, the original query is returned unchanged.\r\n *\r\n * @param query - The original DrizzleSelectQuery to which the filter will be appended.\r\n * @param append - The SQL filter to append, or `undefined` if no filter should be added.\r\n * @returns The updated DrizzleSelectQuery with the appended filter, or the original query if no changes were made.\r\n */\r\nexport const appendFilter = ({\r\n  query,\r\n  append,\r\n}: {\r\n  query: DrizzleSelectQuery;\r\n  append: SQL | undefined;\r\n}): DrizzleSelectQuery => {\r\n  // If there is nothing to append then there is nothing to do\r\n  if (typeof append === 'undefined' || !append.queryChunks?.length) {\r\n    return query;\r\n  }\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  const anyQuery = query as any;\r\n  // If the query has no where clause then just pop it on\r\n  if (!anyQuery._?.config?.where?.queryChunks?.length) {\r\n    return anyQuery.where(append) as AnyPgSelect;\r\n  }\r\n  // Otherwise, and the two queries together and set that\r\n  const left: SQL = anyQuery._.config.where!;\r\n  const right: SQL = append!;\r\n  if (left && right) {\r\n    const combinedQuery = and(left, right);\r\n    if (combinedQuery) {\r\n      return anyQuery.where(combinedQuery) as AnyPgSelect;\r\n    }\r\n  }\r\n  // If we made it all the way to here then there was nothing for us to do\r\n  return query;\r\n};\r\n\r\n/**\r\n * Creates a Drizzle-compatible filter for attachment or email queries.\r\n *\r\n * This function builds a SQL condition that can filter documents to include either\r\n * attachments (when attachments = true) or only emails (when attachments = false).\r\n *\r\n * @param props - Configuration props for building the attachment/email filter\r\n * @returns A SQL condition that can be used with Drizzle's where() method\r\n *\r\n * @example\r\n * ```typescript\r\n * import { emails } from '@/drizzle/schema';\r\n *\r\n * const condition = buildDrizzleAttachmentOrEmailFilter({\r\n *   attachments: true,\r\n *   email_id: 'email-123',\r\n *   email_id_column: emails.emailId,\r\n *   document_id_column: emails.documentId,\r\n * });\r\n *\r\n * const result = await db.select().from(emails).where(condition);\r\n * ```\r\n */\r\nexport const buildDrizzleAttachmentOrEmailFilter = ({\r\n  attachments,\r\n  email_id,\r\n  email_id_column,\r\n  document_id_column,\r\n  emailToDocumentIdFn,\r\n}: BuildDrizzleAttachmentOrEmailFilterProps): SQL | undefined => {\r\n  if (!email_id) {\r\n    return undefined;\r\n  }\r\n\r\n  let includeAttachments = true;\r\n  if (typeof attachments === 'boolean') {\r\n    includeAttachments = attachments;\r\n  } else if (typeof attachments === 'object' && attachments !== null) {\r\n    let searchParams: URLSearchParams;\r\n    if (attachments instanceof URL) {\r\n      searchParams = attachments.searchParams;\r\n    } else if (attachments instanceof URLSearchParams) {\r\n      searchParams = attachments;\r\n    } else if (isLikeNextRequest(attachments)) {\r\n      searchParams = new URL(attachments.url!).searchParams;\r\n    } else {\r\n      // Handle generic objects with url property\r\n      const asObj = attachments as Record<string, unknown>;\r\n      if (asObj && asObj.url && typeof asObj.url === 'string') {\r\n        try {\r\n          searchParams = new URL(asObj.url).searchParams;\r\n        } catch {\r\n          throw new Error('Invalid attachments parameter', {\r\n            cause: attachments,\r\n          });\r\n        }\r\n      } else {\r\n        throw new Error('Invalid attachments parameter', {\r\n          cause: attachments,\r\n        });\r\n      }\r\n    }\r\n    // Default to include attachments if parameter is missing\r\n    if (!searchParams.has('attachments')) {\r\n      includeAttachments = true;\r\n    } else {\r\n      includeAttachments = isTruthy(searchParams.get('attachments'));\r\n    }\r\n  }\r\n\r\n  if (!email_id_column) {\r\n    email_id_column = schema.documentUnits.emailId;\r\n  }\r\n\r\n  if (includeAttachments) {\r\n    if ('table' in email_id_column) {\r\n      return eq(email_id_column, email_id);\r\n    } else {\r\n      return eq(email_id_column, sql`${email_id}`);\r\n    }\r\n  }\r\n  if (emailToDocumentIdFn) {\r\n    // If emailToDocumentIdFn is provided, use it to filter by document ID\r\n    if ('table' in document_id_column) {\r\n      return eq(document_id_column, emailToDocumentIdFn(email_id));\r\n    } else {\r\n      return eq(document_id_column, emailToDocumentIdFn(email_id));\r\n    }\r\n  } else {\r\n    // Fallback: use a custom SQL function call\r\n    if ('table' in document_id_column) {\r\n      return eq(document_id_column, sql`email_to_document_id(${email_id})`);\r\n    } else {\r\n      return eq(document_id_column, sql`email_to_document_id(${email_id})`);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Creates a Drizzle-compatible filter condition for a single filter item.\r\n *\r\n * This function converts MUI Data Grid filter operators into corresponding Drizzle ORM\r\n * filter conditions.\r\n *\r\n * @param props - Configuration props for building the item filter\r\n * @returns A SQL condition that can be used with Drizzle's where() method\r\n *\r\n * @example\r\n * ```typescript\r\n * import { users } from '@/drizzle/schema';\r\n *\r\n * const getColumn = (name: string) => {\r\n *   switch (name) {\r\n *     case 'name': return users.name;\r\n *     case 'email': return users.email;\r\n *     default: return undefined;\r\n *   }\r\n * };\r\n *\r\n * const condition = buildDrizzleItemFilter({\r\n *   item: { field: 'name', operator: 'contains', value: 'John' },\r\n *   getColumn,\r\n * });\r\n *\r\n * const result = await db.select().from(users).where(condition);\r\n * ```\r\n */\r\nexport const buildDrizzleItemFilter = ({\r\n  item,\r\n  getColumn,\r\n  columnMap = {},\r\n}: BuildDrizzleItemFilterProps): SQL | undefined => {\r\n  const columnMapper = columnMapFactory(columnMap);\r\n  const mappedField = columnMapper(item.field);\r\n  const column = getColumn(mappedField);\r\n\r\n  if (!column) {\r\n    console.warn(\r\n      `buildDrizzleItemFilter: Unknown column '${mappedField}' (mapped from '${item.field}')`,\r\n    );\r\n    return undefined;\r\n  }\r\n\r\n  switch (item.operator) {\r\n    case 'equals':\r\n      return 'table' in column\r\n        ? eq(column, item.value)\r\n        : eq(sql`${column}`, item.value);\r\n    case 'notEquals':\r\n      return 'table' in column\r\n        ? ne(column, item.value)\r\n        : ne(sql`${column}`, item.value);\r\n    case 'contains':\r\n      return ilike(column, `%${item.value}%`);\r\n    case 'notContains':\r\n      return sql`${column} NOT ILIKE ${`%${item.value}%`}`;\r\n    case 'startsWith':\r\n      return ilike(column, `${item.value}%`);\r\n    case 'endsWith':\r\n      return ilike(column, `%${item.value}`);\r\n    case 'isEmpty':\r\n      return or(\r\n        isNull(column),\r\n        'table' in column ? eq(column, '') : eq(sql`${column}`, ''),\r\n      );\r\n    case 'isNotEmpty':\r\n      return and(\r\n        isNotNull(column),\r\n        'table' in column ? ne(column, '') : ne(sql`${column}`, ''),\r\n      );\r\n    case 'isAnyOf':\r\n      return 'table' in column\r\n        ? inArray(column, item.value)\r\n        : inArray(sql`${column}`, item.value);\r\n    case 'isNoneOf':\r\n      return 'table' in column\r\n        ? notInArray(column, item.value)\r\n        : notInArray(sql`${column}`, item.value);\r\n    case 'isGreaterThan':\r\n      return 'table' in column\r\n        ? gt(column, item.value)\r\n        : gt(sql`${column}`, item.value);\r\n    case 'isLessThan':\r\n      return 'table' in column\r\n        ? lt(column, item.value)\r\n        : lt(sql`${column}`, item.value);\r\n    case 'isGreaterThanOrEqual':\r\n      return 'table' in column\r\n        ? gte(column, item.value)\r\n        : gte(sql`${column}`, item.value);\r\n    case 'isLessThanOrEqual':\r\n      return 'table' in column\r\n        ? lte(column, item.value)\r\n        : lte(sql`${column}`, item.value);\r\n    case 'isBetween':\r\n      return 'table' in column\r\n        ? between(column, item.value[0], item.value[1])\r\n        : between(sql`${column}`, item.value[0], item.value[1]);\r\n    case 'isNotBetween':\r\n      return 'table' in column\r\n        ? notBetween(column, item.value[0], item.value[1])\r\n        : notBetween(sql`${column}`, item.value[0], item.value[1]);\r\n    case 'isNull':\r\n      return isNull(column);\r\n    case 'isNotNull':\r\n      return isNotNull(column);\r\n    case 'in':\r\n      // Handle array containment - this is PostgreSQL specific\r\n      return sql`${item.value} = ANY(${column})`;\r\n    default:\r\n      throw new Error(`Unsupported operator: ${item.operator}`, {\r\n        cause: item,\r\n      });\r\n  }\r\n};\r\n\r\n/**\r\n * Applies dynamic filter logic to a Drizzle select query.\r\n *\r\n * This function parses filter options from various sources (URL parameters, GridFilterModel, etc.)\r\n * and applies the appropriate where clauses to a Drizzle query builder.\r\n *\r\n * @param props - Configuration props for building the query filter\r\n * @returns The query builder with where clauses applied\r\n *\r\n * @example\r\n * ```typescript\r\n * // Basic usage with a simple column map\r\n * const query = db.select().from(users);\r\n * const filteredQuery = buildDrizzleQueryFilter({\r\n *   query,\r\n *   source: searchParams, // or URL, GridFilterModel, etc.\r\n *   getColumn: (name) => {\r\n *     switch (name) {\r\n *       case 'name': return users.name;\r\n *       case 'email': return users.email;\r\n *       case 'created_at': return users.createdAt;\r\n *       default: return undefined;\r\n *     }\r\n *   },\r\n *   columnMap: { displayName: 'name', userEmail: 'email' },\r\n * });\r\n *\r\n * // Usage with table schema object\r\n * const tableColumns = {\r\n *   name: users.name,\r\n *   email: users.email,\r\n *   created_at: users.createdAt,\r\n * };\r\n *\r\n * const filteredQuery = buildDrizzleQueryFilter({\r\n *   query: db.select().from(users),\r\n *   source: req.url,\r\n *   getColumn: (name) => tableColumns[name as keyof typeof tableColumns],\r\n *   defaultFilter: [{ field: 'name', operator: 'isNotEmpty', value: '' }],\r\n * });\r\n * ```\r\n */\r\nexport const buildDrizzleQueryFilter = ({\r\n  query,\r\n  source,\r\n  getColumn,\r\n  defaultFilter,\r\n  columnMap = {},\r\n  additional,\r\n}: BuildDrizzleQueryFilterProps): DrizzleSelectQuery => {\r\n  /**\r\n   * Parses the filter model from the source.\r\n   */\r\n  const parseFilterFromSource = (\r\n    src: typeof source,\r\n  ): GridFilterModel | undefined => {\r\n    if (isGridFilterModel(src)) {\r\n      return src;\r\n    }\r\n\r\n    if (typeof src === 'string') {\r\n      try {\r\n        const url = new URL(src);\r\n        return parseFilterOptions(url.searchParams, additional);\r\n      } catch {\r\n        // If string is not a valid URL, return undefined\r\n        return undefined;\r\n      }\r\n    }\r\n\r\n    if (src instanceof URL) {\r\n      return parseFilterOptions(src.searchParams, additional);\r\n    }\r\n\r\n    if (isLikeNextRequest(src)) {\r\n      try {\r\n        const url = new URL(src.url!);\r\n        return parseFilterOptions(url.searchParams, additional);\r\n      } catch {\r\n        return undefined;\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  };\r\n\r\n  // Parse the filter model from the source\r\n  let filterModel = parseFilterFromSource(source);\r\n\r\n  // If no filter from source, try default filter\r\n  if (!filterModel && defaultFilter) {\r\n    filterModel = parseFilterFromSource(defaultFilter);\r\n  }\r\n\r\n  // If still no filter model or no items, return original query\r\n  if (!filterModel || !filterModel.items || filterModel.items.length === 0) {\r\n    return query;\r\n  }\r\n\r\n  // Build filter conditions\r\n  const conditions: SQL[] = [];\r\n\r\n  for (const item of filterModel.items) {\r\n    const condition = buildDrizzleItemFilter({ item, getColumn, columnMap });\r\n    if (condition) {\r\n      conditions.push(condition);\r\n    }\r\n  }\r\n\r\n  // If no valid conditions, return original query\r\n  if (conditions.length === 0) {\r\n    return query;\r\n  }\r\n\r\n  // Combine conditions based on logic operator\r\n  const logicOperator = filterModel.logicOperator || 'and';\r\n  const combinedCondition =\r\n    logicOperator === 'or' ? or(...conditions) : and(...conditions);\r\n\r\n  return appendFilter({\r\n    query,\r\n    append: combinedCondition,\r\n  });\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\queryHelpers\\drizzle\\buildDrizzleOrderBy.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":12,"column":1,"nodeType":"Program","endLine":291,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Drizzle OrderBy Builder for Data Grid\r\n *\r\n * This module provides functionality to apply dynamic ordering logic to Drizzle PgSelectBuilder\r\n * queries, similar to the postgres.js buildOrderBy function but adapted for Drizzle ORM.\r\n *\r\n * @module lib/components/mui/data-grid/buildDrizzleOrderBy\r\n * @version 1.0.0\r\n * @since 2025-07-26\r\n */\r\n\r\nimport { isLikeNextRequest } from '@/lib/nextjs-util/guards';\r\nimport type { GridSortModel } from '@mui/x-data-grid-pro';\r\nimport { asc, desc, SQL } from 'drizzle-orm';\r\nimport type { PgColumn } from 'drizzle-orm/pg-core';\r\nimport { isGridSortModel } from '../../guards';\r\nimport type { BuildDrizzleOrderByProps, DrizzleSortedQuery } from './types';\r\nimport { columnMapFactory, parseSortOptions } from '../utility';\r\n\r\n/**\r\n * Applies dynamic order by logic to a Drizzle select query.\r\n *\r\n * This function parses sort options from various sources (URL parameters, GridSortModel, etc.)\r\n * and applies the appropriate orderBy clauses to a Drizzle query builder.\r\n *\r\n * @param props - Configuration props for building the order by clause\r\n * @returns The query builder with orderBy applied\r\n *\r\n * @example\r\n * ```typescript\r\n * // Basic usage with a simple column map\r\n * const query = db.select().from(users);\r\n * const orderedQuery = buildDrizzleOrderBy({\r\n *   query,\r\n *   source: searchParams, // or URL, GridSortModel, etc.\r\n *   defaultSort: 'name',\r\n *   columnMap: { displayName: 'name', userEmail: 'email' },\r\n *   getColumn: (name) => {\r\n *     switch (name) {\r\n *       case 'name': return users.name;\r\n *       case 'email': return users.email;\r\n *       case 'created_at': return users.createdAt;\r\n *       default: return undefined;\r\n *     }\r\n *   }\r\n * });\r\n *\r\n * // Usage with table schema object\r\n * const tableColumns = {\r\n *   name: users.name,\r\n *   email: users.email,\r\n *   created_at: users.createdAt,\r\n * };\r\n *\r\n * const orderedQuery = buildDrizzleOrderBy({\r\n *   query: db.select().from(users),\r\n *   source: req.url,\r\n *   defaultSort: [{ field: 'name', sort: 'asc' }],\r\n *   getColumn: (name) => tableColumns[name as keyof typeof tableColumns]\r\n * });\r\n *\r\n * // Advanced usage with custom SQL expressions\r\n * const orderedQuery = buildDrizzleOrderBy({\r\n *   query: db.select().from(users),\r\n *   source: sortModel,\r\n *   getColumn: (name) => {\r\n *     switch (name) {\r\n *       case 'full_name':\r\n *         return sql`${users.firstName} || ' ' || ${users.lastName}`;\r\n *       case 'name':\r\n *         return users.name;\r\n *       default:\r\n *         return undefined;\r\n *     }\r\n *   }\r\n * });\r\n * ```\r\n */\r\nexport const buildDrizzleOrderBy = ({\r\n  query,\r\n  source,\r\n  defaultSort,\r\n  columnMap = {},\r\n  getColumn,\r\n}: BuildDrizzleOrderByProps): DrizzleSortedQuery => {\r\n  // Create column mapping function\r\n  const columnMapper = columnMapFactory(columnMap);\r\n\r\n  /**\r\n   * Applies a GridSortModel to the query builder.\r\n   *\r\n   * @param sortModel - The sort model to apply\r\n   * @returns The query builder with orderBy applied\r\n   */\r\n  const applySortModel = (sortModel: GridSortModel): DrizzleSortedQuery => {\r\n    if (sortModel.length === 0) {\r\n      return query;\r\n    }\r\n\r\n    // Build array of order by expressions\r\n    const orderByExpressions: (SQL | PgColumn)[] = [];\r\n\r\n    for (const sortItem of sortModel) {\r\n      const mappedColumnName = columnMapper(sortItem.field);\r\n      const column = getColumn(mappedColumnName);\r\n\r\n      if (column) {\r\n        const orderExpression =\r\n          sortItem.sort === 'desc' ? desc(column) : asc(column);\r\n        orderByExpressions.push(orderExpression);\r\n      } else {\r\n        // Log warning about unknown column\r\n        console.warn(\r\n          `buildDrizzleOrderBy: Unknown column '${mappedColumnName}' (mapped from '${sortItem.field}')`,\r\n        );\r\n      }\r\n    }\r\n\r\n    if (orderByExpressions.length === 0) {\r\n      return query;\r\n    }\r\n\r\n    // Apply all order by expressions\r\n    return Array.isArray(query)\r\n      ? query\r\n      : (query.orderBy(...orderByExpressions) as DrizzleSortedQuery);\r\n  };\r\n\r\n  /**\r\n   * Applies a default sort to the query builder.\r\n   *\r\n   * @param sort - The default sort specification\r\n   * @returns The query builder with orderBy applied\r\n   */\r\n  const applyDefaultSort = (\r\n    sort: GridSortModel | string | SQL | SQL.Aliased | PgColumn,\r\n  ): DrizzleSortedQuery => {\r\n    if (typeof sort === 'string') {\r\n      // String column name - map it and get the column\r\n      const mappedColumnName = columnMapper(sort);\r\n      const column = getColumn(mappedColumnName);\r\n\r\n      if (column) {\r\n        return Array.isArray(query)\r\n          ? query\r\n          : (query.orderBy(asc(column)) as DrizzleSortedQuery);\r\n      } else {\r\n        console.warn(\r\n          `buildDrizzleOrderBy: Unknown default sort column '${mappedColumnName}' (mapped from '${sort}')`,\r\n        );\r\n        return query;\r\n      }\r\n    } else if (Array.isArray(sort)) {\r\n      // GridSortModel\r\n      return applySortModel(sort);\r\n    } else {\r\n      // SQL expression or PgColumn - use directly\r\n      // We know sort is either SQL or PgColumn here due to type narrowing\r\n      return Array.isArray(query)\r\n        ? query\r\n        : (query.orderBy(asc(sort as SQL | PgColumn)) as DrizzleSortedQuery);\r\n    }\r\n  };\r\n\r\n  // Parse the sort model from the source\r\n  const sortBy = isGridSortModel(source)\r\n    ? source\r\n    : parseSortOptions(\r\n        typeof source === 'string'\r\n          ? (() => {\r\n              try {\r\n                return new URL(source);\r\n              } catch {\r\n                // If string is not a valid URL, return undefined to use default sort\r\n                return undefined;\r\n              }\r\n            })()\r\n          : isLikeNextRequest(source)\r\n            ? new URL(source.url!)\r\n            : source,\r\n      );\r\n\r\n  // Apply sorting logic\r\n  if (!sortBy) {\r\n    // No sort specified, use default if provided\r\n    return defaultSort ? applyDefaultSort(defaultSort) : query;\r\n  }\r\n\r\n  // Apply the parsed sort model\r\n  return applySortModel(sortBy);\r\n};\r\n\r\n/**\r\n * Helper function to create a column getter from a schema object.\r\n *\r\n * This utility simplifies the creation of the getColumn function when you have\r\n * a schema object or table reference.\r\n *\r\n * @param columns - Object mapping column names to Drizzle column objects\r\n * @returns A getColumn function for use with buildDrizzleOrderBy\r\n *\r\n * @example\r\n * ```typescript\r\n * import { users } from '@/drizzle/schema';\r\n *\r\n * const getColumn = createColumnGetter({\r\n *   name: users.name,\r\n *   email: users.email,\r\n *   created_at: users.createdAt,\r\n *   // Custom SQL expression\r\n *   full_name: sql`${users.firstName} || ' ' || ${users.lastName}`,\r\n * });\r\n *\r\n * const orderedQuery = buildDrizzleOrderBy({\r\n *   query: db.select().from(users),\r\n *   source: req.url,\r\n *   getColumn,\r\n * });\r\n * ```\r\n */\r\nexport const createColumnGetter = (\r\n  columns: Record<string, PgColumn | SQL>,\r\n): ((columnName: string) => PgColumn | SQL | undefined) => {\r\n  return (columnName: string) => columns[columnName];\r\n};\r\n\r\n/**\r\n * Helper function to create a simple column getter for a single table.\r\n *\r\n * This utility uses reflection to automatically map common column naming patterns.\r\n * It's useful when you want basic column mapping without defining every column manually.\r\n *\r\n * @param table - The Drizzle table object\r\n * @param customMappings - Optional custom column mappings\r\n * @returns A getColumn function for use with buildDrizzleOrderBy\r\n *\r\n * @example\r\n * ```typescript\r\n * import { users } from '@/drizzle/schema';\r\n *\r\n * const getColumn = createTableColumnGetter(users, {\r\n *   // Map custom field names to table columns\r\n *   display_name: users.name,\r\n *   user_email: users.email,\r\n * });\r\n *\r\n * const orderedQuery = buildDrizzleOrderBy({\r\n *   query: db.select().from(users),\r\n *   source: gridSortModel,\r\n *   getColumn,\r\n * });\r\n * ```\r\n */\r\nexport const createTableColumnGetter = (\r\n  table: Record<string, unknown>,\r\n  customMappings: Record<string, PgColumn | SQL> = {},\r\n): ((columnName: string) => PgColumn | SQL | undefined) => {\r\n  return (columnName: string) => {\r\n    // Check custom mappings first\r\n    if (customMappings[columnName]) {\r\n      return customMappings[columnName];\r\n    }\r\n\r\n    // Try direct table property access (only for valid identifier names)\r\n    if (\r\n      !columnName.includes('-') &&\r\n      table[columnName] &&\r\n      typeof table[columnName] === 'object'\r\n    ) {\r\n      return table[columnName] as PgColumn;\r\n    }\r\n\r\n    // Try common naming pattern conversions (only for valid identifier names)\r\n    if (!columnName.includes('-')) {\r\n      const camelCase = columnName.replace(/_([a-z])/g, (_, letter) =>\r\n        letter.toUpperCase(),\r\n      );\r\n      if (table[camelCase] && typeof table[camelCase] === 'object') {\r\n        return table[camelCase] as PgColumn;\r\n      }\r\n\r\n      const snakeCase = columnName.replace(/([A-Z])/g, '_$1').toLowerCase();\r\n      if (table[snakeCase] && typeof table[snakeCase] === 'object') {\r\n        return table[snakeCase] as PgColumn;\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\queryHelpers\\drizzle\\buildDrizzlePagination.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":11,"column":1,"nodeType":"Program","endLine":101,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Drizzle Pagination Builder for Data Grid\r\n *\r\n * This module provides functionality to apply dynamic pagination logic to Drizzle PgSelectBuilder\r\n * queries, similar to the postgres.js buildPagination function but adapted for Drizzle ORM.\r\n *\r\n * @module lib/components/mui/data-grid/buildDrizzlePagination\r\n * @version 1.0.0\r\n * @since 2025-07-27\r\n */\r\nimport type { LikeNextRequest } from '@/lib/nextjs-util/types';\r\nimport type { PaginatedGridListRequest } from '../../types';\r\nimport type { DrizzleSelectQuery } from './types';\r\nimport type { AnyPgSelect } from 'drizzle-orm/pg-core';\r\nimport { parsePaginationStats as parsePaginationStatsImpl } from '../utility';\r\nimport { deprecate } from '@/lib/nextjs-util/utils';\r\n/**\r\n * Props for configuring Drizzle pagination functionality.\r\n */\r\nexport type BuildDrizzlePaginationProps = {\r\n  /**\r\n   * The Drizzle select query to apply pagination to.\r\n   */\r\n  query: Pick<\r\n    Exclude<DrizzleSelectQuery, Array<Record<string, unknown>>>,\r\n    'limit' | 'offset'\r\n  >;\r\n\r\n  /**\r\n   * The request object containing pagination parameters.\r\n   */\r\n  req:\r\n    | URL\r\n    | URLSearchParams\r\n    | (PaginatedGridListRequest | undefined)\r\n    | LikeNextRequest;\r\n};\r\n\r\n/**\r\n * Parses pagination statistics from a given request object.\r\n *\r\n * @param req - The request object which can be of type URL, URLSearchParams, or PaginationStats.\r\n * @returns An object containing pagination statistics including page, num, total, and offset.\r\n *\r\n * The function extracts the `page` and `num` parameters from the request object.\r\n * If the request object is of type URL or URLSearchParams, it retrieves these parameters from the search parameters.\r\n * If the request object is of type PaginationStats, it directly uses the `page` and `num` properties.\r\n * If the request object is undefined or null, it defaults to page 1 and num 10.\r\n *\r\n * The `page` and `num` values are normalized to ensure they are numeric and fall back to default values if necessary.\r\n * The `offset` is calculated based on the `page` and `num` values.\r\n *\r\n * @example\r\n * ```typescript\r\n * const url = new URL('https://example.com?page=2&num=20');\r\n * const stats = parsePaginationStats(url);\r\n * console.log(stats); // { page: 2, num: 20, total: 0, offset: 20 }\r\n * ```\r\n */\r\nexport const parsePaginationStats = deprecate(\r\n  (\r\n    req:\r\n      | URL\r\n      | URLSearchParams\r\n      | (PaginatedGridListRequest | undefined)\r\n      | LikeNextRequest,\r\n  ): PaginatedGridListRequest & { offset: number } =>\r\n    parsePaginationStatsImpl(req),\r\n  \"DP0010 - parsePaginationStats.  Import from '@/lib/components/mui/data-grid/queryHelpers/utility instead.\",\r\n);\r\n\r\n/**\r\n * Applies dynamic pagination logic to a Drizzle select query.\r\n *\r\n * This function parses pagination parameters from various sources and applies\r\n * the appropriate LIMIT and OFFSET clauses to a Drizzle query builder.\r\n *\r\n * @param props - Configuration props for building the pagination\r\n * @returns The query builder with pagination applied\r\n *\r\n * @example\r\n * ```typescript\r\n * import { db, users } from '@/drizzle/schema';\r\n *\r\n * const query = db.select().from(users);\r\n * const paginatedQuery = buildDrizzlePagination({\r\n *   query,\r\n *   req: searchParams, // or URL, URLSearchParams, etc.\r\n * });\r\n *\r\n * const results = await paginatedQuery;\r\n * ```\r\n */\r\nexport const buildDrizzlePagination = ({\r\n  query,\r\n  req,\r\n}: BuildDrizzlePaginationProps): DrizzleSelectQuery => {\r\n  const { num, offset } = parsePaginationStatsImpl(req);\r\n  return (query.offset(offset) as AnyPgSelect).limit(num) as DrizzleSelectQuery;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\queryHelpers\\drizzle\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\queryHelpers\\drizzle\\selectForGrid.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":52,"column":1,"nodeType":"Program","endLine":330,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":126,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5579,5582],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5579,5582],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":126,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5584,5587],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5584,5587],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":126,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5589,5592],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5589,5592],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Select For Grid Utility - Advanced Data Grid Query Builder\r\n *\r\n * This module provides a comprehensive solution for server-side data grid operations using Drizzle ORM.\r\n * It integrates filtering, sorting, pagination, and counting functionality into a unified API that\r\n * maintains 100% wire compatibility with existing Material UI DataGrid endpoints while providing\r\n * type-safe query building and execution.\r\n *\r\n * **Key Features:**\r\n * - **Unified Query Processing**: Single function handles filtering, sorting, and pagination\r\n * - **Type-Safe Operations**: Full TypeScript support with Drizzle ORM schema integration\r\n * - **Performance Optimized**: Concurrent execution of data and count queries\r\n * - **Flexible Column Mapping**: Support for frontend-to-database field name translation\r\n * - **Record Transformation**: Optional post-query data transformation pipeline\r\n * - **Wire Compatible**: Drop-in replacement for existing pagination API endpoints\r\n * - **Automatic Count Generation**: Eliminates duplicate query crafting for totals\r\n *\r\n * **Architecture:**\r\n * ```\r\n * Request → Parse Params → Filter → Sort → Paginate → Execute → Transform → Response\r\n *    ↓         ↓           ↓       ↓        ↓         ↓         ↓         ↓\r\n * URL Params  Pagination  Query   Query   Query    Parallel  Mapper   Paginated\r\n * Extraction  Statistics  Filter  Order   Limit    Execution Function  Results\r\n * ```\r\n *\r\n * **Database Integration:**\r\n * - **Query Builder**: Uses Drizzle's type-safe query construction\r\n * - **Subquery Pattern**: Automatic count query generation via subquery wrapping\r\n * - **Transaction Safe**: All operations use consistent database connections\r\n * - **Index Optimized**: Supports database index utilization for performance\r\n *\r\n * **Performance Characteristics:**\r\n * - Concurrent data and count query execution for reduced latency\r\n * - Minimal memory footprint through streaming-friendly pagination\r\n * - Database-level filtering and sorting to reduce data transfer\r\n * - Type-safe operations preventing runtime query errors\r\n * - Optimized count queries using subquery patterns\r\n *\r\n * **Use Cases:**\r\n * - Material UI DataGrid server-side data loading\r\n * - Large dataset pagination with filtering and sorting\r\n * - API endpoint data grid integration\r\n * - Administrative dashboards and data management interfaces\r\n * - Report generation with dynamic filtering capabilities\r\n *\r\n * @module lib/components/mui/data-grid/selectForGrid\r\n * @version 2.0.0\r\n * @author Data Grid Team\r\n * @since 1.0.0\r\n */\r\n\r\nimport type { PaginatedResultset } from '@/data-models/_types';\r\nimport { parsePaginationStats } from '@/lib/components/mui/data-grid/queryHelpers/utility';\r\nimport { buildDrizzleQueryFilter } from './buildDrizzleFilter';\r\nimport { buildDrizzleOrderBy } from './buildDrizzleOrderBy';\r\nimport { buildDrizzlePagination } from './buildDrizzlePagination';\r\nimport type {\r\n  DrizzleSelectQuery,\r\n  DrizzleSelectQueryBase,\r\n  SelectForGridProps,\r\n} from './types';\r\nimport type { AnyPgSelect, PgSession } from 'drizzle-orm/pg-core';\r\nimport type { PgCountBuilder } from 'drizzle-orm/pg-core/query-builders/count';\r\nimport { drizDb } from '@/lib/drizzle-db';\r\n\r\n/**\r\n * Creates both data and count query factories from a base Drizzle select query.\r\n *\r\n * This factory function implements the subquery pattern to generate consistent count queries\r\n * that maintain the same filtering and joining logic as the main data query. This eliminates\r\n * the need to manually craft separate count queries and ensures data consistency.\r\n *\r\n * **Subquery Pattern:**\r\n * ```sql\r\n * -- Main Query: SELECT * FROM (base_query) AS app_subq_count LIMIT 20 OFFSET 0\r\n * -- Count Query: SELECT COUNT(*) FROM (base_query) AS app_subq_count\r\n * ```\r\n *\r\n * **Key Benefits:**\r\n * - **Single Source of Truth**: Count query automatically inherits all filtering logic\r\n * - **Performance Optimized**: Database engine can optimize the subquery execution\r\n * - **Type Safety**: Maintains Drizzle's type checking throughout the operation\r\n * - **Consistency Guaranteed**: Count always reflects the actual filtered dataset\r\n *\r\n * **Database Optimization:**\r\n * - Leverages PostgreSQL's query planner for subquery optimization\r\n * - Enables index usage on the underlying tables\r\n * - Minimizes query planning overhead through consistent structure\r\n * - Supports complex joins and where clauses transparently\r\n *\r\n * @param select - The base Drizzle select query to wrap for counting\r\n * @returns Object containing both select and count query builders\r\n *\r\n * @example\r\n * ```typescript\r\n * // Base query with complex filtering and joins\r\n * const baseQuery = db\r\n *   .select({ id: emails.id, subject: emails.subject })\r\n *   .from(emails)\r\n *   .leftJoin(attachments, eq(attachments.emailId, emails.id))\r\n *   .where(and(\r\n *     eq(emails.isActive, true),\r\n *     gte(emails.receivedAt, new Date('2024-01-01'))\r\n *   ));\r\n *\r\n * // Generate count-compatible queries\r\n * const { select, count } = countQueryFactory(baseQuery);\r\n *\r\n * // Execute concurrently\r\n * const [data, total] = await Promise.all([\r\n *   select.limit(20).offset(40),\r\n *   count\r\n * ]);\r\n *\r\n * console.log(`Found ${total} total records, showing 20`);\r\n * ```\r\n *\r\n * @throws {Error} When the input query cannot be converted to a subquery\r\n * @since 2.0.0\r\n */\r\nexport const countQueryFactory = (\r\n  select: DrizzleSelectQuery,\r\n): {\r\n  select: DrizzleSelectQueryBase;\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  count: PgCountBuilder<PgSession<any, any, any>>;\r\n} => {\r\n  const db = drizDb();\r\n  const subQ = (select as AnyPgSelect).as('app_subq_count');\r\n  return {\r\n    select: db.select().from(subQ),\r\n    count: db.$count(subQ),\r\n  };\r\n};\r\n\r\n/**\r\n * Applies dynamic filtering, sorting, and pagination to a Drizzle query for data grid operations.\r\n *\r\n * This function integrates the buildDrizzleFilter, buildDrizzleOrderBy, and buildDrizzlePagination\r\n * utilities to create a complete data grid query solution that returns paginated results with\r\n * 100% wire compatibility with existing API endpoints.\r\n *\r\n * **Processing Pipeline:**\r\n * 1. **Parameter Extraction**: Parses pagination, filtering, and sorting from request URL\r\n * 2. **Query Filtering**: Applies dynamic WHERE clauses based on filter model\r\n * 3. **Query Sorting**: Adds ORDER BY clauses with column mapping support\r\n * 4. **Count Generation**: Creates optimized count query using subquery pattern\r\n * 5. **Pagination**: Applies LIMIT/OFFSET for page-based results\r\n * 6. **Concurrent Execution**: Runs data and count queries in parallel\r\n * 7. **Result Transformation**: Optional record mapping for response formatting\r\n *\r\n * **Performance Features:**\r\n * - **Parallel Execution**: Data and count queries execute concurrently\r\n * - **Index Optimization**: Leverages database indexes through proper query structure\r\n * - **Memory Efficiency**: Streams results without loading entire dataset\r\n * - **Type Safety**: Full TypeScript support prevents runtime query errors\r\n * - **Query Reuse**: Single base query generates both data and count operations\r\n *\r\n * **Error Handling:**\r\n * - **Graceful Degradation**: Continues operation if optional features fail\r\n * - **Type Validation**: Ensures column mappings are valid at compile time\r\n * - **Query Validation**: Drizzle ORM prevents malformed SQL generation\r\n * - **Connection Management**: Automatic database connection handling\r\n *\r\n * @template T - The expected result record type\r\n * @param props - Configuration props for the grid query\r\n * @param props.req - Next.js request object containing URL parameters\r\n * @param props.emailId - Email context ID (maintained for API compatibility)\r\n * @param props.query - Base Drizzle select query to enhance\r\n * @param props.getColumn - Function to map field names to Drizzle column objects\r\n * @param props.columnMap - Optional mapping of frontend field names to database columns\r\n * @param props.recordMapper - Optional function to transform query results\r\n *\r\n * @returns Promise resolving to paginated result set with metadata\r\n *\r\n * @example\r\n * ```typescript\r\n * // Basic usage with email documents\r\n * import { selectForGrid } from '@/lib/components/mui/data-grid/selectForGrid';\r\n * import { createColumnGetter } from '@/lib/components/mui/data-grid/buildDrizzleOrderBy';\r\n *\r\n * export async function GET(request: NextRequest) {\r\n *   const baseQuery = db\r\n *     .select({\r\n *       id: emails.id,\r\n *       subject: emails.subject,\r\n *       sender: emails.fromAddress,\r\n *       receivedAt: emails.receivedAt,\r\n *     })\r\n *     .from(emails)\r\n *     .where(eq(emails.isActive, true));\r\n *\r\n *   const getColumn = createColumnGetter({\r\n *     id: emails.id,\r\n *     subject: emails.subject,\r\n *     sender: emails.fromAddress,\r\n *     receivedAt: emails.receivedAt,\r\n *   });\r\n *\r\n *   const result = await selectForGrid({\r\n *     req: request,\r\n *     emailId: 'context-id',\r\n *     query: baseQuery,\r\n *     getColumn,\r\n *     columnMap: {\r\n *       'sender_name': 'fromAddress', // Frontend field -> DB column\r\n *     },\r\n *   });\r\n *\r\n *   return NextResponse.json(result);\r\n * }\r\n * ```\r\n *\r\n * @example\r\n * ```typescript\r\n * // Advanced usage with joins and transformations\r\n * const complexQuery = db\r\n *   .select({\r\n *     propertyId: schema.documentProperty.propertyId,\r\n *     value: schema.documentProperty.propertyValue,\r\n *     actionType: schema.callToActionDetails.actionType,\r\n *     documentId: schema.documentProperty.documentId,\r\n *   })\r\n *   .from(schema.documentProperty)\r\n *   .leftJoin(schema.callToActionDetails,\r\n *     eq(schema.callToActionDetails.propertyId, schema.documentProperty.propertyId))\r\n *   .where(eq(schema.documentProperty.documentPropertyTypeId, 4));\r\n *\r\n * const result = await selectForGrid({\r\n *   req,\r\n *   emailId,\r\n *   query: complexQuery,\r\n *   getColumn: createTableColumnGetter(schema.documentProperty),\r\n *   columnMap: {\r\n *     displayName: 'propertyValue',\r\n *     type: 'actionType',\r\n *   },\r\n *   recordMapper: (record) => ({\r\n *     ...record,\r\n *     displayValue: `${record.value} (${record.actionType})`,\r\n *     formattedId: `DOC-${record.documentId}`,\r\n *   }),\r\n * });\r\n * ```\r\n *\r\n * @example\r\n * ```typescript\r\n * // Response format (wire compatible with existing APIs)\r\n * {\r\n *   results: [\r\n *     { id: 1, subject: \"Email 1\", sender: \"user@example.com\" },\r\n *     { id: 2, subject: \"Email 2\", sender: \"admin@example.com\" }\r\n *   ],\r\n *   pageStats: {\r\n *     page: 1,        // Current page number\r\n *     num: 20,        // Records per page\r\n *     total: 157      // Total matching records\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @throws {Error} When the base query cannot be executed\r\n * @throws {TypeError} When required parameters are missing or invalid\r\n * @throws {DatabaseError} When database connection or query execution fails\r\n *\r\n * @see {@link countQueryFactory} for count query generation details\r\n * @see {@link buildDrizzleQueryFilter} for filtering logic\r\n * @see {@link buildDrizzleOrderBy} for sorting implementation\r\n * @see {@link buildDrizzlePagination} for pagination details\r\n *\r\n * @since 2.0.0\r\n */\r\nexport async function selectForGrid<T = Record<string, unknown>>({\r\n  req,\r\n  query,\r\n  getColumn,\r\n  columnMap = {},\r\n  recordMapper,\r\n  defaultSort,\r\n}: SelectForGridProps<T>): Promise<PaginatedResultset<Partial<T>>> {\r\n  // Parse pagination parameters from the request\r\n  const paginationStats = parsePaginationStats(new URL(req.url));\r\n\r\n  // Apply filtering logic\r\n  const filteredQuery = buildDrizzleQueryFilter({\r\n    query,\r\n    source: req,\r\n    getColumn,\r\n    columnMap,\r\n  });\r\n\r\n  // Apply sorting logic\r\n  const sortedQuery = buildDrizzleOrderBy({\r\n    query: filteredQuery,\r\n    source: req,\r\n    getColumn,\r\n    columnMap,\r\n    defaultSort,\r\n  });\r\n\r\n  const { select, count } = countQueryFactory(sortedQuery as AnyPgSelect);\r\n\r\n  // Apply pagination logic\r\n  const paginatedQuery: unknown = buildDrizzlePagination({\r\n    query: select,\r\n    req,\r\n  });\r\n\r\n  // Execute both queries concurrently\r\n  const [results, totalCount] = await Promise.all([\r\n    typeof paginatedQuery === 'function' ? paginatedQuery() : paginatedQuery,\r\n    count,\r\n  ]);\r\n\r\n  // Transform results if mapper is provided\r\n  const transformedResults = recordMapper\r\n    ? (results as Record<string, unknown>[]).map(recordMapper)\r\n    : (results as Partial<T>[]);\r\n\r\n  // Return paginated result set with wire compatibility\r\n  return {\r\n    results: transformedResults,\r\n    pageStats: {\r\n      page: paginationStats.page,\r\n      num: paginationStats.num,\r\n      total: totalCount,\r\n    },\r\n  };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\queryHelpers\\drizzle\\selectForGridV2.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\queryHelpers\\drizzle\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":219,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { LikeNextRequest } from '@/lib/nextjs-util/types';\r\nimport type {\r\n  GridFilterModel,\r\n  GridFilterItem,\r\n  GridSortModel,\r\n} from '@mui/x-data-grid-pro';\r\nimport type { NextRequest } from 'next/server';\r\nimport type { ColumnBaseConfig, SQL } from 'drizzle-orm';\r\nimport type { AnyPgSelect, PgColumn } from 'drizzle-orm/pg-core';\r\n\r\n// Type for Drizzle select query builder - simplified to match actual usage\r\nexport type DrizzleSelectQueryBase = Pick<\r\n  AnyPgSelect,\r\n  'where' | 'orderBy' | 'offset' | 'limit' | 'prepare' | 'execute' | '_' | 'as'\r\n>;\r\n\r\nexport type DrizzleSelectQuery =\r\n  | DrizzleSelectQueryBase\r\n  | Array<Record<string, unknown>>;\r\n\r\nexport type DrizzleSortedQuery = Omit<DrizzleSelectQuery, 'where' | 'orderBy'>;\r\n\r\n/**\r\n * Props for configuring the selectForGrid function.\r\n */\r\nexport type SelectForGridProps<T> = {\r\n  /**\r\n   * The NextRequest object containing URL parameters for filtering, sorting, and pagination.\r\n   */\r\n  req: NextRequest;\r\n\r\n  /**\r\n   * The Drizzle select query builder to apply operations to.\r\n   */\r\n  query: DrizzleSelectQuery;\r\n\r\n  /**\r\n   * A function to get the actual column object from a column name.\r\n   * This is required because Drizzle needs actual column references for operations.\r\n   *\r\n   * @param columnName - The database column name (after mapping)\r\n   * @returns The Drizzle column object or SQL expression\r\n   */\r\n  getColumn: (columnName: string) => PgColumn | SQL | SQL.Aliased | undefined;\r\n\r\n  /**\r\n   * A mapping or function to translate source column names to database column names.\r\n   */\r\n  columnMap?: ((sourceColumnName: string) => string) | Record<string, string>;\r\n\r\n  /**\r\n   * Optional transformer function to convert database records to domain objects.\r\n   * If not provided, records are returned as-is.\r\n   */\r\n  recordMapper?: (record: Record<string, unknown>) => T;\r\n\r\n  /**\r\n   * The default sort model or column name to use if none is provided.\r\n   */\r\n  defaultSort?: GridSortModel | string | SQL | PgColumn;\r\n};\r\n\r\n/**\r\n * Props for configuring Drizzle order by functionality.\r\n */\r\nexport type BuildDrizzleOrderByProps = {\r\n  /**\r\n   * The Drizzle select query to apply ordering to.\r\n   */\r\n  query: DrizzleSelectQuery;\r\n\r\n  /**\r\n   * The request object, typically similar to Next.js's request, URL, or direct sort model.\r\n   */\r\n  source: LikeNextRequest | URL | string | GridSortModel | undefined;\r\n\r\n  /**\r\n   * The default sort model or column name to use if none is provided.\r\n   */\r\n  defaultSort?: GridSortModel | string | SQL | SQL.Aliased | PgColumn;\r\n\r\n  /**\r\n   * A mapping or function to translate source column names to database column names.\r\n   */\r\n  columnMap?: ((sourceColumnName: string) => string) | Record<string, string>;\r\n\r\n  /**\r\n   * A function to get the actual column object from a column name.\r\n   * This is required because Drizzle needs actual column references for orderBy.\r\n   *\r\n   * @param columnName - The database column name (after mapping)\r\n   * @returns The Drizzle column object or SQL expression\r\n   */\r\n  getColumn: (columnName: string) => PgColumn | SQL | SQL.Aliased | undefined;\r\n};\r\n\r\ntype EmailColumnType = PgColumn<\r\n  ColumnBaseConfig<'string', 'PgUUID'>,\r\n  object,\r\n  object\r\n>;\r\n\r\n/**\r\n * Props for configuring Drizzle attachment or email filter functionality.\r\n */\r\nexport type BuildDrizzleAttachmentOrEmailFilterProps = {\r\n  /**\r\n   * Value used to determine if the filter should include attachments or target only the email.\r\n   * If true, the filter will include attachments; if false, it will target only the email.\r\n   * This value is typically derived from the request URL or query parameters.\r\n   * If not provided, the filter will default to including attachments.\r\n   */\r\n  attachments: boolean | LikeNextRequest | URL | URLSearchParams | undefined;\r\n\r\n  /**\r\n   * The email ID to be used in the filter.\r\n   */\r\n  email_id: string | undefined;\r\n\r\n  /**\r\n   * The Drizzle column object for the email ID field.\r\n   * \r\n   * \r\n   * \r\n   * getColumn: <\r\n    T extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\r\n    TRuntimeConfig extends object = object,\r\n    TConfig extends object = object,\r\n  >(columnName: string) => PgColumn<T, TRuntimeConfig, TConfig> | undefined;\r\n   * \r\n   * \r\n   */\r\n  email_id_column: EmailColumnType | SQL.Aliased<EmailColumnType>;\r\n\r\n  /**\r\n   * The Drizzle column object for the document ID field.\r\n   */\r\n  document_id_column:\r\n    | PgColumn<ColumnBaseConfig<'number', 'PgInteger'>, object, object>\r\n    | SQL.Aliased<number>;\r\n\r\n  /**\r\n   * Function that returns a SQL expression for email_to_document_id conversion.\r\n   * This should be a function that takes an email ID and returns a SQL expression.\r\n   */\r\n  emailToDocumentIdFn?: (emailId: string) => SQL;\r\n};\r\n\r\n/**\r\n * Props for configuring Drizzle item filter functionality.\r\n */\r\nexport type BuildDrizzleItemFilterProps = {\r\n  /**\r\n   * The filter item from MUI Data Grid.\r\n   */\r\n  item: GridFilterItem;\r\n\r\n  /**\r\n   * A function to get the actual column object from a column name.\r\n   * This is required because Drizzle needs actual column references for filtering.\r\n   *     Column<ColumnBaseConfig<ColumnDataType, string>, object, object>\r\n   * @param columnName - The database column name (after mapping)\r\n   * @returns The Drizzle column object or SQL expression\r\n   */\r\n  /*\r\n  getColumn: <\r\n    T extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\r\n    TRuntimeConfig extends object = object,\r\n    TConfig extends object = object,\r\n  >(columnName: string) => PgColumn<T, TRuntimeConfig, TConfig> | SQL | undefined;\r\n*/\r\n  getColumn: (columnName: string) => PgColumn | SQL | SQL.Aliased | undefined;\r\n\r\n  /**\r\n   * A mapping or function to translate source column names to database column names.\r\n   */\r\n  columnMap?: ((sourceColumnName: string) => string) | Record<string, string>;\r\n};\r\n\r\n/**\r\n * Props for configuring Drizzle query filter functionality.\r\n */\r\nexport type BuildDrizzleQueryFilterProps = {\r\n  /**\r\n   * The Drizzle select query to apply filtering to.\r\n   */\r\n  query: DrizzleSelectQuery;\r\n\r\n  /**\r\n   * The filter criteria source, typically specifying the fields and values to filter by.\r\n   */\r\n  source: GridFilterModel | LikeNextRequest | URL | string | undefined;\r\n\r\n  /**\r\n   * A function to get the actual column object from a column name.\r\n   * This is required because Drizzle needs actual column references for filtering.\r\n   *\r\n   * @param columnName - The database column name (after mapping)\r\n   * @returns The Drizzle column object or SQL expression\r\n   */\r\n  getColumn: (columnName: string) => PgColumn | SQL | SQL.Aliased | undefined;\r\n\r\n  /**\r\n   * (Optional) A default filter to apply if no specific filter is provided.\r\n   */\r\n  defaultFilter?: GridFilterModel | LikeNextRequest | URL | string;\r\n\r\n  /**\r\n   * A mapping or function to translate source column names to database column names.\r\n   */\r\n  columnMap?: ((sourceColumnName: string) => string) | Record<string, string>;\r\n\r\n  /**\r\n   * An optional set of additional filters that should be applied to the query.\r\n   * This can include any additional criteria that are not part of the main filter model.\r\n   */\r\n  additional?: Record<string, Omit<GridFilterItem, 'field'>>;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\queryHelpers\\drizzle\\utility.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\queryHelpers\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\queryHelpers\\postgres\\buildOrderBy.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":53,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GridSortModel } from '@mui/x-data-grid';\r\nimport { isSqlNeonAdapter, unwrapAdapter, SqlDb } from '@/lib/neondb';\r\nimport { isGridSortModel } from './guards';\r\nimport { BuildOrderByProps } from './types';\r\nimport { columnMapFactory, parseSortOptions } from '../utility';\r\n\r\n/**\r\n * Build ORDER BY clause for PostgreSQL queries\r\n */\r\nexport const buildOrderBy = <\r\n  RecordType extends Record<string, unknown> = Record<string, unknown>,\r\n>({\r\n  sql: sqlFromProps,\r\n  source,\r\n  defaultSort,\r\n  columnMap = {},\r\n}: BuildOrderByProps<RecordType>) => {\r\n  const sql = isSqlNeonAdapter(sqlFromProps)\r\n    ? unwrapAdapter<RecordType>(sqlFromProps)\r\n    : (sqlFromProps as SqlDb<RecordType>);\r\n\r\n  const mapColumn = columnMapFactory(columnMap);\r\n\r\n  // Parse sort options from source\r\n  let sortModel: GridSortModel = [];\r\n\r\n  if (source) {\r\n    sortModel = parseSortOptions(source)!;\r\n  }\r\n\r\n  // Use default sort if no sort model found\r\n  if (!sortModel?.length && defaultSort) {\r\n    if (typeof defaultSort === 'string') {\r\n      sortModel = [{ field: defaultSort, sort: 'asc' }];\r\n    } else if (isGridSortModel(defaultSort)) {\r\n      sortModel = defaultSort;\r\n    }\r\n  }\r\n\r\n  if (!sortModel?.length) {\r\n    return sql``;\r\n  }\r\n\r\n  // Build ORDER BY clause\r\n  const orderClauses = sortModel.map((item) => {\r\n    const column = mapColumn(item.field);\r\n    const direction = item.sort === 'desc' ? 'DESC' : 'ASC';\r\n    return sql`${column} ${direction}`;\r\n  });\r\n\r\n  return sql`ORDER BY ${orderClauses.join(', ')}`;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\queryHelpers\\postgres\\buildPagination.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":25,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { isSqlNeonAdapter, unwrapAdapter, SqlDb } from '@/lib/neondb';\r\nimport { BuildPaginationProps } from './types';\r\nimport { parsePaginationOptions } from '../utility';\r\n\r\n/**\r\n * Build LIMIT and OFFSET clauses for PostgreSQL queries\r\n */\r\nexport const buildPagination = <\r\n  RecordType extends Record<string, unknown> = Record<string, unknown>,\r\n>({\r\n  sql: sqlFromProps,\r\n  source,\r\n  defaultPageSize = 25,\r\n  maxPageSize = 100,\r\n}: BuildPaginationProps<RecordType>) => {\r\n  const sql = isSqlNeonAdapter(sqlFromProps)\r\n    ? unwrapAdapter<RecordType>(sqlFromProps)\r\n    : (sqlFromProps as SqlDb<RecordType>);\r\n  const ops = parsePaginationOptions(source, defaultPageSize, maxPageSize);\r\n  const { offset, limit } =\r\n    'offset' in ops ? ops : { offset: 0, limit: defaultPageSize };\r\n\r\n  return sql`LIMIT ${limit} OFFSET ${offset}`;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\queryHelpers\\postgres\\buildQueryFilter.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":238,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GridFilterModel, GridFilterItem } from '@mui/x-data-grid-pro';\r\nimport {\r\n  ISqlNeonAdapter,\r\n  isSqlNeonAdapter,\r\n  SqlDb,\r\n  unwrapAdapter,\r\n} from '@/lib/neondb';\r\nimport { isLikeNextRequest } from '@/lib/nextjs-util/guards';\r\nimport { LikeNextRequest } from '@/lib/nextjs-util/types';\r\nimport { columnMapFactory } from '../utility';\r\nimport { BuildQueryFilterProps, BuildItemFilterProps } from './types';\r\nimport { isGridFilterModel } from './guards';\r\nimport { isTruthy } from '@/lib/react-util/utility-methods';\r\n\r\nexport const buildAttachmentOrEmailFilter = ({\r\n  attachments,\r\n  email_id,\r\n  email_id_column = 'email_id',\r\n  email_id_table = '', // default to empty string for test compatibility\r\n  document_id_column = 'unit_id',\r\n  document_id_table = '', // default to empty string for test compatibility\r\n  sql: sqlFromProps,\r\n  append = false,\r\n}: {\r\n  /**\r\n   * Value used to determine if the filter should include attachments or target only the email.\r\n   * If true, the filter will include attachments; if false, it will target only the email.\r\n   * This value is typically derived from the request URL or query parameters.\r\n   * If not provided, the filter will default to including attachments.\r\n   */\r\n  attachments: boolean | LikeNextRequest | URL | URLSearchParams | undefined;\r\n  /**\r\n   * The email ID to be used in the filter.\r\n   */\r\n  email_id: string | undefined;\r\n  /**\r\n   * Name of the email id column; defaults to `email_id`.\r\n   */\r\n  email_id_column?: string;\r\n  /**\r\n   * Name of the email id table; defaults to `du` (document_units).\r\n   */\r\n  email_id_table?: string;\r\n  /**\r\n   * Name of the document id column; defaults to `unit_id`.\r\n   */\r\n  document_id_column?: string;\r\n  /**\r\n   * Name of the document id table; defaults to `du` (document_units).\r\n   */\r\n  document_id_table?: string;\r\n  /**\r\n   * The SQL adapter or database instance used to build and execute the query.\r\n   */\r\n  sql: ISqlNeonAdapter | SqlDb<Record<string, unknown>>;\r\n  /**\r\n   * If true, the filter will be appended to the existing filter - eg and AND keyword will be used.\r\n   * If false or not provided, the filter will create a new filter - eg the WHERE keyword will be used.\r\n   */\r\n  append?: boolean;\r\n}) => {\r\n  const sql = isSqlNeonAdapter(sqlFromProps)\r\n    ? unwrapAdapter(sqlFromProps)\r\n    : (sqlFromProps as SqlDb<Record<string, unknown>>);\r\n  let includeAttachments = true;\r\n  if (typeof attachments === 'boolean') {\r\n    includeAttachments = attachments;\r\n  } else if (typeof attachments === 'object' && attachments !== null) {\r\n    let searchParams: URLSearchParams;\r\n    if (attachments instanceof URL) {\r\n      searchParams = attachments.searchParams;\r\n    } else if (attachments instanceof URLSearchParams) {\r\n      searchParams = attachments;\r\n    } else if (isLikeNextRequest(attachments)) {\r\n      searchParams = new URL(attachments.url!).searchParams;\r\n    } else {\r\n      throw new Error('Invalid attachments parameter', { cause: attachments });\r\n    }\r\n    includeAttachments =\r\n      searchParams.has('attachments') &&\r\n      isTruthy(searchParams.get('attachments'));\r\n  }\r\n\r\n  const conjunction = append === true ? sql`AND` : sql`WHERE`;\r\n\r\n  if (includeAttachments) {\r\n    // If email_id_table is empty, just use the column\r\n    return email_id_table === ''\r\n      ? sql`${conjunction} ${sql(email_id_column)} = ${email_id}`\r\n      : sql`${conjunction} ${sql(email_id_table)}.${sql(email_id_column)} = ${email_id}`;\r\n  }\r\n  // If document_id_table is empty, just use the column\r\n  if (!document_id_table) {\r\n    return sql`${conjunction} email_to_document_id(${email_id}) = ${sql(document_id_column)} `;\r\n  }\r\n  return sql`${conjunction} email_to_document_id(${email_id}) = ${sql(document_id_table)}.${sql(document_id_column)} `;\r\n};\r\n\r\n/**\r\n * Build a single filter condition for an item\r\n */\r\nexport const buildItemFilter = ({\r\n  item,\r\n  columnMap = {},\r\n}: BuildItemFilterProps): string => {\r\n  const mapColumn = columnMapFactory(columnMap);\r\n  const column = mapColumn(item.field);\r\n\r\n  switch (item.operator) {\r\n    case 'contains':\r\n      return `${column} ILIKE '%${item.value}%'`;\r\n    case 'equals':\r\n      return `${column} = '${item.value}'`;\r\n    case 'startsWith':\r\n      return `${column} ILIKE '${item.value}%'`;\r\n    case 'endsWith':\r\n      return `${column} ILIKE '%${item.value}'`;\r\n    case 'isEmpty':\r\n      return `${column} IS NULL OR ${column} = ''`;\r\n    case 'isNotEmpty':\r\n      return `${column} IS NOT NULL AND ${column} != ''`;\r\n    case 'isAnyOf':\r\n      if (Array.isArray(item.value)) {\r\n        const values = item.value.map((v) => `'${v}'`).join(', ');\r\n        return `${column} IN (${values})`;\r\n      }\r\n      return `${column} = '${item.value}'`;\r\n    default:\r\n      return `${column} = '${item.value}'`;\r\n  }\r\n};\r\n\r\n/**\r\n * Build query filter for PostgreSQL\r\n */\r\nexport const buildQueryFilter = <\r\n  RecordType extends Record<string, unknown> = Record<string, unknown>,\r\n>({\r\n  sql: sqlFromProps,\r\n  source,\r\n  defaultFilter,\r\n  columnMap = {},\r\n  additional = {},\r\n  append = false,\r\n}: BuildQueryFilterProps<RecordType>) => {\r\n  const sql = isSqlNeonAdapter(sqlFromProps)\r\n    ? unwrapAdapter<RecordType>(sqlFromProps)\r\n    : (sqlFromProps as SqlDb<RecordType>);\r\n\r\n  // Parse filter model from source\r\n  let filterModel: GridFilterModel | null = null;\r\n\r\n  if (!source && defaultFilter) {\r\n    source = defaultFilter;\r\n  }\r\n\r\n  if (!source) {\r\n    return sql``;\r\n  }\r\n\r\n  if (typeof source === 'string') {\r\n    try {\r\n      const parsed = JSON.parse(source);\r\n      if (isGridFilterModel(parsed)) {\r\n        filterModel = parsed;\r\n      }\r\n    } catch {\r\n      return sql``;\r\n    }\r\n  } else if (source instanceof URL) {\r\n    const filterParam = source.searchParams.get('filter');\r\n    if (filterParam && filterParam.trim()) {\r\n      try {\r\n        const parsed = JSON.parse(filterParam);\r\n        if (isGridFilterModel(parsed)) {\r\n          filterModel = parsed;\r\n        }\r\n      } catch {\r\n        return sql``;\r\n      }\r\n    }\r\n  } else if (source && isLikeNextRequest(source) && source.url) {\r\n    const url = new URL(source.url);\r\n    const filterParam = url.searchParams.get('filter');\r\n    if (filterParam && filterParam.trim()) {\r\n      try {\r\n        const parsed = JSON.parse(filterParam);\r\n        if (isGridFilterModel(parsed)) {\r\n          filterModel = parsed;\r\n        }\r\n      } catch {\r\n        return sql``;\r\n      }\r\n    }\r\n  } else if (isGridFilterModel(source)) {\r\n    filterModel = source;\r\n  }\r\n\r\n  if (!filterModel || !filterModel.items || filterModel.items.length === 0) {\r\n    return sql``;\r\n  }\r\n\r\n  // Build filter conditions\r\n  const conditions: string[] = [];\r\n\r\n  // Add main filter items\r\n  for (const item of filterModel.items) {\r\n    const condition = buildItemFilter({ item, columnMap });\r\n    if (condition) {\r\n      conditions.push(condition);\r\n    }\r\n  }\r\n\r\n  // Add additional filters\r\n  for (const [field, itemProps] of Object.entries(additional)) {\r\n    const item: GridFilterItem = { field, ...itemProps };\r\n    const condition = buildItemFilter({ item, columnMap });\r\n    if (condition) {\r\n      conditions.push(condition);\r\n    }\r\n  }\r\n\r\n  if (conditions.length === 0) {\r\n    return sql``;\r\n  }\r\n\r\n  // Combine conditions based on linkOperator\r\n  const filterWithLinkOperator: GridFilterModel & {\r\n    linkOperator?: 'and' | 'or';\r\n  } = filterModel;\r\n  const linkOperator = (\r\n    filterWithLinkOperator.linkOperator ?? 'and'\r\n  ).toLocaleLowerCase();\r\n  const operator = linkOperator === 'or' ? ' OR ' : ' AND ';\r\n\r\n  return sql(`${append ? 'AND ' : 'WHERE '} (${conditions.join(operator)})`);\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\queryHelpers\\postgres\\guards.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":55,"endColumn":3}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { GridSortModel, GridFilterModel } from '@mui/x-data-grid-pro';\r\n\r\n/**\r\n * Type guard to check if a value is a GridSortModel.\r\n */\r\nexport const isGridSortModel = (value: unknown): value is GridSortModel => {\r\n  if (!Array.isArray(value)) {\r\n    return false;\r\n  }\r\n  \r\n  return value.every(item => \r\n    typeof item === 'object' &&\r\n    item !== null &&\r\n    'field' in item &&\r\n    typeof item.field === 'string' &&\r\n    'sort' in item &&\r\n    (item.sort === 'asc' || item.sort === 'desc' || item.sort === null || item.sort === undefined)\r\n  );\r\n};\r\n\r\n/**\r\n * Type guard to check if a value is a GridFilterModel.\r\n */\r\nexport const isGridFilterModel = (value: unknown): value is GridFilterModel => {\r\n  if (typeof value !== 'object' || value === null) {\r\n    return false;\r\n  }\r\n  \r\n  const obj = value as Record<string, unknown>;\r\n  \r\n  return (\r\n    'items' in obj &&\r\n    Array.isArray(obj.items) &&\r\n    obj.items.every(item => \r\n      typeof item === 'object' &&\r\n      item !== null &&\r\n      'field' in item &&\r\n      typeof item.field === 'string'\r\n    )\r\n  );\r\n};\r\n\r\n/**\r\n * Type guard to check if a value is a string.\r\n */\r\nexport const isString = (value: unknown): value is string => {\r\n  return typeof value === 'string';\r\n};\r\n\r\n/**\r\n * Type guard to check if a value is a URL.\r\n */\r\nexport const isURL = (value: unknown): value is URL => {\r\n  return value instanceof URL;\r\n};","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\queryHelpers\\postgres\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\queryHelpers\\postgres\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":120,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { LikeNextRequest } from '@/lib/nextjs-util/types';\r\nimport type {\r\n  GridFilterModel,\r\n  GridFilterItem,\r\n  GridSortModel,\r\n} from '@mui/x-data-grid-pro';\r\nimport type { Sql } from 'postgres';\r\nimport type { ISqlNeonAdapter, SqlDb } from '@/lib/neondb';\r\n\r\n/**\r\n * Props for configuring the buildOrderBy function for PostgreSQL.\r\n */\r\nexport type BuildOrderByProps<\r\n  RecordType extends Record<string, unknown> = Record<string, unknown>,\r\n> = {\r\n  /**\r\n   * The PostgreSQL client or adapter instance.\r\n   */\r\n  sql: Sql<RecordType> | ISqlNeonAdapter | SqlDb<RecordType> | unknown;\r\n\r\n  /**\r\n   * The request object, typically similar to Next.js's request, URL, or direct sort model.\r\n   */\r\n  source: LikeNextRequest | URL | string | GridSortModel | undefined;\r\n\r\n  /**\r\n   * The default sort model or column name to use if none is provided.\r\n   */\r\n  defaultSort?: GridSortModel | string;\r\n\r\n  /**\r\n   * A mapping or function to translate source column names to database column names.\r\n   */\r\n  columnMap?: ((sourceColumnName: string) => string) | Record<string, string>;\r\n};\r\n\r\n/**\r\n * Props for configuring the buildPagination function for PostgreSQL.\r\n */\r\nexport type BuildPaginationProps<\r\n  RecordType extends Record<string, unknown> = Record<string, unknown>,\r\n> = {\r\n  /**\r\n   * The PostgreSQL client or adapter instance.\r\n   */\r\n  sql: Sql<RecordType> | ISqlNeonAdapter | SqlDb<RecordType> | unknown;\r\n\r\n  /**\r\n   * The request object containing pagination parameters.\r\n   */\r\n  source?: LikeNextRequest | URL | string | undefined;\r\n\r\n  /**\r\n   * Default page size if not specified in the request.\r\n   */\r\n  defaultPageSize?: number;\r\n\r\n  /**\r\n   * Maximum allowed page size to prevent abuse.\r\n   */\r\n  maxPageSize?: number;\r\n\r\n  /**\r\n   * Optional request parameter for backward compatibility.\r\n   */\r\n  req?: unknown;\r\n};\r\n\r\n/**\r\n * Props for configuring the buildQueryFilter function for PostgreSQL.\r\n */\r\nexport type BuildQueryFilterProps<\r\n  RecordType extends Record<string, unknown> = Record<string, unknown>,\r\n> = {\r\n  /**\r\n   * The PostgreSQL client or adapter instance.\r\n   */\r\n  sql: Sql<RecordType> | ISqlNeonAdapter | SqlDb<RecordType> | unknown;\r\n\r\n  /**\r\n   * The filter criteria source, typically specifying the fields and values to filter by.\r\n   */\r\n  source: GridFilterModel | LikeNextRequest | URL | string | undefined;\r\n\r\n  /**\r\n   * (Optional) A default filter to apply if no specific filter is provided.\r\n   */\r\n  defaultFilter?: GridFilterModel | LikeNextRequest | URL | string;\r\n\r\n  /**\r\n   * A mapping or function to translate source column names to database column names.\r\n   */\r\n  columnMap?: ((sourceColumnName: string) => string) | Record<string, string>;\r\n\r\n  /**\r\n   * An optional set of additional filters that should be applied to the query.\r\n   */\r\n  additional?: Record<string, Omit<GridFilterItem, 'field'>>;\r\n\r\n  /**\r\n   * Optional append parameter for backward compatibility.\r\n   */\r\n  append?: unknown;\r\n};\r\n\r\n/**\r\n * Props for configuring item filter functionality for PostgreSQL.\r\n */\r\nexport type BuildItemFilterProps = {\r\n  /**\r\n   * The filter item from MUI Data Grid.\r\n   */\r\n  item: GridFilterItem;\r\n\r\n  /**\r\n   * A mapping or function to translate source column names to database column names.\r\n   */\r\n  columnMap?: ((sourceColumnName: string) => string) | Record<string, string>;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\queryHelpers\\utility.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":313,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { LikeNextRequest } from '@/lib/nextjs-util/types';\r\nimport type {\r\n  GridFilterModel,\r\n  GridSortModel,\r\n  GridFilterItem,\r\n} from '@mui/x-data-grid-pro';\r\nimport { isLikeNextRequest } from '@/lib/nextjs-util/guards';\r\nimport { isGridSortModel, isString, isURL } from './postgres/guards';\r\nimport { isGridFilterModel } from '../guards';\r\nimport type { ArrayElement } from '@/lib/typescript/_types';\r\nimport type { PaginatedGridListRequest } from '../types';\r\nimport { normalizeNullableNumeric } from '@/data-models/_utilities';\r\ntype GridSortItem = ArrayElement<GridSortModel>;\r\n\r\n/**\r\n * Parses filter options from various input types and returns a `GridFilterModel` if available.\r\n *\r\n * Accepts a `URL`, `URLSearchParams`, or a `GridFilterModel` (or `undefined`), and attempts to extract\r\n * a valid `GridFilterModel` from the input. If the input is a `URL`, it uses its `searchParams`.\r\n * If the input is a `URLSearchParams`, it looks for a `filter` parameter and parses it as JSON.\r\n * If the parsed object is a valid `GridFilterModel` and contains items, it is returned.\r\n * Returns `undefined` if no valid filter model is found or if the filter model has no items.\r\n *\r\n * @param req - The request input, which can be a `URL`, `URLSearchParams`, or a `GridFilterModel` (or `undefined`).\r\n * @returns The parsed `GridFilterModel` if valid and contains items, otherwise `undefined`.\r\n */\r\nexport const parseFilterOptions = (\r\n  req: URL | URLSearchParams | (GridFilterModel | undefined),\r\n  additional?: Record<string, Omit<GridFilterItem, 'field'>>,\r\n): GridFilterModel | undefined => {\r\n  const appendAdditional = (\r\n    x: GridFilterModel,\r\n  ): GridFilterModel | undefined => {\r\n    const addKeys = Object.keys(additional ?? {});\r\n    return x.items.length === 0\r\n      ? addKeys.length > 0\r\n        ? {\r\n            ...x,\r\n            items: addKeys.map((key) => ({ field: key, ...additional![key] })),\r\n          }\r\n        : undefined\r\n      : addKeys.length > 0\r\n        ? {\r\n            ...x,\r\n            items: [\r\n              ...(x.items || []),\r\n              ...addKeys.map((key) => ({ field: key, ...additional![key] })),\r\n            ],\r\n          }\r\n        : x;\r\n  };\r\n\r\n  if (isGridFilterModel(req)) {\r\n    return appendAdditional(req);\r\n  }\r\n  if (req instanceof URL) {\r\n    req = req.searchParams;\r\n  } else if (req instanceof URLSearchParams) {\r\n    // do nothing\r\n  } else {\r\n    return undefined;\r\n  }\r\n  const filterParam = req.get('filter');\r\n  if (!filterParam) return appendAdditional({ items: [] });\r\n  const check = JSON.parse(filterParam);\r\n  if (isGridFilterModel(check)) {\r\n    check.items = check.items.filter((x) => x.field && x.operator && x.value);\r\n    return appendAdditional(check);\r\n  }\r\n  return appendAdditional({ items: [] });\r\n};\r\n\r\n/**\r\n * Factory function to create a column mapping function.\r\n */\r\nexport const columnMapFactory = (\r\n  columnMap: ((sourceColumnName: string) => string) | Record<string, string>,\r\n): ((sourceColumnName: string) => string) => {\r\n  if (typeof columnMap === 'function') {\r\n    return columnMap;\r\n  }\r\n\r\n  return (sourceColumnName: string) =>\r\n    columnMap[sourceColumnName] || sourceColumnName;\r\n};\r\n\r\ntype ParseSortOptionsParam =\r\n  | URLSearchParams\r\n  | LikeNextRequest\r\n  | URL\r\n  | string\r\n  | GridSortModel;\r\n\r\n/**\r\n * Parse sort options from various sources.\r\n */\r\nexport const parseSortOptions = (\r\n  source?: ParseSortOptionsParam,\r\n): typeof source extends infer TSource\r\n  ? TSource extends ParseSortOptionsParam\r\n    ? GridSortModel\r\n    : undefined\r\n  : never => {\r\n  if (source === null) {\r\n    return [] as GridSortModel; // Test expects [] for null\r\n  }\r\n\r\n  if (source === undefined) {\r\n    return undefined as undefined; // Test expects undefined for undefined\r\n  }\r\n\r\n  if (isGridSortModel(source)) {\r\n    return source;\r\n  }\r\n\r\n  if (isString(source)) {\r\n    // Handle empty string case\r\n    if (source.trim() === '') {\r\n      return undefined as undefined;\r\n    }\r\n\r\n    try {\r\n      const parsed = JSON.parse(source);\r\n      if (isGridSortModel(parsed)) {\r\n        return parsed;\r\n      }\r\n    } catch {\r\n      // If parsing as json fails, try [field]:asc|desc format\r\n      const extracted = source.split(',').reduce((acc, item) => {\r\n        if (!item.trim()) return acc; // Skip empty items\r\n\r\n        // Split only on the first colon to handle cases like 'foo:bar:desc'\r\n        const colonIndex = item.indexOf(':');\r\n        if (colonIndex === -1) {\r\n          // No colon found, use default sort\r\n          acc.push({\r\n            field: item.trim(),\r\n            sort: 'asc' as 'asc' | 'desc',\r\n          });\r\n        } else {\r\n          const field = item.substring(0, colonIndex);\r\n          const direction = item.substring(colonIndex + 1).trim();\r\n          acc.push({\r\n            field: field, // Preserve spaces in field name per test\r\n            sort: (direction.toLowerCase() === 'desc' ? 'desc' : 'asc') as\r\n              | 'asc'\r\n              | 'desc',\r\n          });\r\n        }\r\n        return acc;\r\n      }, [] as GridSortItem[]);\r\n\r\n      if (extracted.length > 0) {\r\n        return extracted as GridSortModel;\r\n      }\r\n    }\r\n    return undefined as undefined; // Return undefined for invalid strings\r\n  }\r\n\r\n  if (source instanceof URLSearchParams) {\r\n    const sortParam = source.get('sort');\r\n    return sortParam ? parseSortOptions(sortParam) : undefined;\r\n  }\r\n\r\n  if (isURL(source)) {\r\n    return parseSortOptions(source.searchParams);\r\n  }\r\n\r\n  if (source && isLikeNextRequest(source) && source.url) {\r\n    const url = new URL(source.url);\r\n    return parseSortOptions(url.searchParams);\r\n  }\r\n\r\n  // For unknown types (objects, numbers, etc.)\r\n  return undefined as undefined;\r\n};\r\n\r\n/**\r\n * Parse pagination options from various sources.\r\n */\r\nexport const parsePaginationOptions = (\r\n  source: LikeNextRequest | URL | URLSearchParams | string | undefined,\r\n  defaultPageSize: number = 25,\r\n  maxPageSize: number = 100,\r\n): { offset: number; limit: number } | { num: number; page: string } => {\r\n  let page = 0;\r\n  let pageSize = defaultPageSize;\r\n\r\n  if (!source) {\r\n    return { offset: 0, limit: pageSize };\r\n  }\r\n\r\n  let searchParams: URLSearchParams | undefined;\r\n\r\n  if (source && isString(source)) {\r\n    try {\r\n      const url = new URL(source);\r\n      searchParams = url.searchParams;\r\n    } catch {\r\n      // If URL parsing fails, use defaults\r\n    }\r\n  } else if (source && isURL(source)) {\r\n    searchParams = source.searchParams;\r\n  } else if (source && isLikeNextRequest(source) && source.url) {\r\n    const url = new URL(source.url);\r\n    searchParams = url.searchParams;\r\n  } else if (source instanceof URLSearchParams) {\r\n    searchParams = source;\r\n  }\r\n\r\n  if (searchParams) {\r\n    const pageParam = searchParams.get('page');\r\n    const pageSizeParam = searchParams.get('pageSize');\r\n\r\n    if (pageParam) {\r\n      const parsedPage = parseInt(pageParam, 10);\r\n      if (!isNaN(parsedPage) && parsedPage >= 0) {\r\n        page = parsedPage;\r\n      }\r\n    }\r\n\r\n    if (pageSizeParam) {\r\n      const parsedPageSize = parseInt(pageSizeParam, 10);\r\n      if (!isNaN(parsedPageSize) && parsedPageSize > 0) {\r\n        pageSize = Math.min(parsedPageSize, maxPageSize);\r\n      }\r\n    } else {\r\n      const numParam = searchParams.get('num');\r\n      if (numParam !== null) {\r\n        const numValue = parseInt(numParam, 10);\r\n        return {\r\n          num:\r\n            isNaN(numValue) || numValue < 1\r\n              ? 100\r\n              : Math.min(numValue, maxPageSize),\r\n          page: (pageParam ?? '').trim(),\r\n        };\r\n      }\r\n    }\r\n  }\r\n\r\n  const offset = page * pageSize;\r\n  return { offset, limit: pageSize };\r\n};\r\n\r\n/**\r\n * Parses pagination statistics from a given request object.\r\n *\r\n * @param req - The request object which can be of type URL, URLSearchParams, or PaginationStats.\r\n * @returns An object containing pagination statistics including page, num, total, and offset.\r\n *\r\n * The function extracts the `page` and `num` parameters from the request object.\r\n * If the request object is of type URL or URLSearchParams, it retrieves these parameters from the search parameters.\r\n * If the request object is of type PaginationStats, it directly uses the `page` and `num` properties.\r\n * If the request object is undefined or null, it defaults to page 1 and num 10.\r\n *\r\n * The `page` and `num` values are normalized to ensure they are numeric and fall back to default values if necessary.\r\n * The `offset` is calculated based on the `page` and `num` values.\r\n *\r\n * @example\r\n * ```typescript\r\n * const url = new URL('https://example.com?page=2&num=20');\r\n * const stats = parsePaginationStats(url);\r\n * console.log(stats); // { page: 2, num: 20, total: 0, offset: 20 }\r\n * ```\r\n */\r\nexport const parsePaginationStats = (\r\n  req:\r\n    | URL\r\n    | URLSearchParams\r\n    | (PaginatedGridListRequest | undefined)\r\n    | LikeNextRequest,\r\n): PaginatedGridListRequest & { offset: number } => {\r\n  let page: number | string | undefined | null;\r\n  let num: number | string | undefined | null;\r\n  let filter: GridFilterModel | undefined;\r\n  let sort: GridSortModel | undefined;\r\n  if (isLikeNextRequest(req)) {\r\n    req = new URL(req.url!);\r\n  }\r\n  if (!!req && ('searchParams' in req || 'get' in req)) {\r\n    if ('searchParams' in req) {\r\n      req = req.searchParams;\r\n    }\r\n    page = req.get('page');\r\n    num = req.get('num');\r\n    filter = parseFilterOptions(req);\r\n    sort = parseSortOptions(req);\r\n  } else {\r\n    if (!req) {\r\n      page = undefined;\r\n      num = undefined;\r\n      filter = undefined;\r\n      sort = undefined;\r\n    } else {\r\n      page = req.page;\r\n      num = req.num;\r\n      filter = req.filter;\r\n      sort = req.sort;\r\n    }\r\n  }\r\n  page = normalizeNullableNumeric(Number(page), 1) ?? 1;\r\n  num = normalizeNullableNumeric(Number(num), 10) ?? 10;\r\n  return {\r\n    filter,\r\n    sort,\r\n    page,\r\n    num,\r\n    total: 0,\r\n    offset: (page - 1) * num,\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":269,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PaginationStats } from '@/data-models/_types';\r\nimport type { LikeNextRequest } from '@/lib/nextjs-util/types';\r\nexport type { LikeNextRequest };\r\nimport type { FirstParameter } from '@/lib/typescript';\r\nimport type {\r\n  GridDataSource,\r\n  GridSortModel,\r\n  GridFilterModel,\r\n  DataGridProProps,\r\n  GridGetRowsResponse,\r\n} from '@mui/x-data-grid-pro';\r\nimport type { Dispatch, SetStateAction } from 'react';\r\n\r\n/**\r\n * Extends the `GridDataSource` type by adding an optional error handler.\r\n *\r\n * @remarks\r\n * This type allows you to provide a custom error handling function that will be called\r\n * when a data source error occurs, such as when fetching or updating rows.  This is useful\r\n * because we are already memoizing the data source, so it's a natural place for a stabilized\r\n * version of error handling logic to reside.\r\n */\r\nexport type ExtendedGridDataSource = GridDataSource & {\r\n  /**\r\n   * @property {DataGridProProps['onDataSourceError']} onDataSourceError - Optional callback invoked with either a `GridGetRowsError`\r\n   * or a `GridUpdateRowError` when an error occurs in the data source.\r\n   */\r\n  onDataSourceError?: DataGridProProps['onDataSourceError'];\r\n  /**\r\n   * @property {boolean} isLoading - Indicates whether the data source is currently loading data.\r\n   * This can be used to show a loading indicator in the UI.\r\n   * @remarks\r\n   * This property is useful for managing the loading state of the data source, allowing you to\r\n   * provide feedback to the user while data is being fetched or processed.\r\n   */\r\n  isLoading: boolean;\r\n  /**\r\n   * @property {string | null} loadError - Contains an error message if an error occurs while loading data.\r\n   * If no error occurs, it is `null`.\r\n   */\r\n  loadError: string | null;\r\n};\r\n\r\n/**\r\n * Props for configuring a data source in the data grid component.\r\n *\r\n * @property setIsLoading - Function to update the loading state of the component.\r\n * @property setError - Function to update the error state, accepting a string message or null.\r\n * @property url - The endpoint URL from which to fetch data.\r\n * @property getRecordData - Optional function to fetch data from a URL. If not provided, the default `fetch` function will be used.\r\n */\r\nexport type DataSourceProps = {\r\n  /**\r\n   * @property {string} url - The endpoint URL from which to fetch data.\r\n   */\r\n  url: string | URL;\r\n  /**\r\n   * @property {(url: string) => Promise<Response>} [getRecordData] - Optional function to fetch data from a URL.\r\n   * If not provided, the default `fetch` function will be used.\r\n   */\r\n  getRecordData?: (props: GetGridRecordDataProps) => Promise<Response>;\r\n};\r\n\r\n/**\r\n * Props containing the parameters needed to retrieve a cache record for a data grid request.\r\n */\r\nexport type RequestCacheRecordProps = {\r\n  /**\r\n   * The endpoint URL for the data request.\r\n   */\r\n  url: string;\r\n  /**\r\n   * The current page number for pagination.\r\n   */\r\n  page: number;\r\n  /**\r\n   * The number of items per page.\r\n   */\r\n  pageSize: number;\r\n  /**\r\n   * The sorting model applied to the returned resultset.\r\n   * @remarks\r\n   * This is an optional property, used is used to determine the order in which the data is displayed\r\n   * in the grid.. If not provided, the default sorting will be applied.\r\n   * The sorting model is an array of objects, each containing the field to sort by and the sort direction.\r\n   * For example:\r\n   * ```typescript\r\n   * const sortModel: GridSortModel = [\r\n   *  { field: 'name', sort: 'asc' },\r\n   *  { field: 'age', sort: 'desc' },\r\n   * ];\r\n   * ```\r\n   * This will sort the data first by `name` in ascending order and then by `age` in descending order.\r\n   */\r\n  sort?: GridSortModel;\r\n  /**\r\n   * An optional filter model to apply to the returned resultset.\r\n   * @remarks\r\n   * This is an optional property, used is used to filter the data displayed in the grid.\r\n   * If not provided, no filtering will be applied.\r\n   * The filter model is an object that contains the filter items, logic operator, and other properties.\r\n   * For example:\r\n   * ```typescript\r\n   * const filterModel: GridFilterModel = {\r\n   *  items: [\r\n   *    { field: 'name', operator: 'contains', value: 'John' },\r\n   *   { field: 'age', operator: '>', value: 30 },\r\n   *  ],\r\n   *  logicOperator: 'and',\r\n   *  quickFilterValues: ['John', 'Doe'],\r\n   *  quickFilterLogicOperator: 'or',\r\n   *  quickFilterExcludeHiddenColumns: true,\r\n   * };\r\n   * ```\r\n   * This will filter the data to include only rows where the `name` contains 'John' and the `age` is greater than 30.\r\n   * * The `logicOperator` determines how the filter items are combined (e.g., 'and' or 'or').\r\n   * * The `quickFilterValues` are used for quick filtering, allowing users to filter the data based on specific values.\r\n   * * The `quickFilterLogicOperator` determines how the quick filter values are combined (e.g., 'and' or 'or').\r\n   * * The `quickFilterExcludeHiddenColumns` specifies whether to exclude hidden columns from the quick filter.\r\n   * * If not provided, no filtering will be applied.\r\n   * * This property is useful for implementing server-side filtering, where the server processes the filter criteria and returns the filtered data.\r\n   * * @see {@link https://mui.com/x/react-data-grid/columns/filtering/#server-side-filtering}\r\n   * @see {@link https://mui.com/x/react-data-grid/columns/sorting/#server-side-sorting}\r\n   * * @default []\r\n   * * @example\r\n   * const filterModel: GridFilterModel = {\r\n   *  items: [\r\n   *   { field: 'name', operator: 'contains', value: 'John' },\r\n   *  { field: 'age', operator: '>', value: 30 },\r\n   * ],\r\n   *  logicOperator: 'and',\r\n   * quickFilterValues: ['John', 'Doe'],\r\n   * quickFilterLogicOperator: 'or',\r\n   * quickFilterExcludeHiddenColumns: true,\r\n   * };\r\n   * * This will filter the data to include only rows where the `name` contains 'John' and the `age` is greater than 30.\r\n   * * The `logicOperator` determines how the filter items are combined (e.g., 'and' or 'or').\r\n   * * The `quickFilterValues` are used for quick filtering, allowing users to filter the data based on specific values.\r\n   * * The `quickFilterLogicOperator` determines how the quick filter values are combined (e.g., 'and' or 'or').\r\n   * * The `quickFilterExcludeHiddenColumns` specifies whether to exclude hidden columns from the quick filter.\r\n   * * If not provided, no filtering will be applied.\r\n   */\r\n  filter?: GridFilterModel;\r\n};\r\n\r\n/**\r\n * Props for managing or caching get request and it's parameters.\r\n */\r\nexport type GetRequestCacheRecordProps = RequestCacheRecordProps & {\r\n  /**\r\n   * A function to fetch record data given a URL, returning a Promise of a Response.\r\n   */\r\n  getRecordData?: (\r\n    props: Omit<GetRequestCacheRecordProps, 'getRecordData' | 'setIsLoading'>,\r\n  ) => Promise<Response>;\r\n  /**\r\n   * A state setter to indicate loading status.\r\n   */\r\n  setIsLoading: Dispatch<SetStateAction<boolean>>;\r\n\r\n  /**\r\n   * An optional AbortSignal to cancel the request if needed.\r\n   * This can be used to abort the request if the component is unmounted or if the\r\n   * request is no longer needed.\r\n   */\r\n  signal?: AbortSignal;\r\n};\r\n\r\n/**\r\n * Type for the callback function to fetch record data.\r\n *\r\n * @remarks\r\n * This type is used to define the shape of the function that will be called to fetch\r\n * record data, including the URL and other parameters.\r\n */\r\nexport type GetGridRecordDataCallback =\r\n  Required<GetRequestCacheRecordProps>['getRecordData'];\r\n\r\n/**\r\n * Represents the properties passed to the `GetGridRecordDataCallback` function.\r\n * This type is derived from the first parameter of the `GetGridRecordDataCallback` type.\r\n */\r\nexport type GetGridRecordDataProps = FirstParameter<GetGridRecordDataCallback>;\r\n\r\n/**\r\n * Represents a request for a paginated grid list, extending {@link PaginationStats}\r\n * with optional sorting and filtering capabilities.\r\n *\r\n * @template T - The type of the pagination key (e.g., number for page index).\r\n * @property {GridFilterModel} [filter] - Optional filter model to apply to the grid data.\r\n * @property {GridSortModel} [sort] - Optional sort model to specify sorting of the grid data.\r\n * @extends PaginationStats\r\n */\r\nexport type PaginatedGridListRequest = PaginationStats<number> & {\r\n  /**\r\n   * @property {GridFilterModel} [filter] - Optional filter model to apply to the grid data.\r\n   * @remarks\r\n   * This property is used to filter the data displayed in the grid.\r\n   * If not provided, no filtering will be applied.\r\n   * The filter model is an object that contains the filter items, logic operator, and other properties.\r\n   * For example:\r\n   * ```typescript\r\n   * const filterModel: GridFilterModel = {\r\n   *  items: [\r\n   *   { field: 'name', operator: 'contains', value: 'John' },\r\n   *  { field: 'age', operator: '>', value: 30 },\r\n   * ],\r\n   */\r\n  filter?: GridFilterModel;\r\n  /**\r\n   * @property {GridSortModel} [sort] - Optional sort model to specify sorting of the grid data.\r\n   * @remarks\r\n   * This property is used to determine the order in which the data is displayed\r\n   * in the grid.\r\n   * If not provided, the default sorting will be applied.\r\n   * The sorting model is an array of objects, each containing the field to sort by and the sort direction.\r\n   * For example:\r\n   * ```typescript\r\n   * const sortModel: GridSortModel = [\r\n   * { field: 'name', sort: 'asc' },\r\n   * { field: 'age', sort: 'desc' },\r\n   * ];\r\n   * ```\r\n   */\r\n  sort?: GridSortModel;\r\n};\r\n\r\n/**\r\n * Type representing the source of a filter, which can be a GridFilterModel,\r\n * LikeNextRequest, or undefined.\r\n *\r\n * @remarks\r\n * This type is used to define the source of the filter criteria for data grid components.\r\n * It can be a GridFilterModel object, a LikeNextRequest object, or undefined if no filter is applied.\r\n */\r\nexport type FilterBySourceType = GridFilterModel | LikeNextRequest | undefined;\r\n\r\n/**\r\n * Represents the response returned when a fetch operation for grid rows is cancelled.\r\n *\r\n * Extends {@link GridGetRowsResponse} and indicates that the operation was cancelled by setting `cancelled` to `true`.\r\n * The `rowCount` property is omitted in this case.\r\n * Optionally includes `pageInfo` with `hasNextPage` set to `true` if there are more pages available.\r\n */\r\nexport type CancelledFetchGridRowsResponse = GridGetRowsResponse & {\r\n  cancelled?: true;\r\n  rowCount?: never;\r\n  pageInfo?:\r\n    | {\r\n        hasNextPage: true;\r\n      }\r\n    | undefined;\r\n};\r\n\r\n/**\r\n * Represents the response from fetching rows for a data grid.\r\n *\r\n * This type can either be:\r\n * - A successful response extending `GridGetRowsResponse` (with an optional `cancelled` property explicitly set to `undefined`), or\r\n * - A `CancelledFetchGridRowsResponse` indicating that the fetch operation was cancelled.\r\n *\r\n * Use this type to handle both successful and cancelled fetch scenarios in data grid operations.\r\n */\r\nexport type FetchGridRowsResponse =\r\n  | (GridGetRowsResponse & {\r\n      cancelled?: never;\r\n    })\r\n  | CancelledFetchGridRowsResponse;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\useDataSource.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":474,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'noOp' is defined but never used.","line":238,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":238,"endColumn":22,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type {\r\n  GridFilterModel,\r\n  GridGetRowsParams,\r\n  GridPaginationModel,\r\n  GridSortModel,\r\n  GridUpdateRowParams,\r\n  GridGetRowsResponse,\r\n  GridValidRowModel,\r\n} from '@mui/x-data-grid-pro';\r\nimport type { DataSourceProps, ExtendedGridDataSource } from './types';\r\nimport { isError, isTruthy } from '@/lib/react-util/utility-methods';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\r\nimport { fetch } from '@/lib/nextjs-util/fetch';\r\nimport {\r\n  useQuery,\r\n  useMutation,\r\n  useQueryClient,\r\n  QueryClient,\r\n  // QueryClient,\r\n} from '@tanstack/react-query';\r\nimport { log } from '@/lib/logger';\r\n// import { has } from 'lodash';\r\n\r\n/**\r\n * Generates a unique query key for React Query based on the data source parameters.\r\n */\r\nconst createQueryKey = (\r\n  url: string,\r\n  page?: number,\r\n  pageSize?: number,\r\n  sortModel?: GridSortModel,\r\n  filterModel?: GridFilterModel,\r\n) => {\r\n  return ['dataGrid', url, page, pageSize, sortModel, filterModel] as const;\r\n};\r\n\r\n/**\r\n * Fetches data from the API endpoint with the given parameters.\r\n */\r\nconst fetchGridData = async (\r\n  url: string,\r\n  page?: number,\r\n  pageSize?: number,\r\n  sortModel?: GridSortModel,\r\n  filterModel?: GridFilterModel,\r\n): Promise<GridGetRowsResponse> => {\r\n  const urlWithParams = new URL(url);\r\n  if (pageSize) {\r\n    urlWithParams.searchParams.set('num', pageSize.toString());\r\n  }\r\n  if (page) {\r\n    urlWithParams.searchParams.set('page', (page + 1).toString()); // API is 1-based, DataGrid is 0-based\r\n  }\r\n\r\n  // Add sort parameters\r\n  if (sortModel?.length) {\r\n    const sortParams = sortModel\r\n      .map(({ field, sort }) => `${field}:${sort}`)\r\n      .join(',');\r\n    urlWithParams.searchParams.set('sort', sortParams);\r\n  }\r\n\r\n  // Add filter parameters\r\n  if (filterModel?.items?.length ?? filterModel?.quickFilterValues?.length) {\r\n    urlWithParams.searchParams.set('filter', JSON.stringify(filterModel));\r\n  }\r\n\r\n  const response = await fetch(urlWithParams.toString());\r\n\r\n  if (!response.ok) {\r\n    throw new Error(`Failed to fetch data: ${response.statusText}`);\r\n  }\r\n\r\n  const parsed = await response.json();\r\n  if (!parsed) {\r\n    throw new Error('No data returned from API');\r\n  }\r\n  if (typeof parsed === 'object') {\r\n    if ('rows' in parsed) {\r\n      return parsed;\r\n    }\r\n    if ('results' in parsed) {\r\n      const result: GridGetRowsResponse = {\r\n        rows: parsed.results as Array<GridValidRowModel>,\r\n      };\r\n      if (\r\n        'pageStats' in parsed &&\r\n        typeof parsed.pageStats === 'object' &&\r\n        !!parsed.pageStats &&\r\n        'total' in parsed.pageStats\r\n      ) {\r\n        result.rowCount = Number(parsed.pageStats.total);\r\n      }\r\n      return result;\r\n    }\r\n  }\r\n  throw new Error('Unexpected data format received from API', {\r\n    cause: parsed,\r\n  });\r\n};\r\n\r\n/**\r\n * Custom React hook for managing a data source for a MUI Data Grid component with React Query.\r\n *\r\n * This hook provides functionality for loading, updating, and handling errors for grid data,\r\n * including pagination, sorting, and filtering. It uses React Query for efficient data fetching,\r\n * caching, and state management.\r\n *\r\n * @param {DataSourceProps} params - The configuration object for the data source.\r\n * @param {string} params.url - The endpoint URL for fetching and updating data.\r\n * @param {Function} params.getRecordData - A function to extract record data from the response.\r\n * @returns {ExtendedGridDataSource} An object containing data source methods and state:\r\n * - `getRows`: Fetches rows with pagination, sorting, and filtering using React Query.\r\n * - `updateRow`: Updates a row in the data source.\r\n * - `onDataSourceError`: Handles and logs data source errors.\r\n * - `isLoading`: Indicates if a data operation is in progress.\r\n * - `clearLoadError`: Clears the current load error.\r\n * - `lastDataSourceError`: The current load error message, if any.\r\n *\r\n * @example\r\n * const dataSource = useDataSourceWithQuery({ url: '/api/data', getRecordData });\r\n * // Use dataSource.getRows, dataSource.updateRow, etc. in your grid component.\r\n */\r\nexport const useDataSource = ({\r\n  url: urlFromProps,\r\n}: DataSourceProps): ExtendedGridDataSource => {\r\n  const [currentQueryParams, setCurrentQueryParams] = useState<{\r\n    page?: number;\r\n    pageSize?: number;\r\n    sortModel?: GridSortModel;\r\n    filterModel?: GridFilterModel;\r\n  } | null>(null);\r\n\r\n  let url: string | URL = urlFromProps; // Initialize with default value\r\n  if (typeof window !== 'undefined') {\r\n    const searchParams = new URLSearchParams(window.location.search);\r\n    const isDrizzle = isTruthy(searchParams.get('drizzle'));\r\n    if (isDrizzle) {\r\n      const baseUrl = new URL(urlFromProps, window.location.origin);\r\n      url = new URL(\r\n        new URL(baseUrl.pathname + '/drizzle', window.location.origin),\r\n      );\r\n    } else {\r\n      url = urlFromProps;\r\n    }\r\n  }\r\n\r\n  const [hasMounted, setHasMounted] = useState(false);\r\n  const pendingQueries = useRef<\r\n    Array<[(x: GridGetRowsResponse) => void, (Error: unknown) => void]>\r\n  >([]);\r\n  useEffect(() => {\r\n    if (!hasMounted) {\r\n      setHasMounted(true);\r\n    }\r\n  }, [hasMounted]);\r\n  const queryClient: QueryClient = useQueryClient();\r\n  // Use React Query for data fetching\r\n  const {\r\n    isLoading,\r\n    isSuccess,\r\n    isPending,\r\n    error: queryError,\r\n    data,\r\n  } = useQuery({\r\n    queryKey: currentQueryParams\r\n      ? createQueryKey(\r\n          String(url),\r\n          currentQueryParams?.page,\r\n          currentQueryParams?.pageSize,\r\n          currentQueryParams?.sortModel,\r\n          currentQueryParams?.filterModel,\r\n        )\r\n      : ['dataGrid', String(url)],\r\n    queryFn: async () => {\r\n      return await fetchGridData(\r\n        String(url),\r\n        currentQueryParams?.page,\r\n        currentQueryParams?.pageSize,\r\n        currentQueryParams?.sortModel,\r\n        currentQueryParams?.filterModel,\r\n      );\r\n    },\r\n    refetchOnWindowFocus: false, // Don't refetch when window gains focus\r\n    refetchOnReconnect: true, // Refetch when connection is restored\r\n    enabled: hasMounted && !!currentQueryParams && !!url,\r\n    staleTime: 30 * 1000, // 30 seconds\r\n    gcTime: 5 * 60 * 1000, // 5 minutes\r\n    retry: (failureCount, error) => {\r\n      let willRetry = failureCount < 3;\r\n      if (error instanceof Error && 'status' in error) {\r\n        const status = (error as Error & { status: number }).status;\r\n        if (status >= 400 && status < 500) {\r\n          // Don't retry on a client error (bad request, url not found, unauthorized, etc.)\r\n          willRetry = false;\r\n        }\r\n      }\r\n      if (willRetry) {\r\n        log((l) =>\r\n          l.warn({\r\n            message: `An unexpected error occurred while loading data; there are ${3 - failureCount} retries remaining.  Details: ${isError(error) ? error.message : String(error)}`,\r\n            source: 'grid::dataSource',\r\n            data: error,\r\n          }),\r\n        );\r\n      } else {\r\n        LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n          log: true,\r\n          source: 'grid::dataSource',\r\n          data: error,\r\n        });\r\n      }\r\n      return willRetry;\r\n    },\r\n  });\r\n\r\n  useEffect(() => {\r\n    if (isPending) {\r\n      return;\r\n    }\r\n    const cancelQueries = (error: unknown) => {\r\n      log((l) =>\r\n        l.verbose(\r\n          'Cleaning up pending queries',\r\n          'error',\r\n          error,\r\n          'url',\r\n          url,\r\n          'currentQueryParams',\r\n          currentQueryParams,\r\n        ),\r\n      );\r\n      pendingQueries.current.forEach(([, reject]) => {\r\n        try {\r\n          reject(error);\r\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        } catch (noOp) {\r\n          // Already logged failure\r\n        }\r\n      });\r\n      pendingQueries.current = [];\r\n    };\r\n    if (isSuccess && data) {\r\n      // If we have data, resolve any pending queries\r\n      log((l) =>\r\n        l.verbose(\r\n          'useDataSource::query resolved with data',\r\n          data,\r\n          'url',\r\n          url,\r\n          'currentQueryParams',\r\n          currentQueryParams,\r\n        ),\r\n      );\r\n      pendingQueries.current.forEach(([resolve]) => resolve(data));\r\n      pendingQueries.current = [];\r\n      return;\r\n    }\r\n    if (queryError && pendingQueries.current.length > 0) {\r\n      cancelQueries(queryError);\r\n      return;\r\n    }\r\n    return () => {\r\n      // Cleanup function to clear pending queries on unmount or when query state changes\r\n      if (!pendingQueries.current?.length) {\r\n        return;\r\n      }\r\n      cancelQueries(new Error('Component unmounted or query state changed'));\r\n    };\r\n  }, [isSuccess, queryError, data, url, currentQueryParams, isPending]);\r\n\r\n  // Mutation for updating rows\r\n  const updateRowMutation = useMutation({\r\n    mutationFn: async (params: GridUpdateRowParams) => {\r\n      const response = await fetch(String(url), {\r\n        method: 'PUT',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify(params.updatedRow),\r\n      });\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to update row: ${response.statusText}`);\r\n      }\r\n      return response.json();\r\n    },\r\n    onSuccess: () => {\r\n      // Invalidate and refetch relevant queries\r\n      queryClient.invalidateQueries({\r\n        queryKey: ['dataGrid', String(url)],\r\n      });\r\n    },\r\n    onError: (error) => {\r\n      const le = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n        log: false,\r\n        source: 'grid::dataSource::update',\r\n      });\r\n      log((l) =>\r\n        l.error(\r\n          'useDataSource::updateRowMutation::error',\r\n          le.message,\r\n          'url',\r\n          url,\r\n        ),\r\n      );\r\n    },\r\n    retry: (failureCount, error) => {\r\n      // Don't retry mutations on 4xx errors\r\n      if (error instanceof Error && 'status' in error) {\r\n        const status = (error as Error & { status: number }).status;\r\n        if (status >= 400 && status < 500) {\r\n          return false;\r\n        }\r\n      }\r\n      // Retry up to 2 times for other errors\r\n      return failureCount < 2;\r\n    },\r\n  });\r\n\r\n  /**\r\n   * Updates a row in the data source using React Query mutation.\r\n   */\r\n  const updateRow = useCallback(\r\n    async (params: GridUpdateRowParams) => {\r\n      // return Promise.resolve(params);\r\n\r\n      try {\r\n        return await updateRowMutation.mutateAsync(params);\r\n      } catch (err) {\r\n        throw err;\r\n      }\r\n    },\r\n    [updateRowMutation],\r\n  );\r\n\r\n  /**\r\n   * Handles errors encountered during data source operations.\r\n   */\r\n  const onDataSourceError = useCallback(\r\n    (error: unknown) => {\r\n      if (!Object.is(error, queryError)) {\r\n        log((l) =>\r\n          l.warn('onDataSourceError::error is not query error...', { error }),\r\n        );\r\n      }\r\n    },\r\n    [queryError],\r\n  );\r\n\r\n  /**\r\n   * Fetches rows using React Query with pagination, sorting, and filtering.\r\n   */\r\n  const getRows = useCallback(\r\n    (props: GridGetRowsParams) => {\r\n      try {\r\n        const {\r\n          paginationModel: {\r\n            pageSize = 10,\r\n            page = 0,\r\n          } = {} as GridPaginationModel,\r\n          sortModel = [] as GridSortModel,\r\n          filterModel = { items: [] } as GridFilterModel,\r\n        } = props;\r\n\r\n        // Update query parameters to trigger React Query\r\n        setCurrentQueryParams((current) => {\r\n          if (\r\n            !current ||\r\n            current.page !== page ||\r\n            current.pageSize !== pageSize ||\r\n            JSON.stringify(current.sortModel) !== JSON.stringify(sortModel) ||\r\n            JSON.stringify(current.filterModel) !== JSON.stringify(filterModel)\r\n          ) {\r\n            return {\r\n              page,\r\n              pageSize,\r\n              sortModel,\r\n              filterModel,\r\n            };\r\n          }\r\n          return current;\r\n        });\r\n\r\n        const queryKey = createQueryKey(\r\n          String(url),\r\n          page,\r\n          pageSize,\r\n          sortModel,\r\n          filterModel,\r\n        );\r\n\r\n        return new Promise<GridGetRowsResponse>((resolve, reject) => {\r\n          const timeout = setTimeout(() => {\r\n            try {\r\n              if (isSuccess) {\r\n                log((l) =>\r\n                  l.warn(\r\n                    'getRows::query timed out - resolving with last known good data to prevent promise memory leak',\r\n                    'queryKey',\r\n                    queryKey,\r\n                    'url',\r\n                    url,\r\n                  ),\r\n                );\r\n                resolve(data);\r\n              }\r\n\r\n              log((l) =>\r\n                l.warn(\r\n                  'getRows::query timed out - rejecting promise',\r\n                  'queryKey',\r\n                  queryKey,\r\n                  'url',\r\n                  url,\r\n                ),\r\n              );\r\n              // Reject the promise if it takes too long\r\n              reject(\r\n                new Error(\r\n                  `Query for ${queryKey.join(', ')} timed out after 30 seconds`,\r\n                ),\r\n              );\r\n            } catch (err) {\r\n              log((l) =>\r\n                l.warn(\r\n                  'Unexpected error caught in getRows proxy resolution.',\r\n                  err,\r\n                ),\r\n              );\r\n            }\r\n          }, 60 * 1000); // 60 seconds timeout\r\n          const wrapCleanup = <X, Y>(cb: (y: X) => Y): ((y: X) => Y) => {\r\n            return (arg: X) => {\r\n              clearTimeout(timeout);\r\n              return cb(arg);\r\n            };\r\n          };\r\n          pendingQueries.current.push([\r\n            wrapCleanup(resolve),\r\n            wrapCleanup(reject),\r\n          ]);\r\n        });\r\n      } catch (err: unknown) {\r\n        log((l) =>\r\n          l.verbose(\r\n            'getRows::error occurred - rethrowing to react query for disposition',\r\n            err,\r\n          ),\r\n        );\r\n        throw err;\r\n      }\r\n    },\r\n    [url, isSuccess, data, setCurrentQueryParams],\r\n  );\r\n\r\n  // Memoize the data source object to prevent unnecessary re-renders\r\n  return useMemo<ExtendedGridDataSource>(() => {\r\n    return {\r\n      getRows,\r\n      updateRow,\r\n      onDataSourceError,\r\n      isLoading: /*!hasMounted || */ isLoading || updateRowMutation.isPending,\r\n      loadError: queryError ? queryError.message : null,\r\n    };\r\n  }, [\r\n    getRows,\r\n    updateRow,\r\n    onDataSourceError,\r\n    // hasMounted,\r\n    isLoading,\r\n    updateRowMutation.isPending,\r\n    queryError,\r\n  ]);\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\data-grid\\useGetRowId.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":43,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type {\r\n  GridRowId,\r\n  GridRowIdGetter,\r\n  GridRowModel,\r\n  GridValidRowModel,\r\n} from '@mui/x-data-grid-pro';\r\n\r\n/**\r\n * Application-global map of grid id getters from fiven fields\r\n */\r\nconst GridRowGetterDictionary = new Map<string, GridRowIdGetter>();\r\n\r\n/**\r\n * Returns a memoized row ID getter function for a specified field.\r\n *\r\n * This hook retrieves a function that extracts the row ID from a given row object\r\n * using the provided field name. The getter function is cached for each unique field\r\n * to avoid unnecessary re-creation and improve performance.\r\n *\r\n * @param field - The name of the field in the row object to use as the row ID.\r\n * @returns A function that takes a row and returns its ID based on the specified field.\r\n * @throws If the row does not contain the required field.\r\n */\r\nexport const useGetRowId = (\r\n  field: string,\r\n): GridRowIdGetter<GridValidRowModel> => {\r\n  let ret = GridRowGetterDictionary.get(field);\r\n  if (!ret) {\r\n    ret = (row: GridRowModel): GridRowId => {\r\n      const rowId = row?.[field] as string;\r\n      if (!rowId) {\r\n        throw new Error(`Row is missing required field: ${field}`);\r\n      }\r\n      return rowId as GridRowId;\r\n    };\r\n    // Cache the getter for future use\r\n    // This allows us to avoid creating a new function every time this hook is called\r\n    // and instead re-uses the same function instance for a given field name.\r\n    GridRowGetterDictionary.set(field, ret);\r\n  }\r\n  return ret;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\components\\mui\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\config\\bundle-analyzers.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":44,"column":1,"nodeType":"Program","endLine":91,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":60,"column":10,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":60,"endColumn":42,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\n\r\n/**\r\n * Bundle Analyzer Integration Helpers\r\n * --------------------------------------------------------------\r\n * This module provides small, typed utility wrappers for conditionally\r\n * enabling the `@next/bundle-analyzer` plugin inside `next.config.{js,ts}`.\r\n *\r\n * RATIONALE\r\n * Keeping this logic isolated:\r\n *  - Avoids inline `require` calls in your main Next.js config (cleaner & testable).\r\n *  - Centralizes the environment flag (`ANALYZE`) semantics.\r\n *  - Makes it easy to compose with other higher‑order config functions.\r\n *\r\n * ENVIRONMENT FLAG\r\n *  Set `ANALYZE=true` (e.g. via CLI or .env file) to enable the analyzer.\r\n *  When enabled, a static visual report for each bundle (client & server) is\r\n *  generated during build without auto‑opening a browser window.\r\n *\r\n * EXAMPLE (next.config.ts)\r\n * ```ts\r\n * import type { NextConfig } from 'next';\r\n * import { withBundleAnalyzer } from './lib/config/bundle-analyzers';\r\n *\r\n * // const baseConfig: NextConfig = { ... };\r\n * export default withBundleAnalyzer(baseConfig);\r\n * ```\r\n *\r\n * DISABLING\r\n *  Omit the env var or set `ANALYZE=false` (default) and the wrapper becomes\r\n *  a no‑op returning the original configuration unchanged.\r\n *\r\n * TESTING STRATEGY\r\n *  - Unit test can inject `process.env.ANALYZE = 'true'` and assert that the\r\n *    returned config has analyzer plugin side effects (or the module factory\r\n *    is invoked). For safety, restore the env var afterwards.\r\n *\r\n * NOTES\r\n *  - Uses `require` instead of `import` to prevent the analyzer dependency\r\n *    from being loaded at all when not needed (micro‑optimization & avoids\r\n *    potential ESM interop quirks in certain Node versions).\r\n */\r\n\r\nimport { NextConfig } from \"next\";\r\n\r\n/**\r\n * Internal helper that always applies the analyzer to the provided Next.js\r\n * configuration object regardless of the `ANALYZE` environment flag.\r\n *\r\n * The generic type `TArg` (typically `NextConfig`) is preserved so downstream\r\n * tooling retains accurate typings.\r\n *\r\n * @internal Prefer using {@link withBundleAnalyzer} unless you explicitly need\r\n *           unconditional application (e.g. in a bespoke build script).\r\n * @param config - Original Next.js configuration object.\r\n * @returns The mutated (wrapped) configuration produced by the analyzer.\r\n */\r\nconst applyBundleAnalyzer = <TArg extends NextConfig>(config: TArg): TArg => {\r\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\r\n  return require('@next/bundle-analyzer')({\r\n    enabled: true,\r\n    openAnalyzer: false,\r\n  })(config);\r\n}\r\n\r\n/**\r\n * Conditionally wraps a Next.js configuration object with the\r\n * `@next/bundle-analyzer` plugin only when `process.env.ANALYZE === 'true'`.\r\n * Otherwise returns the input configuration unchanged (transparent no‑op).\r\n *\r\n * Typical usage is a simple export in `next.config.ts` so that local or CI\r\n * builds can opt‑in to bundle visualization without touching source.\r\n *\r\n * @example\r\n * ```ts\r\n * // next.config.ts\r\n * import { withBundleAnalyzer } from './lib/config/bundle-analyzers';\r\n * export default withBundleAnalyzer({ reactStrictMode: true });\r\n * ```\r\n *\r\n * @typeParam TArg - Concrete shape of the Next.js config (inferred).\r\n * @param config - Original Next.js configuration object.\r\n * @returns Either the analyzer‑enhanced config (when enabled) or the original.\r\n */\r\nexport const withBundleAnalyzer = <TArg extends NextConfig>(config: TArg): TArg => {\r\n  if (process.env.ANALYZE === 'true') {\r\n    return applyBundleAnalyzer(config);\r\n  }\r\n  return config;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\config\\ignore-unsupported-packs-plugin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\config\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\config\\public-env.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":116,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextConfigPlugin } from './types';\r\n\r\n/**\r\n * Public Environment Configuration (Next.js)\r\n * --------------------------------------------------------------\r\n * Centralized, typed access to environment variables that are considered\r\n * safe for inclusion in the browser bundle. In Next.js only variables whose\r\n * names begin with `NEXT_PUBLIC_` are automatically inlined into client builds.\r\n *\r\n * This module performs three related duties:\r\n * 1. Documents every public runtime environment variable the application relies on.\r\n * 2. Provides a single import location to aid discoverability and tree‑shaking.\r\n * 3. Normalizes (and where appropriate, mirrors) select values so fallback\r\n *    logic lives in one place instead of being repeated across the codebase.\r\n *\r\n * SECURITY NOTE\r\n * Do NOT add secrets, credentials, API keys (without explicit public intent),\r\n * or any sensitive values here. Anything placed in this object that starts\r\n * with `NEXT_PUBLIC_` is baked into the shipped JavaScript and becomes visible\r\n * to end users. Treat this file as public surface area documentation.\r\n *\r\n * TELEMETRY CONNECTION STRING HANDLING\r\n * The property `AZURE_MONITOR_CONNECTION_STRING` (without the `NEXT_PUBLIC_`\r\n * prefix) is deliberately included as a convenience mirror to allow server\r\n * code to access either the private value (if set) or fall back to the\r\n * public one. Because it does NOT start with `NEXT_PUBLIC_`, Next.js will NOT\r\n * expose its value to client bundles; any client‑side reference to it will\r\n * evaluate to its literal (likely `undefined`) at build time. This is safe\r\n * provided no confidential value is leaked through the fallback chain.\r\n *\r\n * USAGE EXAMPLE\r\n * ```ts\r\n * import { PublicEnv } from '@/lib/config/public-env';\r\n *\r\n * console.info('Client log level:', PublicEnv.NEXT_PUBLIC_LOG_LEVEL_CLIENT);\r\n * ```\r\n *\r\n * EXTENDING\r\n * When adding a new public variable:\r\n * 1. Add it to your runtime environment (.env*.local, deployment config, etc.).\r\n * 2. Confirm the name starts with `NEXT_PUBLIC_`.\r\n * 3. Append a documented entry below with a concise description.\r\n * 4. Avoid transforming / parsing here; keep this layer a thin mapping.\r\n */\r\n\r\n/**\r\n * Shape (compile‑time) of the exported `PublicEnv` object.\r\n * Useful for generic utilities that operate over the set of public env keys.\r\n */\r\nexport type PublicEnvShape = typeof PublicEnv;\r\n\r\n/**\r\n * Union of all public environment variable keys.\r\n */\r\nexport type PublicEnvKey = keyof typeof PublicEnv;\r\n\r\n/**\r\n * Union type of all public environment variable values (string | undefined literals).\r\n */\r\nexport type PublicEnvValue = (typeof PublicEnv)[PublicEnvKey];\r\n\r\n/**\r\n * Canonical collection of public (and safe mirrored) environment variables.\r\n * All properties are `readonly` via `as const` to preserve literal types.\r\n */\r\nexport const PublicEnv = {\r\n  /**\r\n   * Base hostname, scheme, and port used for constructing absolute URLs on the client.\r\n   * Example: `https://app.example.com`\r\n   */\r\n  NEXT_PUBLIC_HOSTNAME: process.env.NEXT_PUBLIC_HOSTNAME,\r\n\r\n  /**\r\n   * Minimum log level for client‑side logging infrastructure.\r\n   * Expected values commonly include: `debug`, `info`, `warn`, `error`.\r\n   * Used to filter browser console / telemetry noise in production.\r\n   */\r\n  NEXT_PUBLIC_LOG_LEVEL_CLIENT: process.env.NEXT_PUBLIC_LOG_LEVEL_CLIENT,\r\n\r\n  /**\r\n   * Public (non‑secret) Azure Monitor connection string variant. Some\r\n   * deployments may choose to expose a limited or proxy endpoint publicly\r\n   * for client telemetry. Prefer the private value where available.\r\n  AZURE_MONITOR_CONNECTION_STRING:\r\n    process.env.AZURE_MONITOR_CONNECTION_STRING,\r\n   */\r\n\r\n  /**\r\n   * Server‑side Azure Monitor connection string with fallback to the\r\n   * public variant if the private one is not defined. This property itself\r\n   * is NOT made public by Next.js (no `NEXT_PUBLIC_` prefix), so runtime\r\n   * options will not be available but the value present at compile time will\r\n   * persist.\r\n   */\r\n  AZURE_MONITOR_CONNECTION_STRING: process.env.AZURE_MONITOR_CONNECTION_STRING,\r\n\r\n  /**\r\n   * Optional Material UI (MUI) license key required for certain premium\r\n   * component packages. Exposed publicly because the library expects the\r\n   * value in browser context; ensure the key is intended for client use.\r\n   */\r\n  NEXT_PUBLIC_MUI_LICENSE: process.env.NEXT_PUBLIC_MUI_LICENSE,\r\n} as const;\r\n\r\nexport const withPublicEnv: NextConfigPlugin = (nextConfig) => {\r\n  return {\r\n    ...nextConfig,\r\n    publicRuntimeConfig: {\r\n      ...(nextConfig.publicRuntimeConfig ?? {}),\r\n      ...PublicEnv,\r\n    },\r\n  };\r\n};\r\n\r\nexport default PublicEnv;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\config\\react-config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\config\\strip-rsc-prefix-plugin.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":66,"column":1,"nodeType":"Program","endLine":150,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Webpack plugin: StripRscPrefixPlugin\r\n * --------------------------------------------------------------\r\n * Purpose\r\n *   Next.js (React Server Components / SSR) sometimes emits source maps whose\r\n *   `sources` entries are prefixed with synthetic roots like:\r\n *     /(rsc)/./lib/ai/middleware/chat-history/import-incoming-message.ts\r\n *     /(rsc)/lib/ai/... or (rsc)/./lib/...\r\n *     /(ssr)/... (observed for certain server bundles)\r\n *   These virtual path segments break debugger resolution (VS Code / Chrome)\r\n *   because no real directory named `(rsc)` or `(ssr)` exists inside the\r\n *   workspace. The result is: \"Source not found\" when setting breakpoints.\r\n *\r\n * What this plugin does\r\n *   - Runs during the `PROCESS_ASSETS_STAGE_DEV_TOOLING` stage.\r\n *   - Scans every emitted `*.map` asset.\r\n *   - If any source path contains `(rsc)` or `(ssr)` at its start (optionally\r\n *     preceded by a slash) with optional `./` segments, it rewrites the prefix\r\n *     to a single leading slash `/` so the remainder of the path becomes\r\n *     relative to the project root (which standard sourceMapPathOverrides can\r\n *     then map to the workspace).\r\n *\r\n * Regex logic (see `normalize`):\r\n *     ^\\/?\\((?:rsc|ssr)\\)\\/(?:\\.\\/*)?\r\n *   Breakdown:\r\n *     ^            : start of string\r\n *     \\/?          : optional leading slash\r\n *     \\(           : literal '('\r\n *     (?:rsc|ssr)  : either 'rsc' or 'ssr'\r\n *     \\)           : literal ')'\r\n *     \\/           : following slash\r\n *     (?:\\.\\/*)?  : zero or one sequence of \"./\" possibly with extra slashes\r\n *\r\n * Why fix the grouping\r\n *   The previous pattern `^\\/?\\(rsc|ssr\\)\\/` incorrectly alternated between\r\n *   the literal substring \"(rsc\" and \"ssr)\" (due to the placement of `|`),\r\n *   so it would *never* match fully-formed prefixes `(rsc)/` or `(ssr)/`.\r\n *   This patch corrects the alternation so both markers normalize properly.\r\n *\r\n * Performance considerations\r\n *   - Operates only on `.map` assets.\r\n *   - Parses JSON once per map containing the tokens; unaffected maps are\r\n *     skipped quickly via `includes` guard.\r\n *   - Complexity is O(n) in number of maps + O(m) in number of sources entries.\r\n *\r\n * Safety / Failure modes\r\n *   - Malformed JSON source maps are ignored (best-effort approach).\r\n *   - Non-matching sources remain untouched.\r\n *   - If Next.js changes its virtual prefix format, extend the regex.\r\n *\r\n * Integration (Next.js `next.config.{js,ts}`):\r\n *   import { StripRscPrefixPlugin } from './lib/config/strip-rsc-prefix-plugin';\r\n *   export default {\r\n *     webpack(config) {\r\n *       config.plugins.push(StripRscPrefixPlugin);\r\n *       return config;\r\n *     }\r\n *   };\r\n *\r\n * Testing suggestions\r\n *   - Build (or dev) with a known RSC map, then grep the resulting `.map` for\r\n *     `\"/(rsc)/\"` before and after enabling the plugin.\r\n *   - Add a Jest snapshot test that feeds a small fabricated source map object\r\n *     through the `normalize` logic (extracted if you want stronger tests).\r\n */\r\nimport type { NextConfig } from 'next';\r\nimport type { WebpackCompilation, WebpackPlugin, WebpackCompiler, RawSourceClassProps, WebpackAsset } from \"./types\";\r\n\r\n/**\r\n * Webpack plugin object normalizing nextjs source maps.\r\n * @public\r\n */\r\nexport const StripRscPrefixPlugin: WebpackPlugin = {\r\n  apply(compiler: WebpackCompiler) {\r\n    compiler.hooks.compilation.tap(\r\n      'StripRscPrefixPlugin',\r\n      (compilation: WebpackCompilation) => {\r\n        compilation.hooks.processAssets.tap(\r\n          {\r\n            name: 'StripRscPrefixPlugin',\r\n            stage:\r\n              compiler.webpack.Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING,\r\n          },\r\n          (assets: Record<PropertyKey, RawSourceClassProps | WebpackAsset>) => {\r\n            for (const [name, asset] of Object.entries(assets)) {\r\n              if (!name.endsWith('.map')) continue;\r\n              const raw = String(\r\n                typeof asset.source === 'function'\r\n                  ? asset.source()\r\n                  : asset.source,\r\n              );\r\n              if (!raw.includes('(rsc)') && !raw.includes('(ssr)')) continue;\r\n              try {\r\n                const map = JSON.parse(raw);\r\n\r\n                // Normalize any leading (rsc)/, /(rsc)/, (rsc)/./, /(rsc)/./\r\n                // Pattern explanation:\r\n                // ^         -> start\r\n                // /?        -> optional leading slash\r\n                // \\(rsc\\)/  -> literal (rsc)/\r\n                // (?:\\./)*  -> optional one or more './'\r\n                /**\r\n                 * Normalize a single source path by removing a leading synthetic\r\n                 * `(rsc)` / `(ssr)` prefix (optionally with leading slash and `./`),\r\n                 * collapsing it to a single root slash.\r\n                 * @param s Raw source path value from a source map.\r\n                 * @returns Normalized path (unchanged if no synthetic prefix).\r\n                 */\r\n                const normalize = (s: string): string => {\r\n                  if (!s.includes('(rsc)') && !s.includes('(ssr)')) return s;\r\n                  // Correct grouping: match \"(rsc)\" or \"(ssr)\" token at start.\r\n                  let out = s.replace(/^\\/?\\((?:rsc|ssr)\\)\\/(?:\\.\\/*)?/, '/');\r\n                  // Guard against accidental doubled slashes after replacement.\r\n                  out = out.replace(/^\\/+/, '/');\r\n                  return out;\r\n                };\r\n\r\n                map.sources = map.sources.map((s: string) => normalize(s));\r\n\r\n                compilation.updateAsset(\r\n                  name,\r\n                  new compiler.webpack.sources.RawSource(JSON.stringify(map)),\r\n                );\r\n              } catch {\r\n                // ignore malformed map\r\n              }\r\n            }\r\n          },\r\n        );\r\n      },\r\n    );\r\n  },\r\n};\r\n\r\nexport const withStripRscPrefixPlugin = <\r\n  TArg extends NextConfig\r\n>(\r\n  nextConfig: TArg\r\n): TArg => {\r\n    const originalWebpack = nextConfig.webpack;\r\n    return {\r\n      ...nextConfig,\r\n      webpack: ((config, args) => {\r\n        config = originalWebpack?.(config, args) ?? config;\r\n        config.plugins.push(StripRscPrefixPlugin);\r\n        return config;\r\n      }) as NextConfig['webpack'],\r\n    } as TArg;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\config\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\config\\typescript-config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\drizzle-db\\connection.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":209,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1828,1831],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1828,1831],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":125,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4536,4539],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4536,4539],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { drizzle } from 'drizzle-orm/postgres-js';\r\nimport schema, { DbDatabaseType } from './schema';\r\nimport { isPromise } from '@/lib/typescript/_guards';\r\nimport { LoggedError } from '../react-util';\r\n\r\n/**\r\n * Drizzle DB connection helpers\r\n *\r\n * This module lazily initializes a Drizzle ORM `DbDatabaseType` instance using\r\n * a pg driver provided by `../neondb/connection`. The initialized instance is\r\n * cached on `globalThis.__obapps` so it survives module reloads and is shared\r\n * across the process. Two convenience entry points are provided:\r\n *\r\n * - `drizDbWithInit()` — async initializer that will wait for initialization\r\n *   and optionally run a callback with the initialized db.\r\n * - `drizDb()` — synchronous accessor that returns the initialized db or\r\n *   throws when initialization is in progress. It also accepts a callback\r\n *   which is invoked with the db when available.\r\n */\r\n\r\nexport { schema };\r\n\r\n/**\r\n * Webpack-safe singleton keys using Symbol.for() to ensure uniqueness across all chunks.\r\n * This approach prevents module duplication issues where different webpack bundles\r\n * would otherwise create separate singleton instances.\r\n */\r\nconst DB_INSTANCE_KEY = Symbol.for('@noeducation/drizzle-db-instance');\r\nconst DB_PROMISE_KEY = Symbol.for('@noeducation/drizzle-db-promise');\r\nconst PG_DRIVER_KEY = Symbol.for('@noeducation/pg-driver-factory');\r\n\r\n/**\r\n * Global registry interface using symbols for webpack-safe singleton access.\r\n * Symbols created with Symbol.for() are globally registered and shared across\r\n * all webpack chunks, preventing duplicate singleton instances.\r\n */\r\ninterface GlobalDbRegistry {\r\n  [DB_INSTANCE_KEY]?: DbDatabaseType;\r\n  [DB_PROMISE_KEY]?: Promise<DbDatabaseType>;\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  [PG_DRIVER_KEY]?: any;\r\n}\r\n\r\n/**\r\n * Accessor for the currently stored Drizzle DB initialization promise.\r\n * Returns undefined before initialization has occurred; otherwise resolves\r\n * to {@link drizDb}.\r\n */\r\nconst get_DrizDbPromise = (): Promise<DbDatabaseType> | undefined =>\r\n  (globalThis as GlobalDbRegistry)[DB_PROMISE_KEY];\r\n\r\n/**\r\n * Setter for the Drizzle DB initialization promise. Passing `undefined`\r\n * clears the stored promise.\r\n */\r\nconst set_DrizDbPromise = (\r\n  db: Promise<DbDatabaseType> | undefined,\r\n): Promise<DbDatabaseType> | undefined => {\r\n  (globalThis as GlobalDbRegistry)[DB_PROMISE_KEY] = db;\r\n  return db;\r\n};\r\n\r\n/**\r\n * Returns the initialized Drizzle DB instance if available, or undefined.\r\n */\r\nconst get_DrizDb = (): DbDatabaseType | undefined =>\r\n  (globalThis as GlobalDbRegistry)[DB_INSTANCE_KEY];\r\n\r\ninterface DrizDbInitOverloads {\r\n  /**\r\n   * Wait for Drizzle DB initialization and return the db instance.\r\n   */\r\n  (): Promise<DbDatabaseType>;\r\n  /**\r\n   * Wait for initialization and invoke the provided callback with the db.\r\n   * The callback may return a value or a promise; the return type is preserved.\r\n   */\r\n  <T>(\r\n    then: (db: DbDatabaseType) => T,\r\n  ): T extends Promise<infer R> ? Promise<R> : Promise<T>;\r\n}\r\n\r\nconst getPostgresDriver = async () => {\r\n  let connection = (globalThis as GlobalDbRegistry)[PG_DRIVER_KEY];\r\n  if (!connection) {\r\n    try {\r\n      const postgresql = await import('../neondb/connection');\r\n      connection = postgresql.pgDbWithInit;\r\n      (globalThis as GlobalDbRegistry)[PG_DRIVER_KEY] = connection;\r\n    } catch (error) {\r\n      throw new Error('Failed to load postgresjs driver', {\r\n        cause: error,\r\n      });\r\n    }\r\n  }\r\n  return connection();\r\n};\r\n\r\n/**\r\n * Ensure the Drizzle DB is initialized and optionally run a callback with the db.\r\n *\r\n * When called without a callback the function resolves to the initialized\r\n * `DbDatabaseType`. When called with a callback the callback will be invoked\r\n * once the db is available and its result is returned (promisified if needed).\r\n */\r\nexport const drizDbWithInit: DrizDbInitOverloads = <T>(\r\n  cb?: (db: DbDatabaseType) => T,\r\n) => {\r\n  const resolver = async (db: DbDatabaseType) => {\r\n    if (cb) {\r\n      const fnRet = cb(db);\r\n      const pRet = isPromise<T>(fnRet) ? await fnRet : fnRet;\r\n      return pRet;\r\n    }\r\n    return Promise.resolve(db) as T;\r\n  };\r\n  const drizDb = get_DrizDb();\r\n  if (!!drizDb) {\r\n    return Promise.resolve(drizDb).then(resolver);\r\n  }\r\n  let drizDbPromise = get_DrizDbPromise();\r\n  if (!drizDbPromise) {\r\n    drizDbPromise = getPostgresDriver()\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      .then((sql: any) => {\r\n        const value = drizzle(sql, {\r\n          casing: 'snake_case',\r\n          schema,\r\n        });\r\n        (globalThis as GlobalDbRegistry)[DB_INSTANCE_KEY] = value;\r\n        return value;\r\n      });\r\n    if (drizDbPromise) {\r\n      set_DrizDbPromise(drizDbPromise);\r\n      drizDbPromise.catch((err) => {\r\n        const le = LoggedError.isTurtlesAllTheWayDownBaby(err, {\r\n          log: true,\r\n          message: 'Error initializing Drizzle DB',\r\n          extra: {\r\n            cause: err,\r\n          },\r\n          source: 'drizDbWithInit',\r\n        });\r\n        // Reset stored promise on error so future callers can retry initialization\r\n        set_DrizDbPromise(undefined);\r\n        throw le;\r\n      });\r\n    } else {\r\n      throw new Error(\r\n        'Failed to initialize Drizzle DB - could not create dbPromise',\r\n      );\r\n    }\r\n  }\r\n  return drizDbPromise.then(resolver) as Promise<T>;\r\n};\r\n\r\ninterface DrizDbOverloads {\r\n  /** Return the initialized Drizzle DB synchronously. Throws when initialization is in progress. */\r\n  (): DbDatabaseType;\r\n  /** Invoke the provided function with the initialized db and return its result (promisified if needed). */\r\n  <T>(\r\n    fn: (driz: DbDatabaseType) => T,\r\n  ): T extends Promise<infer R> ? Promise<R> : Promise<T>;\r\n}\r\n\r\n/**\r\n * Synchronous accessor for the Drizzle DB instance.\r\n *\r\n * If the DB is already initialized the function returns the instance or, when\r\n * a callback is provided, invokes the callback with the db. When the DB is not\r\n * yet initialized this function will throw, signaling callers to retry or\r\n * await initialization via `drizDbWithInit()`.\r\n */\r\nexport const drizDb: DrizDbOverloads = <T>(\r\n  fn?: (driz: DbDatabaseType) => T,\r\n) => {\r\n  const drizDb = get_DrizDb();\r\n  if (drizDb) {\r\n    if (fn) {\r\n      const fnRet = fn(drizDb);\r\n      return isPromise(fnRet) ? fnRet : Promise.resolve(fnRet);\r\n    }\r\n    return get_DrizDb();\r\n  }\r\n  // Queue up initialization if not already started so callers can observe it.\r\n  const dbWithInit = drizDbWithInit();\r\n  dbWithInit.catch((err) => {\r\n    LoggedError.isTurtlesAllTheWayDownBaby(err, {\r\n      log: true,\r\n      message: 'Error initializing Drizzle DB',\r\n      extra: {\r\n        cause: err,\r\n      },\r\n      source: 'drizDb initialize',\r\n    });\r\n    return Promise.resolve();\r\n  });\r\n  throw new Error(\r\n    'Drizzle DB is being initialized; please try your call again later.',\r\n    {\r\n      cause: {\r\n        code: 'DB_INITIALIZING',\r\n        retry: true,\r\n        enqueue: dbWithInit.then,\r\n      },\r\n    },\r\n  );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\drizzle-db\\db-helpers.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":330,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { eq, and } from 'drizzle-orm';\r\nimport {\r\n  documentRelationship,\r\n  documentRelationshipReason,\r\n  documentUnits,\r\n  documentProperty,\r\n} from '@/drizzle/schema';\r\nimport type {\r\n  DatabaseType,\r\n  DbTransactionType,\r\n  DocumentPropertyType,\r\n  DocumentRelationshipType,\r\n} from './drizzle-types';\r\nimport { schema } from './schema';\r\nimport { log } from '@/lib/logger';\r\nimport { LoggedError } from '../react-util';\r\nimport { newUuid } from '../typescript';\r\nimport { EmailPropertyTypeTypeId } from '@/data-models/api/email-properties/property-type';\r\n\r\n/**\r\n * Resolves a relationship reason into a valid relationship reason ID.\r\n *\r\n * @param db - The database instance or transaction to use.\r\n * @param reason - The reason to resolve, which can be a string, number, or undefined.\r\n * @param add - Whether to add the reason to the database if it does not exist. Defaults to true.\r\n * @returns The resolved relationship reason ID, or undefined if the reason is invalid.\r\n *\r\n * @example\r\n * ```typescript\r\n * const reasonId = await getDocumentRelationReason({\r\n *   db,\r\n *   reason: 'Duplicate',\r\n *   add: true,\r\n * });\r\n * console.log(reasonId); // Outputs the ID of the reason\r\n * ```\r\n */\r\nexport const getDocumentRelationReason = async ({\r\n  db,\r\n  reason,\r\n  add = true,\r\n}: {\r\n  db: DatabaseType | DbTransactionType;\r\n  add?: boolean;\r\n  reason: string | number | undefined | null;\r\n}) => {\r\n  if (typeof reason === 'number') {\r\n    return reason;\r\n  }\r\n  const normalized = reason?.toString()?.trim()?.toLowerCase();\r\n  if (!normalized) {\r\n    return undefined;\r\n  }\r\n  const alreadyNumber = Number(normalized);\r\n  if (!isNaN(alreadyNumber)) {\r\n    return alreadyNumber;\r\n  }\r\n  const rows =\r\n    (await db\r\n      .select({\r\n        relationReasonId: schema.documentRelationshipReason.relationReasonId,\r\n      })\r\n      .from(schema.documentRelationshipReason)\r\n      .where(eq(schema.documentRelationshipReason.description, normalized))\r\n      .limit(1)\r\n      .execute()) ?? [];\r\n  if (rows.length > 0) {\r\n    const { relationReasonId } = rows[0];\r\n    if (relationReasonId || !add) {\r\n      return relationReasonId;\r\n    }\r\n  }\r\n  const [{ relationReasonId: newRelationReasonId } = {}] = await db\r\n    .insert(documentRelationshipReason)\r\n    .values({ description: normalized })\r\n    .returning();\r\n  return newRelationReasonId;\r\n};\r\n\r\ntype LikeDocumentRelationshipType = Omit<\r\n  DocumentRelationshipType,\r\n  'timestamp' | 'relationshipReasonId'\r\n> & {\r\n  relationshipReasonId: number | string;\r\n};\r\n\r\n/**\r\n * Adds document relationships to the database.\r\n *\r\n * @param db - The database transaction to use.\r\n * @param addDocumentRelations - An array of document relationships to add.\r\n * @returns An array of added document relationships.\r\n *\r\n * @example\r\n * ```typescript\r\n * const relationships = await addDocumentRelations({\r\n *   db,\r\n *   addDocumentRelations: [\r\n *     {\r\n *       sourceDocumentId: 1,\r\n *       targetDocumentId: 2,\r\n *       relationshipReasonId: 'Duplicate',\r\n *     },\r\n *   ],\r\n * });\r\n * console.log(relationships); // Outputs the added relationships\r\n * ```\r\n */\r\nexport const addDocumentRelations = async ({\r\n  db,\r\n  addDocumentRelations,\r\n}: {\r\n  db: DbTransactionType;\r\n  addDocumentRelations?: Array<LikeDocumentRelationshipType>;\r\n}): Promise<Array<DocumentRelationshipType>> => {\r\n  if (!addDocumentRelations?.length) {\r\n    return [];\r\n  }\r\n  try {\r\n    const values = (\r\n      await Promise.all(\r\n        addDocumentRelations.map(\r\n          ({\r\n            sourceDocumentId,\r\n            targetDocumentId,\r\n            relationshipReasonId: reason,\r\n          }) =>\r\n            new Promise<Omit<DocumentRelationshipType, 'timestamp'>>(\r\n              async (resolve, reject) => {\r\n                try {\r\n                  // Resolve incoming reason into a valid relationship id\r\n                  const relationshipReasonId = await getDocumentRelationReason({\r\n                    db,\r\n                    reason,\r\n                  });\r\n                  if (!relationshipReasonId) {\r\n                    throw new Error('Failed to get relationship reason ID');\r\n                  }\r\n                  // Check if the relationship already exists\r\n\r\n                  const exists = await db\r\n                    .select()\r\n                    .from(schema.documentRelationship)\r\n                    .where(\r\n                      and(\r\n                        eq(\r\n                          schema.documentRelationship.sourceDocumentId,\r\n                          sourceDocumentId,\r\n                        ),\r\n                        eq(\r\n                          schema.documentRelationship.targetDocumentId,\r\n                          targetDocumentId,\r\n                        ),\r\n                        eq(\r\n                          schema.documentRelationship.relationshipReasonId,\r\n                          relationshipReasonId,\r\n                        ),\r\n                      ),\r\n                    )\r\n                    .limit(1)\r\n                    .execute();\r\n                  if (exists && exists.length > 0) {\r\n                    log((l) =>\r\n                      l.warn(\r\n                        'Document relationship already exists - skipping',\r\n                        {\r\n                          sourceDocumentId,\r\n                          targetDocumentId,\r\n                          relationshipReasonId,\r\n                        },\r\n                      ),\r\n                    );\r\n                    resolve(undefined as unknown as DocumentRelationshipType);\r\n                  } else {\r\n                    resolve({\r\n                      sourceDocumentId,\r\n                      targetDocumentId,\r\n                      relationshipReasonId,\r\n                    });\r\n                  }\r\n                } catch (error) {\r\n                  reject(error);\r\n                }\r\n              },\r\n            ),\r\n        ),\r\n      )\r\n    ).filter(Boolean);\r\n    if (!values.length) {\r\n      return [];\r\n    }\r\n    return await db.insert(documentRelationship).values(values).returning();\r\n  } catch (error) {\r\n    throw LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: 'addDocumentRelations',\r\n      data: { addDocumentRelations },\r\n    });\r\n  }\r\n};\r\n\r\ntype AddNoteRetVal<TNotes> =\r\n  TNotes extends Array<string>\r\n    ? Promise<Array<DocumentPropertyType>>\r\n    : TNotes extends string\r\n      ? Promise<DocumentPropertyType>\r\n      : TNotes extends Array<{\r\n            policyBasis: string[];\r\n            tags: string[];\r\n            note: string;\r\n          }>\r\n        ? Promise<Array<DocumentPropertyType>>\r\n        : TNotes extends { policyBasis: string[]; tags: string[]; note: string }\r\n          ? Promise<DocumentPropertyType>\r\n          : TNotes extends []\r\n            ? Promise<Array<DocumentPropertyType>>\r\n            : never;\r\n\r\nexport const addNotesToDocument = async <\r\n  TNotes extends\r\n    | string\r\n    | Array<string>\r\n    | { policyBasis: string[]; tags: string[]; note: string }\r\n    | Array<{ policyBasis: string[]; tags: string[]; note: string }>,\r\n>({\r\n  db,\r\n  notes: notesFromProps,\r\n  documentId: documentIdFromProps,\r\n}: {\r\n  db: DbTransactionType | DatabaseType;\r\n  notes: TNotes;\r\n  documentId: number;\r\n}): Promise<AddNoteRetVal<TNotes>> => {\r\n  if (!('documentUnits' in db.query)) {\r\n    throw new Error(\r\n      'Invalid database instance - must be a transaction or query builder',\r\n    );\r\n  }\r\n  // If db is a query builder, we need to get the actual db instance\r\n  const record = await db.query.documentUnits.findFirst({\r\n    where: eq(schema.documentUnits.unitId, documentIdFromProps),\r\n    columns: {\r\n      emailId: true,\r\n      attachmentId: true,\r\n      documentType: true,\r\n    },\r\n    with: {\r\n      docProp: {\r\n        columns: {\r\n          documentId: true, // Ensure we get the document ID\r\n        },\r\n      },\r\n    },\r\n  });\r\n  if (!record) {\r\n    throw new Error('Email ID not found for the document');\r\n  }\r\n  const { emailId, attachmentId, documentType, docProp } = record;\r\n  const documentId =\r\n    documentType === 'email' || documentType === 'attachment'\r\n      ? documentIdFromProps\r\n      : (docProp?.documentId ?? documentIdFromProps);\r\n\r\n  let notes: Array<{ policyBasis: string[]; tags: string[]; note: string }>;\r\n  if (Array.isArray(notesFromProps)) {\r\n    notes = notesFromProps.map((note) =>\r\n      typeof note === 'string'\r\n        ? {\r\n            policyBasis: [],\r\n            tags: [],\r\n            note,\r\n          }\r\n        : {\r\n            policyBasis: note.policyBasis || [],\r\n            tags: note.tags || [],\r\n            note: note.note,\r\n          },\r\n    );\r\n  } else if (typeof notesFromProps === 'string') {\r\n    notes = [\r\n      {\r\n        policyBasis: [],\r\n        tags: [],\r\n        note: notesFromProps,\r\n      },\r\n    ];\r\n  } else {\r\n    notes = [notesFromProps];\r\n  }\r\n\r\n  // iterate through records, assinging id's and building insert records\r\n  const inputRecords = notes.map(({ policyBasis, tags, note }) => {\r\n    const propertyId = newUuid();\r\n    const createdOn = new Date(Date.now()).toISOString();\r\n    const documentRecord = {\r\n      documentPropertyId: propertyId,\r\n      emailId,\r\n      attachmentId,\r\n      documentType: 'note',\r\n      content: note,\r\n      createdOn,\r\n    };\r\n    const documentPropertyRecord: DocumentPropertyType = {\r\n      propertyId,\r\n      documentId,\r\n      documentPropertyTypeId: EmailPropertyTypeTypeId.Note,\r\n      createdOn,\r\n      propertyValue: note,\r\n      policyBasis,\r\n      tags,\r\n    };\r\n    return {\r\n      documentRecord,\r\n      documentPropertyRecord,\r\n    };\r\n  });\r\n  const normalizedNotes = inputRecords.map((r) => r.documentPropertyRecord);\r\n\r\n  await db.transaction(async (tx) => {\r\n    await tx\r\n      .insert(documentUnits)\r\n      .values(inputRecords.map((r) => r.documentRecord));\r\n    await tx.insert(documentProperty).values(normalizedNotes);\r\n  });\r\n\r\n  return Array.isArray(notesFromProps)\r\n    ? (normalizedNotes as unknown as AddNoteRetVal<TNotes>)\r\n    : (normalizedNotes[0] as unknown as AddNoteRetVal<TNotes>);\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\drizzle-db\\drizzle-error.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":52,"column":1,"nodeType":"Program","endLine":416,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * PostgresError represents the shape of an error object returned by\r\n * PostgreSQL drivers (for example node-postgres / pg) and by wrappers such\r\n * as Drizzle/driver adapters. It extends the standard JavaScript `Error`\r\n * with Postgres-specific fields (many mapped from the server's error\r\n * response) and with optional driver/wrapper additions.\r\n *\r\n * This interface is intentionally permissive: most properties are\r\n * optional because different drivers, connection pools, and Postgres\r\n * server versions populate different subsets of fields. Code that\r\n * consumes `PostgresError` should therefore treat fields as possibly\r\n * `undefined` and use safe checks (optional chaining / strict equality)\r\n * when making decisions based on the error contents.\r\n *\r\n * Common usage patterns:\r\n * - Inspect `code` (SQLSTATE) to branch on specific error classes\r\n *   (e.g. '23505' => unique_violation).\r\n * - Use `detail`, `hint`, and `constraint` for richer diagnostics\r\n *   (useful when logging or surfacing errors to developers).\r\n * - The `query` and `parameters` fields (driver/wrapper additions)\r\n *   may be present and are helpful for retry logic and observability,\r\n *   but should never be logged in full in production if they contain\r\n *   sensitive data.\r\n *\r\n * Example:\r\n * ```ts\r\n * function handleDbError(err: unknown) {\r\n *   if ((err as PostgresError)?.code === '23505') {\r\n *     // unique violation - handle conflict\r\n *   }\r\n *   const pgErr = err as PostgresError;\r\n *   console.error('DB error', {\r\n *     sqlstate: pgErr.code,\r\n *     table: pgErr.table,\r\n *     constraint: pgErr.constraint,\r\n *     hint: pgErr.hint,\r\n *   });\r\n * }\r\n * ```\r\n *\r\n * Notes:\r\n * - `code` is the SQLSTATE error code (string). See\r\n *   https://www.postgresql.org/docs/current/errcodes-appendix.html for\r\n *   semantic meanings (e.g. '23505' = unique_violation).\r\n * - `position` and `internalPosition` are character offsets (as strings)\r\n *   returned by the server for parse/compile/runtime errors; they are\r\n *   usually present for syntax errors only.\r\n * - Driver/wrapper fields (`query`, `parameters`, `cause`, `originalError`)\r\n *   are non-standard and may be added by library layers around the raw\r\n *   driver. Treat them as optional and implementation-specific.\r\n */\r\nexport interface PostgresError extends Error {\r\n  /**\r\n   * Always 'DrizzleError' for errors thrown by Drizzle or its adapters.\r\n   */\r\n  name: 'DrizzleError';\r\n  /**\r\n   * SQLSTATE error code reported by Postgres (string). See Postgres\r\n   * documentation for values (e.g. '23505' = unique_violation).\r\n   */\r\n  code?: string;\r\n  /** Severity reported by Postgres (e.g. \"ERROR\", \"FATAL\", \"PANIC\"). */\r\n  severity?: string;\r\n  /** Detailed human-readable error message from Postgres. */\r\n  detail?: string;\r\n  /** An optional hint from Postgres about how to resolve the error. */\r\n  hint?: string;\r\n  /** Position (character offset) of error within the query string (when present). */\r\n  position?: string;\r\n  /** Internal position within a nested/internal query (when present). */\r\n  internalPosition?: string;\r\n  /** The text of the internally generated query (when present). */\r\n  internalQuery?: string;\r\n  /** Where the error occurred (context text), if the server provided it. */\r\n  where?: string;\r\n  /** Schema name related to the error (if applicable). */\r\n  schema?: string;\r\n  /** Table name related to the error (if applicable). */\r\n  table?: string;\r\n  /** Column name related to the error (if applicable). */\r\n  column?: string;\r\n  /** Data type name related to the error (if applicable). */\r\n  dataType?: string;\r\n  /** Constraint name when the error is a constraint violation. */\r\n  constraint?: string; // constraint name for violations\r\n  /** Source filename reported by Postgres server (internal). */\r\n  file?: string;\r\n  /** Source line number reported by Postgres server (internal). */\r\n  line?: string;\r\n  /** Source routine reported by Postgres server (internal). */\r\n  routine?: string;\r\n  // driver/drizzle additions:\r\n  /** The SQL text the driver executed (if the wrapper recorded it). */\r\n  query?: string;\r\n  /** The bound parameters for `query`, if recorded by the wrapper/driver. */\r\n  parameters?: unknown[];\r\n  /** Cause or wrapped error object (when an adapter wraps the original error). */\r\n  cause?: unknown; // drizzle/other wrapper may set this\r\n  /** Original lower-level error if the wrapper preserved it. */\r\n  originalError?: unknown;\r\n}\r\n/**\r\n * Type guard to check if an error is a DrizzleError.\r\n *\r\n * @param error - The error to check.\r\n * @returns True if the error is a DrizzleError, false otherwise.\r\n */\r\nexport const isDrizzleError = (error: unknown): error is PostgresError =>\r\n  typeof error === 'object' &&\r\n  error != null &&\r\n  'name' in error &&\r\n  error.name === 'DrizzleError';\r\n\r\n/**\r\n * Canonical mapping of PostgreSQL SQLSTATE codes to short descriptions.\r\n * The keys are upper-cased SQLSTATE strings (5-character class or specific\r\n * codes) and values are the canonical short description tokens used in\r\n * Postgres documentation and other toolchains.\r\n *\r\n * This map intentionally contains only the most commonly encountered\r\n * SQLSTATE codes and the comprehensive list used by our codebase. If you\r\n * need additional codes, append them here following the same pattern.\r\n */\r\nexport const PG_ERROR_CODE_DESCRIPTIONS: Record<string, string> = {\r\n  '00000': 'successful_completion',\r\n  '01000': 'warning',\r\n  '0100C': 'dynamic_result_sets_returned',\r\n  '01008': 'implicit_zero_bit_padding',\r\n  '01003': 'null_value_eliminated_in_set_function',\r\n  '01007': 'privilege_not_granted',\r\n  '01006': 'privilege_not_revoked',\r\n  '01004': 'string_data_right_truncation',\r\n  '01P01': 'deprecated_feature',\r\n  '02000': 'no_data',\r\n  '02001': 'no_additional_dynamic_result_sets_returned',\r\n  '03000': 'sql_statement_not_yet_complete',\r\n  '08000': 'connection_exception',\r\n  '08003': 'connection_does_not_exist',\r\n  '08006': 'connection_failure',\r\n  '08001': 'sqlclient_unable_to_establish_sqlconnection',\r\n  '08004': 'sqlserver_rejected_establishment_of_sqlconnection',\r\n  '08007': 'transaction_resolution_unknown',\r\n  '08P01': 'protocol_violation',\r\n  '09000': 'triggered_action_exception',\r\n  '0A000': 'feature_not_supported',\r\n  '0B000': 'invalid_transaction_initiation',\r\n  '0F000': 'locator_exception',\r\n  '0F001': 'invalid_locator_specification',\r\n  '0L000': 'invalid_grantor',\r\n  '0LP01': 'invalid_grant_operation',\r\n  '0P000': 'invalid_role_specification',\r\n  '0Z000': 'diagnostics_exception',\r\n  '0Z002': 'stacked_diagnostics_accessed_without_active_handler',\r\n  '20000': 'case_not_found',\r\n  '21000': 'cardinality_violation',\r\n  '22000': 'data_exception',\r\n  '2202E': 'array_subscript_error',\r\n  '22021': 'character_not_in_repertoire',\r\n  '22008': 'datetime_field_overflow',\r\n  '22012': 'division_by_zero',\r\n  '22005': 'error_in_assignment',\r\n  '2200B': 'escape_character_conflict',\r\n  '22022': 'indicator_overflow',\r\n  '22015': 'interval_field_overflow',\r\n  '2201E': 'invalid_argument_for_logarithm',\r\n  '22014': 'invalid_argument_for_ntile_function',\r\n  '22016': 'invalid_argument_for_nth_value_function',\r\n  '2201F': 'invalid_argument_for_power_function',\r\n  '2201G': 'invalid_argument_for_width_bucket_function',\r\n  '22018': 'invalid_character_value_for_cast',\r\n  '22007': 'invalid_datetime_format',\r\n  '22019': 'invalid_escape_character',\r\n  '2200D': 'invalid_escape_octet',\r\n  '22025': 'invalid_escape_sequence',\r\n  '22P06': 'nonstandard_use_of_escape_character',\r\n  '22010': 'invalid_indicator_parameter_value',\r\n  '22023': 'invalid_parameter_value',\r\n  '22013': 'invalid_preceding_or_following_size',\r\n  '2201B': 'invalid_regular_expression',\r\n  '2201W': 'invalid_row_count_in_limit_clause',\r\n  '2201X': 'invalid_row_count_in_result_offset_clause',\r\n  '2202H': 'invalid_tablesample_argument',\r\n  '2202G': 'invalid_tablesample_repeat',\r\n  '22009': 'invalid_time_zone_displacement_value',\r\n  '2200C': 'invalid_use_of_escape_character',\r\n  '2200G': 'most_specific_type_mismatch',\r\n  '22004': 'null_value_not_allowed',\r\n  '22002': 'null_value_no_indicator_parameter',\r\n  '22003': 'numeric_value_out_of_range',\r\n  '2200H': 'sequence_generator_limit_exceeded',\r\n  '22026': 'string_data_length_mismatch',\r\n  '22001': 'string_data_right_truncation',\r\n  '22011': 'substring_error',\r\n  '22027': 'trim_error',\r\n  '22024': 'unterminated_c_string',\r\n  '2200F': 'zero_length_character_string',\r\n  '22P01': 'floating_point_exception',\r\n  '22P02': 'invalid_text_representation',\r\n  '22P03': 'invalid_binary_representation',\r\n  '22P04': 'bad_copy_file_format',\r\n  '22P05': 'untranslatable_character',\r\n  '2200L': 'not_an_xml_document',\r\n  '2200M': 'invalid_xml_document',\r\n  '2200N': 'invalid_xml_content',\r\n  '2200S': 'invalid_xml_comment',\r\n  '2200T': 'invalid_xml_processing_instruction',\r\n  '22030': 'duplicate_json_object_key_value',\r\n  '22031': 'invalid_argument_for_sql_json_datetime_function',\r\n  '22032': 'invalid_json_text',\r\n  '22033': 'invalid_sql_json_subscript',\r\n  '22034': 'more_than_one_sql_json_item',\r\n  '22035': 'no_sql_json_item',\r\n  '22036': 'non_numeric_sql_json_item',\r\n  '22037': 'non_unique_keys_in_a_json_object',\r\n  '22038': 'singleton_sql_json_item_required',\r\n  '22039': 'sql_json_array_not_found',\r\n  '2203A': 'sql_json_member_not_found',\r\n  '2203B': 'sql_json_number_not_found',\r\n  '2203C': 'sql_json_object_not_found',\r\n  '2203D': 'too_many_json_array_elements',\r\n  '2203E': 'too_many_json_object_members',\r\n  '2203F': 'sql_json_scalar_required',\r\n  '2203G': 'sql_json_item_cannot_be_cast_to_target_type',\r\n  '23000': 'integrity_constraint_violation',\r\n  '23001': 'restrict_violation',\r\n  '23502': 'not_null_violation',\r\n  '23503': 'foreign_key_violation',\r\n  '23505': 'unique_violation',\r\n  '23514': 'check_violation',\r\n  '23P01': 'exclusion_violation',\r\n  '24000': 'invalid_cursor_state',\r\n  '25000': 'invalid_transaction_state',\r\n  '25001': 'active_sql_transaction',\r\n  '25002': 'branch_transaction_already_active',\r\n  '25008': 'held_cursor_requires_same_isolation_level',\r\n  '25003': 'inappropriate_access_mode_for_branch_transaction',\r\n  '25004': 'inappropriate_isolation_level_for_branch_transaction',\r\n  '25005': 'no_active_sql_transaction_for_branch_transaction',\r\n  '25006': 'read_only_sql_transaction',\r\n  '25007': 'schema_and_data_statement_mixing_not_supported',\r\n  '25P01': 'no_active_sql_transaction',\r\n  '25P02': 'in_failed_sql_transaction',\r\n  '25P03': 'idle_in_transaction_session_timeout',\r\n  '25P04': 'transaction_timeout',\r\n  '26000': 'invalid_sql_statement_name',\r\n  '27000': 'triggered_data_change_violation',\r\n  '28000': 'invalid_authorization_specification',\r\n  '28P01': 'invalid_password',\r\n  '2B000': 'dependent_privilege_descriptors_still_exist',\r\n  '2BP01': 'dependent_objects_still_exist',\r\n  '2D000': 'invalid_transaction_termination',\r\n  '2F000': 'sql_routine_exception',\r\n  '2F005': 'function_executed_no_return_statement',\r\n  '2F002': 'modifying_sql_data_not_permitted',\r\n  '2F003': 'prohibited_sql_statement_attempted',\r\n  '2F004': 'reading_sql_data_not_permitted',\r\n  '34000': 'invalid_cursor_name',\r\n  '38000': 'external_routine_exception',\r\n  '38001': 'containing_sql_not_permitted',\r\n  '38002': 'modifying_sql_data_not_permitted',\r\n  '38003': 'prohibited_sql_statement_attempted',\r\n  '38004': 'reading_sql_data_not_permitted',\r\n  '39000': 'external_routine_invocation_exception',\r\n  '39001': 'invalid_sqlstate_returned',\r\n  '39004': 'null_value_not_allowed',\r\n  '39P01': 'trigger_protocol_violated',\r\n  '39P02': 'srf_protocol_violated',\r\n  '39P03': 'event_trigger_protocol_violated',\r\n  '3B000': 'savepoint_exception',\r\n  '3B001': 'invalid_savepoint_specification',\r\n  '3D000': 'invalid_catalog_name',\r\n  '3F000': 'invalid_schema_name',\r\n  '40000': 'transaction_rollback',\r\n  '40002': 'transaction_integrity_constraint_violation',\r\n  '40001': 'serialization_failure',\r\n  '40003': 'statement_completion_unknown',\r\n  '40P01': 'deadlock_detected',\r\n  '42000': 'syntax_error_or_access_rule_violation',\r\n  '42601': 'syntax_error',\r\n  '42501': 'insufficient_privilege',\r\n  '42846': 'cannot_coerce',\r\n  '42803': 'grouping_error',\r\n  '42P20': 'windowing_error',\r\n  '42P19': 'invalid_recursion',\r\n  '42830': 'invalid_foreign_key',\r\n  '42602': 'invalid_name',\r\n  '42622': 'name_too_long',\r\n  '42939': 'reserved_name',\r\n  '42804': 'datatype_mismatch',\r\n  '42P18': 'indeterminate_datatype',\r\n  '42P21': 'collation_mismatch',\r\n  '42P22': 'indeterminate_collation',\r\n  '42809': 'wrong_object_type',\r\n  '428C9': 'generated_always',\r\n  '42703': 'undefined_column',\r\n  '42883': 'undefined_function',\r\n  '42P01': 'undefined_table',\r\n  '42P02': 'undefined_parameter',\r\n  '42704': 'undefined_object',\r\n  '42701': 'duplicate_column',\r\n  '42P03': 'duplicate_cursor',\r\n  '42P04': 'duplicate_database',\r\n  '42723': 'duplicate_function',\r\n  '42P05': 'duplicate_prepared_statement',\r\n  '42P06': 'duplicate_schema',\r\n  '42P07': 'duplicate_table',\r\n  '42712': 'duplicate_alias',\r\n  '42710': 'duplicate_object',\r\n  '42702': 'ambiguous_column',\r\n  '42725': 'ambiguous_function',\r\n  '42P08': 'ambiguous_parameter',\r\n  '42P09': 'ambiguous_alias',\r\n  '42P10': 'invalid_column_reference',\r\n  '42611': 'invalid_column_definition',\r\n  '42P11': 'invalid_cursor_definition',\r\n  '42P12': 'invalid_database_definition',\r\n  '42P13': 'invalid_function_definition',\r\n  '42P14': 'invalid_prepared_statement_definition',\r\n  '42P15': 'invalid_schema_definition',\r\n  '42P16': 'invalid_table_definition',\r\n  '42P17': 'invalid_object_definition',\r\n  '44000': 'with_check_option_violation',\r\n  '53000': 'insufficient_resources',\r\n  '53100': 'disk_full',\r\n  '53200': 'out_of_memory',\r\n  '53300': 'too_many_connections',\r\n  '53400': 'configuration_limit_exceeded',\r\n  '54000': 'program_limit_exceeded',\r\n  '54001': 'statement_too_complex',\r\n  '54011': 'too_many_columns',\r\n  '54023': 'too_many_arguments',\r\n  '55000': 'object_not_in_prerequisite_state',\r\n  '55006': 'object_in_use',\r\n  '55P02': 'cant_change_runtime_param',\r\n  '55P03': 'lock_not_available',\r\n  '55P04': 'unsafe_new_enum_value_usage',\r\n  '57000': 'operator_intervention',\r\n  '57014': 'query_canceled',\r\n  '57P01': 'admin_shutdown',\r\n  '57P02': 'crash_shutdown',\r\n  '57P03': 'cannot_connect_now',\r\n  '57P04': 'database_dropped',\r\n  '57P05': 'idle_session_timeout',\r\n  '58000': 'system_error',\r\n  '58030': 'io_error',\r\n  '58P01': 'undefined_file',\r\n  '58P02': 'duplicate_file',\r\n  F0000: 'config_file_error',\r\n  F0001: 'lock_file_exists',\r\n  HV000: 'fdw_error',\r\n  HV005: 'fdw_column_name_not_found',\r\n  HV002: 'fdw_dynamic_parameter_value_needed',\r\n  HV010: 'fdw_function_sequence_error',\r\n  HV021: 'fdw_inconsistent_descriptor_information',\r\n  HV024: 'fdw_invalid_attribute_value',\r\n  HV007: 'fdw_invalid_column_name',\r\n  HV008: 'fdw_invalid_column_number',\r\n  HV004: 'fdw_invalid_data_type',\r\n  HV006: 'fdw_invalid_data_type_descriptors',\r\n  HV091: 'fdw_invalid_descriptor_field_identifier',\r\n  HV00B: 'fdw_invalid_handle',\r\n  HV00C: 'fdw_invalid_option_index',\r\n  HV00D: 'fdw_invalid_option_name',\r\n  HV090: 'fdw_invalid_string_length_or_buffer_length',\r\n  HV00A: 'fdw_invalid_string_format',\r\n  HV009: 'fdw_invalid_use_of_null_pointer',\r\n  HV014: 'fdw_too_many_handles',\r\n  HV001: 'fdw_out_of_memory',\r\n  HV00P: 'fdw_no_schemas',\r\n  HV00J: 'fdw_option_name_not_found',\r\n  HV00K: 'fdw_reply_handle',\r\n  HV00Q: 'fdw_schema_not_found',\r\n  HV00R: 'fdw_table_not_found',\r\n  HV00L: 'fdw_unable_to_create_execution',\r\n  HV00M: 'fdw_unable_to_create_reply',\r\n  HV00N: 'fdw_unable_to_establish_connection',\r\n  P0000: 'plpgsql_error',\r\n  P0001: 'raise_exception',\r\n  P0002: 'no_data_found',\r\n  P0003: 'too_many_rows',\r\n  P0004: 'assert_failure',\r\n  XX000: 'internal_error',\r\n  XX001: 'data_corrupted',\r\n  XX002: 'index_corrupted',\r\n};\r\n\r\n/**\r\n * Return a short canonical description for the provided SQLSTATE code.\r\n *\r\n * @param code - SQLSTATE code (case-insensitive, may include whitespace)\r\n * @returns canonical description string (for example 'unique_violation') or\r\n *   `undefined` if the code is not present in the built-in mapping.\r\n *\r\n * @example\r\n * ```ts\r\n * describePostgresErrorCode('23505'); // -> 'unique_violation'\r\n * describePostgresErrorCode(' 22p02 '); // -> 'invalid_text_representation'\r\n * ```\r\n */\r\nexport const errorFromCode = (\r\n  code: string | undefined | unknown,\r\n): string | undefined => {\r\n  let k: string | undefined;\r\n  if (typeof code === 'string') {\r\n    k = code;\r\n  } else if (isDrizzleError(code)) {\r\n    k = code.code;\r\n  } else {\r\n    k = undefined;\r\n  }\r\n  if (!k) {\r\n    return undefined;\r\n  }\r\n  return PG_ERROR_CODE_DESCRIPTIONS[k.trim().toUpperCase()];\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\drizzle-db\\drizzle-sql.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\drizzle-db\\drizzle-types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":45,"column":1,"nodeType":"Program","endLine":774,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":759,"column":8,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":773,"endColumn":2,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Drizzle Database Type Definitions\r\n *\r\n * This module provides comprehensive type definitions for database operations in the NoEducation application.\r\n * It extracts and exports TypeScript types from the Drizzle schema to ensure type safety across all\r\n * database interactions, including SELECT operations, query building, and transaction handling.\r\n *\r\n * The module serves as the central type registry for:\r\n * - Table select types (inferred from schema definitions)\r\n * - Query builder types (for type-safe query construction)\r\n * - Individual entity types (for specific domain objects)\r\n * - Transaction types (for atomic operations)\r\n *\r\n * This approach provides:\r\n * - **Type Safety**: Compile-time validation of database operations\r\n * - **Intellisense**: Rich autocompletion in IDEs\r\n * - **Refactoring Safety**: Automatic updates when schema changes\r\n * - **Documentation**: Self-documenting code through types\r\n *\r\n * @module lib/drizzle-db/drizzle-types\r\n * @version 1.0.0\r\n * @since 2025-07-16\r\n *\r\n * @example\r\n * ```typescript\r\n * import type {\r\n *   EmailType,\r\n *   DocumentUnitQueryShape,\r\n *   DatabaseType\r\n * } from '@/lib/drizzle-db/drizzle-types';\r\n *\r\n * // Type-safe entity handling\r\n * function processEmail(email: EmailType) {\r\n *   console.log(`Processing email: ${email.subject}`);\r\n * }\r\n *\r\n * // Type-safe query building\r\n * const queryOptions: DocumentUnitQueryShape = {\r\n *   where: eq(documentUnits.emailId, emailId),\r\n *   with: { documentProperty: true }\r\n * };\r\n * ```\r\n */\r\n\r\nimport type { FirstParameter } from '@/lib/typescript';\r\nimport type { DbFullSchemaType, DbDatabaseType } from './schema';\r\n\r\n/**\r\n * Type alias for the complete database instance with full schema support.\r\n *\r\n * This type represents the configured database instance that includes all tables,\r\n * relations, and query methods. It provides the foundation for all database\r\n * operations and type inference throughout the application.\r\n *\r\n * @typedef {DbDatabaseType} DatabaseType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { DatabaseType } from '@/lib/drizzle-db/drizzle-types';\r\n *\r\n * function performDatabaseOperation(db: DatabaseType) {\r\n *   // Access to all schema tables and relations\r\n *   return db.query.users.findMany();\r\n * }\r\n * ```\r\n *\r\n * @see {@link DbDatabaseType} - The underlying database type from schema\r\n */\r\nexport type DatabaseType = DbDatabaseType;\r\n\r\n/**\r\n * Utility type that extracts SELECT result types from all schema tables.\r\n *\r\n * This mapped type iterates through the complete schema and extracts the `$inferSelect`\r\n * type from each table that supports SELECT operations. It uses conditional type\r\n * mapping to include only tables that have the `$inferSelect` property.\r\n *\r\n * The type works by:\r\n * 1. Iterating through all keys in `DbFullSchemaType`\r\n * 2. Checking if each entity has a `$inferSelect` property\r\n * 3. Including only those entities in the final type\r\n * 4. Extracting the actual SELECT type from each entity\r\n *\r\n * This provides a centralized registry of all table result types, ensuring\r\n * consistency across the application when working with database query results.\r\n *\r\n * @typedef {object} TableSelectTypes\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { TableSelectTypes } from '@/lib/drizzle-db/drizzle-types';\r\n *\r\n * // Access specific table result types\r\n * type UserResult = TableSelectTypes['users'];\r\n * type EmailResult = TableSelectTypes['emails'];\r\n *\r\n * // Use in functions that process query results\r\n * function processUsers(users: UserResult[]) {\r\n *   users.forEach(user => console.log(user.email));\r\n * }\r\n * ```\r\n *\r\n * @see {@link DbFullSchemaType} - The complete schema type used for extraction\r\n */\r\nexport type TableSelectTypes = {\r\n  [K in keyof DbFullSchemaType as '$inferSelect' extends keyof DbFullSchemaType[K]\r\n    ? K\r\n    : never]: DbFullSchemaType[K] extends { $inferSelect: unknown }\r\n    ? DbFullSchemaType[K]['$inferSelect']\r\n    : never;\r\n};\r\n\r\n/**\r\n * Type alias for the complete database schema.\r\n *\r\n * This provides a more semantic name for the full schema type, making it\r\n * clear when working with schema-level operations versus specific table types.\r\n *\r\n * @typedef {DbFullSchemaType} SchemaType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { SchemaType } from '@/lib/drizzle-db/drizzle-types';\r\n *\r\n * function getTableFromSchema<T extends keyof SchemaType>(\r\n *   schema: SchemaType,\r\n *   tableName: T\r\n * ): SchemaType[T] {\r\n *   return schema[tableName];\r\n * }\r\n * ```\r\n *\r\n * @see {@link DbFullSchemaType} - The underlying schema type\r\n */\r\nexport type SchemaType = DbFullSchemaType;\r\n\r\n// ============================================================================\r\n// INDIVIDUAL ENTITY TYPES\r\n// ============================================================================\r\n\r\n/**\r\n * Type definition for document unit entities.\r\n *\r\n * Document units represent individual pieces of content that can be analyzed,\r\n * embedded, and processed. They serve as the atomic units of document processing\r\n * in the system and can be associated with emails, attachments, or standalone content.\r\n *\r\n * @typedef {TableSelectTypes['documentUnits']} DocumentUnitType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { DocumentUnitType } from '@/lib/drizzle-db/drizzle-types';\r\n *\r\n * function analyzeDocumentUnit(unit: DocumentUnitType) {\r\n *   console.log(`Analyzing unit ${unit.unitId} of type ${unit.documentType}`);\r\n *   return processContent(unit.content);\r\n * }\r\n * ```\r\n */\r\nexport type DocumentUnitType = TableSelectTypes['documentUnits'];\r\n\r\n/**\r\n * Type definition for document property entities.\r\n *\r\n * Document properties represent metadata and analysis results associated with\r\n * document units. They store various types of extracted information, compliance\r\n * data, and analytical insights derived from document processing.\r\n *\r\n * @typedef {TableSelectTypes['documentProperty']} DocumentPropertyType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { DocumentPropertyType } from '@/lib/drizzle-db/drizzle-types';\r\n *\r\n * function extractPropertyValue(property: DocumentPropertyType): string | null {\r\n *   return property.propertyValue;\r\n * }\r\n * ```\r\n */\r\nexport type DocumentPropertyType = TableSelectTypes['documentProperty'];\r\n\r\n/**\r\n * Type definition for document property type metadata.\r\n *\r\n * This represents the classification and categorization system for document\r\n * properties, defining what types of properties can be extracted and stored.\r\n *\r\n * @typedef {TableSelectTypes['emailPropertyType']} DocumentPropertyTypeType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { DocumentPropertyTypeType } from '@/lib/drizzle-db/drizzle-types';\r\n *\r\n * function getPropertyTypeInfo(propertyType: DocumentPropertyTypeType) {\r\n *   return {\r\n *     id: propertyType.documentPropertyTypeId,\r\n *     description: propertyType.description\r\n *   };\r\n * }\r\n * ```\r\n */\r\nexport type DocumentPropertyTypeType = TableSelectTypes['emailPropertyType'];\r\n\r\n/**\r\n * Type definition for document relationship entities.\r\n *\r\n * Document relationships define connections and associations between different\r\n * document units, enabling the system to understand document hierarchies,\r\n * references, and contextual connections.\r\n *\r\n * @typedef {TableSelectTypes['documentRelationship']} DocumentRelationshipType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { DocumentRelationshipType } from '@/lib/drizzle-db/drizzle-types';\r\n *\r\n * function processDocumentRelationship(relationship: DocumentRelationshipType) {\r\n *   console.log(`Relationship between ${relationship.parentDocumentId} and ${relationship.childDocumentId}`);\r\n * }\r\n * ```\r\n */\r\nexport type DocumentRelationshipType = TableSelectTypes['documentRelationship'];\r\n\r\n/**\r\n * Type definition for email entities.\r\n *\r\n * Emails represent the core communication objects in the system, containing\r\n * message content, metadata, and associated processing information.\r\n *\r\n * @typedef {TableSelectTypes['emails']} EmailType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { EmailType } from '@/lib/drizzle-db/drizzle-types';\r\n *\r\n * function displayEmail(email: EmailType) {\r\n *   return {\r\n *     subject: email.subject,\r\n *     from: email.fromAddress,\r\n *     date: email.receivedDate\r\n *   };\r\n * }\r\n * ```\r\n */\r\nexport type EmailType = TableSelectTypes['emails'];\r\n\r\n/**\r\n * Type definition for email attachment entities.\r\n *\r\n * Email attachments represent files associated with email messages, including\r\n * their metadata, content, and processing status.\r\n *\r\n * @typedef {TableSelectTypes['emailAttachments']} EmailAttachmentType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { EmailAttachmentType } from '@/lib/drizzle-db/drizzle-types';\r\n *\r\n * function processAttachment(attachment: EmailAttachmentType) {\r\n *   console.log(`Processing ${attachment.filename} (${attachment.mimeType})`);\r\n * }\r\n * ```\r\n */\r\nexport type EmailAttachmentType = TableSelectTypes['emailAttachments'];\r\n\r\n/**\r\n * Type definition for key point entities.\r\n *\r\n * Key points represent important information extracted from documents,\r\n * highlighting significant content that requires attention or action.\r\n *\r\n * @typedef {TableSelectTypes['keyPointsDetails']} KeyPointType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { KeyPointType } from '@/lib/drizzle-db/drizzle-types';\r\n *\r\n * function highlightKeyPoint(keyPoint: KeyPointType) {\r\n *   return `Key Point: ${keyPoint.description}`;\r\n * }\r\n * ```\r\n */\r\nexport type KeyPointType = TableSelectTypes['keyPointsDetails'];\r\n\r\n/**\r\n * Type definition for call-to-action entities.\r\n *\r\n * Call-to-actions represent actionable items identified in documents that\r\n * require follow-up, response, or specific handling.\r\n *\r\n * @typedef {TableSelectTypes['callToActionDetails']} CallToActionType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { CallToActionType } from '@/lib/drizzle-db/drizzle-types';\r\n *\r\n * function processCallToAction(cta: CallToActionType) {\r\n *   console.log(`Action required: ${cta.description}`);\r\n *   return { priority: cta.priority, dueDate: cta.dueDate };\r\n * }\r\n * ```\r\n */\r\nexport type CallToActionType = TableSelectTypes['callToActionDetails'];\r\n\r\n/**\r\n * Type definition for call-to-action category entities.\r\n *\r\n * Categories provide classification and organization for call-to-action items,\r\n * enabling better management and prioritization of required actions.\r\n *\r\n * @typedef {TableSelectTypes['callToActionCategory']} CallToActionCategoryType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { CallToActionCategoryType } from '@/lib/drizzle-db/drizzle-types';\r\n *\r\n * function getCategoryInfo(category: CallToActionCategoryType) {\r\n *   return {\r\n *     name: category.categoryName,\r\n *     description: category.description\r\n *   };\r\n * }\r\n * ```\r\n */\r\nexport type CallToActionCategoryType = TableSelectTypes['callToActionCategory'];\r\n\r\n/**\r\n * Type definition for call-to-action response entities.\r\n *\r\n * Responses track the handling and completion of call-to-action items,\r\n * providing audit trails and status tracking for required actions.\r\n *\r\n * @typedef {TableSelectTypes['callToActionResponseDetails']} CallToActionResponseType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { CallToActionResponseType } from '@/lib/drizzle-db/drizzle-types';\r\n *\r\n * function recordResponse(response: CallToActionResponseType) {\r\n *   console.log(`Response recorded for CTA: ${response.callToActionId}`);\r\n * }\r\n * ```\r\n */\r\nexport type CallToActionResponseType =\r\n  TableSelectTypes['callToActionResponseDetails'];\r\n\r\n/**\r\n * Type definition for call-to-action response link entities.\r\n *\r\n * This type represents the linking table between call-to-actions and their responses,\r\n * enabling many-to-many relationships and complex response tracking.\r\n *\r\n * @typedef {TableSelectTypes['callToActionDetailsCallToActionResponse']} CallToActionResponsiveActionLinkType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { CallToActionResponsiveActionLinkType } from '@/lib/drizzle-db/drizzle-types';\r\n *\r\n * function linkActionToResponse(link: CallToActionResponsiveActionLinkType) {\r\n *   console.log(`Linking CTA ${link.callToActionId} to response ${link.responseId}`);\r\n * }\r\n * ```\r\n */\r\nexport type CallToActionResponsiveActionLinkType =\r\n  TableSelectTypes['callToActionDetailsCallToActionResponse'];\r\n\r\n/**\r\n * Type definition for call-to-action response link entities.\r\n *\r\n * This type represents the linking table between call-to-actions and their responses,\r\n * enabling many-to-many relationships and complex response tracking.\r\n *\r\n * @typedef {TableSelectTypes['callToActionDetailsCallToActionResponse']} CallToActionResponsiveActionLinkType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { UserPublicKeysType } from '@/lib/drizzle-db';\r\n *\r\n * function getUserPublicKeys(keys: UserPublicKeysType[]) {\r\n *   keys.forEach(key => {\r\n *     console.log(`User ID: ${key.userId}, Public Key: ${key.publicKey}`);\r\n *   });\r\n * }\r\n * ```\r\n */\r\nexport type UserPublicKeysType = TableSelectTypes['userPublicKeys'];\r\n\r\n/**\r\n * Type definition for violation detail entities.\r\n *\r\n * Violation details represent compliance issues, policy violations, or regulatory\r\n * concerns identified during document analysis and processing.\r\n *\r\n * @typedef {TableSelectTypes['violationDetails']} ViolationDetailsType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { ViolationDetailsType } from '@/lib/drizzle-db/drizzle-types';\r\n *\r\n * function handleViolation(violation: ViolationDetailsType) {\r\n *   console.error(`Violation detected: ${violation.description}`);\r\n *   return { severity: violation.severity, action: 'escalate' };\r\n * }\r\n * ```\r\n */\r\nexport type ViolationDetailsType = TableSelectTypes['violationDetails'];\r\n\r\n/**\r\n * Type definition for model entities.\r\n *\r\n * Models represent AI models available for use in the system, including their\r\n * metadata, capabilities, and associated providers.\r\n *\r\n * @typedef {TableSelectTypes['models']} ModelsType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { ModelsType } from '@/lib/drizzle-db/drizzle-types';\r\n * function getModelInfo(model: ModelsType) {\r\n *   return {\r\n *     id: model.modelId,\r\n *     name: model.name,\r\n *     description: model.description,\r\n *     provider: model.providerName,\r\n *     capabilities: model.capabilities\r\n *   };\r\n * }\r\n * ```\r\n */\r\nexport type ModelsType = TableSelectTypes['models'];\r\n\r\n/**\r\n * Type definition for model providers.\r\n *\r\n * Providers provide the AI models available in the system, including their\r\n *\r\n * @typedef {TableSelectTypes['providers']} ProvidersType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { ProvidersType } from '@/lib/drizzle-db/drizzle-types';\r\n * function getModelInfo(providers: ProvidersType) {\r\n *   return {\r\n *     id: providers.modelId,\r\n *     name: providers.name,\r\n *     description: providers.description,\r\n *   };\r\n * }\r\n * ```\r\n */\r\nexport type ProvidersType = TableSelectTypes['providers'];\r\n\r\n/**\r\n * Type definition for model quota entities.\r\n *\r\n * Model quotas represent usage limits, allocation, and consumption tracking for AI models\r\n * within the system. They help manage resource usage, enforce limits, and provide insights\r\n * into model utilization for users or organizations.\r\n *\r\n * @typedef {TableSelectTypes['modelQuotas']} ModelQuotasType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { ModelQuotasType } from '@/lib/drizzle-db/drizzle-types';\r\n * function getQuotaInfo(quota: ModelQuotasType) {\r\n *   return {\r\n *     modelId: quota.modelId,\r\n *     userId: quota.userId,\r\n *     quotaLimit: quota.quotaLimit,\r\n *     quotaUsed: quota.quotaUsed,\r\n *     period: quota.period\r\n *   };\r\n * }\r\n * ```\r\n */\r\nexport type ModelQuotasType = TableSelectTypes['modelQuotas'];\r\n\r\n/**\r\n * Type definition for compliance score entities.\r\n *\r\n * Compliance scores provide quantitative assessments of document compliance\r\n * with various policies, regulations, and organizational standards.\r\n *\r\n * @typedef {TableSelectTypes['complianceScoresDetails']} ComplianceScoreType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { ComplianceScoreType } from '@/lib/drizzle-db/drizzle-types';\r\n *\r\n * function evaluateCompliance(score: ComplianceScoreType) {\r\n *   return {\r\n *     score: score.complianceScore,\r\n *     status: score.complianceScore > 0.8 ? 'compliant' : 'needs-review'\r\n *   };\r\n * }\r\n * ```\r\n */\r\nexport type ComplianceScoreType = TableSelectTypes['complianceScoresDetails'];\r\n\r\n/**\r\n * Type definition for chat message instance\r\n *\r\n * Chat messages represent individual messages exchanged in a chat session,\r\n * including their content, metadata, and associated user information.\r\n *\r\n * @typedef {TableSelectTypes['chatMessages']} ChatMessagesType\r\n * ChatMessagesType\r\n * @example\r\n * ```typescript\r\n * import type { ChatMessagesType } from '@/lib/drizzle-db/drizzle-types';\r\n *\r\n * function evaluateChatMessage(message: ChatMessagesType) {\r\n *   return {\r\n *     content: message.content,\r\n *     role: message.role,\r\n *     messageId: message.messageId\r\n *   };\r\n * }\r\n * ```\r\n */\r\nexport type ChatMessagesType = TableSelectTypes['chatMessages'];\r\n\r\nexport type ChatTurnsType = TableSelectTypes['chatTurns'];\r\n\r\nexport type ChatsType = TableSelectTypes['chats'];\r\n\r\nexport type ChatToolType = TableSelectTypes['chatTool'];\r\n\r\nexport type ChatToolCallsType = TableSelectTypes['chatToolCalls'];\r\n\r\n// ============================================================================\r\n// QUERY BUILDER TYPES\r\n// ============================================================================\r\n\r\n/**\r\n * Utility type that extracts query builder interfaces for all database tables.\r\n *\r\n * This mapped type provides type-safe query building capabilities by extracting\r\n * the parameter types from each table's `findFirst` method. It enables\r\n * intellisense and type checking for query options including WHERE clauses,\r\n * ORDER BY, relations, and other query parameters.\r\n *\r\n * The type works by:\r\n * 1. Accessing the `query` property of the database type\r\n * 2. For each table in the query interface, extracting the first parameter of `findFirst`\r\n * 3. This parameter contains all the query options (where, orderBy, with, etc.)\r\n *\r\n * @typedef {object} QueryBuilders\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { QueryBuilders } from '@/lib/drizzle-db/drizzle-types';\r\n *\r\n * // Type-safe query options\r\n * const userQuery: QueryBuilders['users'] = {\r\n *   where: eq(users.email, 'user@example.com'),\r\n *   with: { profile: true },\r\n *   orderBy: asc(users.createdAt)\r\n * };\r\n *\r\n * // Use in database operations\r\n * const result = await db.query.users.findFirst(userQuery);\r\n * ```\r\n *\r\n * @see {@link FirstParameter} - Utility type for extracting first parameter\r\n * @see {@link DatabaseType} - The database type used for query extraction\r\n */\r\nexport type QueryBuilders = {\r\n  [K in keyof DatabaseType['query']]: FirstParameter<\r\n    DatabaseType['query'][K]['findFirst']\r\n  >;\r\n};\r\n\r\n/**\r\n * Query builder type for document unit operations.\r\n *\r\n * @typedef {QueryBuilders['documentUnits']} DocumentUnitQueryShape\r\n *\r\n * @example\r\n * ```typescript\r\n * const query: DocumentUnitQueryShape = {\r\n *   where: eq(documentUnits.emailId, emailId),\r\n *   with: { documentProperty: true }\r\n * };\r\n * ```\r\n */\r\nexport type DocumentUnitQueryShape = QueryBuilders['documentUnits'];\r\n\r\n/**\r\n * Query builder type for document property operations.\r\n *\r\n * @typedef {QueryBuilders['documentProperty']} DocumentPropertyQueryShape\r\n *\r\n * @example\r\n * ```typescript\r\n * const query: DocumentPropertyQueryShape = {\r\n *   where: eq(documentProperty.documentPropertyTypeId, typeId),\r\n *   orderBy: desc(documentProperty.createdOn)\r\n * };\r\n * ```\r\n */\r\nexport type DocumentPropertyQueryShape = QueryBuilders['documentProperty'];\r\n\r\n/**\r\n * Query builder type for email operations.\r\n *\r\n * @typedef {QueryBuilders['emails']} EmailQueryShape\r\n *\r\n * @example\r\n * ```typescript\r\n * const query: EmailQueryShape = {\r\n *   where: and(\r\n *     eq(emails.fromAddress, sender),\r\n *     gt(emails.receivedDate, lastWeek)\r\n *   ),\r\n *   with: { attachments: true, recipients: true }\r\n * };\r\n * ```\r\n */\r\nexport type EmailQueryShape = QueryBuilders['emails'];\r\n\r\n/**\r\n * Query builder type for email attachment operations.\r\n *\r\n * @typedef {QueryBuilders['emailAttachments']} EmailAttachmentQueryShape\r\n *\r\n * @example\r\n * ```typescript\r\n * const query: EmailAttachmentQueryShape = {\r\n *   where: eq(emailAttachments.emailId, emailId),\r\n *   orderBy: asc(emailAttachments.filename)\r\n * };\r\n * ```\r\n */\r\nexport type EmailAttachmentQueryShape = QueryBuilders['emailAttachments'];\r\n\r\n/**\r\n * Query builder type for key point operations.\r\n *\r\n * @typedef {QueryBuilders['keyPointsDetails']} KeyPointQueryShape\r\n *\r\n * @example\r\n * ```typescript\r\n * const query: KeyPointQueryShape = {\r\n *   where: eq(keyPointsDetails.documentId, documentId),\r\n *   orderBy: desc(keyPointsDetails.importance)\r\n * };\r\n * ```\r\n */\r\nexport type KeyPointQueryShape = QueryBuilders['keyPointsDetails'];\r\n\r\n/**\r\n * Query builder type for call-to-action operations.\r\n *\r\n * @typedef {QueryBuilders['callToActionDetails']} CallToActionQueryShape\r\n *\r\n * @example\r\n * ```typescript\r\n * const query: CallToActionQueryShape = {\r\n *   where: eq(callToActionDetails.status, 'pending'),\r\n *   with: { category: true, responses: true }\r\n * };\r\n * ```\r\n */\r\nexport type CallToActionQueryShape = QueryBuilders['callToActionDetails'];\r\n\r\n/**\r\n * Query builder type for call-to-action category operations.\r\n *\r\n * @typedef {QueryBuilders['callToActionCategory']} CallToActionCategoryQueryShape\r\n *\r\n * @example\r\n * ```typescript\r\n * const query: CallToActionCategoryQueryShape = {\r\n *   orderBy: asc(callToActionCategory.categoryName)\r\n * };\r\n * ```\r\n */\r\nexport type CallToActionCategoryQueryShape =\r\n  QueryBuilders['callToActionCategory'];\r\n\r\n/**\r\n * Query builder type for call-to-action response operations.\r\n *\r\n * @typedef {QueryBuilders['callToActionResponseDetails']} CallToActionResponseQueryShape\r\n *\r\n * @example\r\n * ```typescript\r\n * const query: CallToActionResponseQueryShape = {\r\n *   where: eq(callToActionResponseDetails.callToActionId, ctaId),\r\n *   orderBy: desc(callToActionResponseDetails.responseDate)\r\n * };\r\n * ```\r\n */\r\nexport type CallToActionResponseQueryShape =\r\n  QueryBuilders['callToActionResponseDetails'];\r\n\r\n/**\r\n * Query builder type for violation detail operations.\r\n *\r\n * @typedef {QueryBuilders['violationDetails']} ViolationDetailsQueryShape\r\n *\r\n * @example\r\n * ```typescript\r\n * const query: ViolationDetailsQueryShape = {\r\n *   where: eq(violationDetails.severity, 'high'),\r\n *   orderBy: desc(violationDetails.detectedAt)\r\n * };\r\n * ```\r\n */\r\nexport type ViolationDetailsQueryShape = QueryBuilders['violationDetails'];\r\n\r\n/**\r\n * Query builder type for compliance score operations.\r\n *\r\n * @typedef {QueryBuilders['complianceScoresDetails']} ComplianceScoresDetailsQueryShape\r\n *\r\n * @example\r\n * ```typescript\r\n * const query: ComplianceScoresDetailsQueryShape = {\r\n *   where: lt(complianceScoresDetails.complianceScore, 0.8),\r\n *   orderBy: asc(complianceScoresDetails.complianceScore)\r\n * };\r\n * ```\r\n */\r\nexport type ComplianceScoresDetailsQueryShape =\r\n  QueryBuilders['complianceScoresDetails'];\r\n\r\n/**\r\n * Re-export of the database transaction type from the schema module.\r\n *\r\n * This provides a convenient import path for transaction types without\r\n * requiring direct access to the schema module.\r\n *\r\n * @see {@link DbTransactionType} - The transaction type from schema module\r\n */\r\nexport type { DbTransactionType } from './schema';\r\n\r\n/**\r\n * Namespace containing organized type collections for easier access.\r\n *\r\n * This namespace provides a structured way to access related types,\r\n * making it easier to import and use type collections in a organized manner.\r\n *\r\n * @namespace Types\r\n *\r\n * @example\r\n * ```typescript\r\n * import { Types } from '@/lib/drizzle-db/drizzle-types';\r\n *\r\n * // Access table types\r\n * type UserType = Types.Tables['users'];\r\n *\r\n * // Access query types\r\n * type UserQuery = Types.Queries['users'];\r\n * ```\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-namespace\r\nexport namespace Types {\r\n  /**\r\n   * Collection of all table SELECT result types.\r\n   *\r\n   * @typedef {TableSelectTypes} Tables\r\n   */\r\n  export type Tables = TableSelectTypes;\r\n\r\n  /**\r\n   * Collection of all query builder types.\r\n   *\r\n   * @typedef {QueryBuilders} Queries\r\n   */\r\n  export type Queries = QueryBuilders;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\drizzle-db\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\drizzle-db\\not-ready-error.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\drizzle-db\\schema.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":27,"column":1,"nodeType":"Program","endLine":354,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'makeMockDb' is assigned a value but only used as a type.","line":122,"column":7,"nodeType":null,"messageId":"usedOnlyAsType","endLine":122,"endColumn":17,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":197,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7654,7657],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7654,7657],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":197,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7659,7662],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7659,7662],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":233,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8925,8928],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8925,8928],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":233,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8930,8933],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8930,8933],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Database Schema Module\r\n *\r\n * This module provides a unified database schema interface for the NoEducation application.\r\n * It combines table definitions from the main schema with custom relations to create a\r\n * comprehensive database schema object that includes all tables, views, enums, and their relationships.\r\n *\r\n * The schema is designed for use with Drizzle ORM and PostgreSQL, providing type-safe\r\n * database operations throughout the application.\r\n *\r\n * @module lib/drizzle-db/schema\r\n * @version 1.0.0\r\n * @since 2025-07-16\r\n *\r\n * @example\r\n * ```typescript\r\n * import { schema, SchemaType, FullSchemaType } from '@/lib/drizzle-db/schema';\r\n *\r\n * // Use the complete schema for database operations\r\n * const db = drizzle(connection, { schema });\r\n *\r\n * // Type-safe table access\r\n * const users = await db.select().from(schema.users);\r\n * ```\r\n */\r\n\r\nimport * as tables from '@/drizzle/schema';\r\nimport * as dbRelations from '@/drizzle/custom-relations';\r\nimport {\r\n  PgQueryResultHKT,\r\n  PgTable,\r\n  PgTransaction,\r\n  PgUpdateBuilder,\r\n} from 'drizzle-orm/pg-core';\r\nimport { drizzle } from 'drizzle-orm/postgres-js';\r\nimport { RelationalQueryBuilder } from 'drizzle-orm/gel-core/query-builders/query';\r\nimport { DrizzleTypeError } from 'drizzle-orm/utils';\r\nimport { TablesRelationalConfig } from 'drizzle-orm';\r\n\r\n/**\r\n * Unified database schema object combining all table definitions and custom relations.\r\n *\r\n * This schema object includes:\r\n * - All table definitions (users, emails, chats, documents, etc.)\r\n * - All enum definitions (importStageType, recipientType, etc.)\r\n * - All view definitions (materialized and regular views)\r\n * - All custom relations between tables\r\n * - Foreign key constraints and indexes\r\n *\r\n * The schema supports the following main functional areas:\r\n * - **Email Management**: emails, emailAttachments, emailRecipients, stagingMessage\r\n * - **Document Processing**: documentUnits, documentProperty, documentUnitEmbeddings\r\n * - **AI Chat System**: chats, chatTurns, chatMessages, chatHistory\r\n * - **User Management**: users, accounts, sessions, contacts\r\n * - **Analysis & Compliance**: analysisStage, complianceScoresDetails, violationDetails\r\n * - **Call-to-Action Tracking**: callToActionDetails, callToActionExpectedResponse\r\n * - **MCP Integration**: mcpSessions, mcpEvents\r\n *\r\n * @constant\r\n * @type {object}\r\n */\r\nconst schema = { ...tables, ...dbRelations };\r\n\r\nexport const relations = dbRelations;\r\n/**\r\n * Complete type definition for the entire database schema.\r\n *\r\n * This type represents the full schema object including all tables, relations,\r\n * views, and enums. It provides comprehensive type safety for all database\r\n * operations and can be used for advanced type manipulations.\r\n *\r\n * @typedef {typeof schema} DbFullSchemaType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { DbFullSchemaType } from '@/lib/drizzle-db/schema';\r\n *\r\n * function processSchema(schema: DbFullSchemaType) {\r\n *   // Access any table or relation with full type safety\r\n *   const userTable = schema.users;\r\n *   const emailRelation = schema.emailsRelations;\r\n * }\r\n * ```\r\n */\r\nexport type DbFullSchemaType = typeof schema;\r\n\r\n/**\r\n * Helper function used to infer the type of our database schema.\r\n *\r\n * This function creates a mock database instance to extract type information\r\n * from Drizzle's type system. It's used internally for type inference and\r\n * should not be called at runtime.\r\n *\r\n * **⚠️ CRITICAL FOR TYPE SYSTEM - DO NOT REMOVE**\r\n *\r\n * This function is essential for:\r\n * - Extracting the correct `DbQueryResultHKT` type from Drizzle's internals\r\n * - Providing type-safe transaction interfaces\r\n * - Ensuring proper TypeScript inference for database operations\r\n *\r\n * The function uses Drizzle's `.mock()` method to create a virtual database\r\n * instance that matches our schema configuration. This allows TypeScript\r\n * to infer the exact types needed for transactions and queries without\r\n * requiring an actual database connection.\r\n *\r\n * @internal\r\n * @returns A mock database instance with the complete schema configured\r\n * @example\r\n * ```typescript\r\n * // This is used internally for type inference only\r\n * type DbInstance = ReturnType<typeof makeMockDb>;\r\n *\r\n * // The function enables these type extractions:\r\n * type TransactionType = Parameters<DbInstance['transaction']>[0];\r\n * type QueryResultType = Parameters<TransactionType>[0];\r\n * ```\r\n *\r\n * @see {@link DbQueryResultHKT} - Type extracted from this function's return type\r\n * @see {@link DbTransactionType} - Transaction type that depends on this function\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nconst makeMockDb = () =>\r\n  drizzle.mock({\r\n    schema,\r\n    casing: 'snake_case',\r\n  });\r\n\r\n/**\r\n * Type definition for the project database instance.\r\n * This type is generated by Drizzle ORM and corresponds to the database instance,\r\n * which includes all tables, relations, and configurations.\r\n * This type is used throughout the application to ensure type-safe database operations\r\n *\r\n *\r\n * @typedef {typeof makeMockDb} DatabaseType\r\n * @example\r\n * ```typescript\r\n * import type { DatabaseType } from '@/lib/drizzle-db/schema';\r\n * // This type represents the database instance with all tables and relations\r\n * const db: DatabaseType = makeMockDb();\r\n * // Use the db instance for type-safe queries\r\n * const users = await db.select().from(schema.users);\r\n * ```\r\n */\r\nexport type DbDatabaseType = Omit<ReturnType<typeof makeMockDb>, '$client'>;\r\n\r\nexport type DbTransactionParam = Parameters<\r\n  ReturnType<typeof makeMockDb>['transaction']\r\n>[0];\r\n\r\n/**\r\n * Higher-Kinded Type (HKT) representing the query result interface for database operations.\r\n *\r\n * This advanced TypeScript type extracts the query result type from Drizzle's transaction\r\n * interface using conditional type inference. It represents the shape of the query builder\r\n * that's available within database transactions and regular database operations.\r\n *\r\n * The HKT pattern allows for:\r\n * - Type-safe query building\r\n * - Proper inference of return types for database operations\r\n * - Consistent typing across transaction and non-transaction contexts\r\n *\r\n * This type is extracted by:\r\n * 1. Creating a mock database instance with our schema via `makeMockDb()`\r\n * 2. Inferring the transaction callback parameter type from the mock instance\r\n * 3. Extracting the `TQueryResult` generic from the `PgTransaction` type\r\n * 4. Using conditional type inference to capture the query builder interface\r\n *\r\n * **Type Extraction Process:**\r\n * ```typescript\r\n * ReturnType<typeof makeMockDb> // → Mock database instance\r\n *   extends { transaction: (...) => ... } // → Check for transaction method\r\n *     ? TQueryResult // → Extract the query result type parameter\r\n *     : never // → Fallback if extraction fails\r\n * ```\r\n *\r\n * @typedef {object} DbQueryResultHKT\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { DbQueryResultHKT } from '@/lib/drizzle-db/schema';\r\n *\r\n * // This type provides the query builder interface\r\n * type QueryBuilder = DbQueryResultHKT;\r\n *\r\n * // Used internally by Drizzle for type-safe operations\r\n * function executeQuery(qb: QueryBuilder) {\r\n *   return qb.select().from(schema.users);\r\n * }\r\n * ```\r\n *\r\n * @see {@link DbTransactionType} - The transaction type that uses this HKT\r\n * @see {@link makeMockDb} - The helper function used for type inference\r\n */\r\nexport type DbQueryResultHKT = DbTransactionParam extends (\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  tx: PgTransaction<infer TQueryResult, any, any>,\r\n) => unknown\r\n  ? TQueryResult\r\n  : never;\r\n\r\n/**\r\n * Filtered schema type containing only entities with relation configurations.\r\n *\r\n * This utility type extracts only the schema entities that have relation\r\n * configurations defined. It's useful when you need to work specifically\r\n * with related data and want to ensure type safety for relational operations.\r\n *\r\n * The type uses conditional type mapping to include only entities where:\r\n * - The entity has a `config` property\r\n * - The `config` property contains a `relations` field\r\n *\r\n * This is particularly useful for:\r\n * - Relational queries with joins\r\n * - Type-safe relation access\r\n * - Filtering out standalone tables without relationships\r\n *\r\n * @typedef {object} DbSchemaType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { DbSchemaType } from '@/lib/drizzle-db/schema';\r\n *\r\n * function queryWithRelations(relationalSchema: DbSchemaType) {\r\n *   // Only tables with relations are available\r\n *   // This ensures you're working with entities that support joins\r\n *   const usersWithRelations = relationalSchema.users;\r\n * }\r\n * ```\r\n */\r\nexport type DbSchemaType = DbTransactionParam extends (\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  tx: PgTransaction<any, any, infer TQueryResult>,\r\n) => unknown\r\n  ? TQueryResult\r\n  : never;\r\n\r\n/**\r\n * Type definition for database transactions with full schema support.\r\n *\r\n * This type represents a PostgreSQL transaction context that includes:\r\n * - Complete type safety for all schema entities\r\n * - Support for both relational and non-relational tables\r\n * - Proper query result type inference\r\n * - Transaction-specific operations and rollback capabilities\r\n *\r\n * The transaction type is parameterized with:\r\n * - `DbQueryResultHKT`: The query result interface for type-safe operations\r\n * - `DbFullSchemaType`: The complete schema including all tables and relations\r\n * - `DbSchemaType`: The filtered schema containing only relational entities\r\n *\r\n * Common use cases:\r\n * - **Atomic Operations**: Ensuring multiple database operations succeed or fail together\r\n * - **Complex Queries**: Performing multi-table operations with proper type safety\r\n * - **Data Consistency**: Maintaining referential integrity across related tables\r\n * - **Error Handling**: Automatic rollback on exceptions\r\n *\r\n * @typedef {PgTransaction<DbQueryResultHKT, DbFullSchemaType, DbSchemaType>} DbTransactionType\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { DbTransactionType } from '@/lib/drizzle-db/schema';\r\n * import { db } from '@/lib/drizzle-db';\r\n *\r\n * // Type-safe transaction function\r\n * async function createUserWithProfile(\r\n *   userData: { name: string; email: string },\r\n *   profileData: { bio: string; avatar: string }\r\n * ) {\r\n *   return await db.transaction(async (tx: DbTransactionType) => {\r\n *     // Insert user with full type safety\r\n *     const [user] = await tx\r\n *       .insert(schema.users)\r\n *       .values(userData)\r\n *       .returning();\r\n *\r\n *     // Insert related profile\r\n *     const [profile] = await tx\r\n *       .insert(schema.userProfiles)\r\n *       .values({ ...profileData, userId: user.id })\r\n *       .returning();\r\n *\r\n *     return { user, profile };\r\n *   });\r\n * }\r\n *\r\n * // Error handling with automatic rollback\r\n * async function transferData(fromId: string, toId: string, amount: number) {\r\n *   try {\r\n *     return await db.transaction(async (tx: DbTransactionType) => {\r\n *       // All operations are atomic\r\n *       await tx.update(schema.accounts)\r\n *         .set({ balance: sql`balance - ${amount}` })\r\n *         .where(eq(schema.accounts.id, fromId));\r\n *\r\n *       await tx.update(schema.accounts)\r\n *         .set({ balance: sql`balance + ${amount}` })\r\n *         .where(eq(schema.accounts.id, toId));\r\n *\r\n *       // If any operation fails, entire transaction rolls back\r\n *     });\r\n *   } catch (error) {\r\n *     console.error('Transaction failed, rolled back:', error);\r\n *     throw error;\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @see {@link DbQueryResultHKT} - The query result type used in transactions\r\n * @see {@link DbFullSchemaType} - The complete schema type\r\n * @see {@link DbSchemaType} - The relational schema type\r\n */\r\nexport type DbTransactionType = PgTransaction<\r\n  DbQueryResultHKT,\r\n  DbFullSchemaType,\r\n  DbSchemaType\r\n>;\r\n\r\n/**\r\n * Named export of the complete database schema.\r\n *\r\n * @see {@link schema}\r\n */\r\nexport { schema };\r\n\r\n/**\r\n * Default export of the complete database schema.\r\n *\r\n * @default schema\r\n * @see {@link schema}\r\n */\r\nexport default schema;\r\n\r\nexport type DbQueryProvider<\r\n  TSchema extends TablesRelationalConfig,\r\n  TFullSchema,\r\n> = {\r\n  query: TFullSchema extends Record<string, never>\r\n    ? DrizzleTypeError<'Seems like the schema generic is missing - did you forget to add it to your DB type?'>\r\n    : {\r\n        [K in keyof TSchema]: RelationalQueryBuilder<TSchema, TSchema[K]>;\r\n      };\r\n  update: <\r\n    TTable extends PgTable,\r\n    TQueryResult extends PgQueryResultHKT = PgQueryResultHKT,\r\n  >(\r\n    table: TTable,\r\n  ) => PgUpdateBuilder<TTable, TQueryResult>;\r\n};\r\nexport type ThisDbQueryProvider = DbQueryProvider<\r\n  DbSchemaType,\r\n  DbQueryResultHKT\r\n>;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\email\\email-id-resolver.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":115,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { drizDbWithInit } from '@/lib/drizzle-db';\r\nimport { isValidUuid } from '@/lib/ai/tools/utility';\r\nimport { redirect, notFound } from 'next/navigation';\r\nimport { LoggedError } from '../react-util';\r\nimport { isRedirectError } from 'next/dist/client/components/redirect-error';\r\n\r\n/**\r\n * Resolves an email ID from either a UUID or document unit ID, with automatic redirects.\r\n *\r\n * @param emailIdParam - The route parameter that could be either an email ID (UUID) or document unit ID (number)\r\n * @param currentPath - The current path to redirect to with the resolved email ID\r\n * @returns The resolved email ID if valid, otherwise triggers redirect or 404\r\n */\r\nexport async function resolveEmailIdWithRedirect(\r\n  emailIdParam: string,\r\n  currentPath: string,\r\n): Promise<string> {\r\n  // If no email id provided, show 404\r\n  if (!emailIdParam) {\r\n    notFound();\r\n  }\r\n\r\n  // Check if it's already a valid UUID (email ID)\r\n  if (isValidUuid(emailIdParam)) {\r\n    return emailIdParam;\r\n  }\r\n\r\n  // Try to parse as document unit ID (numeric)\r\n  const documentId = Number(emailIdParam);\r\n  if (!documentId || Number.isNaN(documentId)) {\r\n    // Invalid format - not UUID and not a valid number\r\n    notFound();\r\n  }\r\n\r\n  // Look up the email ID associated with this document unit ID\r\n  try {\r\n    const doc = await (\r\n      await drizDbWithInit()\r\n    ).query.documentUnits.findFirst({\r\n      where: (d, { eq, isNotNull, and }) =>\r\n        and(eq(d.unitId, documentId), isNotNull(d.emailId)),\r\n      columns: {\r\n        unitId: true,\r\n        emailId: true,\r\n      },\r\n    });\r\n\r\n    if (!doc || !doc.emailId) {\r\n      // No matching document found\r\n      notFound();\r\n    }\r\n\r\n    // Document ID was used - redirect to the email ID equivalent\r\n    const redirectPath = currentPath.replace(`[emailId]`, doc.emailId);\r\n    redirect(redirectPath);\r\n  } catch (error) {\r\n    if (isRedirectError(error)) {\r\n      throw error;\r\n    }\r\n    LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: 'EmailIdResolver',\r\n      message: 'Failed to resolve document ID to email ID',\r\n      critical: true,\r\n    });\r\n    notFound();\r\n  }\r\n}\r\n\r\n/**\r\n * Resolves an email ID from either a UUID or document unit ID, without redirects.\r\n * Used for cases where you just need the email ID value.\r\n *\r\n * @param emailIdParam - The route parameter that could be either an email ID (UUID) or document unit ID (number)\r\n * @returns The resolved email ID if valid, otherwise null\r\n */\r\nexport async function resolveEmailId(\r\n  emailIdParam: string,\r\n): Promise<string | null> {\r\n  // If no email id provided, return null\r\n  if (!emailIdParam) {\r\n    return null;\r\n  }\r\n\r\n  // Check if it's already a valid UUID (email ID)\r\n  if (isValidUuid(emailIdParam)) {\r\n    return emailIdParam;\r\n  }\r\n\r\n  // Try to parse as document unit ID (numeric)\r\n  const documentId = Number(emailIdParam);\r\n  if (!documentId || Number.isNaN(documentId)) {\r\n    // Invalid format - not UUID and not a valid number\r\n    return null;\r\n  }\r\n\r\n  // Look up the email ID associated with this document unit ID\r\n  try {\r\n    const doc = await (\r\n      await drizDbWithInit()\r\n    ).query.documentUnits.findFirst({\r\n      where: (d, { eq }) => eq(d.unitId, documentId),\r\n      columns: {\r\n        unitId: true,\r\n        emailId: true,\r\n      },\r\n    });\r\n\r\n    return doc?.emailId || null;\r\n  } catch (error) {\r\n    console.error('Error resolving document ID to email ID:', error);\r\n    return null;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\email\\import\\default\\manager-completed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\email\\import\\default\\transactional-statemanager.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":285,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ctx' is defined but never used.","line":280,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":280,"endColumn":8,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  ImportSourceMessage,\r\n  ImportStage,\r\n  ImportStageValues,\r\n} from '@/data-models/api/import/email-message';\r\nimport {\r\n  TransactionalImportStageManager,\r\n  StageProcessorContext,\r\n  AdditionalStageOptions,\r\n} from '../types';\r\nimport { query, queryExt } from '@/lib/neondb';\r\nimport { CustomAppInsightsEvent, log } from '@/lib/logger';\r\nimport { NextRequest } from 'next/server';\r\nimport { NextApiRequest } from 'next';\r\n\r\n/**\r\n * The `TransactionalStateManagerBase` class provides a base implementation for managing\r\n * the state of import transactions. It implements the `TransactionalImportStageManager` interface\r\n * and provides methods to begin, commit, and rollback transactions, as well as to execute\r\n * stage processors.\r\n *\r\n */\r\nexport class TransactionalStateManagerBase\r\n  implements TransactionalImportStageManager\r\n{\r\n  static readonly NullId = 'null-id' as const;\r\n  static readonly calculateNextStage = (stage: ImportStage) => {\r\n    if (stage === 'completed') {\r\n      return 'completed';\r\n    }\r\n    const thisStageIndex = ImportStageValues.indexOf(stage);\r\n    if (thisStageIndex === -1) {\r\n      throw new Error(`Invalid stage: ${stage}`);\r\n    }\r\n    return ImportStageValues[thisStageIndex + 1];\r\n  };\r\n  #transactionId: string | null;\r\n  readonly #stage: ImportStage;\r\n  readonly #nextStage: ImportStage;\r\n  #activeTransaction: ImportSourceMessage | undefined;\r\n  #request: NextRequest | NextApiRequest;\r\n  #skipStageBump = false;\r\n  protected importEvent: CustomAppInsightsEvent | undefined;\r\n\r\n  constructor(stage: ImportStage, { req }: AdditionalStageOptions) {\r\n    this.#stage = stage;\r\n\r\n    this.#nextStage =\r\n      stage === 'completed'\r\n        ? stage\r\n        : ImportStageValues[ImportStageValues.indexOf(stage) + 1];\r\n\r\n    this.#transactionId = TransactionalStateManagerBase.NullId;\r\n    this.#request = req;\r\n  }\r\n  get request(): NextRequest | NextApiRequest {\r\n    return this.#request;\r\n  }\r\n  get requireRequest(): NextRequest | NextApiRequest {\r\n    if (!this.#request) {\r\n      throw new Error('Request is required');\r\n    }\r\n    return this.#request;\r\n  }\r\n  /**\r\n   * Gets the transaction ID of the currently active transaction.\r\n   * If there is no active transaction, returns a null identifier.\r\n   *\r\n   * @returns {string} The transaction ID or a null identifier.\r\n   */\r\n  protected get txId(): string {\r\n    return this.#transactionId ?? TransactionalStateManagerBase.NullId;\r\n  }\r\n  /**\r\n   * Gets the current import stage.\r\n   *\r\n   * @returns {ImportStage} The current stage of the import process.\r\n   */\r\n  get stage(): ImportStage {\r\n    return this.#stage;\r\n  }\r\n\r\n  /**\r\n   * Gets the next stage of the import process.\r\n   *\r\n   * @returns {ImportStage} The next stage of the import process.\r\n   */\r\n  get nexStage(): ImportStage {\r\n    return this.#nextStage;\r\n  }\r\n\r\n  /**\r\n   * Begins a new import transaction.\r\n   *\r\n   * @template TStage - The type of the import stage.\r\n   * @param {StageProcessorContext} options - The context for the stage processor, containing the target and next stage.\r\n   * @returns {Promise<StageProcessorContext>} - A promise that resolves to the stage processor context.\r\n   * @throws {Error} - Throws an error if a transaction is already in progress.\r\n   */\r\n  public begin(options: StageProcessorContext): Promise<StageProcessorContext> {\r\n    if (this.#activeTransaction) {\r\n      throw new Error('Transaction already in progress');\r\n    }\r\n    if (options.target && typeof options.target === 'object') {\r\n      this.setTransaction(options.target);\r\n    }\r\n\r\n    return Promise.resolve(options);\r\n  }\r\n\r\n  /**\r\n   * Sets the current transaction with the provided target.\r\n   *\r\n   * @param target - The transaction target to set. Must be an object with an `id` property.\r\n   * @param skipStageBump - A flag indicating whether to skip the stage bump when tx commits.\r\n   * @throws {Error} If a transaction is already in progress.\r\n   * @throws {Error} If the target is not a valid object.\r\n   *\r\n   * @remarks\r\n   * This method initializes a new transaction by setting the `#transactionId` and `#activeTransaction`\r\n   * properties. It also logs an audit message indicating that the import transaction has started.\r\n   */\r\n  protected setTransaction(\r\n    target: ImportSourceMessage,\r\n    skipStageBump?: boolean,\r\n  ): boolean {\r\n    if (this.#activeTransaction) {\r\n      throw new Error('Transaction already in progress');\r\n    }\r\n    if (\r\n      !target ||\r\n      typeof target !== 'object' ||\r\n      !target.raw ||\r\n      !target.raw.id\r\n    ) {\r\n      return false;\r\n    }\r\n    this.#transactionId = target.id ?? TransactionalStateManagerBase.NullId;\r\n    this.#activeTransaction = JSON.parse(JSON.stringify(target));\r\n    if (skipStageBump === true) {\r\n      this.#skipStageBump = true;\r\n    }\r\n    log((l) =>\r\n      l.info({\r\n        message: '[AUDIT]: Import Transaction Started.',\r\n        stage: this.stage,\r\n        txId: this.txId,\r\n      }),\r\n    );\r\n    return true;\r\n  }\r\n  /**\r\n   * Commits the current stage of the import process.\r\n   *\r\n   * @template TStage - The type of the import stage.\r\n   * @param {StageProcessorContext} ctx - The context of the current stage processor.\r\n   * @returns {Promise<StageProcessorContext>} - A promise that resolves to the updated stage processor context.\r\n   * @throws {Error} - Throws an error if there is no active transaction or if the staging message update fails.\r\n   */\r\n  public async commit(\r\n    ctx: StageProcessorContext,\r\n  ): Promise<StageProcessorContext> {\r\n    if (this.importEvent) {\r\n      this.importEvent.dispose();\r\n      log((l) => l.info(this.importEvent!)).then(\r\n        () => (this.importEvent = undefined),\r\n      );\r\n    }\r\n    if (!this.#skipStageBump) {\r\n      const work = ctx;\r\n      work.currentStage = ctx.nextStage as ImportStage;\r\n      if (work.target) {\r\n        work.target.stage = work.currentStage;\r\n      }\r\n      if (ctx.currentStage !== 'completed') {\r\n        work.nextStage = TransactionalStateManagerBase.calculateNextStage(\r\n          ctx.nextStage,\r\n        );\r\n      }\r\n    }\r\n    if (!this.#activeTransaction) {\r\n      return ctx;\r\n    }\r\n    const id = this.txId;\r\n    if (id === TransactionalStateManagerBase.NullId) {\r\n      if (ctx.currentStage !== 'new') {\r\n        log((l) => l.error(new Error('Transaction ID is null')));\r\n      }\r\n    } else if (!this.#skipStageBump) {\r\n      if (ctx.currentStage === 'completed') {\r\n        const result = await query(\r\n          (sql) =>\r\n            sql`DELETE FROM staging_message WHERE id = ${id} RETURNING id`,\r\n        );\r\n        if (!result.length) {\r\n          throw new Error('Failed to delete staging message');\r\n        }\r\n      } else {\r\n        const result = await queryExt(\r\n          (sql) =>\r\n            sql`UPDATE staging_message SET stage = ${ctx.currentStage} WHERE id = ${id}`,\r\n        );\r\n        if (!result.rowCount) {\r\n          throw new Error('Failed to update staging message');\r\n        }\r\n      }\r\n      log((l) =>\r\n        l.info({\r\n          message: '[AUDIT]: Import Transaction Committed.',\r\n          stage: this.#stage,\r\n          txId: this.#activeTransaction?.id,\r\n        }),\r\n      );\r\n    }\r\n    this.#resetTransaction();\r\n    return ctx;\r\n  }\r\n\r\n  #resetTransaction(): void {\r\n    this.#activeTransaction = undefined;\r\n    this.#transactionId = TransactionalStateManagerBase.NullId;\r\n    this.#skipStageBump = false;\r\n  }\r\n\r\n  /**\r\n   * Rolls back the current transaction.\r\n   *\r\n   * If the transaction ID is null, logs an error message.\r\n   * Otherwise, updates the stage of the message in the staging_message table\r\n   * to the current stage and logs a warning message indicating that the\r\n   * import transaction has been rolled back.\r\n   *\r\n   * After rolling back, sets the active transaction to null.\r\n   *\r\n   * @returns {Promise<void>} A promise that resolves when the rollback is complete.\r\n   */\r\n  public async rollback(): Promise<void> {\r\n    if (this.importEvent) {\r\n      this.importEvent.dispose();\r\n      log((l) => l.info(this.importEvent!)).then(\r\n        () => (this.importEvent = undefined),\r\n      );\r\n    }\r\n    const id = this.txId;\r\n    if (!id || id === TransactionalStateManagerBase.NullId) {\r\n      log((l) => l.verbose({ message: 'No active transaction to roll back' }));\r\n      this.#resetTransaction();\r\n      return;\r\n    }\r\n    const result = await query(\r\n      (sql) =>\r\n        sql`UPDATE staging_message SET stage = ${\r\n          this.#stage\r\n        } WHERE id = ${id} RETURNING id`,\r\n    );\r\n\r\n    if (!result.length) {\r\n      throw new Error('Rollback failed: no rows updated');\r\n    }\r\n\r\n    log((l) =>\r\n      l.warn({\r\n        message: '[AUDIT]: Import Transaction Rolled Back.',\r\n        stage: this.#stage,\r\n        txId: this.txId,\r\n      }),\r\n    );\r\n    this.#resetTransaction();\r\n  }\r\n  /**\r\n   * Executes the stage processor with the given context.\r\n   *\r\n   * @template TStage - The type of the import stage.\r\n   * @param {StageProcessorContext} ctx - The context for the stage processor.\r\n   * @returns {Promise<StageProcessorContext>} A promise that resolves to the stage processor context.\r\n   * @throws {Error} Throws an error indicating that the method is not implemented.\r\n   */\r\n  public run(\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    ctx: StageProcessorContext,\r\n  ): Promise<StageProcessorContext> {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\email\\import\\google\\attachment-download.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\email\\import\\google\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\email\\import\\google\\manager-attachments.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\email\\import\\google\\manager-body.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'supress' is defined but never used.","line":325,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":325,"endColumn":29,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\email\\import\\google\\manager-contacts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\email\\import\\google\\manager-header.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":255,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  EmailPropertyRepository,\r\n  EmailPropertyTypeRepository,\r\n} from '@/lib/api/email/properties';\r\n\r\nimport { ImportStage } from '@/data-models/api/import/email-message';\r\nimport {\r\n  EmailProperty,\r\n  EmailPropertyCategoryTypeId,\r\n} from '@/data-models/api/email-properties/property-type';\r\nimport {\r\n  StageProcessorContext,\r\n  ImportStageManagerFactory,\r\n  AdditionalStageOptions,\r\n} from '../types';\r\nimport { TransactionalStateManagerBase } from '../default/transactional-statemanager';\r\nimport { AggregateError } from '@/lib/react-util/errors/aggregate-error';\r\nimport { isError } from '@/lib/react-util/utility-methods';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { CustomAppInsightsEvent, log } from '@/lib/logger';\r\nimport { newUuid } from '@/lib/typescript';\r\nconst EmailPropertyTypeMap: Map<string, number> = new Map();\r\nconst parseEmailId = (x: string) => {\r\n  const match = x.match(/<([^>]+)>/);\r\n  return match ? match[1] : x;\r\n};\r\ntype ParseHeaderArrayProps = {\r\n  split?: string;\r\n  parse?: (arg0: string) => string;\r\n};\r\nconst HeadersWithArrayValueMap: Record<string, ParseHeaderArrayProps> = {\r\n  To: { split: ',' },\r\n  Cc: { split: ',' },\r\n  Bcc: { split: ',' },\r\n  'In-Reply-To': { split: ' ', parse: parseEmailId },\r\n  References: { split: ' ', parse: parseEmailId },\r\n  'Return-Path': { parse: parseEmailId },\r\n  'Message-ID': { parse: parseEmailId },\r\n} as const;\r\nconst HeadersWithArrayValueKeys: ReadonlyArray<\r\n  keyof typeof HeadersWithArrayValueMap\r\n> = Object.keys(HeadersWithArrayValueMap);\r\nconst indexOfHeaderWithArrayKey = (headerName: string): number =>\r\n  HeadersWithArrayValueKeys.findIndex(\r\n    (x: string) => x.toLowerCase() === headerName.toLowerCase(),\r\n  );\r\nconst getHeaderWithArraySplitBy = (\r\n  headerName: string,\r\n): ParseHeaderArrayProps | undefined => {\r\n  const indexOf = indexOfHeaderWithArrayKey(headerName);\r\n  return indexOf === -1\r\n    ? undefined\r\n    : HeadersWithArrayValueMap[HeadersWithArrayValueKeys[indexOf]];\r\n};\r\n\r\ntype HeaderFailedResult = { status: 'failure'; error: Error };\r\ntype HeaderSuccessResult = { status: 'success'; result: EmailProperty };\r\ntype HeaderSaveResult = HeaderSuccessResult | HeaderFailedResult;\r\n\r\nclass HeaderStateManager extends TransactionalStateManagerBase {\r\n  #importEvent: CustomAppInsightsEvent | undefined;\r\n\r\n  constructor(stage: ImportStage, options: AdditionalStageOptions) {\r\n    super(stage, options);\r\n  }\r\n\r\n  async begin(context: StageProcessorContext) {\r\n    this.#importEvent = new CustomAppInsightsEvent('import::headers');\r\n    this.#importEvent.startTimer('header-import');\r\n    super.begin(context);\r\n    // Load a map of currently known email header identifiers\r\n    if (EmailPropertyTypeMap.size === 0) {\r\n      const emailPropertyRepository: EmailPropertyTypeRepository =\r\n        new EmailPropertyTypeRepository();\r\n      const data =\r\n        await emailPropertyRepository.listForCategory('Email Header');\r\n      data.results.forEach((property) => {\r\n        EmailPropertyTypeMap.set(property.name, property.typeId as number);\r\n      });\r\n    }\r\n    return context;\r\n  }\r\n  async run(context: StageProcessorContext) {\r\n    const { target, currentStage } = context;\r\n    if (typeof target !== 'object') {\r\n      throw new Error(`Expected source message: ${currentStage}`);\r\n    }\r\n    // Get us some repositories\r\n    const emailPropertyRepository: EmailPropertyRepository =\r\n      new EmailPropertyRepository();\r\n    const emailPropertyTypeRepository = new EmailPropertyTypeRepository();\r\n\r\n    type HeaderUploadStatus = {\r\n      name: string;\r\n      status: 'success' | 'failure' | 'skipped';\r\n      typeId: number;\r\n      reason?: string;\r\n    };\r\n\r\n    const operations = target.raw?.payload?.headers?.map((header) => {\r\n      if (!header || !header.name || !header.value) {\r\n        const noHeaderRet = Promise.resolve<HeaderUploadStatus>({\r\n          name: header.name ?? 'Missing',\r\n          status: 'skipped',\r\n          typeId: -1,\r\n        });\r\n        return noHeaderRet;\r\n      }\r\n      const { name: headerName, value: headerValue } = header;\r\n      return new Promise<HeaderUploadStatus>(async (resolve, reject) => {\r\n        let typeId = -1;\r\n        try {\r\n          typeId = EmailPropertyTypeMap.get(headerName) ?? -1;\r\n          if (typeId === -1) {\r\n            const newPropertyType = await emailPropertyTypeRepository.create({\r\n              categoryId: EmailPropertyCategoryTypeId.EmailHeader,\r\n              name: headerName,\r\n              createdOn: new Date(),\r\n            });\r\n            if (!newPropertyType || !newPropertyType.typeId) {\r\n              throw new Error(\r\n                'An unexpected failure occurred while creating a new email property type.',\r\n              );\r\n            }\r\n            // then add it to our local cache for re-use and move on\r\n            typeId = newPropertyType.typeId as number;\r\n            EmailPropertyTypeMap.set(headerName, typeId);\r\n          }\r\n\r\n          const headerParseOptions = getHeaderWithArraySplitBy(headerName);\r\n          if (headerParseOptions) {\r\n            const parts = headerParseOptions.split\r\n              ? headerValue.split(headerParseOptions.split)\r\n              : [headerValue];\r\n            const valueParser = headerParseOptions.parse ?? ((x: string) => x);\r\n            const operations = await Promise.all(\r\n              parts.map((part) => {\r\n                const newProperty: EmailProperty = {\r\n                  documentId: target.documentId!,\r\n                  value: valueParser(part).trim(),\r\n                  propertyId: newUuid(),\r\n                  createdOn: new Date(),\r\n                  typeId: typeId,\r\n                };\r\n                return emailPropertyRepository.create(newProperty).then(\r\n                  (result) => {\r\n                    if (!result || !result.propertyId) {\r\n                      return {\r\n                        status: 'failure',\r\n                        error: new Error(\r\n                          'An unexpected failure occurred while creating a new email property.',\r\n                        ),\r\n                      } as HeaderSaveResult;\r\n                    }\r\n                    this.#importEvent!.increment('processed');\r\n                    return { status: 'success', result } as HeaderSaveResult;\r\n                  },\r\n                  (error) => ({\r\n                    status: 'failure',\r\n                    error: isError(error) ? error : new Error(error),\r\n                  }),\r\n                );\r\n              }),\r\n            );\r\n            const allErrors = operations.filter(\r\n              (x) => x.status === 'failure',\r\n            ) as HeaderFailedResult[];\r\n            if (allErrors.length > 0) {\r\n              throw new AggregateError(\r\n                'An unexpected failure occurred while importing message headers.',\r\n                ...allErrors.map((x) => x.error),\r\n              );\r\n            }\r\n            const successfulOps = operations as HeaderSuccessResult[];\r\n            const { documentId, propertyId } = successfulOps[0].result;\r\n            log((l) =>\r\n              l.verbose({\r\n                message: `Created array of email property for email header ${headerName}: ${operations.length} items created.`,\r\n                headerName,\r\n                documentId,\r\n                propertyId,\r\n                typeId,\r\n                count: operations.length,\r\n              }),\r\n            );\r\n          } else {\r\n            const newProperty: EmailProperty = {\r\n              documentId: target.documentId!,\r\n              value: headerValue,\r\n              propertyId: newUuid(),\r\n              createdOn: new Date(),\r\n              typeId,\r\n            };\r\n            const result = await emailPropertyRepository.create(newProperty);\r\n            if (!result || !result.propertyId) {\r\n              throw new Error(\r\n                'An unexpected failure occurred while creating a new email property.',\r\n              );\r\n            }\r\n            log((l) =>\r\n              l.verbose({\r\n                message: `Created email property for email header `,\r\n                headerName,\r\n                documentId: result.documentId,\r\n                propertyId: result.propertyId,\r\n                typeId: result.typeId,\r\n              }),\r\n            );\r\n            this.#importEvent!.increment('processed');\r\n          }\r\n          resolve({ name: headerName, status: 'success', typeId });\r\n        } catch (error) {\r\n          const le = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n            log: true,\r\n            source: 'HeaderStateManager',\r\n            message:\r\n              'An unexpected error occurred while processing email headers.',\r\n          });\r\n          resolve({\r\n            name: headerName,\r\n            status: 'failure',\r\n            typeId,\r\n            reason: le.message,\r\n          });\r\n        }\r\n        reject(\r\n          new Error(\r\n            'An unexpected error occurred while processing email headers.',\r\n          ),\r\n        );\r\n      });\r\n    }) as Promise<HeaderUploadStatus>[];\r\n    const allHeaders = await Promise.all(operations);\r\n    if (allHeaders.some((header) => header.status === 'failure')) {\r\n      throw new Error(\r\n        'An unexpected error occurred while processing email headers.',\r\n      );\r\n    }\r\n    return context;\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to create an ImportStageManager instance.\r\n *\r\n * @param options - The options to configure the manager.\r\n * @returns An ImportStageManager instance configured with the provided options.\r\n */\r\nconst managerFactory: ImportStageManagerFactory = (\r\n  stage: ImportStage,\r\n  addOps: AdditionalStageOptions,\r\n) => new HeaderStateManager(stage, addOps);\r\n\r\nexport default managerFactory;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\email\\import\\google\\manager-new.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\email\\import\\google\\manager-staged.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":70,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  AdditionalStageOptions,\r\n  ImportStageManagerFactory,\r\n  StageProcessorContext,\r\n} from '../types';\r\nimport { TransactionalStateManagerBase } from '../default/transactional-statemanager';\r\nimport { ImportStage } from '@/data-models/api/import/email-message';\r\nimport { createStagingRecord } from '@/lib/api/email/import/google';\r\nimport { log } from '@/lib/logger';\r\n\r\nclass StagedManager extends TransactionalStateManagerBase {\r\n  constructor(stage: ImportStage, options: AdditionalStageOptions) {\r\n    super(stage, options);\r\n  }\r\n\r\n  async run(context: StageProcessorContext) {\r\n    const { target, currentStage } = context;\r\n    let { providerEmailId } = context;\r\n\r\n    if (typeof providerEmailId !== 'string' || !providerEmailId) {\r\n      if (!target?.raw.id) {\r\n        throw new Error(\r\n          `Invalid state for staging - provider email id not found.`,\r\n        );\r\n      }\r\n      providerEmailId = target.raw.id;\r\n      log((l) =>\r\n        l.warn(\r\n          'ProviderEmailId value pulled from raw output; is this a retry?',\r\n        ),\r\n      );\r\n    }\r\n    const req = this.requireRequest;\r\n    const responseMessage = await createStagingRecord(providerEmailId, {\r\n      req,\r\n    }).awaitable;\r\n    if (!responseMessage) {\r\n      throw new Error(\r\n        `An unexpected failure occurred queuing email ${providerEmailId}.`,\r\n      );\r\n    }\r\n    this.setTransaction(responseMessage);\r\n    log((l) =>\r\n      l.info({\r\n        message: '[AUDIT]: Email import queued successfully.',\r\n        providerEmailId,\r\n        stage: currentStage,\r\n      }),\r\n    );\r\n    return {\r\n      ...context,\r\n      target: responseMessage,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to create an ImportStageManager supporting the staged stage.\r\n *\r\n * @param stage - The import stage to manage.\r\n * @param options - The options to configure the ImportStageManager.\r\n * @returns An ImportStageManager instance.\r\n */\r\nconst managerFactory: ImportStageManagerFactory = (\r\n  stage: ImportStage,\r\n  options: AdditionalStageOptions,\r\n) => new StagedManager(stage, options);\r\n\r\nexport default managerFactory;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\email\\import\\google\\managermapfactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\email\\import\\google\\stage-attachment-utility.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":134,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { AttachmentStagedResult, StageAttachmentProps } from './types';\r\nimport { queueAttachment } from './attachment-download';\r\nimport { StagedAttachmentRepository } from '@/lib/api/email/import/staged-attachment';\r\nimport { gmail_v1 } from '@googleapis/gmail';\r\n\r\n/**\r\n * Stages an email attachment for further processing by creating a staged attachment record\r\n * and queuing it for import. Handles errors and returns the status of the operation.\r\n *\r\n * @param req - The request object, typically containing user/session context.\r\n * @param stagedMessageId - The identifier for the staged email message.\r\n * @param part - The message part representing the attachment, conforming to Gmail API schema.\r\n * @returns A promise that resolves to an object indicating the status of the staging operation,\r\n *          including the partId and error message if applicable.\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = await stageAttachment({\r\n *   req,\r\n *   stagedMessageId: 'abc123',\r\n *   part: {\r\n *     partId: '2',\r\n *     filename: 'document.pdf',\r\n *     mimeType: 'application/pdf',\r\n *     body: { size: 1024, attachmentId: 'att456' },\r\n *     headers: [{ name: 'Content-Type', value: 'application/pdf' }]\r\n *   }\r\n * });\r\n * if (result.status === 'success') {\r\n *   console.log('Attachment staged:', result.partId);\r\n * } else {\r\n *   console.error('Failed to stage attachment:', result.error);\r\n * }\r\n * ```\r\n */\r\nexport const stageAttachment = async ({\r\n  req,\r\n  stagedMessageId,\r\n  part,\r\n}: StageAttachmentProps): Promise<AttachmentStagedResult> => {\r\n  const {\r\n    partId = 'unknown',\r\n    filename,\r\n    mimeType,\r\n  } = part as gmail_v1.Schema$MessagePart;\r\n  try {\r\n    if (partId === 'unknown') {\r\n      throw new Error('partId is required');\r\n    }\r\n    const repository = new StagedAttachmentRepository();\r\n    const model = await repository.create({\r\n      stagedMessageId,\r\n      partId: Number(partId),\r\n      filename: filename ?? `attachment-${partId}`,\r\n      mimeType:\r\n        mimeType ??\r\n        part.headers?.find((h) => h.name === 'Content-Type')?.value ??\r\n        null,\r\n      storageId: null,\r\n      imported: false,\r\n      size: part.body!.size ?? 0,\r\n      fileOid: null,\r\n      attachmentId: part.body!.attachmentId!,\r\n    });\r\n\r\n    await queueAttachment({\r\n      id: `${stagedMessageId}:${model.partId}`,\r\n      job: { model: { ...model, stagedMessageId: stagedMessageId } },\r\n      req: req,\r\n    });\r\n\r\n    return {\r\n      status: 'success',\r\n      partId: partId!,\r\n    };\r\n  } catch (error) {\r\n    const e = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: 'email-import',\r\n      data: { stagedMessageId, partId, filename, mimeType },\r\n    });\r\n    return {\r\n      status: 'error',\r\n      error: e.message,\r\n      partId: partId ?? 'unknown',\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * Recursively queues staged attachments for processing.\r\n *\r\n * This function takes a staged message part and, if it contains an attachment,\r\n * stages it for processing. If the part contains nested parts, it recursively\r\n * processes each sub-part, collecting all resulting promises into a flat array.\r\n *\r\n * @param req - The request object used for staging attachments.\r\n * @param stagedMessageId - The identifier for the staged message.\r\n * @param part - The message part to process, which may contain attachments and/or nested parts.\r\n * @returns An array of promises, each resolving to an `AttachmentStagedResult` for a staged attachment.\r\n *\r\n * @example\r\n * ```typescript\r\n * const results = await Promise.all(\r\n *   queueStagedAttachments({\r\n *     req,\r\n *     stagedMessageId: 'abc123',\r\n *     part: emailPart,\r\n *   })\r\n * );\r\n * ```\r\n */\r\nexport const queueStagedAttachments = ({\r\n  req,\r\n  stagedMessageId,\r\n  part: partFromProps,\r\n}: StageAttachmentProps): Array<Promise<AttachmentStagedResult>> => {\r\n  const partItems = [];\r\n  if (partFromProps.filename && partFromProps.body?.attachmentId) {\r\n    partItems.push(\r\n      stageAttachment({ req, stagedMessageId, part: partFromProps }),\r\n    );\r\n  }\r\n  return partFromProps.parts\r\n    ? [\r\n        ...partItems,\r\n        ...partFromProps.parts.flatMap((part) =>\r\n          queueStagedAttachments({ req, stagedMessageId, part }),\r\n        ),\r\n      ]\r\n    : partItems;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\email\\import\\google\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":50,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { gmail_v1 } from '@googleapis/gmail';\r\nimport { NextApiRequest } from 'next';\r\nimport { NextRequest } from 'next/server';\r\n\r\n/**\r\n * Props required for staging an email attachment.\r\n *\r\n * @property req - The incoming request object, which can be either a Next.js API request or a Next.js middleware request.\r\n * @property stagedMessageId - The identifier for the staged email message to which the attachment belongs.\r\n * @property part - The specific part of the Gmail message representing the attachment, following the Gmail API schema.\r\n */\r\nexport type StageAttachmentProps = {\r\n  /**\r\n   * The incoming request object, which can be either a Next.js API request or a Next.js middleware request.\r\n   */\r\n  req: NextRequest | NextApiRequest;\r\n  /**\r\n   * The identifier for the staged email message to which the attachment belongs.\r\n   */\r\n  stagedMessageId: string;\r\n  /**\r\n   * The specific part of the Gmail message representing the attachment, following the Gmail API schema.\r\n   * This part contains details such as the part ID, filename, MIME type, and body size.\r\n   * It is expected to conform to the `gmail_v1.Schema$MessagePart` type from the Gmail API.\r\n   */\r\n  part: gmail_v1.Schema$MessagePart;\r\n};\r\n\r\n/**\r\n * Represents the result of staging an email attachment.\r\n *\r\n * @property status - Indicates whether the staging was successful ('success') or encountered an error ('error').\r\n * @property error - Optional error message if the staging failed.\r\n * @property partId - The identifier for the email part associated with the attachment.\r\n */\r\nexport type AttachmentStagedResult = {\r\n  /**\r\n   * Indicates whether the staging was successful ('success') or encountered an error ('error').\r\n   */\r\n  status: 'success' | 'error';\r\n  /**\r\n   * Optional error message if the staging failed.\r\n   */\r\n  error?: string;\r\n  /**\r\n   * The identifier for the email part associated with the attachment.\r\n   */\r\n  partId: string;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\email\\import\\google\\utilities.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\email\\import\\importmanager.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":292,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  GmailEmailImportSource,\r\n  ImportResponse,\r\n  ImportSourceMessage,\r\n  ImportStage,\r\n  ImportStageValues,\r\n} from '@/data-models/api/import/email-message';\r\nimport {\r\n  ImportStageManagerFactory,\r\n  type ImportManagerMap,\r\n  type StageProcessorContext,\r\n} from './types';\r\nimport { managerMapFactory } from './google/managermapfactory';\r\nimport { log } from '@/lib/logger';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { isError } from '@/lib/react-util/utility-methods';\r\nimport { NextRequest } from 'next/server';\r\nimport { TransactionalStateManagerBase } from './default/transactional-statemanager';\r\nimport {\r\n  context,\r\n  SpanKind,\r\n  SpanStatusCode,\r\n  trace,\r\n  Tracer,\r\n} from '@opentelemetry/api';\r\n\r\n// import { appMeters } from '@/instrumentation';\r\n\r\n/**\r\n * The `DefaultImportManager` class implements the `ImportManager` interface and provides\r\n * functionality to manage different stages of an import process.\r\n *\r\n * @remarks\r\n * This class defines a static `Stages` property which lists the various stages of the import\r\n * process. It also provides a `chain` method to combine two objects into one, ensuring that\r\n * methods from both objects are called in sequence.\r\n *\r\n * @example\r\n * ```typescript\r\n * const manager = new DefaultImportManager();\r\n * const combined = manager.chain(leftObject, rightObject);\r\n * ```\r\n *\r\n * @typeParam TLeft - The type of the left object.\r\n * @typeParam TRight - The type of the right object.\r\n * @typeParam TRet - The return type which extends `ImportStageManager`.\r\n */\r\nexport class DefaultImportManager {\r\n  static Stages = ImportStageValues;\r\n  readonly #provider: string;\r\n  readonly #map: ImportManagerMap;\r\n  readonly #tracer: Tracer;\r\n  /**\r\n   * Creates an instance of `DefaultImportManager`.\r\n   *\r\n   * @constructor\r\n   * @param {string} provider - The provider used to create the manager map.\r\n   */\r\n  constructor(provider: string) {\r\n    this.#provider = provider;\r\n    this.#map = managerMapFactory(this.#provider);\r\n    this.#tracer = trace.getTracer('sue-the-schools-webui');\r\n  }\r\n\r\n  /**\r\n   * Runs the import stage for the given email ID.\r\n   *\r\n   * @async\r\n   * @param {string | ImportSourceMessage} emailId - The email ID or import source message.\r\n   * @param {Object} options - The options object.\r\n   * @param {NextRequest} options.req - The request object.\r\n   * @returns {Promise<ImportSourceMessage>} - The import source message.\r\n   */\r\n  async runImportStage(\r\n    target: ImportSourceMessage,\r\n    { req }: { req: NextRequest },\r\n  ): Promise<ImportSourceMessage> {\r\n    const typedRunStage = async (stage: ImportStage) => {\r\n      const providerEmailId = target?.providerId ?? 'No ID';\r\n\r\n      const stageContext: StageProcessorContext = {\r\n        providerEmailId,\r\n        target,\r\n        currentStage: stage,\r\n        nextStage: TransactionalStateManagerBase.calculateNextStage(stage),\r\n        accountId: -1,\r\n      };\r\n      const factory = this.#map[stage] as ImportStageManagerFactory;\r\n      const stateManager = factory(stage, { req });\r\n\r\n      try {\r\n        // Begin tx -> run tx -> commit/rollback tx\r\n        const context = await stateManager\r\n          .begin(stageContext)\r\n          .then((c) => stateManager.run(c))\r\n          .then((c) => stateManager.commit(c))\r\n          .catch((e) =>\r\n            stateManager\r\n              .rollback()\r\n              .then(() => {\r\n                throw e;\r\n              })\r\n              .catch((e2) => {\r\n                throw new AggregateError('Error during rollback', e, e2);\r\n              }),\r\n          );\r\n        // If we didn't throw and we're processing the 'new' stage then whatever we got back is what we want\r\n        if (stage === 'new') {\r\n          return context.target;\r\n        }\r\n        if (!context.target) {\r\n          throw new Error(\r\n            `No import target found in current context in stage ${stage}`,\r\n          );\r\n        }\r\n        return context.target;\r\n      } catch (error) {\r\n        throw LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n          log: true,\r\n          source: 'DefaultImportManager',\r\n          data: { stage, providerEmailId },\r\n          critical: true,\r\n        });\r\n      }\r\n    };\r\n    const result = await typedRunStage(target.stage);\r\n    if (!result) {\r\n      throw new Error('Expected a valid ImportSourceMessage to be returned.');\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Imports the email for the given email ID.\r\n   *\r\n   * @async\r\n   * @param {string | ImportSourceMessage} emailId - The email ID or import source message.\r\n   * @param {Object} options - The options object.\r\n   * @param {NextRequest} options.req - The request object.\r\n   * @returns {Promise<{ success: boolean; message: string; data?: ImportSourceMessage; error?: unknown }>} - The result of the import operation.\r\n   */\r\n  async importEmail(\r\n    emailId: string,\r\n    { req }: { req: NextRequest },\r\n  ): Promise<ImportResponse> {\r\n    const activeContext = context.active();\r\n\r\n    return this.#tracer.startActiveSpan(\r\n      'Import Email',\r\n      {\r\n        root: false,\r\n        kind: SpanKind.INTERNAL,\r\n        startTime: performance.now(),\r\n      },\r\n      activeContext,\r\n      async (emailImportSpan): Promise<ImportResponse> => {\r\n        emailImportSpan\r\n          .setAttribute('emailId', emailId)\r\n          .setAttribute('provider', this.#provider)\r\n          .setAttribute('timestamp', new Date().toISOString());\r\n        try {\r\n          let currentUserId = 0;\r\n          let result: ImportSourceMessage = {\r\n            providerId: emailId ?? TransactionalStateManagerBase.NullId,\r\n            stage: 'new',\r\n            raw: null as unknown as GmailEmailImportSource,\r\n            userId: undefined as unknown as number,\r\n          };\r\n          let tries = 0;\r\n          let lastStage: ImportStage | null = null;\r\n          await context.with(\r\n            trace.setSpan(activeContext, emailImportSpan),\r\n            async () => {\r\n              while (result.stage !== 'completed') {\r\n                await this.#tracer.startActiveSpan(\r\n                  result.stage === 'staged'\r\n                    ? 'Staging email for import'\r\n                    : `Import Stage: ${result.stage}`,\r\n                  {\r\n                    root: false,\r\n                    kind: SpanKind.INTERNAL,\r\n                    startTime: performance.now(),\r\n                  },\r\n                  activeContext,\r\n                  async (stageSpan): Promise<void> => {\r\n                    if (currentUserId) {\r\n                      stageSpan.setAttribute('userId', currentUserId);\r\n                    }\r\n                    try {\r\n                      if (lastStage === result.stage) {\r\n                        tries++;\r\n                        if (tries > 3) {\r\n                          const stageError = new Error(\r\n                            `Import stage did not progress after 3 attempts: ${result.stage}`,\r\n                          );\r\n                          stageSpan.recordException(\r\n                            stageError,\r\n                            performance.now(),\r\n                          );\r\n                          /*\r\n                          appMeters\r\n                            .createCounter('Email Import Stage Failed')\r\n                            .add(1);\r\n                          */\r\n                          stageSpan\r\n                            .addEvent(\r\n                              'Import stage failed',\r\n                              { stage: result.stage },\r\n                              performance.now(),\r\n                            )\r\n                            .setStatus({\r\n                              code: SpanStatusCode.ERROR,\r\n                              message: `Import stage ${result.stage} failed`,\r\n                            });\r\n                          throw stageError;\r\n                        }\r\n                        stageSpan.addEvent(\r\n                          'Import stage did not progress, retrying.',\r\n                          { tries: tries, stage: result.stage },\r\n                          performance.now(),\r\n                        );\r\n                      } else {\r\n                        lastStage = result.stage;\r\n                        tries = 0;\r\n                      }\r\n                      result = await this.runImportStage(result, { req });\r\n\r\n                      if (result.userId !== currentUserId) {\r\n                        log((l) =>\r\n                          l.info({\r\n                            message: 'User ID changed',\r\n                            stage:\r\n                              typeof result === 'string' ? 'new' : result.stage,\r\n                          }),\r\n                        );\r\n                        stageSpan.setAttribute('userId', currentUserId);\r\n                        emailImportSpan.setAttribute('userId', currentUserId);\r\n                        currentUserId = result.userId;\r\n                      }\r\n                      log((l) =>\r\n                        l.info({\r\n                          message: 'Import stage completed',\r\n                          stage:\r\n                            typeof result === 'string' ? 'new' : result.stage,\r\n                        }),\r\n                      );\r\n                    } finally {\r\n                      stageSpan.end();\r\n                    }\r\n                  },\r\n                );\r\n              }\r\n            },\r\n          );\r\n\r\n          // appMeters.createCounter('Email Import Operation Successful').add(1);\r\n          emailImportSpan\r\n            .addEvent('Import completed', {}, performance.now())\r\n            .setStatus({\r\n              code: SpanStatusCode.OK,\r\n              message: 'Import completed successfully',\r\n            });\r\n          return {\r\n            success: true,\r\n            message: 'Import successful',\r\n            data: result,\r\n          };\r\n        } catch (error) {\r\n          const le = LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n            source: 'DefaultImportManager',\r\n            log: true,\r\n          });\r\n          emailImportSpan.recordException(le, Date.now());\r\n          // appMeters.createCounter('EmailImportOperationFailed').add(1);\r\n          emailImportSpan\r\n            .addEvent('Import failed', {}, performance.now())\r\n            .setStatus({\r\n              code: SpanStatusCode.ERROR,\r\n              message: 'Import failed',\r\n            });\r\n          return {\r\n            success: false,\r\n            message: (isError(error) ? error.message : null) ?? 'Import failed',\r\n            error: le,\r\n          };\r\n        } finally {\r\n          emailImportSpan.end();\r\n        }\r\n      },\r\n    );\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\email\\import\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":166,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  ImportSourceMessage,\r\n  ImportStage,\r\n} from '@/data-models/api/import/email-message';\r\nimport { ContactRepository } from '@/lib/api/contacts/database';\r\nimport { EmailRepository } from '@/lib/api/email/database';\r\nimport { StagedAttachmentRepository } from '@/lib/api/email/import/staged-attachment';\r\nimport { ThreadRepository } from '@/lib/api/thread/database';\r\nimport { NextApiRequest } from 'next';\r\nimport { NextRequest } from 'next/server';\r\n\r\n/**\r\n * Represents the context for processing a specific stage in the import process.\r\n *\r\n * @type {Object} StageProcessorContext\r\n * @property {string} providerEmailId - The provider identifier for the email source.\r\n * @property {ImportSourceMessage} target - The target of the import.\r\n * @property {ImportStage} currentStage - The current stage of the import process.\r\n * @property {ImportStage} nextStage - The next stage of the import process.\r\n * @property {number} accountId - The ID of the account associated with the import process.\r\n */\r\nexport type StageProcessorContext = {\r\n  /**\r\n   * Provider identifier for the email source.\r\n   */\r\n  providerEmailId: string;\r\n  /**\r\n   * Source email message.\r\n   */\r\n  target?: ImportSourceMessage;\r\n  /**\r\n   * Current stage of the import process.\r\n   */\r\n  currentStage: ImportStage;\r\n  /**\r\n   * Next stage of the import process.\r\n   */\r\n  nextStage: ImportStage;\r\n  /**\r\n   * Account ID associated with the import process.\r\n   */\r\n  accountId: number;\r\n};\r\n\r\n/**\r\n * Represents a manager for handling transactional import stages.\r\n */\r\nexport type TransactionalImportStageManager = {\r\n  /**\r\n   * Begins the transactional stage processing.\r\n   *\r\n   * @param target - The context for the current stage.\r\n   * @returns A promise that resolves with the updated context after beginning the stage.\r\n   */\r\n  begin: (target: StageProcessorContext) => Promise<StageProcessorContext>;\r\n  /**\r\n   * Executes the transactional processing of the current stage.\r\n   *\r\n   * @param target - The context for the current stage.\r\n   * @returns A promise that resolves with the updated context after running the stage.\r\n   */\r\n  run: (target: StageProcessorContext) => Promise<StageProcessorContext>;\r\n  /**\r\n   * Commits the transactional changes made during the stage processing.\r\n   *\r\n   * @param target - The context for the current stage.\r\n   * @returns A promise that resolves with the updated context after committing the stage.\r\n   */\r\n  commit: (target: StageProcessorContext) => Promise<StageProcessorContext>;\r\n  /**\r\n   * Rolls back any changes made during the stage processing.\r\n   *\r\n   * @returns A promise that resolves when rollback has completed.\r\n   */\r\n  rollback: () => Promise<void>;\r\n};\r\n\r\n/**\r\n * Represents the context for processing a specific stage in the import process.\r\n */\r\nexport type AdditionalStageOptions = {\r\n  req: NextRequest | NextApiRequest;\r\n  threadRepository?: ThreadRepository;\r\n  emailRepository?: EmailRepository;\r\n  contactRepository?: ContactRepository;\r\n  stagedAttachmentRepository?: StagedAttachmentRepository;\r\n};\r\n\r\n/**\r\n * An array of string constants representing the key values for stage manager methods.\r\n *\r\n * - 'begin': Represents the beginning of a stage.\r\n * - 'commit': Represents the commitment of a stage.\r\n * - 'rollback': Represents the rollback of a stage.\r\n * - 'run': Represents the execution of a stage.\r\n */\r\nexport const StageManagerMethodKeyValues = [\r\n  'begin',\r\n  'commit',\r\n  'rollback',\r\n  'run',\r\n] as const;\r\n\r\n/**\r\n * A factory function type that creates a `TransactionalImportStageManager` for a given import stage.\r\n *\r\n * @template TStage - The type of the import stage, which extends `ImportStage`.\r\n * @param stage - The specific import stage for which the manager is being created.\r\n * @param param1 - An object containing the request information.\r\n * @param param1.req - The `NextRequest` object representing the HTTP request.\r\n * @param param1.additionalOption - Additional options for the stage manager (if any).\r\n * @returns A `TransactionalImportStageManager` instance for the specified import stage.\r\n */\r\nexport type ImportStageManagerFactory = (\r\n  stage: ImportStage,\r\n  { req }: AdditionalStageOptions,\r\n) => TransactionalImportStageManager;\r\n\r\n/**\r\n * A map of import stages to their respective stage manager factories.\r\n */\r\nexport type ImportManagerMap = {\r\n  [K in ImportStage]: ImportStageManagerFactory;\r\n};\r\n\r\n/**\r\n * Values array representing the types of recipients for an email message.\r\n */\r\nexport const RecipientTypeValues = ['to', 'cc', 'bcc', 'from'] as const;\r\n\r\n/**\r\n * Represents the types of recipients for an email message.\r\n */\r\nexport type RecipientType = (typeof RecipientTypeValues)[number];\r\n\r\n/**\r\n * Represents a parsed contact with full name, first name, last name, and email address.\r\n *\r\n * @property {string} fullName - The full name of the contact.\r\n * @property {string} firstName - The first name of the contact.\r\n * @property {string} lastName - The last name of the contact.\r\n * @property {string} email - The email address of the contact.\r\n */\r\nexport type ParsedContact = {\r\n  /**\r\n   * The full name of the contact.\r\n   */\r\n  fullName: string;\r\n  /**\r\n   * The first name of the contact.\r\n   */\r\n  firstName: string;\r\n  /**\r\n   * The last name of the contact.\r\n   */\r\n  lastName: string;\r\n  /**\r\n   * The email address of the contact.\r\n   */\r\n  email: string;\r\n  /**\r\n   * The type of recipient this contact was parsed from.\r\n   */\r\n  recipientType: RecipientType;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\email\\parsedHeaderMap.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":366,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ContactSummary } from '@/data-models/api/contact';\r\nimport { isKeyOf } from '../typescript';\r\n\r\n/**\r\n * Represents an email header with a name and value.\r\n */\r\nexport interface EmailHeader {\r\n  /**\r\n   * The name of the header before the `:` separator. For example, `To`.\r\n   */\r\n  name?: string | null;\r\n  /**\r\n   * The value of the header after the `:` separator. For example, `someuser@example.com`.\r\n   */\r\n  value?: string | null;\r\n}\r\n\r\n/**\r\n * Parses an email ID from a string.\r\n *\r\n * @param {string} x - The string to parse.\r\n * @returns {string} The parsed email ID.\r\n */\r\nexport type ContactInHeader = Omit<ContactSummary, 'name' | 'contactId'> & {\r\n  name?: string;\r\n};\r\n\r\n/**\r\n * Properties for parsing an array of headers.\r\n *\r\n * @property {string} [split] - The delimiter used to split the header string.\r\n * @property {(arg0: string) => string} [parse] - A function to parse each split header string.\r\n */\r\nexport type ParseHeaderArrayRecord = {\r\n  split?: string;\r\n  parse?: (arg0: string) => string | ContactInHeader;\r\n};\r\n\r\ntype ParseHeaderOptions = {\r\n  expandArrays?: boolean;\r\n  parseContacts?: boolean;\r\n  extractBrackets?: boolean;\r\n};\r\n\r\n/**\r\n * Extracts contact information from a string.\r\n *\r\n * The input string is expected to be in the format \"Name <email@example.com>\".\r\n * If the input string matches this format, the function returns an object with\r\n * `name` and `email` properties. If the input string does not match this format,\r\n * the function returns an object with only the `email` property.\r\n *\r\n * @param x - The input string containing the contact information.\r\n * @returns An object containing the extracted contact information.\r\n *          If the input string matches the expected format, the object will have\r\n *          `name` and `email` properties. Otherwise, it will only have the `email` property.\r\n */\r\nexport class EmailHeaderParser implements ParseHeaderArrayRecord {\r\n  readonly #parser: (x: string) => ContactInHeader | string;\r\n  readonly #split?: string;\r\n\r\n  constructor(splitArrays: boolean, parse: boolean) {\r\n    this.#parser = parse\r\n      ? (x: string) => {\r\n          const match = x.match(/\\s*(?:([^<]+)\\s+)<([^>]+)>/);\r\n          return match\r\n            ? { name: match[1].replaceAll('\"', ''), email: match[2].trim() }\r\n            : { email: x.trim() };\r\n        }\r\n      : (x: string) => x;\r\n    this.#split = splitArrays ? ',' : undefined;\r\n  }\r\n  get split() {\r\n    return this.#split;\r\n  }\r\n  get parse() {\r\n    return this.#parser;\r\n  }\r\n}\r\n\r\nexport class BracketHeaderParser implements ParseHeaderArrayRecord {\r\n  readonly #parser: (x: string) => string;\r\n  readonly #split?: string;\r\n\r\n  constructor(splitArrays: boolean, parse: boolean) {\r\n    this.#parser = parse\r\n      ? (x: string) => {\r\n          const match = x.match(/<([^>]+)>/);\r\n          return match ? match[1] : x;\r\n        }\r\n      : (x: string) => x;\r\n    this.#split = splitArrays ? ' ' : undefined;\r\n  }\r\n  get split() {\r\n    return this.#split;\r\n  }\r\n  get parse() {\r\n    return this.#parser;\r\n  }\r\n}\r\n\r\n/**\r\n * A specialized map for handling email headers, extending the native `Map` class.\r\n * This map allows for multiple values per key and provides utility methods for\r\n * common operations on email headers.\r\n *\r\n * @extends Map\r\n */\r\nexport class ParsedHeaderMap extends Map<\r\n  string,\r\n  string | ContactInHeader | Array<string | ContactInHeader>\r\n> {\r\n  /**\r\n   * Creates a map of header parsing options based on the provided configuration.\r\n   *\r\n   * @param options - An object containing optional configuration properties.\r\n   * @param options.expandArrays - If true, splits the header values by commas.\r\n   * @param options.parseContacts - If true, parses the header values as contacts.\r\n   * @param options.extractBrackets - If true, extracts values from brackets in the header.\r\n   * @returns A record where the keys are header names and the values are parsing options.\r\n   */\r\n  public static makeParseMap = ({\r\n    expandArrays = false,\r\n    parseContacts = false,\r\n    extractBrackets = false,\r\n  }: ParseHeaderOptions = {}) => {\r\n    const ret = {\r\n      to: new EmailHeaderParser(expandArrays, parseContacts),\r\n      cc: new EmailHeaderParser(expandArrays, parseContacts),\r\n      bcc: new EmailHeaderParser(expandArrays, parseContacts),\r\n      from: new EmailHeaderParser(expandArrays, parseContacts),\r\n      'return-path': new BracketHeaderParser(expandArrays, extractBrackets),\r\n      'message-id': new BracketHeaderParser(expandArrays, extractBrackets),\r\n      'in-reply-to': new BracketHeaderParser(expandArrays, extractBrackets),\r\n      references: new BracketHeaderParser(expandArrays, extractBrackets),\r\n      get: (key: string): ParseHeaderArrayRecord | undefined => {\r\n        const normalKey = key.toLocaleLowerCase();\r\n        if (isKeyOf(normalKey, ret)) {\r\n          if (normalKey === 'get') return undefined;\r\n          return ret[normalKey];\r\n        }\r\n      },\r\n    };\r\n\r\n    return ret;\r\n  };\r\n\r\n  /**\r\n   * Converts a `ContactInHeader` object to a string representation.\r\n   * If the contact has a name, it returns the name; otherwise, it returns the email.\r\n   *\r\n   * @param contact - The contact object containing name and email.\r\n   * @returns The name of the contact if available, otherwise the email.\r\n   */\r\n  public static readonly headerContactToString = (contact: ContactInHeader) =>\r\n    contact.name ?? contact.email;\r\n\r\n  /**\r\n   * Converts the given value to a string representation.\r\n   * If the value is a string, it returns the value as is.\r\n   * If the value is a ContactInHeader object, it returns the email property of the object.\r\n   *\r\n   * @param value - The value to be converted to a string. It can be either a string or a ContactInHeader object.\r\n   * @returns The string representation of the value.\r\n   */\r\n  public static readonly valueAsString = (value: string | ContactInHeader) =>\r\n    typeof value === 'string'\r\n      ? value\r\n      : ParsedHeaderMap.headerContactToString(value);\r\n\r\n  /**\r\n   * Converts a value to a `ContactInHeader` object.\r\n   *\r\n   * @param contact - The contact value, either a string or a `ContactInHeader` object.\r\n   * @returns A `ContactInHeader` object.\r\n   */\r\n  public static readonly valueAsContact = (\r\n    contact: string | ContactInHeader,\r\n  ) => (typeof contact === 'string' ? { email: contact } : contact);\r\n\r\n  /**\r\n   * Creates a ParsedHeaderMap instance from an array of Gmail message headers.\r\n   * @param headers - An array of Gmail message headers.\r\n   * @returns A new ParsedHeaderMap instance populated with the provided headers.\r\n   */\r\n  public static fromHeaders(\r\n    headers: Array<EmailHeader> | undefined,\r\n    options?: Partial<ParseHeaderOptions>,\r\n  ): ParsedHeaderMap {\r\n    const parseOptionMap = ParsedHeaderMap.makeParseMap(options);\r\n    const map = new ParsedHeaderMap();\r\n    for (const header of headers ?? []) {\r\n      if (header.name && header.value) {\r\n        if (map.has(header.name)) {\r\n          let value:\r\n            | string\r\n            | ContactInHeader\r\n            | Array<string | ContactInHeader> = header.value;\r\n          const parser = parseOptionMap.get(header.name);\r\n          if (parser) {\r\n            if (parser.split) {\r\n              value = value.split(parser.split).map(parser.parse ?? ((x) => x));\r\n            } else if (parser.parse) {\r\n              value = parser.parse(value);\r\n            }\r\n          }\r\n          if (Array.isArray(value)) {\r\n            const existing = map.get(header.name);\r\n            if (existing) {\r\n              if (Array.isArray(existing)) {\r\n                existing.push(...value);\r\n              } else {\r\n                map.set(header.name, [existing, ...value]);\r\n              }\r\n            }\r\n          } else {\r\n            const existing = map.get(header.name);\r\n            if (Array.isArray(existing)) {\r\n              existing.push(value);\r\n            } else if (existing) {\r\n              map.set(header.name, [existing, value]);\r\n            } else {\r\n              map.set(header.name, value);\r\n            }\r\n          }\r\n        } else {\r\n          let value:\r\n            | string\r\n            | ContactInHeader\r\n            | Array<string | ContactInHeader> = header.value;\r\n          const parser = parseOptionMap.get(header.name);\r\n          if (parser) {\r\n            if (parser.split) {\r\n              value = value.split(parser.split).map(parser.parse ?? ((x) => x));\r\n            } else if (parser.parse) {\r\n              value = parser.parse(value);\r\n            }\r\n          }\r\n          map.set(header.name, value);\r\n        }\r\n      }\r\n    }\r\n    return map;\r\n  }\r\n  /**\r\n   * Retrieves the first value associated with the specified key.\r\n   * @param key - The key whose first value is to be retrieved.\r\n   * @returns The first value associated with the key, or undefined if the key does not exist.\r\n   */\r\n  public getFirstValue(key: string) {\r\n    const value = this.get(key);\r\n    if (Array.isArray(value)) {\r\n      return value[0];\r\n    }\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the first value associated with the specified key as a string.\r\n   *\r\n   * @param key - The key whose first value is to be retrieved.\r\n   * @returns The first value associated with the key as a string, or undefined if the key does not exist.\r\n   */\r\n  public getFirstStringValue(key: string) {\r\n    const value = this.getFirstValue(key);\r\n    return value ? ParsedHeaderMap.valueAsString(value) : undefined;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the first value associated with the specified key as a `ContactInHeader` object.\r\n   *\r\n   * @param key - The key whose first value is to be retrieved.\r\n   * @returns The first value associated with the key as a `ContactInHeader` object, or undefined if the key does not exist.\r\n   */\r\n  public getFirstContactValue(key: string) {\r\n    const value = this.getFirstValue(key);\r\n    return value ? ParsedHeaderMap.valueAsContact(value) : undefined;\r\n  }\r\n  /**\r\n   * Retrieves the first value associated with the specified key, or a default value if the key does not exist.\r\n   * @param key - The key whose first value is to be retrieved.\r\n   * @param defaultValue - The default value to return if the key does not exist.\r\n   * @returns The first value associated with the key, or the default value if the key does not exist.\r\n   */\r\n  public getFirstValueOrDefault(key: string, defaultValue: string) {\r\n    return this.getFirstStringValue(key) ?? defaultValue;\r\n  }\r\n\r\n  /**\r\n   * Retrieves all values associated with the specified key.\r\n   * @param key - The key whose values are to be retrieved.\r\n   * @returns An array of values associated with the key, or an empty array if the key does not exist.\r\n   */\r\n  public getAllValues(key: string): Array<string | ContactInHeader> {\r\n    const value = this.get(key);\r\n    return Array.isArray(value) ? value : value ? [value] : [];\r\n  }\r\n\r\n  /**\r\n   * Retrieves all values associated with the specified key as strings.\r\n   *\r\n   * @param key - The key whose values are to be retrieved.\r\n   * @returns An array of string values associated with the key.\r\n   */\r\n  public getAllStringValues(key: string): Array<string> {\r\n    const value = this.getAllValues(key);\r\n    return value.map(ParsedHeaderMap.valueAsString);\r\n  }\r\n\r\n  /**\r\n   * Retrieves all values associated with the specified key as Contact objects.\r\n   *\r\n   * @param key - The key whose values are to be retrieved.\r\n   * @returns An array of string values associated with the key.\r\n   */\r\n  public getAllContactValues(key: string): Array<ContactInHeader> {\r\n    const value = this.getAllValues(key);\r\n    return value.map(ParsedHeaderMap.valueAsContact);\r\n  }\r\n\r\n  /**\r\n   * Checks if the specified value exists for the given key.\r\n   * @param key - The key to check values against.\r\n   * @param value - The value to check for presence.\r\n   * @returns True if the value exists for the key, otherwise false.\r\n   */\r\n  public hasValue(key: string, value: string): boolean {\r\n    const values = this.getAllValues(key);\r\n    return values.includes(value);\r\n  }\r\n\r\n  /**\r\n   * Counts the number of values associated with the specified key.\r\n   * @param key - The key whose associated values are to be counted.\r\n   * @returns The count of values associated with the key.\r\n   */\r\n  public countValues(key: string): number {\r\n    return this.getAllValues(key).length;\r\n  }\r\n\r\n  /**\r\n   * Clears all values associated with the specified key.\r\n   * @param key - The key whose values are to be cleared.\r\n   */\r\n  public clearValues(key: string): void {\r\n    this.delete(key);\r\n  }\r\n\r\n  /**\r\n   * Clears all values in the map.\r\n   * @returns void\r\n   */\r\n  public clearAllValues(): void {\r\n    this.clear();\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if the given value is an instance of ParsedHeaderMap.\r\n *\r\n * @param value - The value to check.\r\n * @returns True if the value is an instance of ParsedHeaderMap, otherwise false.\r\n */\r\nexport const isParsedHeaderMap = (value: unknown): value is ParsedHeaderMap =>\r\n  value instanceof ParsedHeaderMap;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\error-monitoring\\error-reporter.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\error-monitoring\\error-reporter.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":618,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { isError } from '@/lib/react-util/utility-methods';\r\nimport { log } from '@/lib/logger';\r\nimport {\r\n  ErrorSeverity,\r\n  KnownEnvironmentType,\r\n  ErrorContext,\r\n  ErrorReport,\r\n  ErrorReporterConfig,\r\n  ErrorReporterInterface,\r\n  IContextEnricher,\r\n} from './types';\r\nimport { isRunningOnEdge } from '../site-util/env';\r\nimport { isDrizzleError, errorFromCode } from '@/lib/drizzle-db/drizzle-error';\r\nimport type { PostgresError } from '@/lib/drizzle-db/drizzle-error';\r\n\r\nexport { ErrorSeverity };\r\n\r\nexport type {\r\n  KnownEnvironmentType,\r\n  ErrorContext,\r\n  ErrorReport,\r\n  ErrorReporterConfig,\r\n  ErrorReporterInterface,\r\n};\r\n\r\nconst isGtagClient = <T>(\r\n  check: T,\r\n): check is T & {\r\n  gtag: (\r\n    signal: string,\r\n    event: string,\r\n    params: Record<string, unknown>,\r\n  ) => void;\r\n} =>\r\n  typeof check === 'object' &&\r\n  check !== null &&\r\n  'gtag' in check &&\r\n  typeof check.gtag === 'function';\r\n\r\nconst asEnvironment = (input: string): KnownEnvironmentType => {\r\n  return ['development', 'staging', 'production'].includes(input)\r\n    ? (input as KnownEnvironmentType)\r\n    : 'development';\r\n};\r\n\r\n/**\r\n * Type guard to check if a value is an ErrorReport\r\n * @param check unknown value to check\r\n * @returns boolean indicating if the value is an ErrorReport\r\n */\r\nconst isErrorReport = (check: unknown): check is ErrorReport =>\r\n  typeof check === 'object' &&\r\n  check !== null &&\r\n  'error' in check &&\r\n  isError(check.error) &&\r\n  'context' in check &&\r\n  check.context !== null &&\r\n  'severity' in check &&\r\n  check.severity !== null &&\r\n  check.severity !== undefined;\r\n\r\nconst defaultConfig: ErrorReporterConfig = {\r\n  enableStandardLogging: true,\r\n  enableConsoleLogging: process.env.NODE_ENV === 'development',\r\n  enableExternalReporting: process.env.NODE_ENV === 'production',\r\n  enableLocalStorage: true,\r\n  maxStoredErrors: 50,\r\n  environment: asEnvironment(process.env.NODE_ENV),\r\n};\r\n\r\nconst isContextEnricher = (check: unknown): check is IContextEnricher =>\r\n  typeof check === 'object' &&\r\n  check !== null &&\r\n  'enrichContext' in check &&\r\n  typeof (check as IContextEnricher).enrichContext === 'function';\r\n\r\n\r\nexport class ErrorReporter implements ErrorReporterInterface {\r\n  private config: ErrorReporterConfig;\r\n\r\n  private constructor(config: ErrorReporterConfig) {\r\n    this.config = config;\r\n  }\r\n\r\n  /**\r\n   * Create a new instance of ErrorReporter\r\n   * @param config ErrorReporter configuration\r\n   * @returns ErrorReporter instance\r\n   */\r\n  public static createInstance = (\r\n    config: Partial<ErrorReporterConfig>,\r\n  ): ErrorReporterInterface =>\r\n    new ErrorReporter({\r\n      ...defaultConfig,\r\n      ...config,\r\n    });\r\n\r\n  /**\r\n   * Get singleton instance of ErrorReporter\r\n   */\r\n  public static getInstance(\r\n    config?: ErrorReporterConfig,\r\n  ): ErrorReporterInterface {\r\n    const GLOBAL_KEY = Symbol.for(\r\n      '@noeducation/error-monitoring:ErrorReporter',\r\n    );\r\n    const registry = globalThis as unknown as {\r\n      [key: symbol]: ErrorReporterInterface | undefined;\r\n    };\r\n    if (!registry[GLOBAL_KEY]) {\r\n      registry[GLOBAL_KEY] = ErrorReporter.createInstance(config ?? {});\r\n    }\r\n    return registry[GLOBAL_KEY]!;\r\n  }\r\n\r\n  async #createErrorReport(\r\n    error: Error | unknown,\r\n    severity: ErrorSeverity = ErrorSeverity.MEDIUM,\r\n    context: Partial<ErrorContext> = {},\r\n  ): Promise<ErrorReport> {\r\n    let baseReport: ErrorReport;\r\n    // Check to see if this is an error report already\r\n    if (isErrorReport(error)) {\r\n      baseReport = error;\r\n      if (!Object.keys(error).length || !error.error.message) {\r\n        baseReport.error = this.normalizeError({\r\n          ...baseReport.error,\r\n          message:\r\n            baseReport?.error.message ?? 'Unknown error - No details provided',\r\n        });\r\n      }\r\n    } else {\r\n      // Ensure we have a proper Error object\r\n      const errorObj = this.normalizeError(error);\r\n      baseReport = {\r\n        error: errorObj,\r\n        severity,\r\n      } as ErrorReport;\r\n      if (\r\n        !Object.keys(error as object).length ||\r\n        !(error as { message?: string }).message\r\n      ) {\r\n        (error as { message?: string }).message =\r\n          'Unknown error - No details provided';\r\n      }\r\n    }\r\n\r\n    // Enrich context with browser/environment data\r\n    const enrichedContext = await this.enrichContext({\r\n      ...(baseReport.context ?? {}),\r\n      ...context,\r\n    });\r\n\r\n    // Create error report\r\n    return {\r\n      ...baseReport,\r\n      fingerprint: this.generateFingerprint(baseReport.error!, enrichedContext),\r\n      context: enrichedContext,\r\n      tags: {\r\n        ...(baseReport.tags ?? {}),\r\n        ...this.generateTags(baseReport.error!, enrichedContext),\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Report an error with context and severity\r\n   */\r\n  public async reportError(\r\n    error: Error | unknown,\r\n    severity: ErrorSeverity = ErrorSeverity.MEDIUM,\r\n    context: Partial<ErrorContext> = {},\r\n  ): Promise<void> {\r\n    try {\r\n      // Ensure we have a proper Error object\r\n      const report = await this.#createErrorReport(error, severity, context);\r\n\r\n      if (this.config.enableStandardLogging) {\r\n        const source = report.context.source ?? 'ErrorReporter';\r\n        log((l) =>\r\n          l.error({\r\n            source,\r\n            body: JSON.stringify(report.error),\r\n            severity: report.severity,\r\n            fingerprint: report.fingerprint,\r\n            tags: report.tags,\r\n            context: report.context,\r\n            [Symbol.toStringTag]: `${source}: (${report.fingerprint ?? 'no fingerprint'}) ${report.error.message}`,\r\n          }),\r\n        );\r\n      }\r\n\r\n      // Console logging for development\r\n      if (this.config.enableConsoleLogging) {\r\n        console.group(`🐛 Error Report [${severity.toUpperCase()}]`);\r\n        console.error('Error:', report.error);\r\n        console.table(report.context);\r\n        console.groupEnd();\r\n      }\r\n\r\n      // Store error locally for offline analysis\r\n      if (this.config.enableLocalStorage && typeof window !== 'undefined') {\r\n        this.storeErrorLocally(report);\r\n      }\r\n\r\n      // Report to external services\r\n      if (this.config.enableExternalReporting) {\r\n        await Promise.allSettled([\r\n          this.reportToGoogleAnalytics(report),\r\n          this.reportToApplicationInsights(report),\r\n          // Add other monitoring services here\r\n        ]);\r\n      }\r\n    } catch (reportingError) {\r\n      // Avoid infinite loops - just log to console\r\n      log((l) => l.error('Error in error reporting system', reportingError));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Report a caught error from an error boundary\r\n   */\r\n  public async reportBoundaryError(\r\n    error: Error,\r\n    errorInfo: { componentStack?: string; errorBoundary?: string },\r\n    severity: ErrorSeverity = ErrorSeverity.HIGH,\r\n  ): Promise<void> {\r\n    await this.reportError(error, severity, {\r\n      componentStack: errorInfo.componentStack,\r\n      errorBoundary: errorInfo.errorBoundary,\r\n      breadcrumbs: ['error-boundary-catch'],\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Report unhandled promise rejections\r\n   */\r\n  public async reportUnhandledRejection(\r\n    reason: unknown,\r\n    promise: Promise<unknown>,\r\n  ): Promise<void> {\r\n    const error = reason instanceof Error ? reason : new Error(String(reason));\r\n    await this.reportError(error, ErrorSeverity.HIGH, {\r\n      breadcrumbs: ['unhandled-promise-rejection'],\r\n      additionalData: { promiseString: promise.toString() },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set up global error handlers\r\n   */\r\n  public setupGlobalHandlers(): void {\r\n    if (typeof window === 'undefined') return;\r\n    if (isRunningOnEdge()) {\r\n      console.log('setupGlobalHandlers::edge');\r\n    }\r\n\r\n    // Unhandled errors\r\n    window.addEventListener('error', (event) => {\r\n      this.reportError(\r\n        event.error || new Error(event.message),\r\n        ErrorSeverity.HIGH,\r\n        {\r\n          url: window.location.href,\r\n          breadcrumbs: ['global-error-handler'],\r\n          additionalData: {\r\n            filename: event.filename,\r\n            lineno: event.lineno,\r\n            colno: event.colno,\r\n          },\r\n        },\r\n      );\r\n    });\r\n\r\n    // Unhandled promise rejections\r\n    window.addEventListener('unhandledrejection', (event) => {\r\n      this.reportUnhandledRejection(event.reason, event.promise);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Normalize any thrown value to an Error object\r\n   */\r\n  private normalizeError(error: unknown): Error {\r\n    if (isError(error)) {\r\n      return error;\r\n    }\r\n    if (typeof error === 'string') {\r\n      return new Error(error);\r\n    }\r\n    return new Error(`Non-error thrown: ${String(error)}`);\r\n  }\r\n\r\n  /**\r\n   * Enrich error context with browser and application data\r\n   */\r\n  private async enrichContext(\r\n    context: Partial<ErrorContext>,\r\n  ): Promise<ErrorContext> {\r\n    const enriched: ErrorContext = {\r\n      timestamp: new Date(),\r\n      ...context,\r\n    };\r\n\r\n    if (typeof window !== 'undefined') {\r\n      enriched.userAgent = navigator.userAgent;\r\n      enriched.url = window.location.href;\r\n    }\r\n\r\n    // If the error (or wrapped cause/originalError) is a Postgres/Drizzle\r\n    // error, extract comprehensive failure information and attach it to\r\n    // the context. We purposely truncate potentially-large or\r\n    // sensitive fields (SQL text, parameter arrays) to avoid leaking data\r\n    // while still providing useful diagnostics.\r\n    try {\r\n      const candidates: unknown[] = [];\r\n      if (context && 'error' in context && context.error)\r\n        candidates.push(context.error);\r\n      // Some wrappers store the lower-level error on `cause` or `originalError`.\r\n      const maybeErr = (context as unknown as { error?: unknown }).error;\r\n      const maybeCause =\r\n        (maybeErr as unknown as { cause?: unknown; originalError?: unknown })\r\n          ?.cause ??\r\n        (maybeErr as unknown as { cause?: unknown; originalError?: unknown })\r\n          ?.originalError;\r\n      if (maybeCause) candidates.push(maybeCause);\r\n\r\n      for (const c of candidates) {\r\n        if (isDrizzleError(c)) {\r\n          const pg = c as PostgresError;\r\n          const dbFailure = {\r\n            sqlstate: pg.code,\r\n            codeDescription: errorFromCode(pg.code),\r\n            severity: pg.severity,\r\n            detail: pg.detail,\r\n            hint: pg.hint,\r\n            position: pg.position,\r\n            internalPosition: pg.internalPosition,\r\n            internalQuery: pg.internalQuery,\r\n            where: pg.where,\r\n            schema: pg.schema,\r\n            table: pg.table,\r\n            column: pg.column,\r\n            dataType: pg.dataType,\r\n            constraint: pg.constraint,\r\n            file: pg.file,\r\n            line: pg.line,\r\n            routine: pg.routine,\r\n            // Truncate long SQL or parameter payloads to keep reports safe and small\r\n            query:\r\n              typeof pg.query === 'string'\r\n                ? pg.query.slice(0, 2000)\r\n                : undefined,\r\n            parameters: Array.isArray(pg.parameters)\r\n              ? pg.parameters.slice(0, 20)\r\n              : undefined,\r\n            // Keep a minimal reference to nested errors where useful\r\n            causeName:\r\n              (pg.cause as unknown as { name?: string })?.name ?? undefined,\r\n            originalErrorName:\r\n              (pg.originalError as unknown as { name?: string })?.name ??\r\n              undefined,\r\n          } as const;\r\n\r\n          // Attach under a stable key so downstream consumers can read it.\r\n          (enriched as Record<string, unknown>).dbError = dbFailure;\r\n          break; // one DB error is enough\r\n        }\r\n      }\r\n    } catch (err) {\r\n      // extraction should never crash the reporter; if it does, log and continue\r\n      log((l) =>\r\n        l.warn('Failed to extract DB failure info for error reporter', err),\r\n      );\r\n    }\r\n\r\n    // Give our error a chance to enrich the context further\r\n    if (isContextEnricher(enriched.error)) {\r\n      try {\r\n        const further = await enriched.error.enrichContext(enriched);\r\n        if (further) {\r\n          Object.assign(enriched, further);\r\n        }\r\n      } catch (err) {\r\n        log((l) =>\r\n          l.warn('Error in custom context enricher for error reporting', err),\r\n        );\r\n      }\r\n    }\r\n    return enriched;\r\n  }\r\n\r\n  /**\r\n   * Generate a fingerprint for error deduplication\r\n   */\r\n  private generateFingerprint(error: Error, context: ErrorContext): string {\r\n    const key = `${error.name}:${error.message}:${context.url || 'unknown'}`;\r\n    return btoa(encodeURIComponent(key))\r\n      .replace(/[^a-zA-Z0-9]/g, '')\r\n      .substring(0, 16);\r\n  }\r\n\r\n  /**\r\n   * Generate tags for error categorization\r\n   */\r\n  private generateTags(\r\n    error: Error,\r\n    context: ErrorContext,\r\n  ): Record<string, string> {\r\n    return {\r\n      environment: this.config.environment,\r\n      errorType: error.name,\r\n      url: context.url || 'unknown',\r\n      userAgent: context.userAgent?.substring(0, 50) || 'unknown',\r\n      errorBoundary: context.errorBoundary || 'none',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Store error in localStorage for offline analysis\r\n   */\r\n  private storeErrorLocally(report: ErrorReport): void {\r\n    try {\r\n      if (typeof localStorage === 'undefined') {\r\n        return;\r\n      }\r\n      const stored = JSON.parse(localStorage.getItem('error-reports') || '[]');\r\n      stored.push({\r\n        ...report,\r\n        error: {\r\n          name: report.error.name,\r\n          message: report.error.message,\r\n          stack: report.error.stack,\r\n        },\r\n      });\r\n\r\n      // Keep only the most recent errors\r\n      const trimmed = stored.slice(-this.config.maxStoredErrors);\r\n      localStorage.setItem('error-reports', JSON.stringify(trimmed));\r\n    } catch {\r\n      // Storage failed, ignore\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Report to Google Analytics if available\r\n   */\r\n  private async reportToGoogleAnalytics(report: ErrorReport): Promise<void> {\r\n    if (typeof window !== 'undefined' && isGtagClient(window)) {\r\n      window.gtag('event', 'exception', {\r\n        description: report.error.message,\r\n        fatal: report.severity === ErrorSeverity.CRITICAL,\r\n        error_severity: report.severity,\r\n        error_fingerprint: report.fingerprint,\r\n      });\r\n    }\r\n  }\r\n\r\n  private async server_reportToApplicationInsights(\r\n    report: ErrorReport,\r\n  ): Promise<void> {\r\n    try {\r\n      // Dynamic import so code doesn't hard-depend on OpenTelemetry at runtime\r\n      const otel = await import('@opentelemetry/api');\r\n      const { trace, context, SpanStatusCode } =\r\n        otel as typeof import('@opentelemetry/api');\r\n\r\n      const activeSpan = trace.getSpan(context.active());\r\n      // Build safe attributes: ensure values are primitive (strings)\r\n      const safeAttributes: Record<string, string> = {\r\n        'error.fingerprint': report.fingerprint ?? '',\r\n        ...(report.tags ?? {}),\r\n        severity: String(report.severity),\r\n        context: JSON.stringify(report.context || {}),\r\n      };\r\n\r\n      // If there is an active and still-recording span, attach the error there.\r\n      // Span.isRecording() is the official guard to know if the span can accept events/attributes.\r\n      if (\r\n        activeSpan &&\r\n        typeof (activeSpan as { isRecording: () => boolean }).isRecording ===\r\n          'function' &&\r\n        (activeSpan as { isRecording: () => boolean }).isRecording()\r\n      ) {\r\n        try {\r\n          activeSpan.setAttributes(\r\n            safeAttributes as unknown as import('@opentelemetry/api').Attributes,\r\n          );\r\n        } catch {\r\n          // ignore attribute errors\r\n        }\r\n        activeSpan.recordException(report.error as unknown as Error);\r\n        activeSpan.setStatus({\r\n          code: SpanStatusCode.ERROR,\r\n          message: report.error.message,\r\n        });\r\n        activeSpan.addEvent('error.reported', {\r\n          context: safeAttributes.context,\r\n        } as import('@opentelemetry/api').Attributes);\r\n        return;\r\n      }\r\n\r\n      // If there was an active span but it has ended (or no active span), create a new\r\n      // short-lived span that is linked to the original span context so the error stays\r\n      // correlated to the same trace.\r\n      const tracer = trace.getTracer('noeducation/error-reporter');\r\n      const links = activeSpan\r\n        ? [{ context: activeSpan.spanContext() }]\r\n        : undefined;\r\n      const span = tracer.startSpan('error.report', {\r\n        attributes:\r\n          safeAttributes as unknown as import('@opentelemetry/api').Attributes,\r\n        links,\r\n      });\r\n      try {\r\n        span.recordException(report.error as unknown as Error);\r\n        span.setStatus({\r\n          code: SpanStatusCode.ERROR,\r\n          message: report.error.message,\r\n        });\r\n        span.addEvent('error.reported', {\r\n          context: safeAttributes.context,\r\n        } as import('@opentelemetry/api').Attributes);\r\n      } finally {\r\n        span.end();\r\n      }\r\n    } catch (err) {\r\n      log((l) => l.warn('OpenTelemetry error reporting failed', err));\r\n    }\r\n  }\r\n\r\n  private async client_reportToApplicationInsights(\r\n    report: ErrorReport,\r\n  ): Promise<void> {\r\n    await import('@/instrument/browser').then((m) => {\r\n      const appInsights = m.getAppInsights();\r\n      if (appInsights) {\r\n        appInsights.trackException({\r\n          exception: report.error,\r\n          severityLevel: this.mapSeverityToAppInsights(report.severity),\r\n          properties: {\r\n            ...report.tags,\r\n            ...report.context,\r\n            fingerprint: report.fingerprint,\r\n          },\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Report to Application Insights if available\r\n   */\r\n  private async reportToApplicationInsights(\r\n    report: ErrorReport,\r\n  ): Promise<void> {\r\n    // Implementation would depend on Application Insights setup\r\n    // This is a placeholder for Azure Application Insights integration\r\n    if (typeof window === 'undefined') {\r\n      await this.server_reportToApplicationInsights(report);\r\n      return;\r\n    }\r\n    if (process.env.NEXT_RUNTIME === 'EDGE') {\r\n      log((l) => l.debug('Would report to Application Insights:', report));\r\n      return;\r\n    }\r\n    await this.client_reportToApplicationInsights(report);\r\n  }\r\n\r\n  /**\r\n   * Map our ErrorSeverity enum to Application Insights KnownSeverityLevel\r\n   */\r\n  private mapSeverityToAppInsights(severity: ErrorSeverity): number {\r\n    // Using numeric values that correspond to Application Insights KnownSeverityLevel enum\r\n    // Based on the pattern: error -> Error, warn -> Warning, info -> Information, default -> Verbose\r\n    switch (severity) {\r\n      case ErrorSeverity.CRITICAL:\r\n      case ErrorSeverity.HIGH:\r\n        return 3; // KnownSeverityLevel.Error\r\n      case ErrorSeverity.MEDIUM:\r\n        return 2; // KnownSeverityLevel.Warning\r\n      case ErrorSeverity.LOW:\r\n        return 1; // KnownSeverityLevel.Information\r\n      default:\r\n        return 0; // KnownSeverityLevel.Verbose\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get stored errors for debugging\r\n   */\r\n  public getStoredErrors(): ErrorReport[] {\r\n    if (typeof window === 'undefined') return [];\r\n    try {\r\n      return JSON.parse(localStorage.getItem('error-reports') || '[]');\r\n    } catch {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear stored errors\r\n   */\r\n  public clearStoredErrors(): void {\r\n    if (typeof window !== 'undefined') {\r\n      localStorage.removeItem('error-reports');\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const errorReporter = ErrorReporter.getInstance();\r\n\r\n// Auto-setup global handlers\r\nif (typeof window !== 'undefined') {\r\n  // errorReporter.setupGlobalHandlers();\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\error-monitoring\\index.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\error-monitoring\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":5,"column":1,"nodeType":"Program","endLine":27,"endColumn":51}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Error monitoring and reporting system exports\r\n */\r\n\r\nexport { ErrorReporter, errorReporter } from './error-reporter';\r\nexport type { \r\n  ErrorContext, \r\n  ErrorReport, \r\n  ErrorReporterConfig \r\n} from './error-reporter';\r\nexport { ErrorSeverity } from './error-reporter';\r\n\r\n// React hook for error reporting in components\r\nexport { useErrorReporter } from './use-error-reporter';\r\n\r\n// High-order component for error boundary wrapping\r\nexport { withErrorBoundary } from './with-error-boundary';\r\n\r\n// Error recovery strategies\r\nexport { \r\n  classifyError, \r\n  getRecoveryActions, \r\n  getDefaultRecoveryAction, \r\n  attemptAutoRecovery \r\n} from './recovery-strategies';\r\nexport type { RecoveryAction, RecoveryStrategy } from './recovery-strategies';\r\nexport { ErrorType } from './recovery-strategies';","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\error-monitoring\\recovery-strategies.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\error-monitoring\\recovery-strategies.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":6,"column":1,"nodeType":"Program","endLine":427,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Error recovery strategies for different types of errors\r\n * Provides automatic and manual recovery mechanisms\r\n */\r\n\r\nimport { log } from '../logger';\r\nimport { clientNavigateSignIn, clientReload } from '../nextjs-util';\r\nimport { isRunningOnEdge } from '../site-util/env';\r\n\r\n/**\r\n * Determines the type of error for appropriate recovery strategy\r\n */\r\nexport enum ErrorType {\r\n  NETWORK = 'network',\r\n  AUTHENTICATION = 'authentication',\r\n  VALIDATION = 'validation',\r\n  PERMISSION = 'permission',\r\n  RATE_LIMIT = 'rate_limit',\r\n  SERVER = 'server',\r\n  CLIENT = 'client',\r\n  UNKNOWN = 'unknown',\r\n}\r\n\r\n/**\r\n * Recovery action that can be taken for an error\r\n */\r\nexport interface RecoveryAction {\r\n  id: string;\r\n  label: string;\r\n  description: string;\r\n  action: () => Promise<void> | void;\r\n  automatic?: boolean; // Whether this action can be taken automatically\r\n  delay?: number; // Delay before automatic action (ms)\r\n  maxRetries?: number; // Maximum number of automatic retries\r\n}\r\n\r\n/**\r\n * Recovery strategy for a specific error type\r\n */\r\nexport interface RecoveryStrategy {\r\n  errorType: ErrorType;\r\n  detect: (error: Error) => boolean;\r\n  actions: RecoveryAction[];\r\n  defaultAction?: string; // ID of the default action\r\n}\r\n\r\nconst uiOnly = (\r\n  action: RecoveryAction | string,\r\n  doIt: () => void,\r\n): (() => void | Promise<void>) => {\r\n  const recoveryAction =\r\n    typeof action === 'string'\r\n      ? {\r\n          id: action,\r\n          label: `Action ${action} not found.`,\r\n        }\r\n      : action;\r\n  if (typeof window !== 'undefined' && !isRunningOnEdge()) {\r\n    return doIt;\r\n  } else {\r\n    return () =>\r\n      log((l) =>\r\n        l.info(\r\n          `UI-only action ${recoveryAction.label} skipped in ${typeof window === 'undefined' ? 'server' : 'edge'} environment.`,\r\n        ),\r\n      );\r\n  }\r\n};\r\n\r\n\r\nexport function classifyError(error: Error): ErrorType {\r\n  const message = error.message.toLowerCase();\r\n  const stack = error.stack?.toLowerCase() || '';\r\n\r\n  // Server errors (check first to avoid false positives)\r\n  if (\r\n    message.includes('internal server error') ||\r\n    message.includes('server error') ||\r\n    message.includes('500') ||\r\n    message.includes('502') ||\r\n    message.includes('503') ||\r\n    message.includes('504') ||\r\n    message.includes('bad gateway') ||\r\n    message.includes('service unavailable') ||\r\n    message.includes('gateway timeout')\r\n  ) {\r\n    return ErrorType.SERVER;\r\n  }\r\n\r\n  // Rate limiting\r\n  if (\r\n    message.includes('rate limit') ||\r\n    message.includes('too many requests') ||\r\n    message.includes('429')\r\n  ) {\r\n    return ErrorType.RATE_LIMIT;\r\n  }\r\n\r\n  // Authentication errors (check stack trace first for specificity)\r\n  if (\r\n    stack.includes('auth') ||\r\n    message.includes('unauthorized') ||\r\n    message.includes('authentication') ||\r\n    message.includes('login') ||\r\n    message.includes('token')\r\n  ) {\r\n    return ErrorType.AUTHENTICATION;\r\n  }\r\n\r\n  // Permission errors\r\n  if (\r\n    message.includes('forbidden') ||\r\n    message.includes('permission') ||\r\n    message.includes('access denied') ||\r\n    message.includes('not allowed')\r\n  ) {\r\n    return ErrorType.PERMISSION;\r\n  }\r\n\r\n  // Network errors (after server errors to avoid false positives)\r\n  if (\r\n    message.includes('fetch') ||\r\n    message.includes('network') ||\r\n    message.includes('connection') ||\r\n    message.includes('timeout') ||\r\n    (error.name === 'TypeError' && message.includes('failed to fetch'))\r\n  ) {\r\n    return ErrorType.NETWORK;\r\n  }\r\n\r\n  // Validation errors\r\n  if (\r\n    message.includes('validation') ||\r\n    message.includes('invalid') ||\r\n    message.includes('required') ||\r\n    error.name === 'ValidationError'\r\n  ) {\r\n    return ErrorType.VALIDATION;\r\n  }\r\n\r\n  // Client-side errors\r\n  if (\r\n    error.name === 'ReferenceError' ||\r\n    error.name === 'TypeError' ||\r\n    error.name === 'RangeError'\r\n  ) {\r\n    return ErrorType.CLIENT;\r\n  }\r\n\r\n  return ErrorType.UNKNOWN;\r\n}\r\n\r\n\r\nexport const recoveryStrategies: RecoveryStrategy[] = [\r\n  {\r\n    errorType: ErrorType.NETWORK,\r\n    detect: (error) => classifyError(error) === ErrorType.NETWORK,\r\n    actions: [\r\n      {\r\n        id: 'retry-request',\r\n        label: 'Retry Request',\r\n        description: 'Attempt the request again',\r\n        action: clientReload,\r\n        automatic: true,\r\n        delay: 1000,\r\n        maxRetries: 3,\r\n      },\r\n      {\r\n        id: 'check-connection',\r\n        label: 'Check Connection',\r\n        description: 'Verify your internet connection',\r\n        action: uiOnly('check-connection', () => {\r\n          if (navigator.onLine) {\r\n            alert('Connection appears to be working. Please try again.');\r\n          } else {\r\n            alert(\r\n              'No internet connection detected. Please check your connection.',\r\n            );\r\n          }\r\n        }),\r\n      },\r\n      {\r\n        id: 'refresh-page',\r\n        label: 'Refresh Page',\r\n        description: 'Reload the page to start fresh',\r\n        action: clientReload,\r\n      },\r\n    ],\r\n    defaultAction: 'retry-request',\r\n  },\r\n  {\r\n    errorType: ErrorType.AUTHENTICATION,\r\n    detect: (error) => classifyError(error) === ErrorType.AUTHENTICATION,\r\n    actions: [\r\n      {\r\n        id: 'login-redirect',\r\n        label: 'Sign In Again',\r\n        description: 'Redirect to login page',\r\n        action: clientNavigateSignIn,\r\n        automatic: true,\r\n        delay: 2000,\r\n      },\r\n      {\r\n        id: 'refresh-token',\r\n        label: 'Refresh Session',\r\n        description: 'Attempt to refresh authentication token',\r\n        action: clientNavigateSignIn,\r\n      },\r\n    ],\r\n    defaultAction: 'login-redirect',\r\n  },\r\n  {\r\n    errorType: ErrorType.PERMISSION,\r\n    detect: (error) => classifyError(error) === ErrorType.PERMISSION,\r\n    actions: [\r\n      {\r\n        id: 'contact-admin',\r\n        label: 'Contact Administrator',\r\n        description: 'Request access from system administrator',\r\n        action: uiOnly('contact-admin', () => {\r\n          alert(\r\n            'You do not have permission to perform this action. Please contact your administrator.',\r\n          );\r\n        }),\r\n      },\r\n      {\r\n        id: 'go-back',\r\n        label: 'Go Back',\r\n        description: 'Return to the previous page',\r\n        action: uiOnly('go-back', () => window.history.back()),\r\n      },\r\n    ],\r\n    defaultAction: 'contact-admin',\r\n  },\r\n  {\r\n    errorType: ErrorType.RATE_LIMIT,\r\n    detect: (error) => classifyError(error) === ErrorType.RATE_LIMIT,\r\n    actions: [\r\n      {\r\n        id: 'wait-retry',\r\n        label: 'Wait and Retry',\r\n        description: 'Wait for rate limit to reset and try again',\r\n        action: uiOnly('wait-retry', () => {\r\n          setTimeout(clientReload, 60000); // Wait 1 minute\r\n        }),\r\n        automatic: true,\r\n        delay: 60000,\r\n      },\r\n      {\r\n        id: 'reduce-requests',\r\n        label: 'Reduce Activity',\r\n        description: 'Slow down your requests and try again later',\r\n        action: uiOnly('reduce-requests', () =>\r\n          alert(\r\n            'Rate limit exceeded. Please slow down your requests and try again in a minute.',\r\n          ),\r\n        ),\r\n      },\r\n    ],\r\n    defaultAction: 'wait-retry',\r\n  },\r\n  {\r\n    errorType: ErrorType.SERVER,\r\n    detect: (error) => classifyError(error) === ErrorType.SERVER,\r\n    actions: [\r\n      {\r\n        id: 'retry-later',\r\n        label: 'Try Again Later',\r\n        description:\r\n          'Server is experiencing issues, try again in a few minutes',\r\n        action: uiOnly('retry-later', () => {\r\n          alert(\r\n            'Server is temporarily unavailable. Please try again in a few minutes.',\r\n          );\r\n        }),\r\n      },\r\n      {\r\n        id: 'contact-support',\r\n        label: 'Contact Support',\r\n        description: 'Report the issue to technical support',\r\n        action: uiOnly('contact-support', () => {\r\n          const subject = encodeURIComponent('Server Error Report');\r\n          const body = encodeURIComponent(\r\n            'I encountered a server error while using the application.',\r\n          );\r\n          window.open(\r\n            `mailto:support@example.com?subject=${subject}&body=${body}`,\r\n          );\r\n        }),\r\n      },\r\n      {\r\n        id: 'refresh-page',\r\n        label: 'Refresh Page',\r\n        description: 'Reload the page to try again',\r\n        action: clientReload,\r\n      },\r\n    ],\r\n    defaultAction: 'retry-later',\r\n  },\r\n  {\r\n    errorType: ErrorType.VALIDATION,\r\n    detect: (error) => classifyError(error) === ErrorType.VALIDATION,\r\n    actions: [\r\n      {\r\n        id: 'review-input',\r\n        label: 'Review Input',\r\n        description: 'Check your input and try again',\r\n        action: uiOnly('review-input', () => {\r\n          alert(\r\n            'Please review your input and correct any errors before trying again.',\r\n          );\r\n        }),\r\n      },\r\n      {\r\n        id: 'reset-form',\r\n        label: 'Reset Form',\r\n        description: 'Clear the form and start over',\r\n        action: () => {\r\n          // This would need to be implemented per form\r\n          console.log('Reset form action');\r\n        },\r\n      },\r\n    ],\r\n    defaultAction: 'review-input',\r\n  },\r\n  {\r\n    errorType: ErrorType.CLIENT,\r\n    detect: (error) => classifyError(error) === ErrorType.CLIENT,\r\n    actions: [\r\n      {\r\n        id: 'refresh-page',\r\n        label: 'Refresh Page',\r\n        description: 'Reload the page to reset the application state',\r\n        action: clientReload,\r\n        automatic: true,\r\n        delay: 1000,\r\n      },\r\n      {\r\n        id: 'clear-cache',\r\n        label: 'Clear Browser Cache',\r\n        description: 'Clear browser cache and reload',\r\n        action: uiOnly('clear-cache', () => {\r\n          if ('caches' in window) {\r\n            return caches\r\n              .keys()\r\n              .then((names) => {\r\n                return Promise.all(names.map((name) => caches.delete(name)));\r\n              })\r\n              .then(clientReload);\r\n          } else {\r\n            clientReload();\r\n          }\r\n        }),\r\n      },\r\n    ],\r\n    defaultAction: 'refresh-page',\r\n  },\r\n  {\r\n    errorType: ErrorType.UNKNOWN,\r\n    detect: (error) => classifyError(error) === ErrorType.UNKNOWN,\r\n    actions: [\r\n      {\r\n        id: 'refresh-page',\r\n        label: 'Refresh Page',\r\n        description: 'Reload the page to try again',\r\n        action: clientReload,\r\n      },\r\n      {\r\n        id: 'report-bug',\r\n        label: 'Report Bug',\r\n        description: 'Report this unexpected error',\r\n        action: uiOnly('report-bug', () => {\r\n          const subject = encodeURIComponent('Bug Report');\r\n          const body = encodeURIComponent(\r\n            'I encountered an unexpected error while using the application.',\r\n          );\r\n          window.open(\r\n            `mailto:support@example.com?subject=${subject}&body=${body}`,\r\n          );\r\n        }),\r\n      },\r\n    ],\r\n    defaultAction: 'refresh-page',\r\n  },\r\n];\r\n\r\n\r\nexport function getRecoveryActions(error: Error): RecoveryAction[] {\r\n  const errorType = classifyError(error);\r\n  const strategy = recoveryStrategies.find((s) => s.errorType === errorType);\r\n  return strategy?.actions || [];\r\n}\r\n\r\n\r\nexport function getDefaultRecoveryAction(error: Error): RecoveryAction | null {\r\n  const errorType = classifyError(error);\r\n  const strategy = recoveryStrategies.find((s) => s.errorType === errorType);\r\n\r\n  if (!strategy) return null;\r\n\r\n  const defaultActionId = strategy.defaultAction;\r\n  if (!defaultActionId) return strategy.actions[0] || null;\r\n\r\n  return strategy.actions.find((a) => a.id === defaultActionId) || null;\r\n}\r\n\r\n\r\nexport async function attemptAutoRecovery(error: Error): Promise<boolean> {\r\n  const defaultAction = getDefaultRecoveryAction(error);\r\n\r\n  if (!defaultAction || !defaultAction.automatic) {\r\n    return false;\r\n  }\r\n\r\n  try {\r\n    if (defaultAction.delay) {\r\n      await new Promise((resolve) => setTimeout(resolve, defaultAction.delay));\r\n    }\r\n\r\n    await defaultAction.action();\r\n    return true;\r\n  } catch (recoveryError) {\r\n    console.error('Auto-recovery failed:', recoveryError);\r\n    return false;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\error-monitoring\\types.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\error-monitoring\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":11,"column":1,"nodeType":"Program","endLine":97,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Types for the error reporting module.\r\n *\r\n * These are extracted so other modules (and tests) can consume the\r\n * ErrorReporter surface without importing the implementation.\r\n */\r\n\r\n/**\r\n * Error severity levels for reporting and prioritization\r\n */\r\nexport enum ErrorSeverity {\r\n  LOW = 'low',\r\n  MEDIUM = 'medium',\r\n  HIGH = 'high',\r\n  CRITICAL = 'critical',\r\n}\r\n\r\n/**\r\n * Known environment strings used by the reporter\r\n */\r\nexport type KnownEnvironmentType = 'development' | 'staging' | 'production';\r\n\r\n/**\r\n * Error context information for better debugging\r\n */\r\nexport interface ErrorContext {\r\n  userId?: string;\r\n  sessionId?: string;\r\n  source?: string;\r\n  userAgent?: string;\r\n  url?: string;\r\n  timestamp?: Date;\r\n  componentStack?: string;\r\n  errorBoundary?: string;\r\n  breadcrumbs?: string[];\r\n  additionalData?: Record<string, unknown>;\r\n  error?: Error;\r\n}\r\n\r\n/**\r\n * Error report structure for external monitoring services\r\n */\r\nexport interface ErrorReport {\r\n  error: Error;\r\n  severity: ErrorSeverity;\r\n  context: ErrorContext;\r\n  fingerprint?: string;\r\n  tags?: Record<string, string>;\r\n}\r\n\r\n/**\r\n * Configuration for error reporting\r\n */\r\nexport interface ErrorReporterConfig {\r\n  enableStandardLogging: boolean;\r\n  enableConsoleLogging: boolean;\r\n  enableExternalReporting: boolean;\r\n  enableLocalStorage: boolean;\r\n  maxStoredErrors: number;\r\n  environment: KnownEnvironmentType;\r\n}\r\n\r\n/**\r\n * Interface describing the runtime surface of the ErrorReporter class.\r\n *\r\n * Implementations should match this shape so callers can depend on the\r\n * contract rather than the concrete class.\r\n */\r\nexport interface ErrorReporterInterface {\r\n  reportError(\r\n    error: Error | unknown,\r\n    severity?: ErrorSeverity,\r\n    context?: Partial<ErrorContext>,\r\n  ): Promise<void>;\r\n\r\n  reportBoundaryError(\r\n    error: Error,\r\n    errorInfo: { componentStack?: string; errorBoundary?: string },\r\n    severity?: ErrorSeverity,\r\n  ): Promise<void>;\r\n\r\n  reportUnhandledRejection(\r\n    reason: unknown,\r\n    promise: Promise<unknown>,\r\n  ): Promise<void>;\r\n\r\n  setupGlobalHandlers(): void;\r\n\r\n  getStoredErrors(): ErrorReport[];\r\n\r\n  clearStoredErrors(): void;\r\n}\r\n\r\nexport type IContextEnricher = {\r\n  enrichContext: (context: ErrorContext) => Promise<ErrorContext>;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\error-monitoring\\use-error-reporter.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\error-monitoring\\use-error-reporter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\error-monitoring\\with-error-boundary.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\error-monitoring\\with-error-boundary.tsx","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":138,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { ComponentType } from 'react';\r\nimport { ErrorBoundary } from 'react-error-boundary';\r\nimport { RenderErrorBoundaryFallback } from '@/components/error-boundaries/renderFallback';\r\nimport { errorReporter, ErrorSeverity } from './error-reporter';\r\n\r\n/**\r\n * Configuration for the error boundary HOC\r\n */\r\ninterface WithErrorBoundaryConfig {\r\n  fallbackComponent?: ComponentType<{\r\n    error: Error;\r\n    resetErrorBoundary: () => void;\r\n  }>;\r\n  onReset?: () => void;\r\n  severity?: ErrorSeverity;\r\n  isolate?: boolean; // If true, errors won't bubble up to parent boundaries\r\n}\r\n\r\n\r\nexport function withErrorBoundary<P extends object>(\r\n  WrappedComponent: ComponentType<P>,\r\n  config: WithErrorBoundaryConfig = {},\r\n) {\r\n  const {\r\n    fallbackComponent: FallbackComponent = RenderErrorBoundaryFallback,\r\n    onReset,\r\n    severity = ErrorSeverity.MEDIUM,\r\n    isolate = false,\r\n  } = config;\r\n\r\n  const componentName =\r\n    WrappedComponent.displayName || WrappedComponent.name || 'Component';\r\n\r\n  const WithErrorBoundaryComponent = (props: P) => {\r\n    return (\r\n      <ErrorBoundary\r\n        fallbackRender={({ error, resetErrorBoundary }) => (\r\n          <FallbackComponent\r\n            error={error}\r\n            resetErrorBoundary={resetErrorBoundary}\r\n          />\r\n        )}\r\n        onError={(error, errorInfo) => {\r\n          // Report the error with component context\r\n          errorReporter.reportBoundaryError(\r\n            error,\r\n            {\r\n              componentStack: errorInfo.componentStack || undefined,\r\n              errorBoundary: `${componentName}ErrorBoundary`,\r\n            },\r\n            severity,\r\n          );\r\n\r\n          // Prevent error from bubbling if isolation is enabled\r\n          if (isolate) {\r\n            console.warn(`Error isolated in ${componentName}:`, error);\r\n          }\r\n        }}\r\n        onReset={() => {\r\n          // Custom reset logic\r\n          if (onReset) {\r\n            onReset();\r\n          }\r\n\r\n          // Default reset behavior\r\n          console.log(`Resetting error boundary for ${componentName}`);\r\n        }}\r\n      >\r\n        <WrappedComponent {...props} />\r\n      </ErrorBoundary>\r\n    );\r\n  };\r\n\r\n  WithErrorBoundaryComponent.displayName = `withErrorBoundary(${componentName})`;\r\n\r\n  return WithErrorBoundaryComponent;\r\n}\r\n\r\n\r\nexport function ErrorBoundaryDecorator(config?: WithErrorBoundaryConfig) {\r\n  return function <T extends ComponentType<Record<string, unknown>>>(\r\n    target: T,\r\n  ): T {\r\n    return withErrorBoundary(target, config) as T;\r\n  };\r\n}\r\n\r\n/**\r\n * Utility component for creating inline error boundaries\r\n */\r\ninterface ErrorBoundaryWrapperProps {\r\n  children: React.ReactNode;\r\n  fallback?: ComponentType<{ error: Error; resetErrorBoundary: () => void }>;\r\n  onError?: (error: Error, errorInfo: { componentStack?: string }) => void;\r\n  onReset?: () => void;\r\n  name?: string;\r\n}\r\n\r\nexport function ErrorBoundaryWrapper({\r\n  children,\r\n  fallback: FallbackComponent = RenderErrorBoundaryFallback,\r\n  onError,\r\n  onReset,\r\n  name = 'InlineErrorBoundary',\r\n}: ErrorBoundaryWrapperProps) {\r\n  return (\r\n    <ErrorBoundary\r\n      fallbackRender={({ error, resetErrorBoundary }) => (\r\n        <FallbackComponent\r\n          error={error}\r\n          resetErrorBoundary={resetErrorBoundary}\r\n        />\r\n      )}\r\n      onError={(error, errorInfo) => {\r\n        // Report the error\r\n        errorReporter.reportBoundaryError(\r\n          error,\r\n          {\r\n            componentStack: errorInfo.componentStack || undefined,\r\n            errorBoundary: name,\r\n          },\r\n          ErrorSeverity.MEDIUM,\r\n        );\r\n\r\n        // Custom error handler\r\n        if (onError) {\r\n          onError(error, {\r\n            componentStack: errorInfo.componentStack || undefined,\r\n          });\r\n        }\r\n      }}\r\n      onReset={onReset}\r\n    >\r\n      {children}\r\n    </ErrorBoundary>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\hooks\\types.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\hooks\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":202,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { HealthStatus } from '@/lib/ai/mem0/types/health-check';\r\n\r\nexport type { HealthStatus } from '@/lib/ai/mem0/types/health-check';\r\n\r\nexport type RawHealthStatus = 'ok' | 'warning' | 'error';\r\n\r\n/**\r\n * Memory health response structure from the /api/health endpoint\r\n *\r\n * @interface MemoryHealthResponse\r\n * @description Raw response structure returned by the health check API for memory services.\r\n * Each subsystem property is optional to handle cases where specific services are unavailable.\r\n *\r\n * @example\r\n * ```typescript\r\n * // Example API response\r\n * {\r\n *   status: 'ok',\r\n *   db: { status: 'ok' },\r\n *   vectorStore: { status: 'warning' },\r\n *   graphStore: { status: 'ok' },\r\n *   historyStore: { status: 'error' },\r\n *   authService: { status: 'ok' }\r\n * }\r\n * ```\r\n */\r\nexport type MemoryHealthResponse = {\r\n  /** Overall memory system health status */\r\n  status: HealthStatus;\r\n\r\n  /** Database subsystem health status - optional as service may be unavailable */\r\n  db?: { status: HealthStatus };\r\n\r\n  /** Vector store subsystem health status - optional as service may be unavailable */\r\n  vectorStore?: { status: HealthStatus };\r\n\r\n  /** Graph store subsystem health status - optional as service may be unavailable */\r\n  graphStore?: { status: HealthStatus };\r\n\r\n  /** History store subsystem health status - optional as service may be unavailable */\r\n  historyStore?: { status: HealthStatus };\r\n\r\n  /** Authentication service health status - optional as service may be unavailable */\r\n  authService?: { status: HealthStatus };\r\n};\r\n\r\n/**\r\n * Detailed memory subsystem status information with guaranteed status values\r\n *\r\n * @interface MemorySubsystemStatus\r\n * @description Normalized subsystem status structure where all properties are required.\r\n * Missing subsystems from the API response are defaulted to 'error' status to ensure\r\n * proper error indication in the UI.\r\n *\r\n * @example\r\n * ```typescript\r\n * const subsystems: MemorySubsystemStatus = {\r\n *   db: 'ok',\r\n *   vectorStore: 'warning',\r\n *   graphStore: 'ok',\r\n *   historyStore: 'error',\r\n *   authService: 'ok'\r\n * };\r\n * ```\r\n */\r\nexport type MemorySubsystemStatus = {\r\n  /** Database connection and query execution status */\r\n  db: HealthStatus;\r\n\r\n  /** Vector embedding storage and retrieval status */\r\n  vectorStore: HealthStatus;\r\n\r\n  /** Knowledge graph storage and traversal status */\r\n  graphStore: HealthStatus;\r\n\r\n  /** Conversation history persistence status */\r\n  historyStore: HealthStatus;\r\n\r\n  /** Authentication service availability status */\r\n  authService: HealthStatus;\r\n};\r\n\r\n/**\r\n * Complete health check response structure from the /api/health endpoint\r\n *\r\n * @interface HealthCheckResponse\r\n * @description Top-level health check response that may contain multiple service categories.\r\n * Currently focused on memory services, but extensible for database, chat, and other services.\r\n *\r\n * @example\r\n * ```typescript\r\n * const response: HealthCheckResponse = {\r\n *   memory: {\r\n *     status: 'ok',\r\n *     db: { status: 'ok' },\r\n *     vectorStore: { status: 'warning' }\r\n *   },\r\n *   database: { status: 'ok' },\r\n *   chat: { status: 'warning' }\r\n * };\r\n * ```\r\n */\r\nexport type HealthCheckResponse = {\r\n  /** Memory service health details - primary focus of this hook */\r\n  memory?: MemoryHealthResponse;\r\n\r\n  /** General database service status - future extension point */\r\n  database?: { status: string };\r\n\r\n  /** Chat service status - future extension point */\r\n  chat?: { status: string };\r\n};\r\n\r\n/**\r\n * Processed memory health data with normalized status and subsystem details\r\n *\r\n * @interface MemoryHealthData\r\n * @description Final data structure returned by the useMemoryHealth hook after processing\r\n * the raw API response. Converts API status codes to standard HealthStatus enum values\r\n * and ensures all subsystems have defined status values.\r\n *\r\n * @example\r\n * ```typescript\r\n * const healthData: MemoryHealthData = {\r\n *   status: 'healthy',\r\n *   subsystems: {\r\n *     db: 'ok',\r\n *     vectorStore: 'warning',\r\n *     graphStore: 'ok',\r\n *     historyStore: 'error',\r\n *     authService: 'ok'\r\n *   }\r\n * };\r\n * ```\r\n */\r\nexport type MemoryHealthData = {\r\n  /** Overall health status using standardized HealthStatus enum */\r\n  status: HealthStatus;\r\n\r\n  /** Detailed status for each memory subsystem */\r\n  subsystems: MemorySubsystemStatus;\r\n};\r\n\r\n/**\r\n * @typedef {Object} MemoryStatusHookResult\r\n * @property {HealthStatus} returns.healthStatus - Current overall health status\r\n * @property {MemorySubsystemStatus|undefined} subsystems - Individual subsystem statuses\r\n * @property {number} refreshInterval - Current refresh interval in milliseconds\r\n * @property {boolean} isLoading - True when initial data is being fetched\r\n * @property {boolean} isFetching - True when any fetch is in progress\r\n * @property {boolean} isError - True when query has encountered an error\r\n * @property {Error|null} error - Current error object if query failed\r\n * @property {MemoryHealthData|undefined} data - Full health data when available\r\n */\r\nexport type MemoryStatusHookResult = {\r\n  /** Latest memory health data or undefined if not yet fetched */\r\n  healthStatus: HealthStatus;\r\n  subsystems: MemorySubsystemStatus | undefined;\r\n  refreshInterval: number;\r\n  isLoading: boolean;\r\n  isFetching: boolean;\r\n  isError: boolean;\r\n  error: Error | null;\r\n  data: MemoryHealthData | undefined;\r\n};\r\n\r\n/**\r\n * Database health response structure for the useDatabaseHealth hook\r\n */\r\nexport type DatabaseHealthResponse = {\r\n  data: RawHealthStatus;\r\n  error: Error | null;\r\n  isError: boolean;\r\n  isFetching: boolean;\r\n  isLoading: boolean;\r\n  healthStatus: RawHealthStatus;\r\n  refreshInterval: number;\r\n};\r\n/**\r\n * Processed chat health data with subsystem details\r\n */\r\nexport type ChatHealthData = {\r\n  status: RawHealthStatus;\r\n  subsystems?: {\r\n    cache: RawHealthStatus;\r\n    queue: RawHealthStatus;\r\n  };\r\n};\r\nexport type ChatHealthHookResponse = {\r\n  data: ChatHealthData | undefined;\r\n  error: Error | null;\r\n  isError: boolean;\r\n  isFetching: boolean;\r\n  isLoading: boolean;\r\n  healthStatus: RawHealthStatus;\r\n  refreshInterval: number;\r\n  subsystems?: {\r\n    cache: RawHealthStatus;\r\n    queue: RawHealthStatus;\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\hooks\\use-chat-health.d.ts","messages":[{"ruleId":"no-jsdoc-in-ts/prefer-function-declarations","severity":1,"message":"Prefer `export function name(...) : ...;` declarations in .d.ts files instead of `export const name: (...) => ...;`.","line":18,"column":16,"nodeType":"VariableDeclarator","endLine":21,"endColumn":49}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * React Query hook for monitoring AI chat service health\r\n * @module @/lib/hooks/use-chat-health\r\n */\r\n\r\ndeclare module '@/lib/hooks/use-chat-health' {\r\n  import type { UseQueryResult } from '@tanstack/react-query';\r\n  import type { HealthCheckResult } from './types';\r\n\r\n  /**\r\n   * Hook for monitoring chat service health status.\r\n   *\r\n   * Polls the health endpoint and returns structured health data.\r\n   *\r\n   * @param options - Query configuration options\r\n   * @returns React Query result with health check data\r\n   */\r\n  export const useChatHealth: (options?: {\r\n    refetchInterval?: number;\r\n    enabled?: boolean;\r\n  }) => UseQueryResult<HealthCheckResult, Error>;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\hooks\\use-chat-health.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":10,"column":1,"nodeType":"Program","endLine":133,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Chat Health Check Hook\r\n *\r\n * This module provides React Query hooks for monitoring chat service health status.\r\n *\r\n * @module lib/hooks/use-chat-health\r\n * @version 1.0.0\r\n */\r\n\r\nimport { Query, useQuery } from '@tanstack/react-query';\r\nimport { fetch } from '@/lib/nextjs-util/fetch';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport { ChatHealthData, ChatHealthHookResponse } from './types';\r\n\r\n/**\r\n * Chat health status type\r\n */\r\ntype ChatHealthStatus = 'ok' | 'warning' | 'error';\r\n\r\n/**\r\n * Chat health response structure from the /api/health endpoint\r\n */\r\ninterface ChatHealthResponse {\r\n  status: ChatHealthStatus;\r\n  cache?: { status: ChatHealthStatus };\r\n  queue?: { status: ChatHealthStatus };\r\n}\r\n\r\n/**\r\n * Complete health check response structure\r\n */\r\ninterface HealthCheckResponse {\r\n  chat?: ChatHealthResponse;\r\n}\r\n\r\n/**\r\n * Fetches chat health status from the API health endpoint\r\n */\r\nconst fetchChatHealth = async (): Promise<ChatHealthData> => {\r\n  try {\r\n    const response = await fetch('/api/health', {\r\n      method: 'GET',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      cache: 'no-store',\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(\r\n        `Health check API request failed with status ${response.status}`,\r\n      );\r\n    }\r\n\r\n    const data: HealthCheckResponse = await response.json();\r\n    const chatData = data.chat;\r\n\r\n    if (!chatData) {\r\n      throw new Error('Chat health status not available in response');\r\n    }\r\n\r\n    return {\r\n      status: chatData.status,\r\n      subsystems: {\r\n        cache: chatData.cache?.status || 'error',\r\n        queue: chatData.queue?.status || 'error',\r\n      },\r\n    };\r\n  } catch (error) {\r\n    LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      context: 'Fetching chat health status',\r\n    });\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Get refresh interval based on health status (in milliseconds)\r\n */\r\nconst getRefreshInterval = (status: ChatHealthStatus): number => {\r\n  switch (status) {\r\n    case 'ok':\r\n      return 180000; // 3 minutes\r\n    case 'warning':\r\n      return 30000; // 30 seconds\r\n    case 'error':\r\n      return 5000; // 5 seconds\r\n    default:\r\n      return 30000; // Default to 30 seconds\r\n  }\r\n};\r\n\r\n/**\r\n * Stable function to calculate refresh interval\r\n */\r\nconst stableGetRefreshInterval = (\r\n  query: Query<ChatHealthData, Error, ChatHealthData, readonly unknown[]>,\r\n) => getRefreshInterval(query.state.data?.status || 'warning');\r\n\r\n/**\r\n * Stable retry delay calculator with exponential backoff\r\n */\r\nconst stableRetryDelay = (attemptIndex: number) =>\r\n  Math.min(1000 * 2 ** attemptIndex, 30000);\r\n\r\n/**\r\n * Stable query key for React Query caching\r\n */\r\nconst stableQueryKey = ['chatHealth'] as const;\r\n\r\n\r\nexport const useChatHealth = (): ChatHealthHookResponse => {\r\n  const query = useQuery<ChatHealthData, Error>({\r\n    queryKey: stableQueryKey,\r\n    queryFn: fetchChatHealth,\r\n    staleTime: 1000,\r\n    refetchOnWindowFocus: false,\r\n    refetchInterval: stableGetRefreshInterval,\r\n    retry: 3,\r\n    retryDelay: stableRetryDelay,\r\n  });\r\n\r\n  const healthStatus = query.data?.status || 'warning';\r\n  const subsystems = query.data?.subsystems;\r\n  const refreshInterval = getRefreshInterval(healthStatus);\r\n\r\n  return {\r\n    ...query,\r\n    healthStatus,\r\n    subsystems,\r\n    refreshInterval,\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\hooks\\use-database-health.d.ts","messages":[{"ruleId":"no-jsdoc-in-ts/prefer-function-declarations","severity":1,"message":"Prefer `export function name(...) : ...;` declarations in .d.ts files instead of `export const name: (...) => ...;`.","line":16,"column":16,"nodeType":"VariableDeclarator","endLine":19,"endColumn":49}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * React Query hook for monitoring database health\r\n * @module @/lib/hooks/use-database-health\r\n */\r\n\r\ndeclare module '@/lib/hooks/use-database-health' {\r\n  import type { UseQueryResult } from '@tanstack/react-query';\r\n  import type { HealthCheckResult } from './types';\r\n\r\n  /**\r\n   * Hook for monitoring database health status.\r\n   *\r\n   * @param options - Query configuration options\r\n   * @returns React Query result with database health data\r\n   */\r\n  export const useDatabaseHealth: (options?: {\r\n    refetchInterval?: number;\r\n    enabled?: boolean;\r\n  }) => UseQueryResult<HealthCheckResult, Error>;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\hooks\\use-database-health.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":10,"column":1,"nodeType":"Program","endLine":108,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Database Health Check Hook\r\n *\r\n * This module provides React Query hooks for monitoring database service health status.\r\n *\r\n * @module lib/hooks/use-database-health\r\n * @version 1.0.0\r\n */\r\n\r\nimport { Query, useQuery } from '@tanstack/react-query';\r\nimport { fetch } from '@/lib/nextjs-util/fetch';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport type {\r\n  RawHealthStatus,\r\n  HealthCheckResponse,\r\n  DatabaseHealthResponse,\r\n} from './types';\r\n\r\n/**\r\n * Fetches database health status from the API health endpoint\r\n */\r\nconst fetchDatabaseHealth = async (): Promise<RawHealthStatus> => {\r\n  try {\r\n    const response = await fetch('/api/health', {\r\n      method: 'GET',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      cache: 'no-store',\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(\r\n        `Health check API request failed with status ${response.status}`,\r\n      );\r\n    }\r\n\r\n    const data: HealthCheckResponse = await response.json();\r\n    const databaseData = data.database;\r\n\r\n    if (!databaseData) {\r\n      throw new Error('Database health status not available in response');\r\n    }\r\n\r\n    return databaseData.status as RawHealthStatus;\r\n  } catch (error) {\r\n    LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      context: 'Fetching database health status',\r\n    });\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Get refresh interval based on health status (in milliseconds)\r\n */\r\nconst getRefreshInterval = (status: RawHealthStatus): number => {\r\n  switch (status) {\r\n    case 'ok':\r\n      return 180000; // 3 minutes\r\n    case 'warning':\r\n      return 30000; // 30 seconds\r\n    case 'error':\r\n      return 5000; // 5 seconds\r\n    default:\r\n      return 30000; // Default to 30 seconds\r\n  }\r\n};\r\n\r\n/**\r\n * Stable function to calculate refresh interval\r\n */\r\nconst stableGetRefreshInterval = (\r\n  query: Query<RawHealthStatus, Error, RawHealthStatus, readonly unknown[]>,\r\n) => getRefreshInterval(query.state.data || 'warning');\r\n\r\n/**\r\n * Stable retry delay calculator with exponential backoff\r\n */\r\nconst stableRetryDelay = (attemptIndex: number) =>\r\n  Math.min(1000 * 2 ** attemptIndex, 30000);\r\n\r\n/**\r\n * Stable query key for React Query caching\r\n */\r\nconst stableQueryKey = ['databaseHealth'] as const;\r\n\r\n\r\nexport const useDatabaseHealth = (): DatabaseHealthResponse => {\r\n  const query = useQuery<RawHealthStatus, Error>({\r\n    queryKey: stableQueryKey,\r\n    queryFn: fetchDatabaseHealth,\r\n    staleTime: 1000,\r\n    refetchOnWindowFocus: false,\r\n    refetchInterval: stableGetRefreshInterval,\r\n    retry: 3,\r\n    retryDelay: stableRetryDelay,\r\n  });\r\n\r\n  const healthStatus = query.data || 'warning';\r\n  const refreshInterval = getRefreshInterval(healthStatus);\r\n\r\n  return {\r\n    ...query,\r\n    healthStatus,\r\n    refreshInterval,\r\n  } as DatabaseHealthResponse;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\hooks\\use-email.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\hooks\\use-email.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\hooks\\use-memory-health.d.ts","messages":[{"ruleId":"no-jsdoc-in-ts/prefer-function-declarations","severity":1,"message":"Prefer `export function name(...) : ...;` declarations in .d.ts files instead of `export const name: (...) => ...;`.","line":16,"column":16,"nodeType":"VariableDeclarator","endLine":19,"endColumn":49}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * React Query hook for monitoring memory service health\r\n * @module @/lib/hooks/use-memory-health\r\n */\r\n\r\ndeclare module '@/lib/hooks/use-memory-health' {\r\n  import type { UseQueryResult } from '@tanstack/react-query';\r\n  import type { HealthCheckResult } from './types';\r\n\r\n  /**\r\n   * Hook for monitoring memory service health status.\r\n   *\r\n   * @param options - Query configuration options\r\n   * @returns React Query result with memory service health data\r\n   */\r\n  export const useMemoryHealth: (options?: {\r\n    refetchInterval?: number;\r\n    enabled?: boolean;\r\n  }) => UseQueryResult<HealthCheckResult, Error>;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\hooks\\use-memory-health.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":34,"column":1,"nodeType":"Program","endLine":210,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Memory Health Check Hook\r\n *\r\n * This module provides React Query hooks for monitoring memory service health status\r\n * with automatic refresh intervals that adapt based on the current health status.\r\n * The health monitoring system tracks multiple subsystems including database,\r\n * vector store, graph store, history store, and authentication service.\r\n *\r\n * @module lib/hooks/use-memory-health\r\n * @version 1.0.0\r\n * @since 2025-09-27\r\n *\r\n * @example\r\n * ```typescript\r\n * import { useMemoryHealth } from '@/lib/hooks/use-memory-health';\r\n *\r\n * function HealthMonitor() {\r\n *   const { healthStatus, subsystems, isLoading, error } = useMemoryHealth();\r\n *\r\n *   if (isLoading) return <div>Checking health...</div>;\r\n *   if (error) return <div>Error: {error.message}</div>;\r\n *\r\n *   return (\r\n *     <div>\r\n *       <p>Overall Status: {healthStatus}</p>\r\n *       <p>Database: {subsystems?.db}</p>\r\n *       <p>Vector Store: {subsystems?.vectorStore}</p>\r\n *     </div>\r\n *   );\r\n * }\r\n * ```\r\n */\r\n\r\nimport { Query, useQuery } from '@tanstack/react-query';\r\nimport { fetch } from '@/lib/nextjs-util/fetch';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport {\r\n  getRefreshInterval,\r\n  type HealthStatus,\r\n} from '@/lib/ai/mem0/types/health-check';\r\n\r\nimport type {\r\n  MemoryHealthData,\r\n  MemorySubsystemStatus,\r\n  MemoryStatusHookResult,\r\n  HealthCheckResponse,\r\n} from '@/lib/hooks/types';\r\n\r\n/**\r\n * Fetches memory health status from the API health endpoint\r\n *\r\n * @async\r\n * @function fetchMemoryHealth\r\n * @description Retrieves current health status for memory services and all subsystems.\r\n * Performs API request to /api/health endpoint, processes the response, and normalizes\r\n * status values. Missing subsystems are defaulted to 'error' status to ensure proper\r\n * error indication in the UI.\r\n *\r\n * @returns {Promise<MemoryHealthData>} Promise that resolves to processed health data\r\n * @throws {Error} When API request fails or memory data is unavailable\r\n *\r\n * @example\r\n * ```typescript\r\n * try {\r\n *   const health = await fetchMemoryHealth();\r\n *   console.log('Overall status:', health.status);\r\n *   console.log('DB status:', health.subsystems.db);\r\n * } catch (error) {\r\n *   console.error('Health check failed:', error.message);\r\n * }\r\n * ```\r\n *\r\n * @see {@link MemoryHealthData} for return type structure\r\n * @see {@link HealthCheckResponse} for raw API response structure\r\n */\r\nconst fetchMemoryHealth = async (): Promise<MemoryHealthData> => {\r\n  try {\r\n    // Fetch health status with no-cache to ensure fresh data\r\n    const response = await fetch('/api/health', {\r\n      method: 'GET',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      cache: 'no-store',\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(\r\n        `Health check API request failed with status ${response.status}`,\r\n      );\r\n    }\r\n\r\n    const data: HealthCheckResponse = await response.json();\r\n\r\n    // Extract memory status from the response\r\n    const memoryData = data.memory;\r\n\r\n    if (!memoryData) {\r\n      throw new Error('Memory health status not available in response');\r\n    }\r\n\r\n    // Map the API status code to standardized health status enum\r\n    const healthStatus: HealthStatus = (() => {\r\n      switch (memoryData.status as HealthStatus | 'ok') {\r\n        case 'ok':\r\n          return 'healthy';\r\n        case 'warning':\r\n          return 'warning';\r\n        case 'error':\r\n          return 'error';\r\n        default:\r\n          return 'warning'; // Default to warning for unknown status codes\r\n      }\r\n    })();\r\n\r\n    // Extract subsystem statuses with error fallbacks for missing services\r\n    const subsystems: MemorySubsystemStatus = {\r\n      db: memoryData.db?.status || 'error',\r\n      vectorStore: memoryData.vectorStore?.status || 'error',\r\n      graphStore: memoryData.graphStore?.status || 'error',\r\n      historyStore: memoryData.historyStore?.status || 'error',\r\n      authService: memoryData.authService?.status || 'error',\r\n    };\r\n\r\n    return {\r\n      status: healthStatus,\r\n      subsystems,\r\n    };\r\n  } catch (error) {\r\n    // Log error with context for debugging purposes\r\n    LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      context: 'Fetching memory health status',\r\n    });\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Stable function to calculate refresh interval based on current health status\r\n *\r\n * @function stableGetRefreshInterval\r\n * @description React Query callback that determines how often to refetch health data\r\n * based on the current health status. Uses stable reference to prevent unnecessary\r\n * re-renders and query restarts.\r\n *\r\n * @param {Query<MemoryHealthData, Error, MemoryHealthData, readonly unknown[]>} query - React Query instance\r\n * @returns {number} Refresh interval in milliseconds\r\n *\r\n * @see {@link getRefreshInterval} for interval calculation logic\r\n */\r\nconst stableGetRefreshInterval = (\r\n  query: Query<MemoryHealthData, Error, MemoryHealthData, readonly unknown[]>,\r\n) => getRefreshInterval(query.state.data?.status || 'warning');\r\n\r\n/**\r\n * Stable exponential backoff retry delay calculator\r\n *\r\n * @function stableRetryDelay\r\n * @description Calculates retry delay using exponential backoff with maximum cap.\r\n * Uses stable reference to prevent React Query from recreating retry configuration.\r\n *\r\n * @param {number} attemptIndex - Zero-based retry attempt number\r\n * @returns {number} Delay in milliseconds before next retry attempt\r\n *\r\n * @example\r\n * ```typescript\r\n * // Attempt 0: 1000ms (1s)\r\n * // Attempt 1: 2000ms (2s)\r\n * // Attempt 2: 4000ms (4s)\r\n * // Attempt 3: 8000ms (8s)\r\n * // Attempt 4: 16000ms (16s)\r\n * // Attempt 5+: 30000ms (30s) - capped\r\n * ```\r\n */\r\nconst stableRetryDelay = (attemptIndex: number) =>\r\n  Math.min(1000 * 2 ** attemptIndex, 30000);\r\n\r\n/**\r\n * Stable query key for React Query caching\r\n *\r\n * @constant {readonly ['memoryHealth']} stableQueryKey\r\n * @description Immutable query key used by React Query for cache identification.\r\n * Uses const assertion to ensure type safety and reference stability.\r\n */\r\nconst stableQueryKey = ['memoryHealth'] as const;\r\n\r\n\r\nexport const useMemoryHealth = (): MemoryStatusHookResult => {\r\n  const query = useQuery<MemoryHealthData, Error>({\r\n    queryKey: stableQueryKey,\r\n    queryFn: fetchMemoryHealth,\r\n    staleTime: 1000, // Consider data stale after 1 second for real-time monitoring\r\n    refetchOnWindowFocus: false, // Prevent excessive API calls on window focus\r\n    refetchInterval: stableGetRefreshInterval, // Dynamic refresh based on health status\r\n    retry: 3, // Retry failed requests up to 3 times\r\n    retryDelay: stableRetryDelay, // Exponential backoff with 30s maximum\r\n  });\r\n\r\n  // Extract commonly used values with safe defaults\r\n  const healthStatus = query.data?.status || 'warning';\r\n  const subsystems = query.data?.subsystems;\r\n  const refreshInterval = getRefreshInterval(healthStatus);\r\n\r\n  return {\r\n    ...query,\r\n    healthStatus,\r\n    subsystems,\r\n    refreshInterval,\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\hooks\\use-statistics.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\hooks\\use-statistics.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":113,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useQuery } from '@tanstack/react-query';\r\nimport type {\r\n  ApiResponse,\r\n  ModelStat,\r\n  QueueInfo,\r\n  QueueSummary,\r\n} from '@/types/statistics';\r\nimport { fetch } from '@/lib/nextjs-util/fetch';\r\nimport { LoggedError } from '../react-util';\r\n\r\nconst STATISTICS_STALE_TIME = 30 * 1000; // 30 seconds\r\nconst STATISTICS_CACHE_TIME = 5 * 60 * 1000; // 5 minutes\r\n\r\n/**\r\n * Fetches model statistics from the API\r\n */\r\nconst fetchModelStatistics = async (\r\n  source: 'database' | 'redis' = 'database',\r\n): Promise<ModelStat[]> => {\r\n  const params = new URLSearchParams({ source });\r\n  try {\r\n    const response = await fetch(`/api/ai/chat/stats/models?${params}`);\r\n\r\n    if (!response.ok) {\r\n      throw new Error('Failed to fetch model statistics');\r\n    }\r\n\r\n    const data: ApiResponse<ModelStat[]> = await response.json();\r\n\r\n    if (!data.success) {\r\n      throw new Error(data.error || 'API returned error response');\r\n    }\r\n\r\n    return data.data;\r\n  } catch (error) {\r\n    throw LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n      log: true,\r\n      source: 'fetchModelStatistics',\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Fetches queue statistics from the API\r\n */\r\nconst fetchQueueStatistics = async (): Promise<{\r\n  summary: QueueSummary;\r\n  queues: QueueInfo[];\r\n}> => {\r\n  const response = await fetch('/api/ai/chat/stats/queues');\r\n\r\n  if (!response.ok) {\r\n    throw new Error('Failed to fetch queue statistics');\r\n  }\r\n\r\n  const data: ApiResponse<{ summary: QueueSummary; queues: QueueInfo[] }> =\r\n    await response.json();\r\n\r\n  if (!data.success) {\r\n    throw new Error(data.error || 'API returned error response');\r\n  }\r\n\r\n  return data.data;\r\n};\r\n\r\n\r\nexport const useModelStatistics = (\r\n  source: 'database' | 'redis' = 'database',\r\n) => {\r\n  return useQuery({\r\n    queryKey: ['modelStatistics', source],\r\n    queryFn: () => fetchModelStatistics(source),\r\n    staleTime: STATISTICS_STALE_TIME,\r\n    gcTime: STATISTICS_CACHE_TIME,\r\n    refetchInterval: STATISTICS_STALE_TIME,\r\n    retry: 3,\r\n    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\r\n  });\r\n};\r\n\r\n\r\nexport const useQueueStatistics = () => {\r\n  return useQuery({\r\n    queryKey: ['queueStatistics'],\r\n    queryFn: fetchQueueStatistics,\r\n    staleTime: STATISTICS_STALE_TIME,\r\n    gcTime: STATISTICS_CACHE_TIME,\r\n    refetchInterval: STATISTICS_STALE_TIME,\r\n    retry: 3,\r\n    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\r\n  });\r\n};\r\n\r\n\r\nexport const useStatistics = (\r\n  modelSource: 'database' | 'redis' = 'database',\r\n) => {\r\n  const modelQuery = useModelStatistics(modelSource);\r\n  const queueQuery = useQueueStatistics();\r\n\r\n  return {\r\n    models: modelQuery,\r\n    queues: queueQuery,\r\n    isLoading: modelQuery.isLoading || queueQuery.isLoading,\r\n    isError: modelQuery.isError || queueQuery.isError,\r\n    error: modelQuery.error || queueQuery.error,\r\n    refetch: () => {\r\n      modelQuery.refetch();\r\n      queueQuery.refetch();\r\n    },\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\logger\\abstract-logger.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":189,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { isError, isRecord, LoggedError } from '@/lib/react-util/core';\r\nimport {\r\n  ApplicationInsightsBaseType,\r\n  ApplicationInsightsCustomEventName,\r\n  ApplicationInsightsEventBaseType,\r\n  ApplicationInsightsExceptionBaseType,\r\n  ATTR_EXCEPTION_MESSAGE,\r\n  ATTR_EXCEPTION_STACKTRACE,\r\n  ATTR_EXCEPTION_TYPE,\r\n} from './constants';\r\nimport { CustomAppInsightsEvent } from './event';\r\nimport type { ILogger } from './types';\r\n\r\nexport class AbstractLogger implements ILogger {\r\n  /**\r\n   *\r\n   */\r\n  constructor() {}\r\n\r\n  protected logInfoMessage(record: object): void {\r\n    throw new Error('Method not implementedfor ' + JSON.stringify(record));\r\n  }\r\n  protected logErrorMessage(record: object): void {\r\n    throw new Error('Method not implemented for ' + JSON.stringify(record));\r\n  }\r\n  protected logWarnMessage(record: object): void {\r\n    throw new Error('Method not implemented for ' + JSON.stringify(record));\r\n  }\r\n  protected logDebugMessage(record: object): void {\r\n    throw new Error('Method not implemented for ' + JSON.stringify(record));\r\n  }\r\n  protected logFatalMessage(record: object): void {\r\n    throw new Error('Method not implemented for ' + JSON.stringify(record));\r\n  }\r\n  protected logVerboseMessage(record: object): void {\r\n    throw new Error('Method not implemented for ' + JSON.stringify(record));\r\n  }\r\n  protected logSillyMessage(record: object): void {\r\n    throw new Error('Method not implemented for ' + JSON.stringify(record));\r\n  }\r\n  protected logTraceMessage(record: object): void {\r\n    throw new Error('Method not implemented for ' + JSON.stringify(record));\r\n  }\r\n\r\n  protected buildLogRecord(\r\n    message: string | Record<string, unknown> | Error | object,\r\n    ...args: unknown[]\r\n  ): [object] {\r\n    let record: Record<string, unknown> & { [Symbol.toStringTag]?: string };\r\n    const properties = {} as Record<string, unknown>;\r\n    const attributes = {} as Record<string, unknown>;\r\n    let sliceArgOffset = 0;\r\n    if (typeof message === 'string') {\r\n      record = { message };\r\n      if (args.length > 0) {\r\n        if (typeof args[0] === 'object' && args[0] !== null) {\r\n          const recordBody = {\r\n            ...(record.body ?? {}),\r\n            ...('body' in args[0] ? (args[0].body ?? {}) : {}),\r\n          };\r\n          record = {\r\n            ...record,\r\n            ...args[0],\r\n            body: recordBody,\r\n          };\r\n          if (Object.keys(recordBody).length === 0) {\r\n            delete record.body;\r\n          }\r\n          sliceArgOffset = 1;\r\n        }\r\n      }\r\n      return this.buildLogRecord(record, ...args.slice(sliceArgOffset));\r\n    }\r\n    if ('dispose' in message && typeof message.dispose === 'function') {\r\n      message.dispose();\r\n    }\r\n    let stringValue: string;\r\n    // Error / exception messages\r\n    if (isError(message)) {\r\n      stringValue = !!message.message\r\n        ? typeof message.message === 'object'\r\n          ? 'body' in message && !!message.body\r\n            ? String(message.body)\r\n            : String(message.message)\r\n          : String(message.message)\r\n        : message.toString();\r\n\r\n      record = {\r\n        [ApplicationInsightsBaseType]: ApplicationInsightsExceptionBaseType,\r\n        ...message,\r\n        [ATTR_EXCEPTION_STACKTRACE]: message.stack,\r\n        [ATTR_EXCEPTION_TYPE]:\r\n          'source' in message ? (message.source ?? message.name) : message.name,\r\n        [ATTR_EXCEPTION_MESSAGE]: stringValue,\r\n      };\r\n      delete record.stack;\r\n      if ('source' in record) {\r\n        delete record.source;\r\n      }\r\n    } else if (CustomAppInsightsEvent.isCustomAppInsightsEvent(message)) {\r\n      // Custom Event messages\r\n      stringValue = `AppInsights Event: ${message.event}`;\r\n      record = {\r\n        [ApplicationInsightsCustomEventName]: message.event,\r\n        [ApplicationInsightsBaseType]: ApplicationInsightsEventBaseType,\r\n        ...message,\r\n        body: {\r\n          measurements: message.measurements ?? {},\r\n          ...('body' in message ? (message.body ?? {}) : {}),\r\n        },\r\n      };\r\n      delete record.measurements;\r\n      delete record.event;\r\n    } else {\r\n      if (!isRecord(message)) {\r\n        throw new Error('Message is not a valid object');\r\n      }\r\n      // and everything else is a generic message\r\n      stringValue = String(message.message ?? message.Message ?? message.body);\r\n      record = {\r\n        msg: stringValue,\r\n        ...message,\r\n      };\r\n    }\r\n    // Append any unprocessed arguments\r\n    if (args.length > sliceArgOffset) {\r\n      record = {\r\n        ...record,\r\n        // TraceArguments: args,\r\n      };\r\n    }\r\n    Object.keys(record).forEach((key) => {\r\n      if (\r\n        typeof key !== 'string' ||\r\n        key.startsWith('_') ||\r\n        typeof record[key] === 'function'\r\n      ) {\r\n        delete record[key];\r\n      }\r\n    });\r\n    // Cleanup message / Message hanger-ons\r\n    delete record.message;\r\n    delete record.Message;\r\n    if (Object.keys(properties).length) {\r\n      record.properties = {\r\n        ...properties,\r\n        ...(record.properties ?? {}),\r\n      };\r\n    }\r\n    if (Object.keys(attributes).length) {\r\n      record.attributes = {\r\n        ...attributes,\r\n        ...(record.attributes ?? {}),\r\n      };\r\n    }\r\n    record[Symbol.toStringTag] = stringValue ?? 'No message provided';\r\n    return [record];\r\n  }\r\n\r\n  info(message: string | object, ...args: unknown[]): void {\r\n    this.logInfoMessage(...this.buildLogRecord(message, ...args));\r\n  }\r\n  error(message: string | object, ...args: unknown[]): void {\r\n    const logArguments = this.buildLogRecord(\r\n      LoggedError.isTurtlesAllTheWayDownBaby(message),\r\n      ...args,\r\n    );\r\n    this.logErrorMessage(...logArguments);\r\n  }\r\n  warn(message: string | object, ...args: unknown[]): void {\r\n    this.logWarnMessage(...this.buildLogRecord(message, ...args));\r\n  }\r\n  debug(message: string | object, ...args: unknown[]): void {\r\n    this.logDebugMessage(...this.buildLogRecord(message, ...args));\r\n  }\r\n  fatal(message: string | object, ...args: unknown[]): void {\r\n    this.logFatalMessage(...this.buildLogRecord(message, ...args));\r\n  }\r\n  verbose(message: string | object, ...args: unknown[]): void {\r\n    this.logVerboseMessage(...this.buildLogRecord(message, ...args));\r\n  }\r\n  silly(message: string | object, ...args: unknown[]): void {\r\n    this.logSillyMessage(...this.buildLogRecord(message, ...args));\r\n  }\r\n  trace(message: string | object, ...args: unknown[]): void {\r\n    this.logTraceMessage(...this.buildLogRecord(message, ...args));\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\logger\\constants.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":97,"endColumn":2}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export const AzureMonitorSampleRate = 'microsoft.sample_rate';\r\nexport const ApplicationInsightsBaseType = '_MS.baseType';\r\nexport const ApplicationInsightsCustomEventName = 'microsoft.custom_event.name';\r\nexport const ApplicationInsightsMessageName =\r\n  'Microsoft.ApplicationInsights.Message';\r\nexport const ApplicationInsightsExceptionName =\r\n  'Microsoft.ApplicationInsights.Exception';\r\nexport const ApplicationInsightsPageViewName =\r\n  'Microsoft.ApplicationInsights.PageView';\r\nexport const ApplicationInsightsAvailabilityName =\r\n  'Microsoft.ApplicationInsights.Availability';\r\nexport const ApplicationInsightsEventName =\r\n  'Microsoft.ApplicationInsights.Event';\r\nexport const ApplicationInsightsMessageBaseType = 'MessageData';\r\nexport const ApplicationInsightsExceptionBaseType = 'ExceptionData';\r\nexport const ApplicationInsightsPageViewBaseType = 'PageViewData';\r\nexport const ApplicationInsightsAvailabilityBaseType = 'AvailabilityData';\r\nexport const ApplicationInsightsEventBaseType = 'EventData';\r\n/**\r\n * The exception message.\r\n *\r\n * @example Division by zero\r\n * @example Can't convert 'int' object to str implicitly\r\n */\r\nexport const ATTR_EXCEPTION_MESSAGE = 'exception.message';\r\n/**\r\n * A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG.\r\n *\r\n * @example \"Exception in thread \"main\" java.lang.RuntimeException: Test exception\\\\n at com.example.GenerateTrace.methodB(GenerateTrace.java:13)\\\\n at com.example.GenerateTrace.methodA(GenerateTrace.java:9)\\\\n at com.example.GenerateTrace.main(GenerateTrace.java:5)\\\\n\"\r\n */\r\nexport const ATTR_EXCEPTION_STACKTRACE = 'exception.stacktrace';\r\n/**\r\n * The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it.\r\n *\r\n * @example java.net.ConnectException\r\n * @example OSError\r\n */\r\nexport const ATTR_EXCEPTION_TYPE = 'exception.type';\r\nexport enum KnownSeverityLevel {\r\n  /** Verbose */\r\n  Verbose = 'Verbose',\r\n  /** Information */\r\n  Information = 'Information',\r\n  /** Warning */\r\n  Warning = 'Warning',\r\n  /** Error */\r\n  Error = 'Error',\r\n  /** Critical */\r\n  Critical = 'Critical',\r\n}\r\nexport const asKnownSeverityLevel = (input: unknown): KnownSeverityLevel => {\r\n  if (typeof input === 'number') {\r\n    if (input < 5){\r\n      switch(input) {\r\n        case 0:\r\n          return KnownSeverityLevel.Verbose;\r\n        case 1:\r\n          return KnownSeverityLevel.Information;\r\n        case 2:\r\n          return KnownSeverityLevel.Warning;\r\n        case 3:\r\n          return KnownSeverityLevel.Error;\r\n        case 4:\r\n          return KnownSeverityLevel.Critical;\r\n      }\r\n    }\r\n    if (input === 0) {\r\n      return KnownSeverityLevel.Verbose;\r\n    }\r\n    if (input < 10) {\r\n      return KnownSeverityLevel.Information;\r\n    }\r\n    if (input < 20) {\r\n      return KnownSeverityLevel.Warning;\r\n    }\r\n    if (input < 30) {\r\n      return KnownSeverityLevel.Error;\r\n    }\r\n    if (input < 40) {\r\n      return KnownSeverityLevel.Critical;\r\n    }      \r\n    return KnownSeverityLevel.Error;\r\n  }\r\n  switch (String(input ?? '').toLocaleLowerCase()) {\r\n    case 'verbose':\r\n      return KnownSeverityLevel.Verbose;\r\n    case 'information':\r\n      return KnownSeverityLevel.Information;\r\n    case 'warning':\r\n      return KnownSeverityLevel.Warning;\r\n    case 'error':\r\n      return KnownSeverityLevel.Error;\r\n    case 'critical':\r\n      return KnownSeverityLevel.Critical;\r\n  }\r\n  return KnownSeverityLevel.Error;\r\n}","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\logger\\core.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":128,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import pino from 'pino';\r\nimport { env, isRunningOnServer } from '@/lib/site-util/env';\r\nimport { WrappedLogger } from './wrapped-logger';\r\nimport type { ILogger, EventSeverity, LogEventOverloads } from './types';\r\nimport { CustomAppInsightsEvent } from './event';\r\n\r\nlet _logger: ILogger;\r\n\r\n/**\r\n * Returns a promise that resolves to an instance of ILogger.\r\n *\r\n * @returns {Promise<ILogger>} A promise that resolves to an ILogger instance.\r\n */\r\nexport const logger = (): Promise<ILogger> =>\r\n  new Promise((resolve) => {\r\n    if (!_logger) {\r\n      if (isRunningOnServer()) {\r\n        _logger = pino<'verbose' | 'silly', false>({\r\n          level: env('LOG_LEVEL_SERVER') ?? 'info',\r\n          name: 'app',\r\n          timestamp: pino.stdTimeFunctions.isoTime,\r\n          customLevels: { verbose: 5, silly: 1 },\r\n          useOnlyCustomLevels: false,\r\n        });\r\n      } else {\r\n        const isJest = process.env.JEST_WORKER_ID !== undefined;\r\n        const transport = isJest\r\n          ? undefined\r\n          : {\r\n              target: 'pino-pretty',\r\n              options: {\r\n                colorize: true,\r\n              },\r\n            };\r\n\r\n        _logger = pino<'verbose' | 'silly', false>({\r\n          level: env('NEXT_PUBLIC_LOG_LEVEL_CLIENT') ?? 'info',\r\n          name: 'app',\r\n          timestamp: pino.stdTimeFunctions.isoTime,\r\n          customLevels: { verbose: 5, silly: 1 },\r\n          useOnlyCustomLevels: false,\r\n          transport,\r\n        });\r\n      }\r\n    }\r\n    resolve(new WrappedLogger(_logger));\r\n  });\r\n\r\nconst resolvedPromise = Promise.resolve();\r\n\r\n/**\r\n * Executes a callback function with the provided logger instance.\r\n *\r\n * @param cb - A callback function that takes a logger instance as an argument.\r\n */\r\nexport const log = (cb: (l: ILogger) => void) => {\r\n  if (_logger) {\r\n    const cbRet = cb(_logger);\r\n    return cbRet !== undefined ? Promise.resolve(cbRet) : resolvedPromise;\r\n  }\r\n  return logger().then(cb);\r\n};\r\n\r\n/**\r\n * @remarks\r\n * This helper function provides multiple overloads for logging events.\r\n * @method\r\n * @name LogEventOverloads#(eventName: string): Promise<ILogger>\r\n * @description Logs an event with the specified name.\r\n * @param {string} eventName - The name of the event to log.\r\n * @returns {Promise<ILogger>} A promise that resolves to an ILogger instance.\r\n *\r\n * @method\r\n * @name LogEventOverloads#(eventName: string, measurements: Record<string, number>): Promise<ILogger>\r\n * @description Logs an event with the specified name and measurements.\r\n * @param {string} eventName - The name of the event to log.\r\n * @param {Record<string, number>} measurements - A record of measurements associated with the event.\r\n * @returns {Promise<ILogger>} A promise that resolves to an ILogger instance.\r\n *\r\n * @method\r\n * @name LogEventOverloads#(severity: EventSeverity, eventName: string): Promise<ILogger>\r\n * @description Logs an event with the specified severity and name.\r\n * @param {EventSeverity} severity - The severity level of the event.\r\n * @param {string} eventName - The name of the event to log.\r\n * @returns {Promise<ILogger>} A promise that resolves to an ILogger instance.\r\n *\r\n * @method\r\n * @description Logs an event with the specified severity, name, and measurements.\r\n * @param {EventSeverity} severity - The severity level of the event.\r\n * @param {string} eventName - The name of the event to log.\r\n * @param {Record<string, number>} measurements - A record of measurements associated with the event.\r\n * @returns {Promise<ILogger>} A promise that resolves to an ILogger instance.\r\n *\r\n * @example\r\n * ```typescript\r\n * logEvent('UserLoggedIn', { userId: 123 });\r\n * logEvent('error', 'ErrorOccurred');\r\n * ```\r\n */\r\nexport const logEvent: LogEventOverloads = (\r\n  severityOrEvent: EventSeverity | string,\r\n  eventOrMeasurements?: string | Record<string, number | string>,\r\n  measurements?: Record<string, number | string>,\r\n) => {\r\n  let severity: EventSeverity = 'info';\r\n  let event: CustomAppInsightsEvent;\r\n  if (measurements) {\r\n    // Only one thing we can be if the third param has a value\r\n    event = new CustomAppInsightsEvent(\r\n      eventOrMeasurements as string,\r\n      measurements,\r\n    );\r\n    severity = severityOrEvent as EventSeverity;\r\n  } else if (eventOrMeasurements) {\r\n    // If the second param is a string, we can assume it's an event name\r\n    if (typeof eventOrMeasurements === 'string') {\r\n      event = new CustomAppInsightsEvent(eventOrMeasurements);\r\n      severity = severityOrEvent as EventSeverity;\r\n    } else {\r\n      // Otherwise, we can assume it's a measurement\r\n      event = new CustomAppInsightsEvent('measurement', eventOrMeasurements);\r\n    }\r\n  } else {\r\n    event = new CustomAppInsightsEvent(severityOrEvent);\r\n  }\r\n  return log((l) => l[severity](event));\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\logger\\event.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":8,"column":1,"nodeType":"Program","endLine":114,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Represents a custom event with optional measurements and a dispose function.\r\n *\r\n * @property {string} event - The name of the event.\r\n * @property {Record<string, number>} [measurements] - Optional measurements associated with the event.\r\n * @property {() => void} [dispose] - Optional function to dispose of the event.\r\n */\r\nexport type ICustomAppInsightsEvent = {\r\n  /**\r\n   * The name of the event.\r\n   */\r\n  event: string;\r\n  /**\r\n   * Optional measurements associated with the event.\r\n   */\r\n  measurements?: Record<string, string | number>;\r\n  /**\r\n   * @returns void\r\n   * @description Disposes of the event and clears any associated resources.\r\n   */\r\n  dispose?: () => void;\r\n};\r\n\r\n/**\r\n * Represents a custom event with measurements and timers.\r\n */\r\nexport class CustomAppInsightsEvent implements ICustomAppInsightsEvent {\r\n  /**\r\n   * Checks if the given object is an instance of ICustomAppInsightsEvent.\r\n   * @param check - The object to check.\r\n   * @returns True if the object is an instance of ICustomAppInsightsEvent, false otherwise.\r\n   */\r\n  static isCustomAppInsightsEvent(\r\n    check: unknown,\r\n  ): check is ICustomAppInsightsEvent {\r\n    return (\r\n      typeof check === 'object' &&\r\n      check !== null &&\r\n      'event' in check &&\r\n      typeof check.event === 'string'\r\n    );\r\n  }\r\n  /**\r\n   * A map to store timer start times.\r\n   */\r\n  readonly #timers = new Map<string, Date>();\r\n  /**\r\n   * The name of the event.\r\n   */\r\n  event: string;\r\n  /**\r\n   * A record to store measurement values.\r\n   */\r\n  readonly measurements: Record<string, number | string>;\r\n\r\n  /**\r\n   * Creates an instance of CustomAppInsightsEvent.\r\n   * @param event - The name of the event.\r\n   * @param measurements - Optional initial measurements.\r\n   */\r\n  constructor(event: string, measurements?: Record<string, number | string>) {\r\n    this.event = event;\r\n    this.measurements = measurements ?? {};\r\n  }\r\n  /**\r\n   * Increments the value of a measurement by a specified amount.\r\n   * @param name - The name of the measurement.\r\n   * @param value - The amount to increment by. Defaults to 1.\r\n   */\r\n  increment(name: string, value: number = 1): void {\r\n    const current = Number(this.measurements[name] ?? 0);\r\n    if (!Number.isFinite(current)) {\r\n      throw new Error(\r\n        `Cannot increment measurement \"${name}\": value \"${this.measurements[name]}\" is not a finite number.`\r\n      );\r\n    }\r\n    this.measurements[name] = current + value;\r\n  }\r\n  /**\r\n   * Starts a timer for a specified measurement.\r\n   * @param name - The name of the timer.\r\n   * @throws Will throw an error if a timer with the same name already exists.\r\n   */\r\n  startTimer(name: string): void {\r\n    if (this.#timers.has(name)) {\r\n      throw new Error(`Timer with name ${name} already exists.`);\r\n    }\r\n    this.#timers.set(name, new Date());\r\n  }\r\n  /**\r\n   * Stops a timer for a specified measurement and records the elapsed time.\r\n   * @param name - The name of the timer.\r\n   * @throws Will throw an error if a timer with the specified name does not exist.\r\n   */\r\n  stopTimer(name: string): void {\r\n    const now = new Date();\r\n    if (!this.#timers.has(name)) {\r\n      throw new Error(`Timer with name ${name} does not exist.`);\r\n    }\r\n    this.measurements[name] = now.getTime() - this.#timers.get(name)!.getTime();\r\n    this.#timers.delete(name);\r\n  }\r\n  /**\r\n   * Disposes of all active timers and records their elapsed times.\r\n   */\r\n  dispose(): void {\r\n    const now = new Date();\r\n    this.#timers.forEach((start, name) => {\r\n      this.measurements[name] = now.getTime() - start.getTime();\r\n    });\r\n    this.#timers.clear();\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\logger\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\logger\\simple-scoped-logger.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":143,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { SimpleLogger, ILogger } from './types';\r\nimport { log } from './core';\r\n\r\n/**\r\n * Represents a single log record for the simple scoped logger.\r\n * @property source - The source or context of the log message.\r\n * @property timestamp - The ISO timestamp when the log was created.\r\n * @property message - The main log message, as a string or object.\r\n * @property data - Optional additional data to include with the log.\r\n */\r\ntype SimpleScoppedLogRecord = {\r\n  /**\r\n   * The source or context for all log messages from this logger.\r\n   * This is typically a string that identifies the part of the application\r\n   */\r\n  source: string;\r\n  /**\r\n   * The timestamp when the log message was created, in ISO format.\r\n   */\r\n  timestamp: string;\r\n  /**\r\n   * The main log message, which can be a string or an object.\r\n   * If an object is provided, it will be serialized to JSON.\r\n   */\r\n  message: string | object;\r\n  /**\r\n   * Optional additional data to include with the log message.\r\n   * This can be any type of data, but is typically an array of unknown values.\r\n   */\r\n  data?: unknown[];\r\n};\r\n\r\n/**\r\n * Properties for configuring a simple scoped logger instance.\r\n * @property source - The source or context for all log messages from this logger.\r\n * @property format - Optional function to format the log record before logging.\r\n */\r\ntype SimpleScopedLoggerProps = {\r\n  /**\r\n   * The source or context for all log messages from this logger.\r\n   * This is typically a string that identifies the part of the application.\r\n   */\r\n  source: string;\r\n  /**\r\n   * Optional function to format the log record before logging.\r\n   * This function takes a SimpleScoppedLogRecord and returns an object to log.\r\n   */\r\n  format?: (msg: SimpleScoppedLogRecord) => object;\r\n};\r\n\r\n/**\r\n * Overload signatures for the simpleScopedLogger factory function.\r\n * Allows creating a logger by passing either a source string or a configuration object.\r\n */\r\ninterface SimpleScopedLoggerOverloads {\r\n  /**\r\n   * Creates a SimpleLogger with a specified source and optional formatting function.\r\n   * @param {SimpleScopedLoggerProps} props - An object containing the source and optional format function.\r\n   * @return {SimpleLogger} A SimpleLogger instance with debug, info, warn, and error methods.\r\n   */\r\n  (props: SimpleScopedLoggerProps): SimpleLogger;\r\n  /**\r\n   * Creates a SimpleLogger with a specified source string.\r\n   * @param {string} source - The source or context for all log messages from this logger.\r\n   * @return {SimpleLogger} A SimpleLogger instance with debug, info, warn, and error methods.\r\n   */\r\n  (source: string): SimpleLogger;\r\n}\r\n\r\n/**\r\n * Creates a simple scoped logger that prefixes all log messages with a source/context.\r\n * Optionally allows formatting of log records before they are logged.\r\n *\r\n * @param sourceOrProps - Either a string (source) or a configuration object.\r\n * @returns A SimpleLogger with debug, info, warn, and error methods.\r\n */\r\nexport const simpleScopedLogger: SimpleScopedLoggerOverloads = (\r\n  sourceOrProps: string | SimpleScopedLoggerProps,\r\n): SimpleLogger => {\r\n  /**\r\n   * Internal configuration for the scoped logger, including source and optional format function.\r\n   */\r\n  const scopedLoggerConfig =\r\n    typeof sourceOrProps === 'string'\r\n      ? { source: sourceOrProps }\r\n      : { ...sourceOrProps };\r\n\r\n  /**\r\n   * Internal helper to format and send log messages to the underlying logger.\r\n   *\r\n   * @param action - The log method to call (debug, info, warn, error).\r\n   * @param args - Arguments passed to the logger method.\r\n   */\r\n  const writeToLog = (\r\n    action: (l: ILogger, msg: object) => void,\r\n    args: unknown[],\r\n  ) => {\r\n    if (args.length === 0) {\r\n      return;\r\n    }\r\n    const msg: SimpleScoppedLogRecord = {\r\n      source: scopedLoggerConfig.source,\r\n      timestamp: new Date().toISOString(),\r\n      message: typeof args[0] === 'object' ? (args[0] ?? {}) : String(args[0]),\r\n    };\r\n    if (args.length > 1) {\r\n      msg['data'] = args.slice(1);\r\n    }\r\n    const valueToLog: object = scopedLoggerConfig.format\r\n      ? scopedLoggerConfig.format(msg)\r\n      : msg;\r\n\r\n    if (valueToLog) {\r\n      Array.from(Object.entries(valueToLog)).forEach(([key, value]) => {\r\n        // Remove empty arrays or objects from the log - this should get rid of the\r\n        // 'invalid attribute value set for key....' log noise.\r\n        if (typeof value === 'object' && value !== null) {\r\n          if (Array.isArray(value)) {\r\n            if (!value.length) {\r\n              delete valueToLog[key as keyof typeof valueToLog];\r\n            }\r\n          } else if (Object.keys(value).length === 0) {\r\n            delete valueToLog[key as keyof typeof valueToLog];\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n\r\n    log((l) => action(l, valueToLog));\r\n  };\r\n  /**\r\n   * Returns a SimpleLogger with standard log level methods.\r\n   * Each method logs with the configured source and optional formatting.\r\n   */\r\n  return {\r\n    debug: (...args: unknown[]) => writeToLog((l, msg) => l.debug(msg), args),\r\n    info: (...args: unknown[]) => writeToLog((l, msg) => l.info(msg), args),\r\n    warn: (...args: unknown[]) => writeToLog((l, msg) => l.warn(msg), args),\r\n    error: (...args: unknown[]) => writeToLog((l, msg) => l.error(msg), args),\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\logger\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":17,"column":1,"nodeType":"Program","endLine":181,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Represents a simple logging interface with methods for different log levels.\r\n *\r\n * @remarks\r\n * This interface defines four primary logging methods: `info`, `warning`, `error`, and `debug`.\r\n * Each method accepts a variable number of arguments of any type.\r\n *\r\n * @example\r\n * ```typescript\r\n * const logger: SimpleLogger = ...;\r\n * logger.info('Application started');\r\n * logger.warning('Low disk space');\r\n * logger.error('Unhandled exception', error);\r\n * logger.debug('User data', user);\r\n * ```\r\n */\r\nexport interface SimpleLogger {\r\n  /**\r\n   * Logs an informational message.\r\n   * This method can accept a variable number of arguments, supporting the signature of `console.info`.\r\n   * @param args - Variable number of arguments to log.\r\n   */\r\n  info(...args: unknown[]): void;\r\n\r\n  /**\r\n   * Logs a warning message.\r\n   * This method can accept a variable number of arguments, supporting the signature of `console.warn`.\r\n   * @param args - Variable number of arguments to log.\r\n   */\r\n  warn(...args: unknown[]): void;\r\n\r\n  /**\r\n   * Logs an error message.\r\n   * This method can accept a variable number of arguments, supporting the signature of `console.error`.\r\n   * @param args - Variable number of arguments to log.\r\n   */\r\n  error(...args: unknown[]): void;\r\n\r\n  /**\r\n   * Logs a debug message.\r\n   * This method can accept a variable number of arguments, supporting the signature of `console.debug`.\r\n   * @param args - Variable number of arguments to log.\r\n   */\r\n  debug(...args: unknown[]): void;\r\n}\r\n\r\n/**\r\n * Defines a contract for logging messages at various severity levels.\r\n *\r\n * Implementations of this interface should provide methods to log messages\r\n * for informational, error, warning, debug, fatal, verbose, silly, and trace events.\r\n * Each method accepts a message (string or object) and optional additional arguments.\r\n */\r\nexport interface ILogger extends SimpleLogger {\r\n  /**\r\n   * Logs an informational message.\r\n   * @param {string | object} message - The message to log.\r\n   * @param args - Additional arguments to log.\r\n   */\r\n  info(message: string | object, ...args: unknown[]): void;\r\n\r\n  /**\r\n   * Logs an error message.\r\n   * @param {string | object} message - The message to log.\r\n   * @param args - Additional arguments to log.\r\n   */\r\n  error(message: string | object, ...args: unknown[]): void;\r\n\r\n  /**\r\n   * Logs a warning message.\r\n   * @param {string | object} message - The message to log.\r\n   * @param args - Additional arguments to log.\r\n   */\r\n  warn(message: string | object, ...args: unknown[]): void;\r\n\r\n  /**\r\n   * Logs a debug message.\r\n   * @param {string | object} message - The message to log.\r\n   * @param args - Additional arguments to log.\r\n   */\r\n  debug(message: string | object, ...args: unknown[]): void;\r\n\r\n  /**\r\n   * Logs a fatal error message.\r\n   * @param {string | object} message - The message to log.\r\n   * @param args - Additional arguments to log.\r\n   */\r\n  fatal(message: string | object, ...args: unknown[]): void;\r\n\r\n  /**\r\n   * Logs a verbose message.\r\n   * @param {string | object} message - The message to log.\r\n   * @param args - Additional arguments to log.\r\n   */\r\n  verbose(message: string | object, ...args: unknown[]): void;\r\n\r\n  /**\r\n   * Logs a silly message. This is the one you put the swear words in.\r\n   * @param {string | object} message - The message to log.\r\n   * @param args - Additional arguments to log.\r\n   */\r\n  silly(message: string | object, ...args: unknown[]): void;\r\n  /**\r\n   * Logs a trace message.\r\n   * @param {string | object} message - The message to log.\r\n   * @param args - Additional arguments to log.\r\n   */\r\n  trace(message: string | object, ...args: unknown[]): void;\r\n}\r\n\r\n/**\r\n * Represents the severity levels of events as defined by the keys of the `ILogger` interface.\r\n * This type is useful for ensuring that only valid logger severity levels are used throughout the application.\r\n */\r\nexport type EventSeverity = keyof ILogger;\r\n\r\n/**\r\n * Provides overloads for logging events with varying levels of detail and severity.\r\n *\r\n * @overload\r\n * Logs an event with the specified name.\r\n * @param {string} eventName - The name of the event to log.\r\n * @returns {Promise<void>} A promise that resolves when the event is logged.\r\n *\r\n * @overload\r\n * Logs an event with the specified name and measurements.\r\n * @param {string} eventName - The name of the event to log.\r\n * @param {Record<string, number>} measurements - A record of measurements associated with the event.\r\n * @returns {Promise<void>} A promise that resolves when the event is logged.\r\n *\r\n * @overload\r\n * Logs an event with the specified severity and name.\r\n * @param {EventSeverity} severity - The severity level of the event.\r\n * @param {string} eventName - The name of the event to log.\r\n * @returns {Promise<void>} A promise that resolves when the event is logged.\r\n *\r\n * @overload\r\n * Logs an event with the specified severity, name, and measurements.\r\n * @param {EventSeverity} severity - The severity level of the event.\r\n * @param {string} eventName - The name of the event to log.\r\n * @param {Record<string, number>} measurements - A record of measurements associated with the event.\r\n * @returns {Promise<void>} A promise that resolves when the event is logged.\r\n */\r\nexport interface LogEventOverloads {\r\n  /**\r\n   * Logs an event with the specified name.\r\n   * @param {string} eventName - The name of the event to log.\r\n   * @returns {Promise<void>} A promise that resolves when the event is logged.\r\n   */\r\n  (eventName: string): Promise<void>;\r\n  /**\r\n   * Logs an event with the specified name and measurements.\r\n   * @param {string} eventName - The name of the event to log.\r\n   * @param {Record<string, number>} measurements - A record of measurements associated with the event.\r\n   * @returns {Promise<void>} A promise that resolves when the event is logged.\r\n   */\r\n  (\r\n    eventName: string,\r\n    measurements: Record<string, number | string>,\r\n  ): Promise<void>;\r\n  /**\r\n   * Logs an event with the specified severity and name.\r\n   * @param {EventSeverity} severity - The severity level of the event.\r\n   * @param {string} eventName - The name of the event to log.\r\n   * @returns {Promise<void>} A promise that resolves when the event is logged.\r\n   */\r\n  (severity: EventSeverity, eventName: string): Promise<void>;\r\n  /**\r\n   * Logs an event with the specified severity, name, and measurements.\r\n   * @param {EventSeverity} severity - The severity level of the event.\r\n   * @param {string} eventName - The name of the event to log.\r\n   * @param {Record<string, number>} measurements - A record of measurements associated with the event.\r\n   * @returns {Promise<void>} A promise that resolves when the event is logged.\r\n   */\r\n  (\r\n    severity: EventSeverity,\r\n    eventName: string,\r\n    measurements: Record<string, number | string>,\r\n  ): Promise<void>;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\logger\\utilities.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":11,"column":1,"nodeType":"Program","endLine":197,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Logger utilities\r\n *\r\n * Provides helpers to detect nested Postgres errors and to generate\r\n * normalized, serializable error log payloads.\r\n *\r\n * Highlights:\r\n * - getDbError: finds a Postgres-like error in error/cause chains\r\n * - errorLogFactory: builds a consistent error object with DB details when present\r\n */\r\nimport { getStackTrace } from '../nextjs-util/get-stack-trace';\r\n\r\n/**\r\n * Shape of a Postgres/DB error we want to extract and log.\r\n */\r\nexport type DbError = Error & {\r\n  code: number;\r\n  detail: string;\r\n  severity: number | string;\r\n  internalQuery?: string;\r\n  where?: string;\r\n  schema?: string;\r\n  table?: string;\r\n  column?: string;\r\n  // Vendor-specific or alternative field names we may remap from\r\n  schema_name?: string;\r\n  column_name?: string;\r\n  table_name?: string;\r\n  query?: string;\r\n  internal_query?: string;\r\n  cause?: unknown;\r\n};\r\n\r\n/**\r\n * Narrow object type used when walking potentially wrapped errors.\r\n */\r\ninterface MaybeWrappedError {\r\n  name?: unknown;\r\n  cause?: unknown;\r\n  error?: unknown;\r\n}\r\n\r\ntype ErrorLike = { message: string; stack?: string };\r\n\r\nconst isErrorLike = (val: unknown): val is ErrorLike => {\r\n  if (!val || typeof val !== 'object') return false;\r\n  const obj = val as Record<string, unknown>;\r\n  return typeof obj['message'] === 'string';\r\n};\r\n\r\n/**\r\n * Recursively extract a Postgres-like error instance from common wrappers.\r\n * Checks the value itself, then `.cause`, `.cause.error`, and `.error`.\r\n */\r\nconst extractDbError = (val: unknown): DbError | undefined => {\r\n  if (!val || typeof val !== 'object') return undefined;\r\n  const e = val as MaybeWrappedError & { name?: string };\r\n  if (e.name === 'PostgresError') return val as DbError;\r\n\r\n  // Walk standard wrapping locations\r\n  const fromCause = extractDbError(e.cause);\r\n  if (fromCause) return fromCause;\r\n  /*\r\n  if (e.cause && typeof e.cause === \"object\") {\r\n    const maybeDeeper = extractDbError((e.cause as MaybeWrappedError).error);\r\n    if (maybeDeeper) return maybeDeeper;\r\n  }\r\n    */\r\n  return extractDbError(e.error);\r\n};\r\n\r\n/**\r\n * Attempts to extract a Postgres/DB error from an unknown thrown value.\r\n *\r\n * Supported shapes (any depth):\r\n * - { name: 'PostgresError', ... }\r\n * - { cause: { name: 'PostgresError', ... } }\r\n * - { cause: { error: { name: 'PostgresError', ... } } }\r\n * - { error: { name: 'PostgresError', ... } }\r\n *\r\n * @param error Unknown thrown value (Error, wrapped error, or other)\r\n * @returns The detected DbError if present, otherwise undefined\r\n */\r\nexport const getDbError = (error: unknown): DbError | undefined =>\r\n  extractDbError(error);\r\n\r\n/**\r\n * Creates a normalized error log payload.\r\n *\r\n * Behavior:\r\n * - If `error` looks like an Error (has `message`), produce `{ message, stack }`\r\n *   - Use the provided `error.stack` if available\r\n *   - Otherwise synthesize a stack via `getStackTrace({ skip: 3 })`\r\n * - If `error` contains a recognized DB error (see `getDbError`), include DB-specific fields:\r\n *   - name, code, detail, severity\r\n *   - internalQuery (from `query` or `internal_query`)\r\n *   - where, schema, table, column, cause\r\n * - Merge `include` and any extra named params into the top-level object\r\n * - Derive a top-level `message` for convenience\r\n *\r\n * @param params Composite parameters\r\n * @param params.error The error value to format\r\n * @param params.source Logical source of the error (logger scope, module, etc.)\r\n * @param params.include Optional additional fields to merge into the payload\r\n * @returns A serializable error log object\r\n */\r\nexport const errorLogFactory: ({\r\n  error,\r\n  source,\r\n  include,\r\n}: {\r\n  error: unknown;\r\n  source: string;\r\n  include?: object;\r\n  severity?: string;\r\n} & Record<string, unknown>) => Record<string, unknown> = ({\r\n  error,\r\n  source,\r\n  include,\r\n  ...params\r\n}) => {\r\n  const ret: Record<string, unknown> = {\r\n    source,\r\n    ...(include ?? {}),\r\n    ...(params ?? {}),\r\n  };\r\n  if (typeof error === 'string') {\r\n    return errorLogFactory({\r\n      error: { message: error },\r\n      source,\r\n      include,\r\n      ...params,\r\n    });\r\n  }\r\n  const defaultError = 'An unexpected error occurred.';\r\n  // if it has a message, it's error-like enough for us\r\n  if (isErrorLike(error)) {\r\n    const stack =\r\n      typeof error['stack'] === 'string'\r\n        ? (error['stack']?.toString() ?? getStackTrace({ skip: 2 }))\r\n        : '';\r\n    const message =\r\n      error['message']?.toString() ?? 'An unknown error occurred.';\r\n    let loggedError: Record<string, unknown> = {\r\n      message,\r\n      stack,\r\n      ...(('cause' in error &&\r\n      typeof error['cause'] === 'object' &&\r\n      error['cause'] !== null\r\n        ? { cause: JSON.stringify(error['cause']) }\r\n        : {}) as Record<string, unknown>),\r\n    };\r\n\r\n    const dbError = getDbError(error);\r\n    if (dbError) {\r\n      loggedError = {\r\n        ...loggedError,\r\n        name: 'name' in dbError ? dbError.name : undefined,\r\n        code: dbError.code,\r\n        detail: dbError.detail,\r\n        severity: dbError.severity,\r\n        internalQuery:\r\n          dbError.query ?? dbError.internal_query ?? dbError.internalQuery,\r\n        where: dbError.where,\r\n        schema: dbError.schema_name ?? dbError.schema,\r\n        table: dbError.table_name ?? dbError.table,\r\n        column: dbError.column_name ?? dbError.column,\r\n        cause: dbError.cause,\r\n      };\r\n    }\r\n    ret.error = loggedError;\r\n    ret.message = loggedError.message as string;\r\n  } else {\r\n    ret.error = JSON.stringify(error ?? 'null');\r\n    ret.message ??= defaultError;\r\n  }\r\n  if (!ret.severity) {\r\n    ret.severity = 'error';\r\n  }\r\n  if (\r\n    ret.error &&\r\n    typeof ret.error === 'object' &&\r\n    Object.keys(ret.error).length === 0\r\n  ) {\r\n    ret.error = {\r\n      message:\r\n        typeof ret.context === 'object' &&\r\n        ret.context &&\r\n        'message' in ret.context &&\r\n        ret.context\r\n          ? (ret.context.message ?? defaultError)\r\n          : defaultError,\r\n    };\r\n  }\r\n  return ret;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\logger\\wrapped-logger.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":40,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AbstractLogger } from './abstract-logger';\r\nimport type { ILogger } from './types';\r\n\r\nexport class WrappedLogger extends AbstractLogger {\r\n  readonly #logger: ILogger;\r\n\r\n  /**\r\n   *\r\n   */\r\n  constructor(logger: ILogger) {\r\n    super();\r\n    this.#logger = logger;\r\n  }\r\n\r\n  protected logInfoMessage(record: object): void {\r\n    this.#logger.info(record);\r\n  }\r\n  protected logErrorMessage(record: object): void {\r\n    this.#logger.error(record);\r\n  }\r\n  protected logWarnMessage(record: object): void {\r\n    this.#logger.warn(record);\r\n  }\r\n  protected logDebugMessage(record: object): void {\r\n    this.#logger.debug(record);\r\n  }\r\n  protected logFatalMessage(record: object): void {\r\n    this.#logger.fatal(record);\r\n  }\r\n  protected logVerboseMessage(record: object): void {\r\n    this.#logger.verbose(record);\r\n  }\r\n  protected logSillyMessage(record: object): void {\r\n    this.#logger.silly(record);\r\n  }\r\n  protected logTraceMessage(record: object): void {\r\n    this.#logger.trace(record);\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\neondb\\_guards.d.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":109,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4109,4112],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4109,4112],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":171,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6245,6248],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6245,6248],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\neondb\\_guards.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[436,439],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[436,439],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":17,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[638,641],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[638,641],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\neondb\\connection.d.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":151,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5698,5701],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5698,5701],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":177,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":177,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6754,6757],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6754,6757],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\neondb\\connection.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1447,1450],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1447,1450],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":40,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1587,1590],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1587,1590],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":43,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1748,1751],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1748,1751],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":58,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2339,2342],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2339,2342],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":99,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3668,3671],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3668,3671],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":103,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3819,3822],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3819,3822],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\neondb\\index-postgres.d.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":40,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1268,1271],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1268,1271],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":40,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1285,1288],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1285,1288],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1311,1314],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1311,1314],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":47,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1495,1498],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1495,1498],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":47,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1512,1515],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1512,1515],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":54,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1712,1715],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1712,1715],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'T2' is defined but never used.","line":72,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":72,"endColumn":36,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":74,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2362,2365],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2362,2365],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":74,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":64,"suggestions":[{"messageId":"suggestPropertyKey","fix":{"range":[2366,2375],"text":"PropertyKey"},"desc":"Use `PropertyKey` instead, this is more explicit than `keyof any`."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":75,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2401,2404],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2401,2404],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2438,2441],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2438,2441],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2459,2462],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2459,2462],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":83,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2663,2666],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2663,2666],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":108,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3487,3490],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3487,3490],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":116,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":116,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3786,3789],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3786,3789],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":120,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":120,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3919,3922],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3919,3922],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":125,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4079,4082],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4079,4082],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":133,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4332,4335],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4332,4335],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":142,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":142,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4605,4608],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4605,4608],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":142,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":142,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4639,4642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4639,4642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'X' is defined but never used.","line":151,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":151,"endColumn":6,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Y' is defined but never used.","line":152,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":152,"endColumn":6,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":159,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5158,5161],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5158,5161],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\neondb\\index-postgres.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":43,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1311,1314],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1311,1314],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1604,1607],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1604,1607],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":64,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1959,1962],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1959,1962],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2137,2140],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2137,2140],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2332,2335],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2332,2335],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":80,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2486,2489],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2486,2489],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":92,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2842,2845],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2842,2845],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":99,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3039,3042],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3039,3042],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":101,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3107,3110],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3107,3110],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":103,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3162,3165],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3162,3165],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":107,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3296,3299],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3296,3299],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":110,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":110,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3452,3455],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3452,3455],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":114,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3561,3564],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3561,3564],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":133,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4110,4113],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4110,4113],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":138,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4281,4284],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4281,4284],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":150,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":150,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4588,4591],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4588,4591],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":157,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4767,4770],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4767,4770],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":169,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":169,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5124,5127],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5124,5127],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":178,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5437,5440],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5437,5440],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":185,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":185,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5645,5648],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5645,5648],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":195,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5864,5867],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5864,5867],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":201,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":201,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6066,6069],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6066,6069],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":214,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":214,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6471,6474],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6471,6474],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":214,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":214,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6488,6491],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6488,6491],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":215,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":215,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6512,6515],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6512,6515],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":218,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":218,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6592,6595],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6592,6595],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":218,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":218,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6609,6612],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6609,6612],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":242,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":242,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7227,7230],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7227,7230],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":262,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":262,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7705,7708],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7705,7708],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":263,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":263,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7736,7739],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7736,7739],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":280,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":280,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8230,8233],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8230,8233],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":281,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":281,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8267,8270],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8267,8270],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":283,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":283,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8313,8316],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8313,8316],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'T2' is defined but never used.","line":385,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":385,"endColumn":34,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":387,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":387,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11591,11594],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11591,11594],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":387,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":387,"endColumn":62,"suggestions":[{"messageId":"suggestPropertyKey","fix":{"range":[11595,11604],"text":"PropertyKey"},"desc":"Use `PropertyKey` instead, this is more explicit than `keyof any`."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":388,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":388,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11628,11631],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11628,11631],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'FullResultsOverride' is defined but never used.","line":392,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":392,"endColumn":24,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":395,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":395,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11856,11859],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11856,11859],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":396,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":396,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11882,11885],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11882,11885],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":397,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":397,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11913,11916],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11913,11916],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":402,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":402,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12048,12051],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12048,12051],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":405,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":405,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12188,12191],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12188,12191],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":405,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":405,"endColumn":62,"suggestions":[{"messageId":"suggestPropertyKey","fix":{"range":[12192,12201],"text":"PropertyKey"},"desc":"Use `PropertyKey` instead, this is more explicit than `keyof any`."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":408,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":408,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12310,12313],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12310,12313],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":439,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":439,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13205,13208],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13205,13208],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":449,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":449,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13552,13555],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13552,13555],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":456,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":456,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13799,13802],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13799,13802],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":458,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":458,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13869,13872],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13869,13872],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":463,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":463,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14079,14082],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14079,14082],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":469,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":469,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14288,14291],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14288,14291],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":469,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":469,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14322,14325],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14322,14325],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":489,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":489,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15145,15148],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15145,15148],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":503,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":503,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15543,15546],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15543,15546],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'X' is defined but never used.","line":510,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":510,"endColumn":4,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Y' is defined but never used.","line":512,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":512,"endColumn":4,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\neondb\\index.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\neondb\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\neondb\\postgres.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\neondb\\postgres.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":9,"column":1,"nodeType":"Program","endLine":636,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":99,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3196,3199],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3196,3199],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":103,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3416,3419],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3416,3419],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":112,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3769,3772],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3769,3772],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// =============================================================================\r\n// Core PostgreSQL Types and Interfaces\r\n// =============================================================================\r\n\r\n/**\r\n * Represents a PostgreSQL connection configuration.\r\n * Equivalent to postgres.Options from 'postgres' package.\r\n */\r\nexport interface PostgresConfig {\r\n  /** Database host */\r\n  host?: string;\r\n  /** Database port */\r\n  port?: number;\r\n  /** Database name */\r\n  database?: string;\r\n  /** Username for authentication */\r\n  username?: string;\r\n  /** Password for authentication */\r\n  password?: string;\r\n  /** SSL configuration */\r\n  ssl?: boolean | object;\r\n  /** Maximum number of connections in pool */\r\n  max?: number;\r\n  /** Idle timeout in seconds */\r\n  idle_timeout?: number;\r\n  /** Connection timeout in seconds */\r\n  connect_timeout?: number;\r\n  /** Whether to prepare statements */\r\n  prepare?: boolean;\r\n  /** Transform function for column names */\r\n  transform?: {\r\n    column?: (column: string) => string;\r\n    value?: (value: unknown) => unknown;\r\n    row?: (row: Record<string, unknown>) => Record<string, unknown>;\r\n  };\r\n  /** Custom types configuration */\r\n  types?: Record<string, unknown>;\r\n  /** Debug mode */\r\n  debug?: boolean | ((connection: number, query: string, parameters: unknown[], paramTypes: unknown[]) => void);\r\n  /** Connection parameters */\r\n  connection?: Record<string, unknown>;\r\n  /** Fetch array size */\r\n  fetch_array_size?: number;\r\n  /** Publications for logical replication */\r\n  publications?: string;\r\n  /** Target session attributes */\r\n  target_session_attrs?: 'read-write' | 'read-only' | 'primary' | 'standby' | 'prefer-standby';\r\n}\r\n\r\n/**\r\n * Represents the result metadata from a PostgreSQL query.\r\n * Equivalent to postgres.ResultMeta<T> from 'postgres' package.\r\n */\r\nexport interface PostgresResultMeta<T = number> {\r\n  /** SQL command that was executed */\r\n  command: string;\r\n  /** Number of rows affected */\r\n  count: T;\r\n  /** Additional meta information */\r\n  [key: string]: unknown;\r\n}\r\n\r\n/**\r\n * Represents a column in a PostgreSQL result set.\r\n * Equivalent to postgres.Column<T> from 'postgres' package.\r\n * \r\n * @template T - The name of the column\r\n */\r\nexport interface PostgresColumn<T extends string> {\r\n  name: T;\r\n  type: number;\r\n  table: number;\r\n  number: number;\r\n  parser?: ((raw: string) => unknown) | undefined;\r\n}\r\n\r\n\r\n/**\r\n * Represents column information from a PostgreSQL result.\r\n * Equivalent to postgres.ColumnList<T> from 'postgres' package.\r\n */\r\nexport type PostgresColumnList<T> = (T extends string ? PostgresColumn<T> : never)[];\r\n\r\n\r\n/**\r\n * Represents a row of data that may or may not exist.\r\n * Equivalent to postgres.MaybeRow from 'postgres' package.\r\n */\r\nexport type PostgresMaybeRow = Record<string, unknown> | undefined;\r\n\r\ninterface PostgresResultQueryMeta<T extends number | null, U>\r\n  extends PostgresResultMeta<T> {\r\n  columns: PostgresColumnList<U>;\r\n}\r\n\r\nexport type PostgresExecutionResult<T> = [] &\r\n  PostgresResultQueryMeta<number, keyof NonNullable<T>>;\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport type PostgresValuesRowList<T extends readonly any[]> =\r\n  T[number][keyof T[number]][][] &\r\n    PostgresResultQueryMeta<T['length'], keyof T[number]>;\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport type PostgresRawRowList<T extends readonly any[]> = Buffer[][] &\r\n    Iterable<Buffer[][]> &\r\n    PostgresResultQueryMeta<T['length'], keyof T[number]>;\r\n  \r\n  \r\n/**\r\n * Represents a list of rows returned from a query.\r\n * Equivalent to postgres.RowList<T> from 'postgres' package.*/\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport type PostgresRowList<T extends readonly any[]> = T &\r\n    Iterable<NonNullable<T[number]>> &\r\n    PostgresResultQueryMeta<T['length'], keyof T[number]>;\r\n\r\n\r\n/**\r\n * Represents a list of rows returned from a query.\r\n * Equivalent to postgres.RowList<T> from 'postgres' package.\r\nexport interface PostgresRowList<T extends Record<string, unknown> = Record<string, unknown>> extends Array<T> {\r\n  /** Query execution command metadata * /\r\n  command: string;\r\n  /** Number of rows returned * /\r\n  count: number;\r\n  /** Column information * /\r\n  columns: PostgresColumnList<keyof T>;\r\n  /** Statement that was executed * /\r\n  statement: PostgresStatement | string;\r\n}\r\n */\r\n\r\n\r\n/**\r\n * Represents a parameter or SQL fragment that can be used in queries.\r\n * Equivalent to postgres.ParameterOrFragment from 'postgres' package.\r\n */\r\nexport type PostgresParameterOrFragment<T = unknown> = \r\n  | T \r\n  | PostgresFragment\r\n  | PostgresHelper<T>;\r\n\r\n/**\r\n * Represents a SQL fragment with parameters.\r\n * Equivalent to postgres.Fragment from 'postgres' package.\r\n */\r\nexport interface PostgresFragment {\r\n  /** The SQL text */\r\n  text: string;\r\n  /** Parameters for the fragment */\r\n  parameters: unknown[];\r\n  /** Parameter types */\r\n  types: number[];\r\n  /** Fragment metadata */\r\n  [key: string]: unknown;\r\n}\r\n\r\n/**\r\n * Represents a helper function for building SQL queries.\r\n * Equivalent to postgres.Helper<T> from 'postgres' package.\r\n */\r\nexport interface PostgresHelper<T = unknown> {\r\n  /** The helper function */\r\n  (values: T[]): PostgresFragment;\r\n  /** Helper configuration */\r\n  [key: string]: unknown;\r\n}\r\n\r\n/**\r\n * Represents a pending database query.\r\n * Equivalent to postgres.PendingQuery<T> from 'postgres' package.\r\n */\r\nexport interface PostgresPendingQuery<T = Record<string, unknown>> extends Promise<PostgresRowList<T[]>> {\r\n  /** The SQL statement */\r\n  statement: PostgresStatement;\r\n  /** Execute the query */\r\n  execute(): Promise<PostgresRowList<T[]>>;\r\n  /** Describe the query */\r\n  describe(): Promise<{\r\n    columns: PostgresColumnList<keyof T>;\r\n    parameters: unknown[];\r\n  }>;\r\n  /** Cancel the query */\r\n  cancel(): Promise<void>;\r\n  /** Whether the query is simple (no parameters) */\r\n  simple: boolean;\r\n  /** Query options */\r\n  options: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Represents a prepared SQL statement.\r\n * Equivalent to postgres.Statement from 'postgres' package.\r\n */\r\nexport interface PostgresStatement {\r\n  /** Statement name */\r\n  name: string;\r\n  /** SQL text */\r\n  text: string;\r\n  /** Parameter types */\r\n  types: number[];\r\n  /** Columns returned by statement */\r\n  columns: PostgresColumnList<string>;\r\n  /** Statement metadata */\r\n  [key: string]: unknown;\r\n}\r\n\r\n/**\r\n * Represents an error from PostgreSQL.\r\n * Equivalent to postgres.PostgresError from 'postgres' package.\r\n */\r\nexport interface PostgresError extends Error {\r\n  /** PostgreSQL error severity */\r\n  severity: string;\r\n  /** PostgreSQL error code */\r\n  code: string;\r\n  /** Detailed error message */\r\n  detail?: string;\r\n  /** Error hint */\r\n  hint?: string;\r\n  /** Position of error in query */\r\n  position?: string;\r\n  /** Internal position */\r\n  internalPosition?: string;\r\n  /** Internal query */\r\n  internalQuery?: string;\r\n  /** Error context */\r\n  where?: string;\r\n  /** Schema name */\r\n  schema?: string;\r\n  /** Table name */\r\n  table?: string;\r\n  /** Column name */\r\n  column?: string;\r\n  /** Data type name */\r\n  dataType?: string;\r\n  /** Constraint name */\r\n  constraint?: string;\r\n  /** Source file */\r\n  file?: string;\r\n  /** Source line */\r\n  line?: string;\r\n  /** Source routine */\r\n  routine?: string;\r\n}\r\n\r\n// =============================================================================\r\n// Transaction Types\r\n// =============================================================================\r\n\r\n/**\r\n * Represents a database transaction.\r\n * Equivalent to postgres transaction types from 'postgres' package.\r\n */\r\nexport interface PostgresTransaction<T extends Record<string, unknown> = Record<string, unknown>> {\r\n  /** Execute a query within the transaction */\r\n  <R extends Record<string, unknown> = T>(\r\n    template: TemplateStringsArray,\r\n    ...parameters: PostgresParameterOrFragment[]\r\n  ): PostgresPendingQuery<R>;\r\n\r\n  /** Execute a query within the transaction with explicit typing */\r\n  <R extends Record<string, unknown> = T>(\r\n    query: string,\r\n    parameters?: PostgresParameterOrFragment[]\r\n  ): PostgresPendingQuery<R>;\r\n\r\n  /** Create a savepoint */\r\n  savepoint<R>(fn: (sql: PostgresTransaction<T>) => R | Promise<R>): Promise<R>;\r\n\r\n  /** Rollback the transaction */\r\n  rollback(): void;\r\n\r\n  /** Additional transaction properties */\r\n  [key: string]: unknown;\r\n}\r\n\r\n// =============================================================================\r\n// Main SQL Interface Types\r\n// =============================================================================\r\n\r\n/**\r\n * Tagged template function for SQL queries.\r\n * Core interface for executing PostgreSQL queries with type safety.\r\n */\r\nexport interface PostgresSqlTemplate<T = Record<string, unknown>> {\r\n  /** Execute a parameterized query using template literals */\r\n  <R = T>(\r\n    template: TemplateStringsArray,\r\n    ...parameters: PostgresParameterOrFragment[]\r\n  ): PostgresPendingQuery<R>;\r\n\r\n  /** Execute a query with string and parameters */\r\n  <R  = T>(\r\n    query: string,\r\n    parameters?: PostgresParameterOrFragment[]\r\n  ): PostgresPendingQuery<R>;\r\n}\r\n\r\n/**\r\n * Transaction execution interface.\r\n */\r\nexport interface PostgresTransactionFunction {\r\n  /** Execute a function within a database transaction */\r\n  <T>(fn: (sql: PostgresTransaction) => T | Promise<T>): Promise<T>;\r\n  /** Execute with specific transaction options */\r\n  <T>(\r\n    options: {\r\n      isolation?: 'read_uncommitted' | 'read_committed' | 'repeatable_read' | 'serializable';\r\n      readonly?: boolean;\r\n      deferrable?: boolean;\r\n    },\r\n    fn: (sql: PostgresTransaction) => T | Promise<T>\r\n  ): Promise<T>;\r\n}\r\n\r\n/**\r\n * Helper functions for building complex queries.\r\n */\r\nexport interface PostgresHelpers {\r\n  /** Create a helper for inserting multiple rows */\r\n  insert<T extends Record<string, unknown>>(\r\n    columns: (keyof T)[],\r\n    options?: { onConflict?: string }\r\n  ): PostgresHelper<T>;\r\n\r\n  /** Create a helper for updating multiple rows */\r\n  update<T extends Record<string, unknown>>(\r\n    columns: (keyof T)[],\r\n    where?: string\r\n  ): PostgresHelper<T>;\r\n\r\n  /** Create a VALUES helper */\r\n  values<T extends Record<string, unknown>>(\r\n    rows: T[],\r\n    columns?: (keyof T)[]\r\n  ): PostgresFragment;\r\n\r\n  /** Create an IN helper for array parameters */\r\n  in<T>(values: T[]): PostgresFragment;\r\n\r\n  /** Create a JSON helper */\r\n  json(value: unknown): PostgresFragment;\r\n\r\n  /** Create an identifier helper */\r\n  identifier(name: string): PostgresFragment;\r\n\r\n  /** Create a raw SQL helper */\r\n  raw(sql: string): PostgresFragment;\r\n}\r\n\r\n/**\r\n * Connection and utility functions.\r\n */\r\nexport interface PostgresUtilities {\r\n  /** End all connections and clean up */\r\n  end(): Promise<void>;\r\n\r\n  /** Get connection information */\r\n  options: PostgresConfig;\r\n\r\n  /** Reserve a connection for multiple queries */\r\n  reserve(): Promise<PostgresReservedConnection>;\r\n\r\n  /** Listen for PostgreSQL notifications */\r\n  listen(\r\n    channel: string,\r\n    fn: (payload: string) => void\r\n  ): Promise<{ unlisten: () => Promise<void> }>;\r\n\r\n  /** Send a notification */\r\n  notify(channel: string, payload?: string): Promise<void>;\r\n\r\n  /** Execute COPY FROM STDIN */\r\n  copyFrom(query: string, options?: { \r\n    format?: 'text' | 'csv' | 'binary';\r\n    delimiter?: string;\r\n    null?: string;\r\n    header?: boolean;\r\n  }): NodeJS.WritableStream;\r\n\r\n  /** Execute COPY TO STDOUT */\r\n  copyTo(query: string, options?: {\r\n    format?: 'text' | 'csv' | 'binary';\r\n    delimiter?: string;\r\n    null?: string;\r\n    header?: boolean;\r\n  }): NodeJS.ReadableStream;\r\n\r\n  /** Get query execution statistics */\r\n  stats(): {\r\n    successful: number;\r\n    errored: number;\r\n    connecting: number;\r\n    connected: number;\r\n    ended: number;\r\n    ending: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Reserved connection interface for exclusive use.\r\n */\r\nexport interface PostgresReservedConnection extends PostgresSqlTemplate {\r\n  /** Release the reserved connection back to the pool */\r\n  release(): void;\r\n}\r\n\r\n// =============================================================================\r\n// Main Sql Interface - Equivalent to postgres.Sql<T>\r\n// =============================================================================\r\n\r\n/**\r\n * Main PostgreSQL database interface.\r\n * This is the complete type-equivalent alias for postgres.Sql<T> from the 'postgres' package.\r\n * \r\n * @template T - The default record type for query results\r\n * \r\n * @example\r\n * ```typescript\r\n * // Use as a complete replacement for postgres.Sql<T>\r\n * const sql: PostgresSql<{ id: number; name: string }> = getConnection();\r\n * \r\n * // Execute queries with type safety\r\n * const users = await sql<User>`SELECT * FROM users WHERE active = ${true}`;\r\n * \r\n * // Use transactions\r\n * const result = await sql.begin(async sql => {\r\n *   await sql`INSERT INTO users (name) VALUES (${name})`;\r\n *   return sql<User>`SELECT * FROM users WHERE name = ${name}`;\r\n * });\r\n * \r\n * // Use helpers\r\n * const insertUsers = sql.helpers.insert(['name', 'email']);\r\n * await sql`${insertUsers(userArray)}`;\r\n * ```\r\n */\r\nexport interface PostgresSql<T >\r\n  extends PostgresSqlTemplate<T>,\r\n          PostgresUtilities {\r\n\r\n  // =============================================================================\r\n  // Transaction Management\r\n  // =============================================================================\r\n\r\n  /** Begin a new transaction */\r\n  begin: PostgresTransactionFunction;\r\n\r\n  // =============================================================================\r\n  // Query Helpers\r\n  // =============================================================================\r\n\r\n  /** Helper functions for building complex queries */\r\n  helpers: PostgresHelpers;\r\n\r\n  // =============================================================================\r\n  // Type Management\r\n  // =============================================================================\r\n\r\n  /** Register custom PostgreSQL types */\r\n  types: {\r\n    /** Add a custom type parser */\r\n    setTypeParser<R>(\r\n      oid: number | string,\r\n      parser: (value: string) => R\r\n    ): void;\r\n    \r\n    /** Get the parser for a type */\r\n    getTypeParser(oid: number | string): ((value: string) => unknown) | undefined;\r\n  };\r\n\r\n  // =============================================================================\r\n  // Connection Pool Management\r\n  // =============================================================================\r\n\r\n  /** Current connection pool parameters */\r\n  parameters: Record<string, string>;\r\n\r\n  /** Connection pool options */\r\n  options: PostgresConfig;\r\n\r\n  // =============================================================================\r\n  // Query Building and Execution\r\n  // =============================================================================\r\n\r\n  /** Create a prepared statement */\r\n  prepare<R  = T>(\r\n    name: string,\r\n    query: string,\r\n    types?: number[]\r\n  ): {\r\n    /** Execute the prepared statement */\r\n    <P  = R>(\r\n      ...parameters: PostgresParameterOrFragment[]\r\n    ): PostgresPendingQuery<P>;\r\n  };\r\n\r\n  /** Execute an unsafe query (bypasses escaping) */\r\n  unsafe<R  = T>(\r\n    query: string,\r\n    parameters?: unknown[]\r\n  ): PostgresPendingQuery<R>;\r\n\r\n  // =============================================================================\r\n  // File Operations\r\n  // =============================================================================\r\n\r\n  /** Load and execute SQL from a file */\r\n  file<R  = T>(\r\n    path: string,\r\n    parameters?: PostgresParameterOrFragment[]\r\n  ): PostgresPendingQuery<R>;\r\n\r\n  // =============================================================================\r\n  // Event Handling\r\n  // =============================================================================\r\n\r\n  /** Add event listeners */\r\n  on(event: 'connect', listener: (connection: unknown) => void): this;\r\n  on(event: 'error', listener: (error: PostgresError) => void): this;\r\n  on(event: 'close', listener: () => void): this;\r\n  on(event: 'notice', listener: (notice: PostgresError) => void): this;\r\n  on(event: string, listener: (...args: unknown[]) => void): this;\r\n\r\n  /** Remove event listeners */\r\n  off(event: string, listener: (...args: unknown[]) => void): this;\r\n\r\n  // =============================================================================\r\n  // Additional Utility Properties\r\n  // =============================================================================\r\n\r\n  /** Check if the connection is closed */\r\n  closed: boolean;\r\n\r\n  /** Current number of active connections */\r\n  totalCount: number;\r\n\r\n  /** Number of idle connections */\r\n  idleCount: number;\r\n\r\n  /** Number of connections being created */\r\n  connectingCount: number;\r\n\r\n  /** Current transaction depth */\r\n  transactionDepth?: number;\r\n\r\n  /** Custom properties for extension */\r\n  [key: string]: unknown;\r\n}\r\n\r\n// =============================================================================\r\n// Factory Function Type\r\n// =============================================================================\r\n\r\n/**\r\n * Factory function type for creating PostgreSQL connections.\r\n * Equivalent to the default export from 'postgres' package.\r\n * \r\n * @example\r\n * ```typescript\r\n * const postgres: PostgresFactory = require('postgres');\r\n * const sql = postgres('postgresql://localhost/mydb');\r\n * ```\r\n */\r\nexport interface PostgresFactory {\r\n  /** Create a new PostgreSQL connection */\r\n  <T extends Record<string, unknown> = Record<string, unknown>>(\r\n    connectionString: string,\r\n    options?: PostgresConfig\r\n  ): PostgresSql<T>;\r\n\r\n  /** Create a new PostgreSQL connection with options only */\r\n  <T extends Record<string, unknown> = Record<string, unknown>>(\r\n    options: PostgresConfig\r\n  ): PostgresSql<T>;\r\n}\r\n\r\n// =============================================================================\r\n// Driver Interface for Compatibility\r\n// =============================================================================\r\n\r\n/**\r\n * PostgreSQL driver interface for compatibility with existing code.\r\n * Equivalent to postgres.PgDbDriver from connection utilities.\r\n */\r\nexport interface PostgresDriver<T extends Record<string, unknown> = Record<string, unknown>> {\r\n  /** The underlying SQL interface */\r\n  sql: PostgresSql<T>;\r\n  \r\n  /** Create a new instance */\r\n  getInstance(): Promise<PostgresSql<T>>;\r\n  \r\n  /** Additional driver properties */\r\n  [key: string]: unknown;\r\n}\r\n\r\n// =============================================================================\r\n// Utility Type Exports\r\n// =============================================================================\r\n\r\n/**\r\n * Re-export all types with postgres prefix for clarity and compatibility.\r\n */\r\nexport type {\r\n  PostgresConfig as PostgresOptions,\r\n  PostgresResultMeta as ResultMeta,\r\n  PostgresColumnList as ColumnList,\r\n  PostgresMaybeRow as MaybeRow,\r\n  PostgresRowList as RowList,\r\n  PostgresParameterOrFragment as ParameterOrFragment,\r\n  PostgresFragment as Fragment,\r\n  PostgresHelper as Helper,\r\n  PostgresPendingQuery as PendingQuery,\r\n  PostgresStatement as Statement,\r\n  //PostgresError as PostgresError,\r\n  PostgresTransaction as Transaction,\r\n  //PostgresSql as Sql,\r\n  PostgresFactory as Postgres,\r\n};\r\n\r\n// =============================================================================\r\n// Default Export - Main Type Alias\r\n// =============================================================================\r\n\r\n/**\r\n * Main type alias equivalent to postgres.Sql<T>.\r\n * This is the primary export that can be used as a drop-in replacement.\r\n * \r\n * @template T - The default record type for query results\r\n */\r\nexport type Sql<T extends Record<string, unknown> = Record<string, unknown>> = PostgresSql<T>;\r\n\r\n/**\r\n * Default export - equivalent to postgres default export.\r\n */\r\nexport default PostgresFactory;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\neondb\\types.d.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":72,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2806,2809],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2806,2809],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":72,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2823,2826],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2823,2826],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":73,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2851,2854],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2851,2854],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\neondb\\types.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":6,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[213,216],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[213,216],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":6,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[230,233],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[230,233],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":6,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[253,256],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[253,256],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\client-navigate.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\client-navigate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\fetch.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\get-stack-trace.d.ts","messages":[{"ruleId":"no-jsdoc-in-ts/prefer-function-declarations","severity":1,"message":"Prefer `export function name(...) : ...;` declarations in .d.ts files instead of `export const name: (...) => ...;`.","line":26,"column":16,"nodeType":"VariableDeclarator","endLine":30,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare module '@/lib/nextjs-util/get-stack-trace' {\r\n  /**\r\n   * Retrieves the current stack trace as a string, optionally skipping a specified number of stack frames.\r\n   *\r\n   * @param options - An optional object to configure stack trace retrieval.\r\n   * @param options.skip - The number of stack frames to skip from the top (default is 1).\r\n   * @param options.max - The maximum number of stack frames to include (default is all).\r\n   * @param options.myCodeOnly - If true, filters the stack to include only frames from your code (excluding node_modules) (default is true).\r\n   * @returns The stack trace as a string, with the specified number of frames skipped.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Get current stack trace\r\n   * const stack = getStackTrace();\r\n   *\r\n   * // Skip first 2 frames\r\n   * const stack = getStackTrace({ skip: 2 });\r\n   *\r\n   * // Include all frames (even node_modules)\r\n   * const fullStack = getStackTrace({ myCodeOnly: false });\r\n   *\r\n   * // Limit to 5 frames\r\n   * const limitedStack = getStackTrace({ max: 5 });\r\n   * ```\r\n   */\r\n  export const getStackTrace: (options?: {\r\n    skip?: number;\r\n    max?: number;\r\n    myCodeOnly?: boolean;\r\n  }) => string;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\get-stack-trace.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\guards.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\guards.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\index.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\server\\error-response\\index.d.ts","messages":[{"ruleId":"no-jsdoc-in-ts/prefer-function-declarations","severity":1,"message":"Prefer `export function name(...) : ...;` declarations in .d.ts files instead of `export const name: (...) => ...;`.","line":55,"column":16,"nodeType":"VariableDeclarator","endLine":58,"endColumn":76},{"ruleId":"no-jsdoc-in-ts/prefer-function-declarations","severity":1,"message":"Prefer `export function name(...) : ...;` declarations in .d.ts files instead of `export const name: (...) => ...;`.","line":72,"column":16,"nodeType":"VariableDeclarator","endLine":75,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * error-response\r\n *\r\n * Utilities for producing consistent JSON error responses in Next.js server code.\r\n *\r\n * - Normalizes a wide range of inputs (string, number, Error, Response, options object)\r\n * - Provides a stable Response payload shape\r\n * - Derives sensible defaults and metadata (status, message, cause, source)\r\n *\r\n * For usage examples, see the README:\r\n * - ./docs/lib/nextjs-util/error-response.md\r\n */\r\n\r\ndeclare module '@/lib/nextjs-util/server/error-response/index' {\r\n  /**\r\n   * Options that can be used to influence how an error response is produced.\r\n   *\r\n   * @property cause - The originating error (or any value). If an `Error` is provided and no\r\n   *                   message is present, the message falls back to `cause.message`.\r\n   * @property status - HTTP status code. Defaults to 500 when omitted.\r\n   * @property message - Error message to present to clients.\r\n   * @property source - Optional string indicating the logical source of the error.\r\n   */\r\n  export type ErrorResponseOptions = {\r\n    cause?: unknown;\r\n    status?: number;\r\n    message?: string;\r\n    source?: string;\r\n  };\r\n\r\n  /**\r\n   * Combine two inputs into a normalized error shape.\r\n   *\r\n   * Rules:\r\n   * - Status: prefers explicit numbers, defaults to 500\r\n   * - Message: derives from inputs; if both inputs provide a message, they are combined\r\n   *            as \"message1 - message2\"; falls back to \"An error occurred\"\r\n   * - Cause: if provided, is stringified; `Error` becomes its `.name`\r\n   * - Source: explicit `source`, or extracted from `cause.source` when present\r\n   *\r\n   * @param first - Primary input: string | number | Error | Response | ErrorResponseOptions | unknown\r\n   * @param second - Secondary input with the same accepted types; overrides where present\r\n   * @returns Normalized `{ status, message, cause?, source? }`\r\n   *\r\n   * @example\r\n   * parseResponseOptions('Auth failed', { status: 401, source: 'auth' })\r\n   * // => { status: 401, message: 'Auth failed', source: 'auth' }\r\n   *\r\n   * @example\r\n   * parseResponseOptions(new Error('Boom'), 'Custom')\r\n   * // => { status: 500, message: 'Boom - Custom', cause: 'Error' }\r\n   *\r\n   * For more end-to-end examples, see {@link ./README.md}.\r\n   */\r\n  export const parseResponseOptions: (\r\n    first?: unknown,\r\n    second?: unknown,\r\n  ) => { status: number; message: string; cause?: string; source?: string };\r\n\r\n  /**\r\n   * Create a errorResponseFactory.\r\n   *\r\n   * @param statusOrError - A flexible input: string | number | Error | Response | ErrorResponseOptions | unknown\r\n   * @param messageOrOptions - Optional second input of the same accepted types; values override the first\r\n   *\r\n   * ### Behavior\r\n   * - If `statusOrError` is a number, it is used as the HTTP status code.\r\n   * - If `statusOrError` is a `Response`, its status and statusText are used.\r\n   * - If `statusOrError` is an Error (as determined by `isError`), its message is used.\r\n   * - Otherwise, defaults to status 500 and a generic error message.\r\n   */\r\n  export const errorResponseFactory: (\r\n    statusOrError?: unknown,\r\n    messageOrOptions?: unknown,\r\n  ) => Response;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\server\\error-response\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\server\\index.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\server\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\server\\types.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\server\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":6,"column":1,"nodeType":"Program","endLine":7,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * A type alias that represents a server error response in a Next.js application.\r\n *\r\n * @type {ServerErrorResponseType} ServerErrorResponse\r\n */\r\nexport type ServerErrorResponseType = Response;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\server\\utils.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\server\\utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\types.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\utils.d.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":112,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4401,4404],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4401,4404],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":112,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4411,4414],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4411,4414],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\nextjs-util\\utils.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1669,1672],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1669,1672],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1679,1682],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1679,1682],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\__mocks__\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":7,"column":1,"nodeType":"Program","endLine":15,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module react-util\r\n *\r\n * This module serves as a mock for the react-util module to be used in Jest tests.\r\n */\r\n\r\nconst generateUniqueId = jest\r\n  .fn()\r\n  .mockImplementation(() => `unique-id-${generateUniqueId.mock.calls.length}`);\r\n\r\nmodule.exports = {\r\n  ...jest.createMockFromModule('fs'),\r\n  generateUniqueId,\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\client.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":7,"column":1,"nodeType":"Program","endLine":10,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module react-util/client\r\n *\r\n * This module serves as a central point to access various client-centric utility functions used\r\n * across the React application.\r\n */\r\nexport * from './utility-methods';\r\nexport * from './errors';\r\nexport * from './hooks';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\core.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\core.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\debounce.d.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[343,346],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[343,346],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":52,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2186,2189],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2186,2189],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\debounce.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":6,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[248,251],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[248,251],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\errors\\aggregate-error.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\errors\\aggregate-error.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\errors\\data-integrity-error.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":4,"column":1,"nodeType":"Program","endLine":103,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * A unique symbol used to brand the `DataIntegrityError` class instances.\r\n */\r\nconst brandDataIntegrityError: symbol = Symbol('DataIntegrityError');\r\n\r\n/**\r\n * Options for specifying details about a validation error.\r\n *\r\n * @property {string} [table] - The name of the table that caused the validation error.\r\n * @property {unknown} [id] - The id of the record value that is missing or invalid, if known.\r\n * @property {string} [source] - The source of the validation error, such as the function or module where it occurred.\r\n */\r\nexport type DataIntegrityErrorOptions = ErrorOptions & {\r\n  table?: string;\r\n  id?: unknown;\r\n  source?: string;\r\n};\r\n\r\nexport class DataIntegrityError extends Error {\r\n  /**\r\n   * Checks if the given error is an instance of `ValidationError`.\r\n   *\r\n   * @param {unknown} e - The error to check.\r\n   * @returns {boolean} `true` if the error is an instance of `ValidationError`, otherwise `false`.\r\n   */\r\n  static isDataIntegrityError(e: unknown): e is DataIntegrityError {\r\n    return (\r\n      typeof e === 'object' &&\r\n      e !== null &&\r\n      'cause' in e &&\r\n      (e as DataIntegrityError).cause === brandDataIntegrityError\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Builds a DataIntegrity error message from the given options.\r\n   *\r\n   * @param {DataIntegrityErrorOptions} options - The options to build the message from.\r\n   * @returns {string} The constructed DataIntegrity error message.\r\n   */\r\n  static buildMessage(options: DataIntegrityErrorOptions): string {\r\n    const { table, source } = options;\r\n    return [\r\n      table ? `Table '${table}'` : 'DataIntegrity error',\r\n      source ? `Source: ${source}` : '',\r\n    ]\r\n      .filter(Boolean)\r\n      .join(' ');\r\n  }\r\n\r\n  #table: string;\r\n  #source: string;\r\n  [Symbol.toStringTag]: string = 'DataIntegrityError';\r\n  /**\r\n   * Constructs a new instance of `DataIntegrityError`.\r\n   *\r\n   * @param {string | DataIntegrityErrorOptions} message - The error message or options to build the message from.\r\n   * @param {DataIntegrityErrorOptions} [options] - Additional options for the DataIntegrity error.\r\n   */\r\n  constructor(\r\n    message: string | DataIntegrityErrorOptions,\r\n    options?: DataIntegrityErrorOptions\r\n  ) {\r\n    super(\r\n      typeof message === 'string'\r\n        ? message\r\n        : DataIntegrityError.buildMessage(message),\r\n      { cause: brandDataIntegrityError }\r\n    );\r\n    this.name = 'DataIntegrityError';\r\n    this.#table = options?.table ?? '';\r\n    this.#source = options?.source ?? '';\r\n    this[Symbol.toStringTag] = this.message;\r\n  }\r\n\r\n  /**\r\n   * Gets the field associated with the DataIntegrity error.\r\n   *\r\n   * @returns {string} The field associated with the DataIntegrity error.\r\n   */\r\n  get table(): string {\r\n    return this.#table;\r\n  }\r\n  /**\r\n   * Gets the source of the DataIntegrity error.\r\n   *\r\n   * @returns {string} The source of the DataIntegrity error.\r\n   */\r\n  get source(): string {\r\n    return this.#source;\r\n  }\r\n\r\n  /**\r\n   * Gets the error message associated with the DataIntegrity error.\r\n   *\r\n   * @returns {string} The error message associated with the DataIntegrity error.\r\n   */\r\n  get message(): string {\r\n    const ret = super.message;\r\n    return ret ?? `Data Integrity issue detected on table ${this.#table}`;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\errors\\error-like.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\errors\\error-like.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\errors\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\errors\\logged-error-reporter\\client.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":31,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { ErrorReporterInterface } from '@/lib/error-monitoring/types';\r\nimport { ErrorReporter } from '@/lib/error-monitoring/error-reporter';\r\n\r\n/**\r\n * Provides access to the shared ErrorReporter instance used by LoggedError.\r\n *\r\n * Usage: LoggedErrorReported.Instance.reportError({...})\r\n */\r\nclass LoggedErrorReporter {\r\n  static #instance: ErrorReporterInterface | undefined;\r\n  static get Instance(): ErrorReporterInterface {\r\n    if (!LoggedErrorReporter.#instance) {\r\n      LoggedErrorReporter.#instance = ErrorReporter.createInstance({\r\n        enableStandardLogging: true,\r\n        enableConsoleLogging: true,\r\n        enableExternalReporting: true,\r\n        enableLocalStorage: true,\r\n      });\r\n    }\r\n    if (!LoggedErrorReporter.#instance) {\r\n      throw new TypeError(\r\n        'Failed to initialize LoggedErrorReporter - telemetry error tracking will not work',\r\n      );\r\n    }\r\n    return LoggedErrorReporter.#instance;\r\n  }\r\n}\r\nexport const clientReporter = (): ErrorReporterInterface => {\r\n  return LoggedErrorReporter.Instance;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\errors\\logged-error-reporter\\edge.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":44,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { ErrorReporterInterface } from '@/lib/error-monitoring/types';\r\nimport { log } from '@/lib/logger';\r\n\r\n/**\r\n * Provides access to the shared ErrorReporter instance used by LoggedError.\r\n *\r\n * Usage: LoggedErrorReported.Instance.reportError({...})\r\n */\r\nclass LoggedErrorReporter {\r\n  static #instance: ErrorReporterInterface | undefined;\r\n  static get Instance(): ErrorReporterInterface {\r\n    if (!LoggedErrorReporter.#instance) {\r\n      const mockReport = (error: unknown) => {\r\n        log((l) =>\r\n          l.error({\r\n            message: 'An error occurred',\r\n            error,\r\n            source: 'Edge Error Reporter instance',\r\n          }),\r\n        );\r\n        return Promise.resolve();\r\n      };\r\n\r\n      LoggedErrorReporter.#instance = {\r\n        reportError: mockReport,\r\n        reportBoundaryError: mockReport,\r\n        reportUnhandledRejection: mockReport,\r\n        setupGlobalHandlers: () => {},\r\n        getStoredErrors: () => [],\r\n        clearStoredErrors: () => {},\r\n      };\r\n    }\r\n    if (!LoggedErrorReporter.#instance) {\r\n      throw new TypeError(\r\n        'Failed to initialize LoggedErrorReporter - telemetry error tracking will not work',\r\n      );\r\n    }\r\n    return LoggedErrorReporter.#instance;\r\n  }\r\n}\r\nexport const edgeReporter = (): ErrorReporterInterface => {\r\n  return LoggedErrorReporter.Instance;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\errors\\logged-error-reporter\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\errors\\logged-error-reporter\\server.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":31,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { ErrorReporterInterface } from '@/lib/error-monitoring/types';\r\nimport { ErrorReporter } from '@/lib/error-monitoring/error-reporter';\r\n\r\n/**\r\n * Provides access to the shared ErrorReporter instance used by LoggedError.\r\n *\r\n * Usage: LoggedErrorReported.Instance.reportError({...})\r\n */\r\nclass LoggedErrorReporter {\r\n  static #instance: ErrorReporterInterface | undefined;\r\n  static get Instance(): ErrorReporterInterface {\r\n    if (!LoggedErrorReporter.#instance) {\r\n      LoggedErrorReporter.#instance = ErrorReporter.createInstance({\r\n        enableStandardLogging: true,\r\n        enableConsoleLogging: false,\r\n        enableExternalReporting: true,\r\n        enableLocalStorage: false,\r\n      });\r\n    }\r\n    if (!LoggedErrorReporter.#instance) {\r\n      throw new TypeError(\r\n        'Failed to initialize LoggedErrorReporter - telemetry error tracking will not work',\r\n      );\r\n    }\r\n    return LoggedErrorReporter.#instance;\r\n  }\r\n}\r\nexport const serverReporter = (): ErrorReporterInterface => {\r\n  return LoggedErrorReporter.Instance;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\errors\\logged-error\\index.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\errors\\logged-error\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\errors\\logged-error\\logged-error-class.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":4,"column":1,"nodeType":"Program","endLine":302,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Documentation is authoritative in: lib/react-util/errors/logged-error.d.ts\r\n// The runtime implementation remains here. Keep implementation edits minimal.\r\n\r\nimport { errorLogFactory, log } from '@/lib/logger';\r\nimport {\r\n  isAbortError,\r\n  isError,\r\n  isProgressEvent,\r\n} from './../../utility-methods';\r\nimport { getStackTrace } from '@/lib/nextjs-util/get-stack-trace';\r\nimport { asKnownSeverityLevel } from '@/lib/logger/constants';\r\nimport { reporter } from './../logged-error-reporter';\r\nimport { TurtleRecursionParams, LoggedErrorOptions } from './types';\r\nimport { ProgressEventError } from '../progress-event-error';\r\n\r\n/**\r\n * A unique symbol used to brand `LoggedError` class instances for runtime type checking.\r\n *\r\n * This symbol ensures that `LoggedError` instances can be reliably identified even\r\n * across different JavaScript execution contexts or when serialized/deserialized.\r\n *\r\n * @private\r\n * @readonly\r\n */\r\nconst brandLoggedError = Symbol.for('@no-education/LoggedError');\r\n/**\r\n * The underlying Error object that this LoggedError wraps.\r\n *\r\n * This contains the original error information including message, stack trace,\r\n * and other properties. The LoggedError acts as a proxy to this underlying error\r\n * while adding enhanced functionality.\r\n *\r\n * @private\r\n * @readonly\r\n */\r\nconst INNER_ERROR = Symbol.for('@no-education/LoggedError::InnerError');\r\n/**\r\n * Whether this error is classified as critical.\r\n *\r\n * Critical errors indicate serious system failures that may require immediate\r\n * attention, alerting, or special handling procedures. Non-critical errors\r\n * are typically logged but don't trigger emergency responses.\r\n *\r\n * @private\r\n * @readonly\r\n */\r\nconst CRITICAL = Symbol.for('@no-education/LoggedError::CriticalFlag');\r\n\r\n// LoggedError class implementation.  Type and extensive documentation in .d.ts.\r\nexport class LoggedError implements Error {\r\n  // Type guard to check if an object is a LoggedError instance.\r\n  static isLoggedError(e: unknown): e is LoggedError {\r\n    return (\r\n      e instanceof LoggedError ||\r\n      (typeof e === 'object' &&\r\n        !!e &&\r\n        brandLoggedError in e &&\r\n        e[brandLoggedError] === true)\r\n    );\r\n  }\r\n\r\n  // Recursively unwraps nested errors and ensures the result is a LoggedError.\r\n  static isTurtlesAllTheWayDownBaby(\r\n    e: unknown,\r\n    {\r\n      log: shouldLog = false,\r\n      relog = false,\r\n      logCanceledOperation = false,\r\n      source = 'Turtles, baby',\r\n      message,\r\n      critical,\r\n      ...itsRecusionMan\r\n    }: TurtleRecursionParams = { log: false },\r\n  ): LoggedError {\r\n    if (\r\n      arguments.length === 1 &&\r\n      typeof e === 'object' &&\r\n      e !== null &&\r\n      'error' in e &&\r\n      isError(e.error) &&\r\n      ('critical' in e || 'log' in e || 'source' in e)\r\n    ) {\r\n      // We've been passed a composite error object...extract error and try again\r\n      const { error: theError, ...allTheRest } = e;\r\n      return LoggedError.isTurtlesAllTheWayDownBaby(\r\n        theError,\r\n        allTheRest as TurtleRecursionParams,\r\n      );\r\n    }\r\n    const isLoggedError = LoggedError.isLoggedError(e);\r\n    if (shouldLog && (!isLoggedError || relog !== true)) {\r\n      if (!isError(e)) {\r\n        // Some dependencies will throw a ProgressEvent instead of an errror\r\n        if (isProgressEvent(e)) {\r\n          return LoggedError.isTurtlesAllTheWayDownBaby(\r\n            new ProgressEventError(e),\r\n            {\r\n              log: shouldLog,\r\n              relog,\r\n              logCanceledOperation,\r\n              source,\r\n              message,\r\n              critical,\r\n              ...itsRecusionMan,\r\n            },\r\n          );\r\n        } else {\r\n          log((l) =>\r\n            l.warn({ message: 'Some bonehead threw a not-error', error: e }),\r\n          );\r\n          debugger;\r\n        }\r\n      }\r\n      if (logCanceledOperation || !isAbortError(e)) {\r\n        const logObject = errorLogFactory({\r\n          error: e,\r\n          source,\r\n          message,\r\n          ...itsRecusionMan,\r\n        });\r\n        reporter()\r\n          .then((instance) => {\r\n            instance.reportError({\r\n              error: e,\r\n              severity: asKnownSeverityLevel(logObject.severity),\r\n              context: {\r\n                source,\r\n                message,\r\n                stack: getStackTrace({ skip: 2 }),\r\n                ...itsRecusionMan,\r\n              },\r\n            });\r\n          })\r\n          .catch((fail) => {\r\n            log((l) => l.error('Failed to report error', { error: fail }));\r\n          });\r\n      }\r\n    }\r\n    if (isLoggedError) {\r\n      return e;\r\n    }\r\n    return isError(e)\r\n      ? new LoggedError(e, { critical })\r\n      : new LoggedError(new Error(String(e)));\r\n  }\r\n\r\n  // Builds a descriptive message from various input types, handling recursion and cycles.\r\n  static buildMessage(options: unknown, visited?: Set<unknown>): string {\r\n    if (!options) {\r\n      return 'null or undefined error';\r\n    }\r\n    if (isError(options)) {\r\n      return options.message;\r\n    }\r\n    if (typeof options === 'object' && options !== null && 'error' in options) {\r\n      if (!visited) {\r\n        visited = new Set();\r\n      }\r\n      if (visited.has(options)) {\r\n        return '[circular error reference]';\r\n      }\r\n      visited.add(options);\r\n      return this.buildMessage(options.error as unknown, visited);\r\n    }\r\n    return options.toString();\r\n  }\r\n\r\n  // Customizes the string tag for better identification in logs and debuggers.\r\n  public get [Symbol.toStringTag](): string {\r\n    const getWithFallback = (propName: string | symbol) => {\r\n      const valueWithFallback =\r\n        (propName in this\r\n          ? (this as Record<string | symbol, unknown>)[propName]\r\n          : undefined) ??\r\n        (this[INNER_ERROR] && propName in this[INNER_ERROR]\r\n          ? this[INNER_ERROR][propName as keyof Error]\r\n          : undefined) ??\r\n        undefined;\r\n      return valueWithFallback ? String(valueWithFallback) : undefined;\r\n    };\r\n    const _fingerprintValue = getWithFallback('fingerprint');\r\n    const _sourceValue = getWithFallback('source');\r\n\r\n    return `LoggedError${\r\n      _fingerprintValue ? ` (Fingerprint: ${_fingerprintValue}) ` : ''\r\n    }${_sourceValue ? ` [Source: ${_sourceValue}] ` : ''}: ${\r\n      this[CRITICAL] ? 'CRITICAL - ' : ''\r\n    }${LoggedError.buildMessage(this)}`;\r\n  }\r\n\r\n  // Constructor overloads to handle various input scenarios.\r\n  constructor(\r\n    message: string | LoggedErrorOptions | Error,\r\n    options?:\r\n      | (Omit<LoggedErrorOptions, 'error'> &\r\n          Partial<Pick<LoggedErrorOptions, 'error'>>)\r\n      | Error,\r\n  ) {\r\n    let ops: LoggedErrorOptions;\r\n    if (typeof message === 'string') {\r\n      if (options) {\r\n        if (isError(options)) {\r\n          ops = { error: options, critical: true };\r\n        } else if (options.error) {\r\n          ops = options as LoggedErrorOptions;\r\n        } else {\r\n          throw new TypeError(\"LoggedError requires an 'error' property\");\r\n        }\r\n      } else {\r\n        ops = { error: new Error(message), critical: true };\r\n      }\r\n    } else {\r\n      ops = isError(message) ? { error: message, critical: true } : message;\r\n    }\r\n    this[INNER_ERROR] = ops.error;\r\n    this[CRITICAL] = ops.critical ?? true;\r\n\r\n    if (!this[INNER_ERROR]) {\r\n      throw new TypeError(\"LoggedError requires an 'error' property\");\r\n    }\r\n    Object.entries(this[INNER_ERROR]).forEach(([key, value]) => {\r\n      if (!(key in this) && typeof value !== 'function') {\r\n        if (typeof key === 'string' || typeof key === 'symbol') {\r\n          this[key as string | symbol] = value;\r\n        }\r\n      }\r\n    });\r\n    if (\r\n      isError(this[INNER_ERROR].cause) &&\r\n      this[INNER_ERROR].cause.name === 'PostgresError'\r\n    ) {\r\n      Object.entries(this[INNER_ERROR]).forEach(([key, value]) => {\r\n        if (!(key in this) && !!value && typeof value !== 'function') {\r\n          if (typeof key === 'string' || typeof key === 'symbol') {\r\n            if (!this[key as string | symbol]) {\r\n              this[key as string | symbol] = value;\r\n            }\r\n          }\r\n        }\r\n      });\r\n    }\r\n    this[brandLoggedError] = true;\r\n  }\r\n\r\n  // Private properties to store error details and metadata.\r\n  [CRITICAL]: boolean = true;\r\n  // The original error being wrapped.\r\n  [INNER_ERROR]: Error;\r\n  // Branding symbol to identify instances of LoggedError.\r\n  [brandLoggedError] = true;\r\n  // Allow dynamic properties from the inner error to be accessible on this instance.\r\n  [key: string | symbol]: unknown;\r\n  // Proxy properties to access underlying error details.\r\n  get error(): Error {\r\n    return this[INNER_ERROR]!;\r\n  }\r\n  // Indicates if the error is critical.\r\n  get critical(): boolean {\r\n    return this[CRITICAL];\r\n  }\r\n  // Proxy standard Error properties to the inner error.\r\n  get name(): string {\r\n    const ret = this[INNER_ERROR]?.name;\r\n    if (\r\n      ret === 'Error' &&\r\n      this[INNER_ERROR]?.cause &&\r\n      isError(this[INNER_ERROR].cause) &&\r\n      this[INNER_ERROR].cause.name === 'PostgresError'\r\n    ) {\r\n      return this[INNER_ERROR].cause.name;\r\n    }\r\n    return this[INNER_ERROR]?.name ?? 'Error';\r\n  }\r\n  // The cause of the error, if any.\r\n  get cause() {\r\n    return this[INNER_ERROR].cause;\r\n  }\r\n  // The stack trace of the error.\r\n  get stack(): string {\r\n    return this[INNER_ERROR].stack ?? 'no stack trace available';\r\n  }\r\n  // The error message.\r\n  get message(): string {\r\n    return this[INNER_ERROR]?.message ?? 'LoggedError: Missing logged error.';\r\n  }\r\n}\r\n// Utility function to recursively dump error details for logging.\r\nexport const dumpError = (e: unknown): string => {\r\n  let ret = '';\r\n  if (isError(e)) {\r\n    ret = e.message ?? 'no message';\r\n    if (e.cause) {\r\n      ret += `\\nCaused by: ${dumpError(e.cause)}`;\r\n    }\r\n  } else if (typeof e === 'object' && e !== null) {\r\n    ret = JSON.stringify(e, null, 5);\r\n  } else {\r\n    ret = String(e);\r\n  }\r\n  return ret;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\errors\\logged-error\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\errors\\next-console-error.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":27,"column":1,"nodeType":"Program","endLine":70,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file next-console-error.ts\r\n * @description\r\n *   Utilities for identifying and working with Next.js console errors in a type-safe way.\r\n *   Next.js attaches special symbols to error objects that are logged to the console, allowing\r\n *   for programmatic detection and handling of these errors. This module provides types and a\r\n *   type guard for working with these errors in React/Next.js applications.\r\n *\r\n * @example\r\n *   import { isConsoleError } from '@/lib/react-util/errors/next-console-error';\r\n *\r\n *   try {\r\n *     // ...some code that may throw...\r\n *   } catch (err) {\r\n *     if (isConsoleError(err)) {\r\n *       // Handle Next.js console error specifically\r\n *       console.warn('Next.js Console Error:', err[nextDigestSymbol], err[nextConsoleErrorType]);\r\n *     }\r\n *   }\r\n *\r\n * @exports\r\n *   - NextConsoleErrorType: Type union for Next.js console error levels\r\n *   - NextConsoleError: Type for errors with Next.js console error symbols\r\n *   - isConsoleError: Type guard for detecting Next.js console errors\r\n */\r\n\r\nconst nextDigestSymbol = Symbol.for('next.console.error.digest');\r\nconst nextConsoleErrorType = Symbol.for('next.console.error.type');\r\n\r\n/**\r\n * Represents the possible types of console messages in a Next.js application.\r\n *\r\n * - `'error'`: Indicates an error message.\r\n * - `'warning'`: Indicates a warning message.\r\n * - `'info'`: Indicates an informational message.\r\n * - `'log'`: Indicates a general log message.\r\n */\r\nexport type NextConsoleErrorType = 'error' | 'warning' | 'info' | 'log';\r\n\r\n/**\r\n * Represents an enhanced Error object used in Next.js for console error handling.\r\n *\r\n * @remarks\r\n * This type extends the standard `Error` object with additional properties specific to Next.js error reporting.\r\n *\r\n * @property {string} [nextDigestSymbol] - A unique digest string associated with the error, used for error tracking and identification.\r\n * @property {string} environmentName - The name of the environment in which the error occurred (e.g., \"production\", \"development\").\r\n * @property {NextConsoleErrorType} [nextConsoleErrorType] - The type of the console error, providing additional context about the error's origin or category.\r\n */\r\nexport type NextConsoleError = Error & {\r\n  [nextDigestSymbol]: string;\r\n  [nextConsoleErrorType]?: NextConsoleErrorType;\r\n  environmentName?: string;\r\n};\r\n\r\n/**\r\n * Determines whether the provided error object is a {@link NextConsoleError}.\r\n *\r\n * Checks if the error is a non-null object, contains the `nextDigestSymbol` property,\r\n * and that the value of this property is `'NEXT_CONSOLE_ERROR'`.\r\n *\r\n * @param error - The value to check.\r\n * @returns `true` if the error is a `NextConsoleError`, otherwise `false`.\r\n */\r\nexport const isConsoleError = (error: unknown): error is NextConsoleError =>\r\n  typeof error === 'object' &&\r\n  !!error &&\r\n  nextDigestSymbol in error &&\r\n  error[nextDigestSymbol] === 'NEXT_CONSOLE_ERROR';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\errors\\progress-event-error.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\errors\\progress-event-error.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\errors\\rate-retry-error.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\errors\\validation-error.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":42,"column":1,"nodeType":"Program","endLine":176,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module ValidationError\r\n *\r\n * This module provides a `ValidationError` class that extends the built-in `Error` class to represent errors that occur during data validation.\r\n * It includes options for specifying details about the validation error, such as the field that caused the error, the value that failed validation,\r\n * the expected value or condition, a human-readable explanation of the failure, and the source of the error.\r\n *\r\n * The module also provides utility methods to check if an error is an instance of `ValidationError` and to build a validation error message from the given options.\r\n *\r\n * @example\r\n * ```typescript\r\n * import { ValidationError, ValidationErrorOptions } from './validation-error';\r\n *\r\n * const options: ValidationErrorOptions = {\r\n *   field: 'username',\r\n *   value: 'invalid_user',\r\n *   expected: 'a valid username',\r\n *   reason: 'Username contains invalid characters',\r\n *   source: 'UserValidator'\r\n * };\r\n *\r\n * const error = new ValidationError(options);\r\n *\r\n * if (ValidationError.isValidationError(error)) {\r\n *   console.error(error.message);\r\n * }\r\n * ```\r\n * @example\r\n * ```typescript\r\n *\r\n * const error = new ValidationError('Username contains invalid characters');\r\n *\r\n * if (ValidationError.isValidationError(error)) {\r\n *   console.error(error.message);\r\n * }\r\n * ```\r\n */\r\n\r\n/**\r\n * A unique symbol used to brand the `ValidationError` class instances.\r\n */\r\nconst brandValidationError: symbol = Symbol('ValidationError');\r\n\r\n/**\r\n * Options for specifying details about a validation error.\r\n *\r\n * @property {string} [field] - The name of the field that caused the validation error.\r\n * @property {unknown} [value] - The value that failed validation.\r\n * @property {unknown} [expected] - The expected value or condition that the value failed to meet.\r\n * @property {string} [reason] - A human-readable explanation of why the validation failed.\r\n * @property {string} [source] - The source of the validation error, such as the function or module where it occurred.\r\n */\r\nexport type ValidationErrorOptions = {\r\n  field?: string;\r\n  value?: unknown;\r\n  expected?: unknown;\r\n  reason?: string;\r\n  source?: string;\r\n};\r\n\r\n/**\r\n * Represents a validation error that occurs during data validation.\r\n * Extends the built-in `Error` class.\r\n */\r\nexport class ValidationError extends Error {\r\n  /**\r\n   * Checks if the given error is an instance of `ValidationError`.\r\n   *\r\n   * @param {unknown} e - The error to check.\r\n   * @returns {boolean} `true` if the error is an instance of `ValidationError`, otherwise `false`.\r\n   */\r\n  static isValidationError(e: unknown): e is ValidationError {\r\n    return (\r\n      typeof e === 'object' &&\r\n      e !== null &&\r\n      'cause' in e &&\r\n      (e as ValidationError).cause === brandValidationError\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Builds a validation error message from the given options.\r\n   *\r\n   * @param {ValidationErrorOptions} options - The options to build the message from.\r\n   * @returns {string} The constructed validation error message.\r\n   */\r\n  static buildMessage(options: ValidationErrorOptions): string {\r\n    const { field, value, expected, reason, source } = options;\r\n    return [\r\n      field ? `Field '${field}'` : 'Validation error',\r\n      value ? `Value: ${JSON.stringify(value)}` : '',\r\n      expected ? `Expected: ${JSON.stringify(expected)}` : '',\r\n      reason ? `Reason: ${reason}` : '',\r\n      source ? `Source: ${source}` : '',\r\n    ]\r\n      .filter(Boolean)\r\n      .join(' ');\r\n  }\r\n\r\n  #field: string;\r\n  #value: unknown;\r\n  #expected: unknown;\r\n  #reason: string;\r\n  #source: string;\r\n  [Symbol.toStringTag]: string = 'ValidationError';\r\n  /**\r\n   * Constructs a new instance of `ValidationError`.\r\n   *\r\n   * @param {string | ValidationErrorOptions} message - The error message or options to build the message from.\r\n   * @param {ValidationErrorOptions} [options] - Additional options for the validation error.\r\n   */\r\n  constructor(\r\n    message: string | ValidationErrorOptions,\r\n    options?: ValidationErrorOptions\r\n  ) {\r\n    super(\r\n      typeof message === 'string'\r\n        ? message\r\n        : ValidationError.buildMessage(message),\r\n      { cause: brandValidationError }\r\n    );\r\n    this.name = 'ValidationError';\r\n    this.#field = options?.field ?? '';\r\n    this.#value = options?.value ?? '';\r\n    this.#expected = options?.expected ?? '';\r\n    this.#reason = options?.reason ?? '';\r\n    this.#source = options?.source ?? '';\r\n    this[Symbol.toStringTag] = this.message;\r\n  }\r\n\r\n  /**\r\n   * Gets the field associated with the validation error.\r\n   *\r\n   * @returns {string} The field associated with the validation error.\r\n   */\r\n  get field(): string {\r\n    return this.#field;\r\n  }\r\n\r\n  /**\r\n   * Gets the value that caused the validation error.\r\n   *\r\n   * @returns {unknown} The value that caused the validation error.\r\n   */\r\n  get value(): unknown {\r\n    return this.#value;\r\n  }\r\n\r\n  /**\r\n   * Gets the expected value for the validation.\r\n   *\r\n   * @returns {unknown} The expected value for the validation.\r\n   */\r\n  get expected(): unknown {\r\n    return this.#expected;\r\n  }\r\n\r\n  /**\r\n   * Gets the reason for the validation error.\r\n   *\r\n   * @returns {string} The reason for the validation error.\r\n   */\r\n  get reason(): string {\r\n    return this.#reason;\r\n  }\r\n\r\n  /**\r\n   * Gets the source of the validation error.\r\n   *\r\n   * @returns {string} The source of the validation error.\r\n   */\r\n  get source(): string {\r\n    return this.#source;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\hooks\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\hooks\\use-dynamic-width.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":42,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { useState, useEffect } from 'react';\r\n\r\n/**\r\n * React hook that returns the current width of a referenced container element.\r\n *\r\n * This hook uses a `ResizeObserver` to monitor changes to the width of the element\r\n * referenced by `containerRef`. Whenever the width changes, the hook updates its state\r\n * and returns the new width. The initial width is set to 400.\r\n *\r\n * @param containerRef - A React ref object pointing to an HTMLElement (or null).\r\n * @returns The current width of the referenced container element.\r\n *\r\n * @example\r\n * const containerRef = useRef<HTMLDivElement>(null);\r\n * const width = useDynamicWidth(containerRef);\r\n */\r\nexport const useDynamicWidth = (\r\n  containerRef: React.RefObject<HTMLElement | null>,\r\n) => {\r\n  const [containerWidth, setContainerWidth] = useState(400);\r\n\r\n  useEffect(() => {\r\n    if (!containerRef.current) return;\r\n\r\n    const resizeObserver = new ResizeObserver((entries) => {\r\n      for (const entry of entries) {\r\n        setContainerWidth(entry.contentRect.width);\r\n      }\r\n    });\r\n\r\n    resizeObserver.observe(containerRef.current);\r\n\r\n    return () => {\r\n      resizeObserver.disconnect();\r\n    };\r\n  }, [containerRef]);\r\n\r\n  return containerWidth;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\hooks\\useInEffect.d.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[800,803],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[800,803],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\hooks\\useInEffect.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":145,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":145,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5639,5642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5639,5642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":7,"column":1,"nodeType":"Program","endLine":10,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module react-util\r\n *\r\n * This module serves as a central point to access various utility functions used\r\n * across the React application.\r\n */\r\nexport * from './utility-methods';\r\nexport * from './errors';\r\nexport * from './hooks';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\simple-circuit-breaker.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\simple-circuit-breaker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\simple-rate-limiter.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\simple-rate-limiter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\url.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\url.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\utility-methods.d.ts","messages":[{"ruleId":"no-jsdoc-in-ts/prefer-function-declarations","severity":1,"message":"Prefer `export function name(...) : ...;` declarations in .d.ts files instead of `export const name: (...) => ...;`.","line":100,"column":16,"nodeType":"VariableDeclarator","endLine":103,"endColumn":24},{"ruleId":"no-jsdoc-in-ts/prefer-function-declarations","severity":1,"message":"Prefer `export function name(...) : ...;` declarations in .d.ts files instead of `export const name: (...) => ...;`.","line":121,"column":16,"nodeType":"VariableDeclarator","endLine":124,"endColumn":44}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview A collection of utility methods for use in React applications.\r\n * @module _utility-methods\r\n */\r\n\r\ndeclare module 'lib/react-util/utility-methods' {\r\n  /**\r\n   * Generates a unique identifier string.\r\n   *\r\n   * @returns {string} A unique identifier consisting of 7 alpha-numeric characters.\r\n   */\r\n  export function generateUniqueId(): string;\r\n\r\n  /**\r\n   * Checks if the given value is an instance of the Error object.\r\n   *\r\n   * @param value - The value to check.\r\n   * @returns True if the value is an Error object, otherwise false.\r\n   */\r\n  export function isError(value: unknown): value is Error;\r\n\r\n  /**\r\n   * Checks if the given value is a DOMException with the name 'AbortError'.\r\n   *\r\n   * @param value - The value to check.\r\n   * @returns True if the value is a DOMException with the name 'AbortError', otherwise false.\r\n   */\r\n  export function isAbortError(value: unknown): value is Error;\r\n\r\n  /**\r\n   * Type guard to check if a value is an XMLHttpRequest.\r\n   * It checks for key properties and methods typical of XMLHttpRequest instances,\r\n   * and infers the type accordingly.\r\n   * @param value - The value to check.\r\n   * @returns True if the value is an XMLHttpRequest, false otherwise.\r\n   */\r\n  export function isXmlHttpRequest(value: unknown): value is XMLHttpRequest;\r\n\r\n  /**\r\n   * Type guard to check if a value is a ProgressEvent from an XMLHttpRequest.\r\n   * This is useful for distinguishing progress events in AJAX requests, which are thrown\r\n   * as errors in some contexts (e.g., Fetch API polyfills).\r\n   * @param value - The value to check.\r\n   * @returns True if the value is a ProgressEvent from an XMLHttpRequest, otherwise false.\r\n   *\r\n   */\r\n  export function isProgressEvent(\r\n    value: unknown,\r\n  ): value is ProgressEvent<XMLHttpRequest>;\r\n\r\n  /**\r\n   * Type guard to check if a value is a TemplateStringsArray.\r\n   *\r\n   * @param value - The value to check.\r\n   * @returns True if the value is a TemplateStringsArray, false otherwise.\r\n   */\r\n  export function isTemplateStringsArray(\r\n    value: unknown,\r\n  ): value is TemplateStringsArray;\r\n\r\n  /**\r\n   * Determines if a given value is truthy.\r\n   *\r\n   * This function evaluates the provided value and returns a boolean indicating\r\n   * whether the value is considered \"truthy\". If the value is `undefined` or `null`,\r\n   * the function returns the specified default value.\r\n   *\r\n   * For string values, the function considers the following strings as truthy:\r\n   * - \"true\"\r\n   * - \"1\"\r\n   * - \"yes\"\r\n   * (case insensitive and trimmed)\r\n   *\r\n   * @param value - The value to evaluate.\r\n   * @param defaultValue - The default boolean value to return if the value is `undefined` or `null`. Defaults to `false`.\r\n   * @returns `true` if the value is considered truthy, otherwise `false`.\r\n   */\r\n  export function isTruthy(value: unknown, defaultValue?: boolean): boolean;\r\n\r\n  /**\r\n   * Checks if the given value is an indexable record (aka object)\r\n   *\r\n   * @param check - The value to check.\r\n   * @returns True if the value is an object, otherwise false.\r\n   */\r\n  export function isRecord(check: unknown): check is Record<string, unknown>;\r\n\r\n  /**\r\n   * A unique symbol used for type branding.\r\n   */\r\n  export const TypeBrandSymbol: unique symbol;\r\n\r\n  /**\r\n   * Checks if the given value is type branded with the specified brand.\r\n   *\r\n   * @param check - The value to check.\r\n   * @param brand - The brand symbol to check against.\r\n   * @returns True if the value is type branded with the specified brand, otherwise false.\r\n   */\r\n  export const isTypeBranded: <TResult>(\r\n    check: unknown,\r\n    brand: symbol,\r\n  ) => check is TResult;\r\n\r\n  /**\r\n   * Result type for categorized promises.\r\n   */\r\n  type CategorizedPromiseResult<T> = {\r\n    fulfilled: Array<T>;\r\n    rejected: Array<unknown>;\r\n    pending: Array<Promise<T>>;\r\n  };\r\n\r\n  /**\r\n   * Waits for all promises to settle and categorizes their results.\r\n   *\r\n   * @param promises - An array of promises to wait for.\r\n   * @param timeoutMs - The timeout duration in milliseconds.\r\n   * @returns An object categorizing the promises into fulfilled, rejected, and pending.\r\n   */\r\n  export const getResolvedPromises: <T>(\r\n    promises: Promise<T>[],\r\n    timeoutMs?: number,\r\n  ) => Promise<CategorizedPromiseResult<T>>;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\react-util\\utility-methods.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":6,"column":1,"nodeType":"Program","endLine":180,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// General utility methods used across React components\r\n// and other parts of the application.\r\n\r\n// Pseudo-random ID generator for lightweight unique IDs.\r\n// Not cryptographically secure; suitable for client-side use.\r\nexport const generateUniqueId = (): string => {\r\n  return Math.random().toString(36).slice(2, 9);\r\n};\r\n\r\n// Type guard to check if a value is an instance of Error\r\n// or at least has the basic shape of an Error object.\r\nexport const isError = (value: unknown): value is Error => {\r\n  return (\r\n    !!value &&\r\n    typeof value === 'object' &&\r\n    (value instanceof Error || ('message' in value && 'name' in value))\r\n  );\r\n};\r\n\r\nexport type SafeProgressEvent<T extends EventTarget = EventTarget> = Event & {\r\n  /**\r\n   * The **`ProgressEvent.lengthComputable`** read-only property is a boolean flag indicating if the resource concerned by the length\r\n   * of the operation.\r\n   *\r\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ProgressEvent/lengthComputable)\r\n   */\r\n  readonly lengthComputable: boolean;\r\n  /**\r\n   * The **`ProgressEvent.loaded`** read-only property is a number indicating the size of the data already transmitted or processed.\r\n   *\r\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ProgressEvent/loaded)\r\n   */\r\n  readonly loaded: number;\r\n  readonly target: T | null;\r\n  /**\r\n   * The **`ProgressEvent.total`** read-only property is a number indicating the total size of the data being transmitted or processed.\r\n   *\r\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ProgressEvent/total)\r\n   */\r\n  readonly total: number;\r\n};\r\n\r\n// Type guard to check if a value is an XMLHttpRequest\r\nexport const isXmlHttpRequest = (value: unknown): value is XMLHttpRequest => {\r\n  return (\r\n    typeof value === 'object' &&\r\n    value !== null &&\r\n    'readyState' in value &&\r\n    'status' in value &&\r\n    'timeout' in value &&\r\n    'upload' in value &&\r\n    'response' in value &&\r\n    'open' in value &&\r\n    typeof value.open === 'function' &&\r\n    'send' in value &&\r\n    typeof value.send === 'function'\r\n  );\r\n};\r\n\r\n// Type guard to check if a value is a ProgressEvent from an XMLHttpRequest\r\nexport const isProgressEvent = (\r\n  value: unknown,\r\n): value is SafeProgressEvent<XMLHttpRequest> =>\r\n  typeof value === 'object' &&\r\n  !!value &&\r\n  'target' in value &&\r\n  isXmlHttpRequest(value.target) &&\r\n  'loaded' in value &&\r\n  typeof value.loaded === 'number' &&\r\n  'total' in value &&\r\n  typeof value.total === 'number' &&\r\n  'lengthComputable' in value &&\r\n  typeof value.lengthComputable === 'boolean';\r\n\r\n// Type guard to check if a value is an Abort error\r\n// (i.e., not null, not an array, and of type 'object').\r\nexport const isAbortError = (value: unknown): value is Error => {\r\n  return value instanceof DOMException && value.name === 'AbortError';\r\n};\r\n\r\n// Type guard to check if a value is a TemplateStringsArray\r\nexport const isTemplateStringsArray = (\r\n  value: unknown,\r\n): value is TemplateStringsArray => {\r\n  return Array.isArray(value) && 'raw' in value;\r\n};\r\n\r\n// Converts various input types to a boolean \"truthy\" value.\r\nexport const isTruthy = (\r\n  value: unknown,\r\n  defaultValue: boolean = false,\r\n): boolean => {\r\n  if (value === undefined || value === null) {\r\n    return defaultValue;\r\n  }\r\n  if (typeof value === 'string') {\r\n    const trimmedValue = value.trim().toLowerCase();\r\n    return (\r\n      trimmedValue === 'true' ||\r\n      trimmedValue === '1' ||\r\n      trimmedValue === 'yes' ||\r\n      trimmedValue === 'y'\r\n    );\r\n  } else if (Array.isArray(value)) {\r\n    return value.length > 0;\r\n    // If we have a completely empty object that's as good as false, and certainly not truthy\r\n  } else if (typeof value === 'object' && Object.keys(value).length === 0) {\r\n    return false;\r\n  }\r\n  return Boolean(value);\r\n};\r\n\r\n// Type guard to check if a value is a non-null object (not an array).\r\nexport const isRecord = (check: unknown): check is Record<string, unknown> => {\r\n  return check !== null && typeof check === 'object';\r\n};\r\n\r\n// Unique symbol used for branding types\r\nexport const TypeBrandSymbol: unique symbol = Symbol('TypeBrandSymbol');\r\n\r\n// Type guard to check if an object has a specific type brand\r\nexport const isTypeBranded = <TResult>(\r\n  check: unknown,\r\n  brand: symbol,\r\n): check is TResult =>\r\n  typeof check === 'object' &&\r\n  check !== null &&\r\n  TypeBrandSymbol in check &&\r\n  check[TypeBrandSymbol] === brand;\r\n\r\n// Type for categorized promise results\r\ntype CategorizedPromiseResult<T> = {\r\n  fulfilled: Array<T>;\r\n  rejected: Array<unknown>;\r\n  pending: Array<Promise<T>>;\r\n};\r\n\r\n// Function to categorize promises into fulfilled, rejected, and pending (timed out)\r\n// based on a specified timeout duration.\r\nexport const getResolvedPromises = async <T>(\r\n  promises: Promise<T>[],\r\n  timeoutMs: number = 60 * 1000,\r\n): Promise<CategorizedPromiseResult<T>> => {\r\n  // Use a unique symbol to identify timeouts\r\n  const TIMEOUT_SYMBOL = Symbol('timeout');\r\n\r\n  // Race each promise against a timeout that RESOLVES with the symbol\r\n  const racedPromises = promises.map((promise) =>\r\n    Promise.race([\r\n      promise,\r\n      new Promise<typeof TIMEOUT_SYMBOL>((resolve) =>\r\n        setTimeout(() => resolve(TIMEOUT_SYMBOL), timeoutMs),\r\n      ),\r\n    ]),\r\n  );\r\n\r\n  // Wait for all races to complete\r\n  const results = await Promise.allSettled(racedPromises);\r\n\r\n  // Categorize results with clear logic\r\n  return results.reduce(\r\n    (acc, result, index) => {\r\n      if (result.status === 'fulfilled') {\r\n        if (result.value === TIMEOUT_SYMBOL) {\r\n          // This promise timed out, still pending\r\n          acc.pending.push(promises[index]);\r\n        } else {\r\n          // This promise resolved (even if value is null/undefined)\r\n          acc.fulfilled.push(result.value);\r\n        }\r\n      } else {\r\n        // This promise rejected\r\n        acc.rejected.push(result.reason);\r\n      }\r\n      return acc;\r\n    },\r\n    { fulfilled: [], rejected: [], pending: [] } as CategorizedPromiseResult<T>,\r\n  );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\send-api-request\\api-request-error.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":4,"column":1,"nodeType":"Program","endLine":51,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * A unique symbol to identify API request errors.\r\n */\r\nconst apiRequestError: unique symbol = Symbol('apiRequest');\r\n\r\n/**\r\n * Represents an error that occurs during an API request.\r\n * Extends the built-in `Error` class to include the response object.\r\n */\r\nexport class ApiRequestError extends Error {\r\n  /**\r\n   * Type guard to check if an error is an instance of `ApiRequestError`.\r\n   * @param error - The error to check.\r\n   * @returns `true` if the error is an instance of `ApiRequestError`, otherwise `false`.\r\n   */\r\n  static isApiRequestError(error: unknown): error is ApiRequestError {\r\n    return (\r\n      error instanceof Error &&\r\n      '__brand' in error &&\r\n      error.__brand === apiRequestError\r\n    );\r\n  }\r\n\r\n  /**\r\n   * The response object associated with the API request error.\r\n   */\r\n  readonly #response: Response;\r\n\r\n  /**\r\n   * A unique brand symbol to identify instances of `ApiRequestError`.\r\n   */\r\n  __brand: symbol = apiRequestError;\r\n\r\n  /**\r\n   * Creates an instance of `ApiRequestError`.\r\n   * @param message - The error message.\r\n   * @param response - The response object associated with the error.\r\n   */\r\n  constructor(message: string, response: Response) {\r\n    super(message);\r\n    this.#response = response;\r\n  }\r\n\r\n  /**\r\n   * Gets the response object associated with the API request error.\r\n   */\r\n  get response(): Response {\r\n    return this.#response;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\send-api-request\\api-requests.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":239,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":79,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":79,"endColumn":19,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { log } from '@/lib/logger';\r\nimport { AbortablePromise, ICancellablePromiseExt } from '@/lib/typescript';\r\nimport type {\r\n  AdditionalRequestParams,\r\n  ApiRequestHelper,\r\n  ApiRequestParams,\r\n  DeleteApiRequestParams,\r\n  ReadApiRequestParams,\r\n  WriteApiRequestParams,\r\n} from './types';\r\nimport { ApiRequestError } from './api-request-error';\r\nimport { LoggedError } from '../react-util/errors/logged-error';\r\nimport { getHeaderValue } from '../nextjs-util';\r\nimport { fetch } from '@/lib/nextjs-util/fetch';\r\n\r\n/**\r\n * Sends an API request with the specified parameters.\r\n *\r\n * @template T - The type of the response data.\r\n * @param {ApiRequestParams} params - The parameters for the API request.\r\n * @param {string} params.url - The URL to send the request to.\r\n * @param {string} params.area - The area of the API being accessed.\r\n * @param {string} params.action - The specific action being performed.\r\n * @param {string} params.method - The HTTP method to use for the request.\r\n * @param {any} [params.input] - The input data to send with the request.\r\n * @param {Request} [params.req] - The server request object, if available.\r\n * @param {boolean} [params.forwardCredentials=true] - Whether to forward credentials (cookies) with the request.\r\n * @returns {ICancellablePromiseExt<T>} A promise that resolves with the response data or rejects with an error.\r\n */\r\nexport const sendApiRequest = <T>({\r\n  url,\r\n  area,\r\n  action,\r\n  method,\r\n  input,\r\n  req: serverRequest,\r\n  forwardCredentials = true,\r\n}: ApiRequestParams): ICancellablePromiseExt<T> =>\r\n  new AbortablePromise<T>(async (resolveOuter, rejectOuter, signal) => {\r\n    try {\r\n      // Build request headers, including forwarded auth cookies if necessary\r\n      const headers = new Headers({\r\n        'Content-Type': 'application/json',\r\n      });\r\n      // If we're on the server and we're forwarding credentials, add the cookies to the request\r\n      if (serverRequest && forwardCredentials) {\r\n        const rawCookieHeader = getHeaderValue(serverRequest, 'cookie');\r\n        if (rawCookieHeader) {\r\n          if (Array.isArray(rawCookieHeader)) {\r\n            headers.append('Cookie', rawCookieHeader.join(';'));\r\n          } else {\r\n            headers.append('Cookie', String(rawCookieHeader));\r\n          }\r\n        }\r\n      }\r\n      // Use headers to initialize the request object\r\n      const request: RequestInit = {\r\n        method,\r\n        headers,\r\n        signal,\r\n      };\r\n      // Add the request body if one exists, serializing when appropriate\r\n      if (input) {\r\n        request.body =\r\n          typeof input === 'string' ? input : JSON.stringify(input);\r\n      }\r\n      // Send all of this off to the fetch API to do its thing\r\n      const response = await fetch(url, request);\r\n      if (!response.ok) {\r\n        let errorMessage = `Api failure: ${response.statusText}`;\r\n        let errorData;\r\n        const errorBody = await response.text();\r\n        try {\r\n          errorData = JSON.parse(errorBody);\r\n          errorMessage += ` - ${\r\n            errorData.message || JSON.stringify(errorData)\r\n          }`;\r\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        } catch (e) {\r\n          errorData = errorBody;\r\n          errorMessage += ` - ${errorData}`;\r\n        }\r\n        rejectOuter(new ApiRequestError(errorMessage, response));\r\n      }\r\n      const contentType = response.headers.get('Content-Type');\r\n      const data =\r\n        contentType && contentType.includes('application/json')\r\n          ? await response.json()\r\n          : await response.text();\r\n      log((l) =>\r\n        l.verbose({\r\n          source: `${area}.${action}`,\r\n          message: `API request completed for [${url}]`,\r\n          url,\r\n          method,\r\n          data,\r\n        }),\r\n      );\r\n      resolveOuter(data);\r\n      return data;\r\n    } catch (error) {\r\n      rejectOuter(\r\n        LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n          log: true,\r\n          source: `${area}.${action}`,\r\n          message: `API request failed for [${url}]`,\r\n          url,\r\n          method,\r\n        }),\r\n      );\r\n    }\r\n  });\r\n\r\n/**\r\n * Sends an API GET request.\r\n *\r\n * @template T - The type of the response data.\r\n * @param {ReadApiRequestParams} props - The parameters for the API request.\r\n * @param {AdditionalRequestParams} [additional] - Additional parameters for the API request.\r\n * @param {Function} [additional.sendApiRequest] - Optional custom function to send the API request.\r\n * @returns {ICancellablePromiseExt<T>} A cancellable promise that resolves with the response data.\r\n */\r\nexport const sendApiGetRequest = <T>(\r\n  props: ReadApiRequestParams,\r\n  {\r\n    sendApiRequest: sendApiRequestInProps,\r\n    ...additional\r\n  }: AdditionalRequestParams = {},\r\n): ICancellablePromiseExt<T> =>\r\n  (sendApiRequestInProps ?? sendApiRequest)<T>({\r\n    ...props,\r\n    ...additional,\r\n    method: 'GET',\r\n  });\r\n\r\n/**\r\n * Sends a POST request to the API.\r\n *\r\n * @template T - The type of the response data.\r\n * @param {WriteApiRequestParams} props - The parameters for the API request.\r\n * @param {AdditionalRequestParams} [additional] - Additional parameters for the API request.\r\n * @param {Function} [additional.sendApiRequest] - Optional custom function to send the API request.\r\n * @returns {ICancellablePromiseExt<T>} A promise that resolves to the response data.\r\n */\r\nexport const sendApiPostRequest = <T>(\r\n  props: WriteApiRequestParams,\r\n  {\r\n    sendApiRequest: sendApiRequestInProps,\r\n    ...additional\r\n  }: AdditionalRequestParams = {},\r\n): ICancellablePromiseExt<T> =>\r\n  (sendApiRequestInProps ?? sendApiRequest)<T>({\r\n    ...props,\r\n    ...additional,\r\n    method: 'POST',\r\n  });\r\n\r\n/**\r\n * Sends an API PUT request.\r\n *\r\n * @template T - The type of the response data.\r\n * @param {WriteApiRequestParams} props - The parameters for the API request.\r\n * @param {AdditionalRequestParams} [additional] - Additional parameters for the API request.\r\n * @param {Function} [additional.sendApiRequest] - Optional custom function to send the API request.\r\n * @returns {ICancellablePromiseExt<T>} A promise that resolves to the response data.\r\n */\r\nexport const sendApiPutRequest = <T>(\r\n  props: WriteApiRequestParams,\r\n  {\r\n    sendApiRequest: sendApiRequestInProps,\r\n    ...additional\r\n  }: AdditionalRequestParams = {},\r\n): ICancellablePromiseExt<T> =>\r\n  (sendApiRequestInProps ?? sendApiRequest)<T>({\r\n    ...props,\r\n    ...additional,\r\n    method: 'PUT',\r\n  });\r\n\r\n/**\r\n * Sends an API DELETE request.\r\n *\r\n * @template T - The type of the response data.\r\n * @param {DeleteApiRequestParams} props - The parameters for the DELETE request.\r\n * @param {AdditionalRequestParams} [additional] - Additional parameters for the request.\r\n * @param {Function} [additional.sendApiRequest] - Optional custom function to send the API request.\r\n * @returns {ICancellablePromiseExt<T>} A cancellable promise that resolves to the response data of type T.\r\n */\r\nexport const sendApiDeleteRequest = <T>(\r\n  props: DeleteApiRequestParams,\r\n  {\r\n    sendApiRequest: sendApiRequestInProps,\r\n    ...additional\r\n  }: AdditionalRequestParams = {},\r\n): ICancellablePromiseExt<T> =>\r\n  (sendApiRequestInProps ?? sendApiRequest)<T>({\r\n    ...props,\r\n    ...additional,\r\n    method: 'DELETE',\r\n  });\r\n\r\n/**\r\n * Factory function to create an API request helper for a specific area.\r\n *\r\n * @param {Object} options - The options for the API request helper.\r\n * @param {string} options.area - The area to be included in the API request parameters.\r\n * @returns {ApiRequestHelper} An object containing methods for making API requests (get, post, put, delete).\r\n *\r\n * @template T - The type of the response data.\r\n */\r\nexport const apiRequestHelperFactory = ({\r\n  area,\r\n}: {\r\n  area: string;\r\n}): ApiRequestHelper => {\r\n  const addArea = <T>(params: T): T & { area: string } => ({\r\n    ...params,\r\n    area,\r\n  });\r\n  return {\r\n    get: <T>(\r\n      params: Omit<ReadApiRequestParams, 'area'>,\r\n      additional?: AdditionalRequestParams,\r\n    ) => sendApiGetRequest<T>(addArea(params), additional),\r\n    post: <T>(\r\n      params: Omit<WriteApiRequestParams, 'area'>,\r\n      additional?: AdditionalRequestParams,\r\n    ) => sendApiPostRequest<T>(addArea(params), additional),\r\n    put: <T>(\r\n      params: Omit<WriteApiRequestParams, 'area'>,\r\n      additional?: AdditionalRequestParams,\r\n    ) => sendApiPutRequest<T>(addArea(params), additional),\r\n    delete: <T>(\r\n      params: Omit<DeleteApiRequestParams, 'area'>,\r\n      additional?: AdditionalRequestParams,\r\n    ) => sendApiDeleteRequest<T>(addArea(params), additional),\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\send-api-request\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\send-api-request\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":133,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ICancellablePromiseExt } from '../typescript';\r\nimport { NextRequest } from 'next/server';\r\nimport { NextApiRequest } from 'next';\r\n\r\n/**\r\n * Represents the parameters required for making an API request.\r\n *\r\n * @property {URL} url - The URL to which the request is made.\r\n * @property {string} area - The area or domain of the API being accessed.\r\n * @property {string} action - The specific action or endpoint being called.\r\n * @property {'GET' | 'POST' | 'PUT' | 'DELETE'} method - The HTTP method used for the request.\r\n * @property {string | Record<string, unknown>} [input] - Optional input data to be sent with the request, can be a string or an object.\r\n * @preperty {NextRequest | NextApiRequest} req - The active request object\r\n * @property {boolean} [forwardCredentials] - Whether to forward credentials to the endpoint.  True by default when the request property is provided.\r\n */\r\nexport type ApiRequestParams = {\r\n  url: URL;\r\n  area: string;\r\n  action: string;\r\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE';\r\n  input?: string | Record<string, unknown>;\r\n  req?: NextRequest | NextApiRequest;\r\n  forwardCredentials?: boolean;\r\n};\r\n\r\n/**\r\n * A function type that represents an API request.\r\n *\r\n * @template T - The type of the response data.\r\n * @param {ApiRequestParams} apiRequest - The parameters for the API request.\r\n * @returns {ICancellablePromiseExt<T>} A cancellable promise that resolves to the response data of type T.\r\n */\r\nexport type ApiRequestFunction = <T>(\r\n  apiRequest: ApiRequestParams\r\n) => ICancellablePromiseExt<T>;\r\n\r\n/**\r\n * Represents the parameters for a read API request.\r\n *\r\n * This type is derived from `ApiRequestParams` by omitting the `method`, `input`,\r\n * and `req` properties. It is used to define the parameters required for making a\r\n * read request to the API.\r\n */\r\nexport type ReadApiRequestParams = Omit<ApiRequestParams, 'method' | 'input'>;\r\n\r\n/**\r\n * Type alias for `DeleteApiRequestParams` which is equivalent to `ReadApiRequestParams`.\r\n * This type is used to define the parameters required for a delete API request.\r\n */\r\nexport type DeleteApiRequestParams = ReadApiRequestParams;\r\n\r\n/**\r\n * Type definition for the parameters of a write API request.\r\n *\r\n * This type is derived from `ApiRequestParams` by omitting the `method` and `input` properties,\r\n * and then adding a new `input` property that can be either a string or a record with string keys and unknown values.\r\n *\r\n * @typeParam ApiRequestParams - The base type for API request parameters.\r\n * @property input - The input data for the API request, which can be a string or a record with string keys and unknown values.\r\n */\r\nexport type WriteApiRequestParams = Omit<\r\n  ApiRequestParams,\r\n  'method' | 'input'\r\n> & { input: string | Record<string, unknown> };\r\n\r\n/**\r\n * Represents additional request parameters for an API request.\r\n *\r\n * This type is a partial version of `ApiRequestParams` with the `method` property omitted.\r\n * It allows specifying any subset of the properties from `ApiRequestParams`, except for `method`.\r\n * @property {ApiRequestFunction} sendApiRequest - An optional function that can be used for dependency injection\r\n * to override the default API request function.\r\n */\r\nexport type AdditionalRequestParams = Partial<\r\n  Omit<ApiRequestParams, 'method'>\r\n> & {\r\n  sendApiRequest?: ApiRequestFunction;\r\n};\r\n/**\r\n * Helper type for making API requests.\r\n *\r\n * @template T - The type of the response data.\r\n */\r\nexport type ApiRequestHelper = {\r\n  /**\r\n   * Makes a GET request.\r\n   *\r\n   * @param params - The parameters for the GET request, excluding the 'area' field.\r\n   * @param additional - Optional additional parameters for the API request.\r\n   * @returns A promise that resolves to the response data of type T.\r\n   */\r\n  get: <T>(\r\n    params: Omit<ReadApiRequestParams, 'area'>,\r\n    additional?: AdditionalRequestParams\r\n  ) => ICancellablePromiseExt<T>;\r\n\r\n  /**\r\n   * Makes a POST request.\r\n   *\r\n   * @param params - The parameters for the POST request, excluding the 'area' field.\r\n   * @param additional - Optional additional parameters for the API request.\r\n   * @returns A promise that resolves to the response data of type T.\r\n   */\r\n  post: <T>(\r\n    params: Omit<WriteApiRequestParams, 'area'>,\r\n    additional?: AdditionalRequestParams\r\n  ) => ICancellablePromiseExt<T>;\r\n\r\n  /**\r\n   * Makes a PUT request.\r\n   *\r\n   * @param params - The parameters for the PUT request, excluding the 'area' field.\r\n   * @param additional - Optional additional parameters for the API request.\r\n   * @returns A promise that resolves to the response data of type T.\r\n   */\r\n  put: <T>(\r\n    params: Omit<WriteApiRequestParams, 'area'>,\r\n    additional?: AdditionalRequestParams\r\n  ) => ICancellablePromiseExt<T>;\r\n\r\n  /**\r\n   * Makes a DELETE request.\r\n   *\r\n   * @param params - The parameters for the DELETE request, excluding the 'area' field.\r\n   * @param additional - Optional additional parameters for the API request.\r\n   * @returns A promise that resolves to the response data of type T.\r\n   */\r\n  delete: <T>(\r\n    params: Omit<DeleteApiRequestParams, 'area'>,\r\n    additional?: AdditionalRequestParams\r\n  ) => ICancellablePromiseExt<T>;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\__mocks__\\url-builder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\after\\index.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\after\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":300,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { log } from '@/lib/logger';\r\nimport { getStackTrace } from '@/lib/nextjs-util';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\n\r\n/**\r\n * Handler invoked by AfterManager queued operations.\r\n * The handler returns a promise which resolves when the cleanup work is complete.\r\n *\r\n * @template T - the resolved value type (defaults to void/unknown)\r\n */\r\ntype TAfterHandler<T = unknown | void> = () => Promise<T>;\r\n\r\n/**\r\n * Webpack-safe singleton key using Symbol.for() to ensure uniqueness across all chunks.\r\n * This approach prevents module duplication issues where different webpack bundles\r\n * would otherwise create separate singleton instances.\r\n */\r\nconst AFTER_MANAGER_KEY = Symbol.for('@noeducation/after-manager-instance');\r\n\r\n/**\r\n * Global registry interface using symbols for webpack-safe singleton access.\r\n * Symbols created with Symbol.for() are globally registered and shared across\r\n * all webpack chunks, preventing duplicate singleton instances.\r\n */\r\ninterface GlobalAfterRegistry {\r\n  [AFTER_MANAGER_KEY]?: AfterManager;\r\n}\r\n\r\n\r\nexport default class AfterManager {\r\n  /** Default timeout (ms) for waiting on registered handlers to complete */\r\n  static readonly #TIMEOUT = 7500;\r\n\r\n  /** Internal singleton accessor stored on globalThis to survive reloads */\r\n  static get #instance(): AfterManager | undefined {\r\n    return (globalThis as GlobalAfterRegistry)[AFTER_MANAGER_KEY];\r\n  }\r\n\r\n  static set #instance(value: AfterManager | undefined) {\r\n    (globalThis as GlobalAfterRegistry)[AFTER_MANAGER_KEY] = value;\r\n  }\r\n\r\n  /**\r\n   * Function provided by the `prexit` module to register a process-exit handler.\r\n   * Stored so we only load prexit lazily once.\r\n   */\r\n  static #prexit: ((cb: () => Promise<void>) => void) | undefined;\r\n\r\n  /** Unique brand symbol used for internal timeout marker objects */\r\n  static readonly #brand: unique symbol = Symbol('AfterManager brand');\r\n\r\n  /** Internal teardown handler that will be placed on the 'teardown' queue by default. */\r\n  static async #innerTeardown(): Promise<void> {\r\n    // TODO: cleanup any registered prexit subs\r\n  }\r\n\r\n  /**\r\n   * Type-guard to determine whether a value has been branded by this manager.\r\n   * Branded values are used internally to indicate timeout sentinel values.\r\n   *\r\n   * @template T\r\n   * @param check - value to test\r\n   * @returns true when the value has the manager brand\r\n   */\r\n  static isBranded<T>(check: T): check is T & { __brand: symbol } {\r\n    const c = check as { __brand: symbol } | undefined;\r\n    return !!c && c.__brand === AfterManager.#brand;\r\n  }\r\n\r\n  /**\r\n   * Mark a value as branded by this manager. Used to create timeout sentinel objects.\r\n   *\r\n   * @template T\r\n   * @param check - value to brand (mutates the object)\r\n   * @returns the same value typed as branded\r\n   */\r\n  static asBranded<T>(check: T): T & { __brand: symbol } {\r\n    if (!AfterManager.isBranded(check)) {\r\n      (check as { __brand: symbol }).__brand = AfterManager.#brand;\r\n    }\r\n    return check as T & { __brand: symbol };\r\n  }\r\n\r\n  /** Map of queue name => array of handlers. Handlers are executed in registration order. */\r\n  readonly #queues: Map<string, Array<TAfterHandler<void>>>;\r\n\r\n  /**\r\n   * Private constructor. Use `AfterManager.getInstance()` to obtain the singleton.\r\n   * The manager registers a default teardown handler to allow centralized cleanup.\r\n   */\r\n  private constructor() {\r\n    this.#queues = new Map();\r\n    this.add('teardown', AfterManager.#innerTeardown);\r\n  }\r\n\r\n  /**\r\n   * Start background wiring such as registering process-exit handlers via `prexit`.\r\n   * This is invoked lazily when the singleton is first created.\r\n   *\r\n   * @private\r\n   */\r\n  async #start(): Promise<void> {\r\n    console.warn('In AfterManager::start', getStackTrace());\r\n    AfterManager.asBranded(AfterManager.#teardown);\r\n    if (!AfterManager.#prexit) {\r\n      try {\r\n        const instance = (await import('prexit')).default;\r\n        if (!instance) {\r\n          throw new Error('Unable to load prexit');\r\n        }\r\n        if (!AfterManager.#prexit) {\r\n          AfterManager.#prexit = instance;\r\n          AfterManager.#prexit(AfterManager.#teardown);\r\n        }\r\n      } catch (error) {\r\n        throw LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n          log: true,\r\n          source: 'AfterManager::start',\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Register a handler for the named queue.\r\n   * If the handler is already registered for that queue this is a no-op and returns false.\r\n   *\r\n   * @param queueName - logical queue name (e.g. 'teardown')\r\n   * @param handler - async handler to invoke when the queue is signalled\r\n   * @returns true when the handler was added, false when it was already present\r\n   */\r\n  public add(queueName: string, handler: TAfterHandler<void>): boolean {\r\n    const queue = this.queue(queueName, true)!;\r\n    if (!queue.includes(handler)) {\r\n      queue.push(handler);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Remove a previously registered handler from a queue.\r\n   *\r\n   * @param queueName - the queue name\r\n   * @param handler - the handler to remove\r\n   * @returns true when the handler was removed\r\n   */\r\n  public remove(queueName: string, handler: TAfterHandler<void>): boolean {\r\n    const q = this.queue(queueName);\r\n    const index = q?.indexOf(handler);\r\n    if (typeof index === 'number' && index !== -1) {\r\n      q.splice(index, 1);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Overloaded accessor for a queue's handlers.\r\n   * When `create` is true the queue is created if missing. Returned arrays are shallow copies\r\n   * to prevent callers from mutating internal arrays.\r\n   */\r\n  public queue(queueName: string): Array<TAfterHandler<void>>;\r\n  public queue(queueName: string, create: true): Array<TAfterHandler<void>>;\r\n  public queue(\r\n    queueName: string,\r\n    create: false,\r\n  ): undefined | Array<TAfterHandler<void>>;\r\n  public queue(\r\n    queueName: string,\r\n    create: boolean = false,\r\n  ): undefined | Array<TAfterHandler<void>> {\r\n    if (!this.#queues.has(queueName) && create) {\r\n      const newQueue = [] as Array<TAfterHandler<void>>;\r\n      this.#queues.set(queueName, newQueue);\r\n      return [...newQueue];\r\n    }\r\n    const q = this.#queues.get(queueName);\r\n    if (q) {\r\n      return [...q];\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Internal teardown entrypoint registered with prexit. Signals the 'teardown' queue.\r\n   *\r\n   * @private\r\n   */\r\n  static async #teardown(): Promise<void> {\r\n    const myInstance = AfterManager.#instance;\r\n    if (myInstance) {\r\n      await myInstance.signal('teardown');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the process-global AfterManager singleton. The instance is lazily created and started.\r\n   *\r\n   * @returns the singleton AfterManager\r\n   */\r\n  public static getInstance(): AfterManager {\r\n    if (!AfterManager.#instance) {\r\n      AfterManager.#instance = new AfterManager();\r\n      AfterManager.#instance.#start();\r\n    }\r\n    return AfterManager.#instance;\r\n  }\r\n\r\n  /**\r\n   * Signal a queue by name, waiting for all registered handlers to complete or until a timeout.\r\n   * Returns a promise that resolves when processing completes or when the timeout occurs.\r\n   *\r\n   * @param signalName - name of the queue to signal\r\n   */\r\n  public async signal(signalName: string): Promise<void> {\r\n    return new Promise(async (resolve, reject) => {\r\n      try {\r\n        const handlers = this.queue(signalName, false);\r\n        if (!handlers) {\r\n          return resolve();\r\n        }\r\n        const promises = handlers.map((handler) => handler());\r\n        const completed = await Promise.race([\r\n          Promise.all(promises),\r\n          new Promise((resolve) =>\r\n            setTimeout(() => {\r\n              const timedOut = { __brand: AfterManager.#brand } as unknown as {\r\n                __brand: symbol;\r\n              };\r\n              resolve(timedOut);\r\n            }, AfterManager.#TIMEOUT),\r\n          ), // Timeout after\r\n        ]);\r\n        // Completed can be either the result array from Promise.all or our timeout sentinel.\r\n        const maybeBranded = completed as unknown;\r\n        let isBrandedObj = false;\r\n        if (\r\n          typeof maybeBranded === 'object' &&\r\n          maybeBranded !== null &&\r\n          '__brand' in (maybeBranded as Record<string, unknown>)\r\n        ) {\r\n          const objBrand = (maybeBranded as Record<string, unknown>).__brand;\r\n          isBrandedObj =\r\n            typeof objBrand === 'symbol' && objBrand === AfterManager.#brand;\r\n        }\r\n        let isBrandedArray = false;\r\n        if (\r\n          Array.isArray(maybeBranded) &&\r\n          (maybeBranded as Array<unknown>).length > 0\r\n        ) {\r\n          const first = (maybeBranded as Array<unknown>)[0];\r\n          if (\r\n            typeof first === 'object' &&\r\n            first !== null &&\r\n            '__brand' in (first as Record<string, unknown>)\r\n          ) {\r\n            const arrBrand = (first as Record<string, unknown>).__brand;\r\n            isBrandedArray =\r\n              typeof arrBrand === 'symbol' && arrBrand === AfterManager.#brand;\r\n          }\r\n        }\r\n        if (isBrandedObj || isBrandedArray) {\r\n          log((l) =>\r\n            l.warn(\r\n              `AfterManager ${signalName} timed out before all registered callbacks completed`,\r\n            ),\r\n          );\r\n          return resolve();\r\n        }\r\n      } catch (error) {\r\n        return reject(\r\n          LoggedError.isTurtlesAllTheWayDownBaby(error, {\r\n            log: true,\r\n            source: `AfterManager signal ${signalName}`,\r\n          }),\r\n        );\r\n      }\r\n      console.log(`Signal received: ${signalName}`);\r\n      resolve(); // Replace with actual resolution logic\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Helper for process exit integration.\r\n   *\r\n   * When called with a callback the callback is registered on the 'teardown' queue.\r\n   * When called with no args the current number of teardown handlers is returned.\r\n   */\r\n  public static processExit(): number;\r\n  public static processExit(cb: () => Promise<void>): void;\r\n  public static processExit(cb?: () => Promise<void>): number | void {\r\n    if (cb) {\r\n      AfterManager.getInstance().add('teardown', cb);\r\n    } else {\r\n      return AfterManager.getInstance().queue('teardown')?.length ?? 0;\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\auth\\_credentialProvider.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\auth\\_credentialProvider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\auth\\_guards.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\auth\\_guards.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\auth\\_types.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\auth\\_types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\auth\\crypto-service.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\auth\\crypto-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\auth\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\auth\\key-validation.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\auth\\key-validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\auth\\keycloak-token-exchange.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\auth\\keycloak-token-exchange.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\auth\\security.d.ts","messages":[{"ruleId":"no-jsdoc-in-ts/prefer-function-declarations","severity":1,"message":"Prefer `export function name(...) : ...;` declarations in .d.ts files instead of `export const name: (...) => ...;`.","line":36,"column":16,"nodeType":"VariableDeclarator","endLine":40,"endColumn":25},{"ruleId":"no-jsdoc-in-ts/prefer-function-declarations","severity":1,"message":"Prefer `export function name(...) : ...;` declarations in .d.ts files instead of `export const name: (...) => ...;`.","line":48,"column":16,"nodeType":"VariableDeclarator","endLine":50,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Session } from 'next-auth';\r\n\r\ndeclare module '@/lib/site-util/auth/security' {\r\n  /**\r\n   * Determines whether a signed-in user is authorized to access (read and/or write) another user's resources.\r\n   *\r\n   * Authorization rules:\r\n   * 1. Returns false if either user ID is missing or falsy.\r\n   * 2. Returns true if the signed-in user is the owner (IDs match).\r\n   * 3. If not the owner:\r\n   *    - Read access (write === false or omitted) is currently allowed for all users.\r\n   *    - Write access (write === true) is denied.\r\n   *\r\n   * This logic is an interim placeholder until a full permissions / roles model is implemented.\r\n   *\r\n   * @param params Object containing user identifiers and requested access mode.\r\n   * @param params.signedInUserId ID of the currently authenticated user.\r\n   * @param params.ownerUserId ID of the resource owner.\r\n   * @param params.write Optional flag indicating a write (mutable) operation; defaults to false (read-only).\r\n   * @returns True if the user is authorized under the above rules; otherwise false.\r\n   *\r\n   * @remarks Future improvement: Replace blanket read access with role-based or ACL-driven evaluation.\r\n   *\r\n   * @example\r\n   * // Owner requesting write access\r\n   * isUserAuthorized({ signedInUserId: 10, ownerUserId: 10, write: true }); // true\r\n   *\r\n   * @example\r\n   * // Non-owner requesting read access\r\n   * isUserAuthorized({ signedInUserId: 3, ownerUserId: 10 }); // true\r\n   *\r\n   * @example\r\n   * // Non-owner requesting write access\r\n   * isUserAuthorized({ signedInUserId: 3, ownerUserId: 10, write: true }); // false\r\n   */\r\n  export const isUserAuthorized: (params: {\r\n    signedInUserId: number;\r\n    ownerUserId: number;\r\n    write?: boolean;\r\n  }) => Promise<boolean>;\r\n\r\n  /**\r\n   * Evaluates whether a given session is still active.\r\n   * @param {Object} props - The properties object.\r\n   * @param {Session | null | undefined} props.session - The session object to evaluate.\r\n   * @returns {boolean} True if the session is active; otherwise false.\r\n   */\r\n  export const isSessionActive: (props: {\r\n    session: Session | null | undefined;\r\n  }) => boolean;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\auth\\security.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\auth\\user-keys-server.d.ts","messages":[{"ruleId":"no-jsdoc-in-ts/prefer-function-declarations","severity":1,"message":"Prefer `export function name(...) : ...;` declarations in .d.ts files instead of `export const name: (...) => ...;`.","line":55,"column":16,"nodeType":"VariableDeclarator","endLine":59,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { DatabaseType } from '../../drizzle-db';\r\n\r\ndeclare module '@/lib/site-util/auth/user-keys-server' {\r\n  /**\r\n   * Returns all public keys for a user that were active at a given date.\r\n   *\r\n   * This function queries the user_public_keys table to find all keys that:\r\n   * 1. Belong to the specified user\r\n   * 2. Have an effectiveDate on or before the specified date\r\n   * 3. Either have no expirationDate (never expire) OR have an expirationDate after the specified date\r\n   *\r\n   * This allows for key rotation and time-based validity checking. For example,\r\n   * when verifying a signature on a document, you can check if the key was valid\r\n   * at the time the document was signed.\r\n   *\r\n   * Authentication:\r\n   * - If userId is not provided, the function will use the current session user\r\n   * - Throws an error if the user is not authenticated\r\n   *\r\n   * @param params - Configuration object\r\n   * @param params.userId - The user's ID (number). If not provided, uses current session user\r\n   * @param params.effectiveDate - ISO string or Date for the point in time to check. Defaults to current date/time\r\n   * @param params.db - Drizzle database instance. If not provided, creates a new instance\r\n   * @returns Promise resolving to an array of base64-encoded public key strings\r\n   * @throws {Error} If user is not authenticated (when userId not provided)\r\n   * @throws {Error} If user ID format is invalid\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Get current user's active public keys\r\n   * const keys = await getActiveUserPublicKeys({\r\n   *   userId: 123\r\n   * });\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Get keys that were valid on a specific date\r\n   * const historicalKeys = await getActiveUserPublicKeys({\r\n   *   userId: 123,\r\n   *   effectiveDate: '2024-01-15T00:00:00Z'\r\n   * });\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Use with existing database connection\r\n   * const db = await drizDbWithInit();\r\n   * const keys = await getActiveUserPublicKeys({\r\n   *   userId: 123,\r\n   *   db\r\n   * });\r\n   * ```\r\n   */\r\n  export const getActiveUserPublicKeys: (params: {\r\n    userId?: number;\r\n    effectiveDate?: string | Date;\r\n    db?: DatabaseType;\r\n  }) => Promise<string[]>;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\auth\\user-keys-server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\auth\\user-keys.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\auth\\user-keys.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\env\\_client.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":97,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { z } from 'zod';\r\nimport { isAiLanguageModelType, AiLanguageModelType } from '@/lib/ai/client';\r\nimport { getMappedSource, ZodProcessors } from './_common';\r\n\r\n/**\r\n * The type representing the validated client environment variables.\r\n *\r\n * This type is generated from the clientEnvSchema and ensures that all\r\n * required and optional environment variables for the client-side application\r\n * are present and correctly typed.\r\n *\r\n * @doc\r\n */\r\nexport type ClientEnvType = ReturnType<typeof clientEnvSchema.parse>;\r\n\r\n/**\r\n * An instance containing environment variables for the client-side application.\r\n *\r\n * IMPORTANT: NEXT_PUBLIC variables need to be directly accessed to avoid being\r\n * stripped during the build process.\r\n *\r\n * @doc\r\n */\r\nexport const clientRawInstance = {\r\n  AZURE_MONITOR_CONNECTION_STRING: process.env.AZURE_MONITOR_CONNECTION_STRING,\r\n  /**\r\n   * The cache timeout for client-side data grids.\r\n   * @type {number | undefined}\r\n   */\r\n  NEXT_PUBLIC_DATAGRID_CLIENT_CACHE_TIMEOUT:\r\n    process.env.NEXT_PUBLIC_DATAGRID_CLIENT_CACHE_TIMEOUT ?? 5 * 60 * 1000,\r\n  /**\r\n   * The default AI model\r\n   */\r\n  NEXT_PUBLIC_DEFAULT_AI_MODEL: process.env.NEXT_PUBLIC_DEFAULT_AI_MODEL,\r\n\r\n  /**\r\n   * The hostname for the public-facing application.\r\n   * @type {string | undefined}\r\n   */\r\n  NEXT_PUBLIC_HOSTNAME: process.env.NEXT_PUBLIC_HOSTNAME,\r\n  /**\r\n   * The log level for client-side logging.\r\n   * @type {string | undefined}\r\n   */\r\n  NEXT_PUBLIC_LOG_LEVEL_CLIENT:\r\n    process.env.NEXT_PUBLIC_LOG_LEVEL_CLIENT ?? 'silly',\r\n  /**\r\n   * Flagsmith API URL for feature flag management and retrieval.\r\n   */\r\n  NEXT_PUBLIC_FLAGSMITH_API_URL: process.env.NEXT_PUBLIC_FLAGSMITH_API_URL!,\r\n  /**\r\n   * Flagsmith environment ID for scoping feature flags.\r\n   */\r\n  NEXT_PUBLIC_FLAGSMITH_ENVIRONMENT_ID:\r\n    process.env.NEXT_PUBLIC_FLAGSMITH_ENVIRONMENT_ID!,\r\n  /**\r\n   * The license key for MUI X Pro components.\r\n   */\r\n  NEXT_PUBLIC_MUI_LICENSE: process.env.NEXT_PUBLIC_MUI_LICENSE,\r\n};\r\n\r\n/**\r\n * Zod schema for validating and parsing client-side environment variables.\r\n *\r\n * This schema ensures that all required environment variables are present and\r\n * have the correct types and default values.\r\n *\r\n * @doc\r\n */\r\nexport const clientEnvSchema = z.object({\r\n  AZURE_MONITOR_CONNECTION_STRING: z.string().optional(),\r\n  NEXT_PUBLIC_DATAGRID_CLIENT_CACHE_TIMEOUT: ZodProcessors.integer().default(\r\n    5 * 60 * 1000,\r\n  ),\r\n  NEXT_PUBLIC_DEFAULT_AI_MODEL: z\r\n    .string()\r\n    .transform((val) => {\r\n      return isAiLanguageModelType(val) ? val : ('hifi' as AiLanguageModelType);\r\n    })\r\n    .default('hifi' as AiLanguageModelType),\r\n  NEXT_PUBLIC_FLAGSMITH_API_URL: z.string().min(1),\r\n  NEXT_PUBLIC_FLAGSMITH_ENVIRONMENT_ID: z.string().min(1),\r\n  NEXT_PUBLIC_HOSTNAME: ZodProcessors.url().default('http://localhost:3000'),\r\n  NEXT_PUBLIC_LOG_LEVEL_CLIENT: ZodProcessors.logLevel().default('silly'),\r\n  NEXT_PUBLIC_MUI_LICENSE: z.string().default(''),\r\n});\r\n\r\n/**\r\n * Parses and validates the client environment variables using the schema.\r\n *\r\n * @returns {ClientEnvType} The validated and typed client environment variables.\r\n * @doc\r\n */\r\nexport const clientEnvFactory = (): ClientEnvType =>\r\n  clientEnvSchema.parse(getMappedSource(clientRawInstance));\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\env\\_common.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":262,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { isTruthy } from '@/lib/react-util/utility-methods';\r\nimport { LoggedError } from '@/lib/react-util/errors/logged-error';\r\nimport z from 'zod';\r\nimport { isAiModelType } from '@/lib/ai/core/guards';\r\nimport { AiModelType, AiModelTypeValues } from '@/lib/ai/core/unions';\r\n\r\n/**\r\n * @module site-util/env/_common\r\n *\r\n * This module provides utilities for determining the current runtime environment.\r\n *\r\n * @typedef {('nodejs' | 'edge' | 'client' | 'static')} RuntimeConfig\r\n * Represents the possible runtime environments.\r\n *\r\n * - 'nodejs': Running in a Node.js environment.\r\n * - 'edge': Running in an Edge environment (e.g., Deno).\r\n * - 'client': Running in a client-side environment (e.g., browser).\r\n * - 'static': Running in a static environment.\r\n *\r\n * @function runtime\r\n * Returns the current runtime environment.\r\n *\r\n * @returns {RuntimeConfig} The current runtime environment.\r\n *\r\n * @function isRunningOnServer\r\n * Checks if the code is running on the server.\r\n *\r\n * @returns {boolean} `true` if running on the server, otherwise `false`.\r\n *\r\n * @function isRunningOnClient\r\n * Checks if the code is running on the client.\r\n *\r\n * @returns {boolean} `true` if running on the client, otherwise `false`.\r\n */\r\n\r\n/**\r\n * Represents the possible runtime environments.\r\n *\r\n * - 'nodejs': Running in a Node.js environment.\r\n * - 'edge': Running in an Edge environment (e.g., Deno).\r\n * - 'client': Running in a client-side environment (e.g., browser).\r\n * - 'static': Running in a static environment.\r\n */\r\nexport type RuntimeConfig = 'nodejs' | 'edge' | 'client' | 'static' | 'server';\r\n\r\n/**\r\n * Determines the current runtime environment.\r\n *\r\n * @returns {RuntimeConfig} The current runtime environment.\r\n */\r\nconst currentRuntime: RuntimeConfig = (() => {\r\n  if (typeof window !== 'undefined') {\r\n    // Client-side detection\r\n    if ('Deno' in window) {\r\n      return 'edge';\r\n    } else if ('process' in window) {\r\n      return 'nodejs';\r\n    }\r\n    return 'client';\r\n  } else {\r\n    // Server-side detection\r\n    if (typeof process !== 'undefined') {\r\n      return 'nodejs';\r\n    }\r\n    return 'server';\r\n  }\r\n  return 'static';\r\n})();\r\n\r\n/**\r\n * Returns the current runtime environment.\r\n *\r\n * @returns {RuntimeConfig} The current runtime environment.\r\n */\r\nexport const runtime = (): RuntimeConfig => currentRuntime;\r\n\r\n/**\r\n * Checks if the code is running on the server.\r\n *\r\n * @returns {boolean} `true` if running on the server, otherwise `false`.\r\n */\r\nexport const isRunningOnServer = (): boolean => currentRuntime !== 'client';\r\n\r\n/**\r\n * Checks if the code is running on the client.\r\n *\r\n * @returns {boolean} `true` if running on the client, otherwise `false`.\r\n */\r\nexport const isRunningOnClient = (): boolean => currentRuntime === 'client';\r\n\r\n/**\r\n * Checks if the code is running on the edge.\r\n *\r\n * @returns {boolean} `true` if running on the edge, otherwise `false`.\r\n */\r\nexport const isRunningOnEdge = (): boolean =>\r\n  process.env.NEXT_RUNTIME === 'edge';\r\n\r\n/**\r\n * A collection of Zod processors for various environment variables.\r\n */\r\nexport const ZodProcessors = {\r\n  /**\r\n   * Processor for URL strings.\r\n   * Ensures the value is a valid URL and removes trailing slashes.\r\n   *\r\n   * @returns {ZodString} A Zod string schema for URLs.\r\n   */\r\n  url: (): z.ZodEffects<z.ZodString, string, string> =>\r\n    z.string().transform((val, ctx) => {\r\n      try {\r\n        const url = new URL(val);\r\n        // Remove trailing slash if present\r\n        return url.href.replace(/\\/$/, '');\r\n      } catch (error: unknown) {\r\n        ctx.addIssue({\r\n          code: z.ZodIssueCode.custom,\r\n          message: `Invalid URL: ${val} - ${LoggedError.isTurtlesAllTheWayDownBaby(error).message}`,\r\n        });\r\n        return z.NEVER;\r\n      }\r\n    }),\r\n  /**\r\n   * Processor for log level strings.\r\n   * Provides a default value of 'info' if not specified.\r\n   *\r\n   * @returns {ZodString} A Zod string schema for log levels.\r\n   */\r\n  logLevel: (level: string = 'info'): z.ZodDefault<z.ZodString> =>\r\n    z.string().default(level ?? 'info'),\r\n\r\n  aiModelType: (\r\n    defaultValue: AiModelType,\r\n  ): z.ZodDefault<z.ZodType<AiModelType, z.ZodTypeDef, unknown>> =>\r\n    z\r\n      .preprocess((val, ctx) => {\r\n        if (isAiModelType(val)) {\r\n          return val;\r\n        }\r\n        ctx.addIssue({\r\n          code: z.ZodIssueCode.custom,\r\n          message: `Invalid AI model type: ${val}`,\r\n          path: ctx.path,\r\n        });\r\n        return z.NEVER;\r\n      }, z.enum(AiModelTypeValues))\r\n      .default(defaultValue),\r\n  /**\r\n   * Processor for integer values.\r\n   * Ensures the value is a valid integer and provides a default value of 120 if not specified.\r\n   *\r\n   * @returns {ZodType<number, ZodTypeDef, unknown>} A Zod schema for integers.\r\n   */\r\n  integer: (): z.ZodType<number, z.ZodTypeDef, unknown> =>\r\n    z.preprocess((val) => {\r\n      if (typeof val === 'string') {\r\n        const parsed = parseInt(val, 10);\r\n        if (!isNaN(parsed)) {\r\n          return parsed;\r\n        }\r\n      }\r\n      return val;\r\n    }, z.number().int()),\r\n\r\n  /**\r\n   * Processor for boolean values.\r\n   * Ensures the value is a valid boolean and provides a default value of false if not specified.\r\n   *\r\n   * @returns {ZodBoolean} A Zod boolean schema.\r\n   */\r\n  boolean: (): z.ZodDefault<z.ZodBoolean> => z.boolean().default(false),\r\n\r\n  /**\r\n   * Processor for truthy boolean values.\r\n   * Ensures the value is a valid boolean and provides a default value if not specified.\r\n   *\r\n   * @returns {ZodBoolean} A Zod boolean schema.\r\n   */\r\n  truthy: (\r\n    defaultValue = false,\r\n  ): z.ZodType<boolean, z.ZodEffectsDef<z.ZodBoolean>, unknown> =>\r\n    z.preprocess(\r\n      (val: unknown) => {\r\n        return typeof val === undefined ||\r\n          val === null ||\r\n          (typeof val === 'string' && val.trim() === '')\r\n          ? !!defaultValue\r\n          : isTruthy(val);\r\n      },\r\n      z.boolean(),\r\n      z.boolean(),\r\n    ),\r\n\r\n  /**\r\n   * Processor for array values.\r\n   * Ensures the value is a valid array and provides a default value of an empty array if not specified.\r\n   *\r\n   * @returns {ZodArray} A Zod array schema.\r\n   */\r\n  array: (): z.ZodDefault<z.ZodArray<z.ZodUnknown>> =>\r\n    z.array(z.unknown()).default([]),\r\n\r\n  /**\r\n   * Processor for object values.\r\n   * Ensures the value is a valid object and provides a default value of an empty object if not specified.\r\n   *\r\n   * @returns {ZodObject} A Zod object schema.\r\n   */\r\n  object: (): z.ZodDefault<z.ZodObject<z.ZodRawShape>> =>\r\n    z.object({}).default({}),\r\n\r\n  /**\r\n   * Trimmed nullable string processor\r\n   * @returns\r\n   */\r\n  nullableString: (): z.ZodEffects<\r\n    z.ZodNullable<z.ZodString>,\r\n    string | null,\r\n    string | null\r\n  > =>\r\n    z\r\n      .string()\r\n      .nullable()\r\n      .transform((val) => (val ? val.trim() : null)),\r\n};\r\n\r\n/**\r\n * Retrieves environment variable values from the provided source object,\r\n * giving precedence to `process.env` values if they exist and are non-empty.\r\n * @param source The source value to read from.\r\n * @returns A record with keys from the source and values from either process.env or the source.\r\n */\r\nexport const getMappedSource = <\r\n  TSource extends Record<string, string | number | undefined>,\r\n>(\r\n  source: TSource,\r\n): Record<keyof TSource, string | number | undefined> => {\r\n  // Handle environments where process.env does not exist (eg client)\r\n  if (\r\n    typeof process !== 'object' ||\r\n    !process ||\r\n    typeof process.env !== 'object' ||\r\n    !process.env\r\n  ) {\r\n    return source;\r\n  }\r\n  const getRawValue = (key: keyof TSource): string | number | undefined => {\r\n    const envValue = process.env[key as string];\r\n    if (typeof envValue === 'string' && envValue.trim() !== '') {\r\n      return envValue;\r\n    }\r\n    return source[key];\r\n  };\r\n  return Object.keys(source).reduce(\r\n    (acc, key) => {\r\n      acc[key as keyof TSource] = getRawValue(key as keyof TSource);\r\n      return acc;\r\n    },\r\n    {} as Record<keyof TSource, string | number | undefined>,\r\n  );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\env\\_server.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":13,"column":1,"nodeType":"Program","endLine":592,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Server-side environment variable configuration and validation\r\n *\r\n * This module provides type-safe access to server-only environment variables\r\n * with Zod schema validation. It extends the client environment variables\r\n * with additional server-specific configuration for databases, AI services,\r\n * authentication providers, and other server-only resources.\r\n *\r\n * @author NoEducation Platform Team\r\n * @version 1.0.0\r\n */\r\n\r\nimport { z } from 'zod';\r\nimport { getMappedSource, isRunningOnClient, ZodProcessors } from './_common';\r\nimport {\r\n  clientEnvFactory,\r\n  clientRawInstance,\r\n  clientEnvSchema,\r\n} from './_client';\r\nimport { AiModelType } from '@/lib/ai/core';\r\n\r\n/**\r\n * Builds the raw environment variable instance by merging client variables\r\n * with server-specific environment variables from process.env.\r\n *\r\n * @returns Raw object containing all environment variables before validation\r\n * @internal\r\n */\r\nconst buildRawInstance = () => {\r\n  const raw = {\r\n    ...clientRawInstance,\r\n    /** Server-side logging level - controls verbosity of server logs. Example: 'debug', 'info', 'warn', 'error' */\r\n    LOG_LEVEL_SERVER: process.env.LOG_LEVEL_SERVER ?? 'warn',\r\n    /** Primary database connection URL for pooled connections. Example: 'postgresql://user:pass@host:5432/dbname' */\r\n    DATABASE_URL: process.env.DATABASE_URL,\r\n    /** Database connection URL for direct/unpooled connections. Example: 'postgresql://user:pass@host:5432/dbname?pgbouncer=true' */\r\n    DATABASE_URL_UNPOOLED: process.env.DATABASE_URL_UNPOOLED,\r\n    /** Azure OpenAI service endpoint URL. Example: 'https://myopenai.openai.azure.com/' */\r\n    AZURE_OPENAI_ENDPOINT: process.env.AZURE_OPENAI_ENDPOINT,\r\n    /** Azure OpenAI API key for authentication. Example: 'abc123def456...' */\r\n    AZURE_API_KEY: process.env.AZURE_API_KEY,\r\n    /** Azure AI Search service endpoint URL. Example: 'https://mysearch.search.windows.net' */\r\n    AZURE_AISEARCH_ENDPOINT: process.env.AZURE_AISEARCH_ENDPOINT,\r\n    /** Azure AI Search service API key. Example: 'xyz789abc456...' */\r\n    AZURE_AISEARCH_KEY: process.env.AZURE_AISEARCH_KEY,\r\n    /** Azure AI Search index name for document storage. Example: 'documents-prod' */\r\n    AZURE_AISEARCH_DOCUMENTS_INDEX_NAME:\r\n      process.env.AZURE_AISEARCH_DOCUMENTS_INDEX_NAME,\r\n    /** Azure OpenAI deployment name for chat models. Example: 'gpt-4-turbo' */\r\n    AZURE_OPENAI_DEPLOYMENT_CHAT: process.env.AZURE_OPENAI_DEPLOYMENT_CHAT,\r\n    /** Azure OpenAI deployment name for embedding models. Example: 'text-embedding-ada-002' */\r\n    AZURE_OPENAI_DEPLOYMENT_EMBEDDING:\r\n      process.env.AZURE_OPENAI_DEPLOYMENT_EMBEDDING,\r\n    /** Azure OpenAI endpoint URL for embedding services. Example: 'https://myembeddings.openai.azure.com/' */\r\n    AZURE_OPENAI_ENDPOINT_EMBEDDING: process.env.AZURE_OPENAI_ENDPOINT,\r\n    /** Azure OpenAI API key for embedding services. Example: 'embed123key456...' */\r\n    AZURE_OPENAI_KEY_EMBEDDING: process.env.AZURE_OPENAI_KEY_EMBEDDING,\r\n    /** Azure OpenAI deployment name for completion models. Example: 'gpt-35-turbo' */\r\n    AZURE_OPENAI_DEPLOYMENT_COMPLETIONS:\r\n      process.env.AZURE_OPENAI_DEPLOYMENT_COMPLETIONS,\r\n    /** Azure OpenAI endpoint URL for completion services. Example: 'https://mycompletions.openai.azure.com/' */\r\n    AZURE_OPENAI_ENDPOINT_COMPLETIONS:\r\n      process.env.AZURE_OPENAI_ENDPOINT_COMPLETIONS,\r\n    /** Azure OpenAI API key for completion services. Example: 'comp789key012...' */\r\n    AZURE_OPENAI_KEY_COMPLETIONS: process.env.AZURE_OPENAI_KEY_COMPLETIONS,\r\n    /** Azure AI Search index name for policy document storage. Example: 'policies-prod' */\r\n    AZURE_AISEARCH_POLICY_INDEX_NAME:\r\n      process.env.AZURE_AISEARCH_POLICY_INDEX_NAME,\r\n    /** Vector dimension size for small embeddings in Azure AI Search. Example: '1536' */\r\n    AZURE_AISEARCH_VECTOR_SIZE_SMALL:\r\n      process.env.AZURE_AISEARCH_VECTOR_SIZE_SMALL,\r\n    /** Vector dimension size for large embeddings in Azure AI Search. Example: '3072' */\r\n    AZURE_AISEARCH_VECTOR_SIZE_LARGE:\r\n      process.env.AZURE_AISEARCH_VECTOR_SIZE_LARGE,\r\n    /** Token overlap count when splitting documents for indexing. Example: '20' */\r\n    AZURE_AISEARCH_DOCUMENT_SPLITTER_OVERLAP:\r\n      process.env.AZURE_AISEARCH_DOCUMENT_SPLITTER_OVERLAP,\r\n    /** Maximum tokens per document chunk during splitting. Example: '512' */\r\n    AZURE_AISEARCH_DOCUMENT_SPLITTER_MAX_TOKENS:\r\n      process.env.AZURE_AISEARCH_DOCUMENT_SPLITTER_MAX_TOKENS,\r\n    /** Google OAuth 2.0 client ID for authentication. Example: '123456789-abcdef.apps.googleusercontent.com' */\r\n    AUTH_GOOGLE_ID: process.env.AUTH_GOOGLE_ID,\r\n    /** Google OAuth 2.0 client secret for authentication. Example: 'GOCSPX-1234567890abcdef...' */\r\n    AUTH_GOOGLE_SECRET: process.env.AUTH_GOOGLE_SECRET,\r\n    /** Google API key for service access. Example: 'AIzaSyD1234567890abcdef...' */\r\n    AUTH_GOOGLE_APIKEY: process.env.AUTH_GOOGLE_APIKEY,\r\n    /** HTTP header name for authentication bypass in development. Example: 'x-auth-bypass-key' */\r\n    AUTH_HEADER_BYPASS_KEY: process.env.AUTH_HEADER_BYPASS_KEY,\r\n    /** HTTP header value for authentication bypass in development. Example: 'dev-secret-123' */\r\n    AUTH_HEADER_BYPASS_VALUE: process.env.AUTH_HEADER_BYPASS_VALUE,\r\n    /*\r\n    AZURE_MONITOR_CONNECTION_STRING:\r\n      process.env.AZURE_MONITOR_CONNECTION_STRING,\r\n    */\r\n    /** Azure Monitor Application Insights connection string. Example: 'InstrumentationKey=12345678-1234-1234-1234-123456789012' */\r\n    AZURE_MONITOR_CONNECTION_STRING:\r\n      process.env.AZURE_MONITOR_CONNECTION_STRING,\r\n    /** Azure Storage account connection string. Example: 'DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=...' */\r\n    AZURE_STORAGE_CONNECTION_STRING:\r\n      process.env.AZURE_STORAGE_CONNECTION_STRING,\r\n    /** Azure Storage account access key. Example: 'wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY' */\r\n    AZURE_STORAGE_ACCOUNT_KEY: process.env.AZURE_STORAGE_ACCOUNT_KEY,\r\n    /** Azure Storage account name. Example: 'mystorageaccount' */\r\n    AZURE_STORAGE_ACCOUNT_NAME: process.env.AZURE_STORAGE_ACCOUNT_NAME,\r\n    /*** Flagsmith server-side SDK key, supporting update and privledged server-side reads */\r\n    FLAGSMITH_SDK_KEY: process.env.FLAGSMITH_SDK_KEY,\r\n    /** Google Generative AI API key for Gemini models. Example: 'AIzaSyA1234567890abcdef...' */\r\n    GOOGLE_GENERATIVE_AI_API_KEY: process.env.GOOGLE_GENERATIVE_AI_API_KEY,\r\n    /** Google Generative AI service base URL. Example: 'https://generativelanguage.googleapis.com/v1beta' */\r\n    GOOGLE_GENERATIVE_AI_BASE_URL: process.env.GOOGLE_GENERATIVE_AI_BASE_URL,\r\n    /** Google Generative AI high-fidelity model name. Example: 'gemini-2.0-flash-exp' */\r\n    GOOGLE_GENERATIVE_HIFI: process.env.GOOGLE_GENERATIVE_HIFI,\r\n    /** Google Generative AI low-fidelity/fast model name. Example: 'gemini-2.0-flash' */\r\n    GOOGLE_GENERATIVE_LOFI: process.env.GOOGLE_GENERATIVE_LOFI,\r\n    /** Google Generative AI embedding model name. Example: 'text-embedding-004' */\r\n    GOOGLE_GENERATIVE_EMBEDDING: process.env.GOOGLE_GENERATIVE_EMBEDDING,\r\n    /** Keycloak OAuth client ID for authentication. Example: 'web-app-client' */\r\n    AUTH_KEYCLOAK_CLIENT_ID: process.env.AUTH_KEYCLOAK_CLIENT_ID,\r\n    /** Keycloak OAuth client secret for authentication. Example: 'abc123-def456-ghi789' */\r\n    AUTH_KEYCLOAK_CLIENT_SECRET: process.env.AUTH_KEYCLOAK_CLIENT_SECRET,\r\n    /** Keycloak audience for impersonation tokens. Example: 'admin-cli' */\r\n    AUTH_KEYCLOAK_IMPERSONATION_AUDIENCE:\r\n      process.env.AUTH_KEYCLOAK_IMPERSONATION_AUDIENCE,\r\n    /** Keycloak issuer URL for token validation. Example: 'https://auth.example.com/realms/myrealm' */\r\n    AUTH_KEYCLOAK_ISSUER: process.env.AUTH_KEYCLOAK_ISSUER,\r\n    /** Keycloak redirect URI for authentication callbacks. Example: 'https://app.example.com/auth/callback' */\r\n    AUTH_KEYCLOAK_REDIRECT_URI: process.env.AUTH_KEYCLOAK_REDIRECT_URI,\r\n    /** Keycloak impersonator username for user impersonation tokens (optional). Example: admin */\r\n    AUTH_KEYCLOAK_IMPERSONATOR_USERNAME:\r\n      process.env.AUTH_KEYCLOAK_IMPERSONATOR_USERNAME,\r\n    /** Keycloak impersonator password for user impersonation tokens (optional). Example: admin */\r\n    AUTH_KEYCLOAK_IMPERSONATOR_PASSWORD:\r\n      process.env.AUTH_KEYCLOAK_IMPERSONATOR_PASSWORD,\r\n    /** Keycloak impersonator offline token for user impersonation tokens (optional). Example: admin */\r\n    AUTH_KEYCLOAK_IMPERSONATOR_OFFLINE_TOKEN:\r\n      process.env.AUTH_KEYCLOAK_IMPERSONATOR_OFFLINE_TOKEN,\r\n    /** Redis connection URL for caching and session storage. Example: 'redis://localhost:6379' */\r\n    REDIS_URL: process.env.REDIS_URL,\r\n    /** Redis password for authentication. Example: 'redis-secret-password' */\r\n    REDIS_PASSWORD: process.env.REDIS_PASSWORD,\r\n    /** User ID to bypass authentication in local development. Example: 'dev-user-123' */\r\n    LOCAL_DEV_AUTH_BYPASS_USER_ID: process.env.LOCAL_DEV_AUTH_BYPASS_USER_ID,\r\n    /** Flag to disable Mem0 memory service integration. Example: 'true' or 'false' */\r\n    MEM0_DISABLED: process.env.MEM0_DISABLED,\r\n    /** Mem0 API service host URL. Example: 'https://api.mem0.ai' */\r\n    MEM0_API_HOST: process.env.MEM0_API_HOST,\r\n    /** Mem0 UI dashboard host URL. Example: 'https://app.mem0.ai' */\r\n    MEM0_UI_HOST: process.env.MEM0_UI_HOST,\r\n    /** Mem0 service username for authentication. Example: 'user@example.com' */\r\n    MEM0_USERNAME: process.env.MEM0_USERNAME,\r\n    /** Mem0 organization ID for scoping. Example: 'org_1234567890abcdef' */\r\n    MEM0_ORG_ID: process.env.MEM0_ORG_ID,\r\n    /** Mem0 project ID for scoping. Example: 'proj_abcdef1234567890' */\r\n    MEM0_PROJECT_ID: process.env.MEM0_PROJECT_ID,\r\n    /** Mem0 API key for service authentication. Example: 'mem0_sk_1234567890abcdef...' */\r\n    MEM0_API_KEY: process.env.MEM0_API_KEY,\r\n    /** Node.js environment mode. Example: 'development', 'production', 'test' */\r\n    NODE_ENV: process.env.NODE_ENV,\r\n    /** OpenAI API key for direct OpenAI service access. Example: 'sk-1234567890abcdef...' */\r\n    OPENAI_API_KEY: process.env.OPENAI_API_KEY,\r\n    /** OpenAI high-fidelity model name for complex tasks. Example: 'gpt-4-turbo' */\r\n    OPENAI_HIFI: process.env.OPENAI_HIFI,\r\n    /** OpenAI low-fidelity/fast model name for simple tasks. Example: 'gpt-3.5-turbo' */\r\n    OPENAI_LOFI: process.env.OPENAI_LOFI,\r\n    /** OpenAI embedding model name for vector generation. Example: 'text-embedding-3-large' */\r\n    OPENAI_EMBEDDING: process.env.OPENAI_EMBEDDING,\r\n    /** Maximum token threshold for AI batch processing. Example: '50000' */\r\n    TOKEN_BATCH_THRESHOLD: process.env.TOKEN_BATCH_THRESHOLD,\r\n  };\r\n  if (!raw.AUTH_KEYCLOAK_REDIRECT_URI) {\r\n    raw.AUTH_KEYCLOAK_REDIRECT_URI = new URL(\r\n      `/api/auth/callback/keycloak`,\r\n      process.env.NEXT_PUBLIC_HOSTNAME,\r\n    ).toString();\r\n  }\r\n  return getMappedSource(raw);\r\n};\r\n\r\n/*\r\nconst literals = AiModelTypeValues.map((v) => z.literal(v));\r\nconst ZodAiModelType = () =>\r\n  z.union([literals[0], literals[1], ...literals.slice(2)]);\r\nconst ZodAiModelType = () => z.enum(AiModelTypeValues);\r\n*/\r\n/**\r\n * Zod schema definition for validating and transforming server-side environment variables.\r\n * Provides type safety, default values, and validation rules for all server configuration.\r\n */\r\nconst serverEnvSchema = z\r\n  .object({\r\n    LOG_LEVEL_SERVER: ZodProcessors.logLevel().describe(\r\n      'Server-side logging level for application logs. Example: debug, info, warn, error',\r\n    ),\r\n    DATABASE_URL: ZodProcessors.url().describe(\r\n      'Primary PostgreSQL database connection URL with connection pooling. Example: postgresql://user:pass@host:5432/dbname',\r\n    ),\r\n    DATABASE_URL_UNPOOLED: ZodProcessors.url()\r\n      .optional()\r\n      .describe(\r\n        'Direct PostgreSQL database connection URL without pooling (optional). Example: postgresql://user:pass@host:5432/dbname?pgbouncer=true',\r\n      ),\r\n    AZURE_OPENAI_ENDPOINT: ZodProcessors.url().describe(\r\n      'Azure OpenAI service endpoint URL for AI model access. Example: https://myopenai.openai.azure.com/',\r\n    ),\r\n    AZURE_API_KEY: z\r\n      .string()\r\n      .min(1)\r\n      .describe(\r\n        'Azure OpenAI API key for service authentication. Example: abc123def456...',\r\n      ),\r\n    AZURE_AISEARCH_ENDPOINT: ZodProcessors.url().describe(\r\n      'Azure AI Search service endpoint URL for document indexing. Example: https://mysearch.search.windows.net',\r\n    ),\r\n    AZURE_AISEARCH_KEY: z\r\n      .string()\r\n      .min(1)\r\n      .describe(\r\n        'Azure AI Search API key for service authentication. Example: xyz789abc456...',\r\n      ),\r\n    AZURE_AISEARCH_DOCUMENTS_INDEX_NAME: z\r\n      .string()\r\n      .min(1)\r\n      .describe(\r\n        'Azure AI Search index name for storing document vectors and metadata. Example: documents-prod',\r\n      ),\r\n    AZURE_OPENAI_DEPLOYMENT_CHAT: z\r\n      .string()\r\n      .optional()\r\n      .default('gpt-4.1' as AiModelType)\r\n      .describe(\r\n        'Azure OpenAI deployment name for chat completions. Default: gpt-4.1. Example: gpt-4-turbo',\r\n      ),\r\n    AZURE_OPENAI_DEPLOYMENT_EMBEDDING: z\r\n      .string()\r\n      .optional()\r\n      .default('text-embedding-3-large' as AiModelType)\r\n      .describe(\r\n        'Azure OpenAI deployment name for text embeddings. Default: text-embedding-3-large. Example: text-embedding-ada-002',\r\n      ),\r\n    AZURE_OPENAI_ENDPOINT_EMBEDDING: z\r\n      .string()\r\n      .default(process.env.AZURE_OPENAI_ENDPOINT ?? '')\r\n      .describe(\r\n        'Azure OpenAI endpoint URL for embedding services (fallback to main endpoint). Example: https://myembeddings.openai.azure.com/',\r\n      ),\r\n    AZURE_OPENAI_KEY_EMBEDDING: z\r\n      .string()\r\n      .default(process.env.AZURE_OPENAI_KEY ?? '')\r\n      .describe(\r\n        'Azure OpenAI API key for embedding services (fallback to main key). Example: embed123key456...',\r\n      ),\r\n    AZURE_OPENAI_DEPLOYMENT_HIFI: z\r\n      .string()\r\n      .optional()\r\n      .default('gpt-4.1' as AiModelType)\r\n      .describe(\r\n        'Azure OpenAI deployment name for high-fidelity chat models. Default: gpt-4.1. Example: gpt-4-turbo',\r\n      ),\r\n    AZURE_OPENAI_DEPLOYMENT_LOFI: z\r\n      .string()\r\n      .optional()\r\n      .default('gpt-4o-mini' as AiModelType)\r\n      .describe(\r\n        'Azure OpenAI deployment name for low-fidelity/fast chat models. Default: gpt-4o-mini. Example: gpt-35-turbo',\r\n      ),\r\n    AZURE_OPENAI_DEPLOYMENT_COMPLETIONS: z\r\n      .string()\r\n      .optional()\r\n      .default('gpt-4o-mini' as AiModelType)\r\n      .describe(\r\n        'Azure OpenAI deployment name for text completions. Default: gpt-4o-mini. Example: gpt-35-turbo',\r\n      ),\r\n    AZURE_OPENAI_ENDPOINT_COMPLETIONS: z\r\n      .string()\r\n      .default(process.env.AZURE_OPENAI_ENDPOINT ?? '')\r\n      .describe(\r\n        'Azure OpenAI endpoint URL for completion services (fallback to main endpoint). Example: https://mycompletions.openai.azure.com/',\r\n      ),\r\n    AZURE_OPENAI_KEY_COMPLETIONS: z\r\n      .string()\r\n      .default(process.env.AZURE_OPENAI_KEY ?? '')\r\n      .describe(\r\n        'Azure OpenAI API key for completion services (fallback to main key). Example: comp789key012...',\r\n      ),\r\n    AZURE_AISEARCH_POLICY_INDEX_NAME: z\r\n      .string()\r\n      .min(1)\r\n      .describe(\r\n        'Azure AI Search index name for storing policy document vectors and metadata. Example: policies-prod',\r\n      ),\r\n    AZURE_AISEARCH_VECTOR_SIZE_SMALL: z\r\n      .number()\r\n      .default(1536)\r\n      .describe(\r\n        'Vector dimension size for small embeddings in Azure AI Search. Default: 1536. Example: 1536',\r\n      ),\r\n    AZURE_AISEARCH_VECTOR_SIZE_LARGE: z\r\n      .number()\r\n      .default(3072)\r\n      .describe(\r\n        'Vector dimension size for large embeddings in Azure AI Search. Default: 3072. Example: 3072',\r\n      ),\r\n    AZURE_AISEARCH_DOCUMENT_SPLITTER_OVERLAP: z\r\n      .number()\r\n      .default(15)\r\n      .describe(\r\n        'Token overlap count when splitting documents for search indexing. Default: 15. Example: 20',\r\n      ),\r\n    AZURE_AISEARCH_DOCUMENT_SPLITTER_MAX_TOKENS: z\r\n      .number()\r\n      .default(512)\r\n      .describe(\r\n        'Maximum tokens per document chunk during splitting for indexing. Default: 512. Example: 512',\r\n      ),\r\n    TOKEN_BATCH_THRESHOLD: z\r\n      .number()\r\n      .default(50000)\r\n      .describe(\r\n        'Maximum cumulative token count (approx) per AI preprocessing batch when grouping case file documents with shared goals. Documents are accumulated until the next document would exceed this threshold, then a batch processing call is executed. Tuned to balance prompt size vs. parallelism. Override via env TOKEN_BATCH_THRESHOLD; defaults to 50,000 tokens. Example: 75000 for larger batches, 25000 for smaller batches',\r\n      ),\r\n    AUTH_GOOGLE_ID: z\r\n      .string()\r\n      .describe(\r\n        'Google OAuth 2.0 client ID for user authentication. Example: 123456789-abcdef.apps.googleusercontent.com',\r\n      ),\r\n    AUTH_GOOGLE_SECRET: z\r\n      .string()\r\n      .describe(\r\n        'Google OAuth 2.0 client secret for authentication flow. Example: GOCSPX-1234567890abcdef...',\r\n      ),\r\n    AUTH_GOOGLE_APIKEY: z\r\n      .string()\r\n      .describe(\r\n        'Google API key for accessing Google services (Gmail, Drive, etc.). Example: AIzaSyD1234567890abcdef...',\r\n      ),\r\n    AUTH_HEADER_BYPASS_KEY: z\r\n      .string()\r\n      .optional()\r\n      .describe(\r\n        'HTTP header name for development authentication bypass (optional). Example: x-auth-bypass-key',\r\n      ),\r\n    AUTH_HEADER_BYPASS_VALUE: z\r\n      .string()\r\n      .optional()\r\n      .describe(\r\n        'HTTP header value for development authentication bypass (optional). Example: dev-secret-123',\r\n      ),\r\n    AZURE_STORAGE_CONNECTION_STRING: z\r\n      .string()\r\n      .min(1)\r\n      .describe(\r\n        'Azure Storage account connection string for blob storage. Example: DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=...',\r\n      ),\r\n    AZURE_STORAGE_ACCOUNT_KEY: z\r\n      .string()\r\n      .min(1)\r\n      .describe(\r\n        'Azure Storage account access key for authentication. Example: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY',\r\n      ),\r\n    AZURE_STORAGE_ACCOUNT_NAME: z\r\n      .string()\r\n      .min(1)\r\n      .describe(\r\n        'Azure Storage account name for blob and file operations. Example: mystorageaccount',\r\n      ),\r\n    FLAGSMITH_SDK_KEY: z\r\n      .string()\r\n      .min(1)\r\n      .describe(\r\n        'Flagsmith server-side SDK key for feature flag management and privileged reads.',\r\n      ),\r\n    GOOGLE_GENERATIVE_AI_API_KEY: z\r\n      .string()\r\n      .min(1)\r\n      .optional()\r\n      .describe(\r\n        'Google Generative AI API key for Gemini model access (optional). Example: AIzaSyA1234567890abcdef...',\r\n      ),\r\n    GOOGLE_GENERATIVE_AI_BASE_URL: ZodProcessors.url()\r\n      .default('https://generativelanguage.googleapis.com/v1beta')\r\n      .describe(\r\n        'Google Generative AI service base URL. Default: https://generativelanguage.googleapis.com/v1beta. Example: https://generativelanguage.googleapis.com/v1beta',\r\n      ),\r\n    GOOGLE_GENERATIVE_HIFI: z\r\n      .string()\r\n      .optional()\r\n      .default('gemini-2.5-pro' as AiModelType)\r\n      .describe(\r\n        'Google Generative AI high-fidelity model name. Default: gemini-2.5-pro. Example: gemini-2.0-flash-exp',\r\n      ),\r\n    GOOGLE_GENERATIVE_LOFI: z\r\n      .string()\r\n      .optional()\r\n      .default('gemini-2.5-flash' as AiModelType)\r\n      .describe(\r\n        'Google Generative AI low-fidelity/fast model name. Default: gemini-2.5-flash. Example: gemini-2.0-flash',\r\n      ),\r\n    GOOGLE_GENERATIVE_EMBEDDING: z\r\n      .string()\r\n      .optional()\r\n      .default('google-embedding' as AiModelType)\r\n      .describe(\r\n        'Google Generative AI embedding model name. Default: google-embedding. Example: text-embedding-004',\r\n      ),\r\n    AUTH_KEYCLOAK_CLIENT_ID: z\r\n      .string()\r\n      .min(1)\r\n      .optional()\r\n      .describe(\r\n        'Keycloak OAuth client ID for authentication (optional). Example: web-app-client',\r\n      ),\r\n    AUTH_KEYCLOAK_CLIENT_SECRET: z\r\n      .string()\r\n      .min(1)\r\n      .optional()\r\n      .describe(\r\n        'Keycloak OAuth client secret for authentication (optional). Example: abc123-def456-ghi789',\r\n      ),\r\n    AUTH_KEYCLOAK_ISSUER: z\r\n      .string()\r\n      .min(1)\r\n      .default(\r\n        'https://login.jollybush-836e15bc.westus3.azurecontainerapps.io/',\r\n      )\r\n      .optional()\r\n      .describe(\r\n        'Keycloak issuer URL for token validation. Default: development instance (optional). Example: https://auth.example.com/realms/myrealm',\r\n      ),\r\n    AUTH_KEYCLOAK_IMPERSONATION_AUDIENCE: z\r\n      .string()\r\n      .optional()\r\n      .describe(\r\n        'Keycloak audience for user impersonation tokens (optional). Example: admin-cli',\r\n      ),\r\n    AUTH_KEYCLOAK_REDIRECT_URI: z\r\n      .string()\r\n      .describe(\r\n        'Keycloak redirect URI for user impersonation tokens (optional). Example: https://auth.example.com/realms/myrealm/protocol/openid-connect/auth',\r\n      ),\r\n    AUTH_KEYCLOAK_IMPERSONATOR_USERNAME: z\r\n      .string()\r\n      .optional()\r\n      .describe(\r\n        'Keycloak impersonator username for user impersonation tokens (optional). Example: admin',\r\n      ),\r\n    AUTH_KEYCLOAK_IMPERSONATOR_PASSWORD: z\r\n      .string()\r\n      .optional()\r\n      .describe(\r\n        'Keycloak impersonator password for user impersonation tokens (optional). Example: admin',\r\n      ),\r\n    AUTH_KEYCLOAK_IMPERSONATOR_OFFLINE_TOKEN: z\r\n      .string()\r\n      .optional()\r\n      .describe(\r\n        'Keycloak impersonator offline token for user impersonation tokens (optional). Example: admin',\r\n      ),\r\n    REDIS_URL: z\r\n      .string()\r\n      .min(1)\r\n      .describe(\r\n        'Redis server connection URL for caching and session storage. Example: redis://localhost:6379',\r\n      ),\r\n    REDIS_PASSWORD: z\r\n      .string()\r\n      .min(1)\r\n      .describe(\r\n        'Redis server authentication password. Example: redis-secret-password',\r\n      ),\r\n    LOCAL_DEV_AUTH_BYPASS_USER_ID: z\r\n      .string()\r\n      .optional()\r\n      .describe(\r\n        'User ID for bypassing authentication in local development (optional). Example: dev-user-123',\r\n      ),\r\n    MEM0_DISABLED: ZodProcessors.truthy(false).describe(\r\n      'Flag to disable Mem0 memory service integration. Default: false. Example: true or false',\r\n    ),\r\n    MEM0_API_HOST: ZodProcessors.url().describe(\r\n      'Mem0 API service host URL for memory operations. Example: https://api.mem0.ai',\r\n    ),\r\n    MEM0_UI_HOST: ZodProcessors.url().describe(\r\n      'Mem0 UI dashboard host URL for memory management. Example: https://app.mem0.ai',\r\n    ),\r\n    MEM0_USERNAME: z\r\n      .string()\r\n      .min(1)\r\n      .describe(\r\n        'Mem0 service username for authentication. Example: user@example.com',\r\n      ),\r\n    MEM0_ORG_ID: ZodProcessors.nullableString()\r\n      .default(null)\r\n      .describe(\r\n        'Mem0 organization ID for account scoping. Default: null. Example: org_1234567890abcdef',\r\n      ),\r\n    MEM0_PROJECT_ID: ZodProcessors.nullableString()\r\n      .default(null)\r\n      .describe(\r\n        'Mem0 project ID for resource scoping. Default: null. Example: proj_abcdef1234567890',\r\n      ),\r\n    MEM0_API_KEY: z\r\n      .string()\r\n      .optional()\r\n      .default('SKYNET')\r\n      .describe(\r\n        'Mem0 API key for service authentication. Default: SKYNET. Example: mem0_sk_1234567890abcdef...',\r\n      ),\r\n    NODE_ENV: z\r\n      .string()\r\n      .describe(\r\n        'Node.js runtime environment mode. Example: development, production, test',\r\n      ),\r\n    OPENAI_API_KEY: z\r\n      .string()\r\n      .optional() // NOTE OpenAI direct model access not required\r\n      .describe(\r\n        'OpenAI API key for direct OpenAI service access (optional - Azure OpenAI preferred). Example: sk-1234567890abcdef...',\r\n      ),\r\n    OPENAI_HIFI: z\r\n      .string()\r\n      .optional()\r\n      .default('gpt-5' as AiModelType)\r\n      .describe(\r\n        'OpenAI high-fidelity model name for complex reasoning tasks. Default: gpt-5. Example: gpt-4-turbo',\r\n      ),\r\n    OPENAI_LOFI: z\r\n      .string()\r\n      .optional()\r\n      .default('gpt-5-mini' as AiModelType)\r\n      .describe(\r\n        'OpenAI low-fidelity/fast model name for simple tasks. Default: gpt-5-mini. Example: gpt-3.5-turbo',\r\n      ),\r\n    OPENAI_EMBEDDING: z\r\n      .string()\r\n      .optional()\r\n      .default('text-embedding-3-large' as AiModelType)\r\n      .describe(\r\n        'OpenAI embedding model name for vector generation. Default: text-embedding-3-large. Example: text-embedding-3-large',\r\n      ),\r\n  })\r\n  .extend(clientEnvSchema.shape); // Include all client env vars as well\r\n\r\n/**\r\n * TypeScript type definition for validated server environment variables.\r\n * Inferred from the Zod schema to ensure type safety across the application.\r\n */\r\nexport type ServerEnvType = ReturnType<typeof serverEnvSchema.parse>;\r\n\r\n/**\r\n * Factory function for creating validated server environment configuration.\r\n *\r\n * This function provides type-safe access to server-side environment variables\r\n * with comprehensive validation and fallback handling. It ensures that all\r\n * required configuration is present and valid before the application starts.\r\n *\r\n * @returns Validated server environment configuration object\r\n *\r\n * @throws {ZodError} When required environment variables are missing or invalid\r\n *\r\n * @example\r\n * ```typescript\r\n * // Get validated server environment\r\n * const env = serverEnvFactory();\r\n *\r\n * // Access configuration with full type safety\r\n * const dbUrl = env.DATABASE_URL;\r\n * const aiModel = env.AZURE_OPENAI_DEPLOYMENT_HIFI;\r\n * const logLevel = env.LOG_LEVEL_SERVER;\r\n * ```\r\n *\r\n * @remarks\r\n * - Returns empty object when running on client-side (SSR safety)\r\n * - Falls back to client environment if DATABASE_URL is missing\r\n * - Validates all environment variables against their schemas\r\n * - Provides default values for optional configuration\r\n */\r\nexport const serverEnvFactory = (): ServerEnvType => {\r\n  try {\r\n    return isRunningOnClient()\r\n      ? ({} as ServerEnvType)\r\n      : serverEnvSchema.parse(buildRawInstance());\r\n  } catch (e) {\r\n    // Check an environment variable to verify really are running on server\r\n    if ((process.env.DATABASE_URL ?? '').length === 0) {\r\n      // We aren't - suppress (arguably could return client here)\r\n      return clientEnvFactory() as unknown as ServerEnvType;\r\n    }\r\n    // Otherwise, rethrow the error\r\n    throw e;\r\n  }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\env\\index.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\env\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\feature-flags\\client.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\feature-flags\\client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\feature-flags\\context.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\feature-flags\\context.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":68,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createContext, useContext } from 'react';\r\nimport {\r\n  AllFeatureFlagsDefault,\r\n  type KnownFeatureType,\r\n  type FeatureFlagStatus,\r\n} from './known-feature';\r\n\r\n/**\r\n * Lightweight feature flags API and provider.\r\n * This module is intentionally independent of Flagsmith's React bindings\r\n * so it can be used in server-rendered pages and hydrated on the client.\r\n */\r\nexport type FeatureFlagsApi = {\r\n  getFlag: (\r\n    key: KnownFeatureType,\r\n    defaultValue?: FeatureFlagStatus,\r\n  ) => FeatureFlagStatus;\r\n  getFlags: (\r\n    keys: KnownFeatureType[],\r\n    defaults?: FeatureFlagStatus[],\r\n  ) => FeatureFlagStatus[];\r\n  getAllFlags: () => Partial<Record<KnownFeatureType, FeatureFlagStatus>>;\r\n  isEnabled: (key: KnownFeatureType | string) => boolean;\r\n  getFlagState: (key: KnownFeatureType | string) => {\r\n    value: FeatureFlagStatus | undefined;\r\n    isLoading: boolean;\r\n    error: null;\r\n  };\r\n  readonly isLoaded: boolean;\r\n  readonly error?: Error | null;\r\n  readonly isFetching: boolean;\r\n  readonly isDefault?: true;\r\n};\r\n\r\nexport const defaultFlags = AllFeatureFlagsDefault as unknown as Record<\r\n  KnownFeatureType,\r\n  FeatureFlagStatus\r\n>;\r\n\r\nexport const FeatureFlagsContext = createContext<FeatureFlagsApi | undefined>(\r\n  undefined,\r\n);\r\n\r\nexport function useFeatureFlagsContext(): FeatureFlagsApi {\r\n  const ctx = useContext(FeatureFlagsContext);\r\n  if (!ctx) {\r\n    return {\r\n      getFlag: (key, defaultValue) => defaultFlags[key] ?? defaultValue,\r\n      getFlags: (keys, defaults) =>\r\n        keys.map((k, i) => defaultFlags[k] ?? defaults?.[i]),\r\n      getAllFlags: () => ({ ...defaultFlags }),\r\n      isEnabled: (key) =>\r\n        Boolean(defaultFlags[key as KnownFeatureType] ?? false),\r\n      getFlagState: (key) => ({\r\n        value: defaultFlags[key as KnownFeatureType],\r\n        isLoading: false,\r\n        error: null,\r\n      }),\r\n      isLoaded: false,\r\n      isFetching: true,\r\n      isDefault: true,\r\n    } as FeatureFlagsApi;\r\n  }\r\n  return ctx;\r\n}\r\n\r\nexport default FeatureFlagsContext;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\feature-flags\\index.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\feature-flags\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\feature-flags\\known-feature.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\feature-flags\\known-feature.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\feature-flags\\server.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\feature-flags\\server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\format.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\format.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\metrics\\index.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\metrics\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\url-builder\\_from-map.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":422,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { IUrlBuilder, MappedPageOverloads } from './_types';\r\nimport { UrlBuilder } from './_impl';\r\n\r\n/**\r\n * Factory function to create a MappedPageOverloads function.\r\n *\r\n * @param builder - The URL builder instance.\r\n * @param page - The page name.\r\n * @returns A function that generates URLs based on the provided slug and params.\r\n */\r\nconst mappedPageOverloadFactory = (\r\n  builder: IUrlBuilder,\r\n  page: string,\r\n): MappedPageOverloads => {\r\n  const ret: MappedPageOverloads = (\r\n    slug?: string | number | object,\r\n    params?: object,\r\n  ) => {\r\n    if (typeof slug === 'object') {\r\n      return builder.page(page, slug);\r\n    } else if (typeof slug === 'string' || typeof slug === 'number') {\r\n      return builder.page(page, slug, params);\r\n    } else {\r\n      return builder.page(page, params);\r\n    }\r\n  };\r\n  return ret;\r\n};\r\n\r\n/**\r\n * Represents a mapped URL builder interface that provides a structured way to build URLs\r\n * for various API endpoints and application features. This interface extends `IUrlBuilder`\r\n * and organizes URL-building logic into nested structures for better modularity and clarity.\r\n *\r\n * @interface MappedUrlBuilder\r\n *\r\n * @property {IUrlBuilder & { attachment: IUrlBuilder & { download: MappedPageOverloads; }; contact: MappedPageOverloads; doc: MappedPageOverloads; email: IUrlBuilder & { search: MappedPageOverloads; thread: MappedPageOverloads; stats: MappedPageOverloads; import: IUrlBuilder & { google: IUrlBuilder & { message: IUrlBuilder & { status: MappedPageOverloads; }; search: MappedPageOverloads; }; list: MappedPageOverloads; }; properties: (emailId: string) => IUrlBuilder & { callToAction: MappedPageOverloads; callToActionResponse: MappedPageOverloads; complianceScores: MappedPageOverloads; keyPoints: MappedPageOverloads; sentimentAnalysis: MappedPageOverloads; violationDetails: MappedPageOverloads; emailHeader: MappedPageOverloads; notes: MappedPageOverloads; }; }; }} api\r\n * A nested structure for API-related URL builders, including endpoints for attachments,\r\n * contacts, document units, and email-related operations such as search, thread, stats,\r\n * and import. Email properties include additional nested builders for specific features.\r\n *\r\n * @property {IUrlBuilder & { bulkEdit: MappedPageOverloads; edit: MappedPageOverloads; }} email\r\n * URL builders for email-related operations, including bulk editing and editing individual emails.\r\n *\r\n * @property {IUrlBuilder & { import: MappedPageOverloads; email: MappedPageOverloads; }} messages\r\n * URL builders for message-related operations, including importing messages and handling emails.\r\n */\r\nexport interface MappedUrlBuilder extends IUrlBuilder {\r\n  /**\r\n   * A nested structure for API-related URL builders, including endpoints for attachments,\r\n   * contacts, document units, and email-related operations such as search, thread, stats,\r\n   * and import. Email properties include additional nested builders for specific features.\r\n   */\r\n  api: IUrlBuilder & {\r\n    /**\r\n     * URL builders for attachment-related operations, including downloading attachments.\r\n     */\r\n    attachment: IUrlBuilder;\r\n    /**\r\n     * URL builder for contact-related operations.\r\n     *\r\n     * @param slug - Optional slug or object for the contact page.\r\n     * @param params - Optional parameters for the contact page.\r\n     * @returns A function that generates the URL for contacts.\r\n     */\r\n    contact: MappedPageOverloads;\r\n    /**\r\n     * URL builder for document unit-related operations.\r\n     *\r\n     * @param slug - Optional slug or object for the document unit page.\r\n     * @param params - Optional parameters for the document unit page.\r\n     * @returns A function that generates the URL for document units.\r\n     */\r\n    documentUnit: MappedPageOverloads;\r\n    /**\r\n     * URL builder for document unit-related operations.\r\n     *\r\n     * @param slug - Optional slug or object for the document unit page.\r\n     * @param params - Optional parameters for the document unit page.\r\n     * @returns A function that generates the URL for document units.\r\n     */\r\n    doc: MappedPageOverloads;\r\n    /**\r\n     * URL builder for email-related operations, including search, thread, stats,\r\n     * and import. Email properties include additional nested builders for specific features.\r\n     *\r\n     * @param slug - Optional slug or object for the email page.\r\n     * @param params - Optional parameters for the email page.\r\n     * @returns A function that generates the URL for email-related operations.\r\n     *\r\n     * @property {IUrlBuilder & { search: MappedPageOverloads; thread: MappedPageOverloads; stats: MappedPageOverloads; import: IUrlBuilder & { google: IUrlBuilder & { message: IUrlBuilder & { status: MappedPageOverloads; }; search: MappedPageOverloads; }; list: MappedPageOverloads; }; properties: (emailId: string) => IUrlBuilder & { callToAction: MappedPageOverloads; callToActionResponse: MappedPageOverloads; complianceScores: MappedPageOverloads; keyPoints: MappedPageOverloads; sentimentAnalysis: MappedPageOverloads; violationDetails: MappedPageOverloads; emailHeader: MappedPageOverloads; notes: MappedPageOverloads; }; }} email\r\n     * URL builders for email-related operations, including search, thread, stats,\r\n     * import, and properties. The properties builder takes an email ID as a parameter\r\n     * and provides additional nested builders for specific features such as\r\n     * call-to-action, compliance scores, and sentiment analysis.\r\n     *\r\n     */\r\n    email: IUrlBuilder & {\r\n      /**\r\n       * URL builder for searching emails.\r\n       */\r\n      search: MappedPageOverloads;\r\n      /**\r\n       * URL builder for email threads.\r\n       */\r\n      thread: MappedPageOverloads;\r\n      /**\r\n       * URL builder for email statistics.\r\n       */\r\n      stats: MappedPageOverloads;\r\n      /**\r\n       * URL builder for importing emails, including Google and list imports.\r\n       */\r\n      import: IUrlBuilder & {\r\n        /**\r\n         * URL builder for Google email imports, including message status and search.\r\n         */\r\n        google: IUrlBuilder & {\r\n          /**\r\n           * URL builder for Google email messages.\r\n           */\r\n          message: IUrlBuilder & {\r\n            /**\r\n             * URL builder for message status.\r\n             *\r\n             * @param slug - Optional slug or object for the message status page.\r\n             * @param params - Optional parameters for the message status page.\r\n             * @returns A function that generates the URL for message status.\r\n             */\r\n            status: MappedPageOverloads;\r\n          };\r\n          /**\r\n           * URL builder for searching Google emails.\r\n           *\r\n           * @param slug - Optional slug or object for the search page.\r\n           * @param params - Optional parameters for the search page.\r\n           * @returns A function that generates the URL for searching Google emails.\r\n           */\r\n          search: MappedPageOverloads;\r\n        };\r\n        /**\r\n         * URL builder for importing emails from a list.\r\n         *\r\n         * @param slug - Optional slug or object for the list page.\r\n         * @param params - Optional parameters for the list page.\r\n         * @returns A function that generates the URL for importing emails from a list.\r\n         */\r\n        list: MappedPageOverloads;\r\n      };\r\n      /**\r\n       * URL builder for email properties, including various features such as\r\n       * call-to-action, compliance scores, and sentiment analysis.\r\n       *\r\n       * @param emailId - The ID of the email for which to retrieve properties.\r\n       * @returns A function that generates the URL for email properties.\r\n       */\r\n      properties: (emailId: string) => IUrlBuilder & {\r\n        /**\r\n         * URL builder for call-to-action properties.\r\n         */\r\n        callToAction: MappedPageOverloads;\r\n        /**\r\n         * URL builder for call-to-action response properties.\r\n         */\r\n        callToActionResponse: MappedPageOverloads;\r\n        /**\r\n         * URL builder for compliance scores properties.\r\n         */\r\n        complianceScores: MappedPageOverloads;\r\n        /**\r\n         * URL builder for key points properties.\r\n         */\r\n        keyPoints: MappedPageOverloads;\r\n        /**\r\n         * URL builder for sentiment analysis properties.\r\n         */\r\n        sentimentAnalysis: MappedPageOverloads;\r\n        /**\r\n         * URL builder for violation details properties.\r\n         */\r\n        violationDetails: MappedPageOverloads;\r\n        /**\r\n         * URL builder for email header properties.\r\n         */\r\n        emailHeader: MappedPageOverloads; // Added emailHeader\r\n        /**\r\n         * URL builder for notes properties.\r\n         */\r\n        notes: MappedPageOverloads;\r\n      };\r\n    };\r\n    /**\r\n     * URL builders for AI-related operations, including chat history.\r\n     */\r\n    ai: IUrlBuilder & {\r\n      /**\r\n       * URL builders for chat-related operations.\r\n       */\r\n      chat: IUrlBuilder & {\r\n        /**\r\n         * URL builder for chat history API.\r\n         */\r\n        history: MappedPageOverloads;\r\n        /**\r\n         * URL builder for chat statistics API.\r\n         */\r\n        stats: MappedPageOverloads;\r\n        /**\r\n         * URL builder for rate retry queue API.\r\n         */\r\n        rateRetry: IUrlBuilder & {\r\n          /**\r\n           * URL builder for rate retry response retrieval API.\r\n           */\r\n          response: MappedPageOverloads;\r\n        };\r\n      };\r\n    };\r\n  };\r\n  /**\r\n   * URL builders for chat-related pages.\r\n   */\r\n  chat: IUrlBuilder & {\r\n    /**\r\n     * URL builder for individual chat details.\r\n     */\r\n    detail: MappedPageOverloads;\r\n  };\r\n  /**\r\n   * URL builders for email-related pages, including bulk editing and editing individual emails.\r\n   */\r\n  email: IUrlBuilder & {\r\n    /**\r\n     * URL builder for bulk editing emails.\r\n     *\r\n     * @param slug - Optional slug or object for the bulk edit page.\r\n     * @param params - Optional parameters for the bulk edit page.\r\n     * @returns A function that generates the URL for bulk editing emails.\r\n     */\r\n    bulkEdit: MappedPageOverloads;\r\n    /**\r\n     * URL builder for editing individual emails.\r\n     *\r\n     * @param slug - Optional slug or object for the edit page.\r\n     * @param params - Optional parameters for the edit page.\r\n     * @returns A function that generates the URL for editing individual emails.\r\n     */\r\n    edit: MappedPageOverloads;\r\n  };\r\n  /**\r\n   * URL builders for message-related pages, including importing messages and handling emails.\r\n   */\r\n  messages: IUrlBuilder & {\r\n    /**\r\n     * URL builder for importing messages.\r\n     *\r\n     * @param slug - Optional slug or object for the import page.\r\n     * @param params - Optional parameters for the import page.\r\n     * @returns A function that generates the URL for importing messages.\r\n     */\r\n    import: MappedPageOverloads;\r\n    /**\r\n     * URL builder for handling emails.\r\n     *\r\n     * @param slug - Optional slug or object for the email page.\r\n     * @param params - Optional parameters for the email page.\r\n     * @returns A function that generates the URL for handling emails.\r\n     */\r\n    email: MappedPageOverloads;\r\n    /**\r\n     * URL builder for handling historic chats.\r\n     *\r\n     * @param slug - Optional slug or object for a specific chat history page.\r\n     * @returns A function that generates the URL for handling historic chats.\r\n     */\r\n    chat: IUrlBuilder & {\r\n      /**\r\n       * URL builder for chat statistics.\r\n       */\r\n      stats: MappedPageOverloads;\r\n      /**\r\n       * URL builder for chat details; equivalent to {@link messages.chat}.\r\n       */\r\n      detail: MappedPageOverloads;\r\n    };\r\n  };\r\n}\r\n\r\n/**\r\n * Factory function to create a `MappedUrlBuilder` instance.\r\n *\r\n * This function initializes a `MappedUrlBuilder` object with a hierarchical structure\r\n * of URL segments and mapped page overloads. It provides a structured way to build\r\n * URLs for various API endpoints and other resources in the application.\r\n *\r\n * The returned `MappedUrlBuilder` includes nested properties and methods for constructing\r\n * URLs for specific API endpoints, such as `api.attachment.download`, `api.email.search`,\r\n * and more. It also supports dynamic URL generation for specific resources, such as\r\n * `api.email.properties(emailId)`.\r\n *\r\n * ### Example Usage\r\n * ```typescript\r\n * const urlBuilder = mappedUrlBuilderFactory();\r\n * const downloadUrl = urlBuilder.api.attachment.download();\r\n * const emailPropertiesUrl = urlBuilder.api.email.properties('12345').callToAction();\r\n * ```\r\n *\r\n * @returns {MappedUrlBuilder} A fully initialized `MappedUrlBuilder` instance with\r\n * nested URL segments and mapped page overloads.\r\n */\r\nexport const mappedUrlBuilderFactory = (): MappedUrlBuilder => {\r\n  const ret = new UrlBuilder({\r\n    parent: null,\r\n    segment: '',\r\n  }) as unknown as MappedUrlBuilder;\r\n  ret.api = ret.child('api') as MappedUrlBuilder['api'];\r\n  ret.api.attachment = ret.child(\r\n    'attachment',\r\n  ) as MappedUrlBuilder['api']['attachment'];\r\n  ret.api.contact = mappedPageOverloadFactory(ret.api, 'contact');\r\n  ret.api.documentUnit = mappedPageOverloadFactory(ret.api, 'document-unit');\r\n  ret.api.email = ret.api.child('email') as MappedUrlBuilder['api']['email'];\r\n  ret.api.email.search = mappedPageOverloadFactory(ret.api.email, 'search');\r\n  ret.api.email.thread = mappedPageOverloadFactory(ret.api.email, 'thread');\r\n  ret.api.email.stats = mappedPageOverloadFactory(ret.api.email, 'stats');\r\n  ret.api.email.import = ret.api.email.child(\r\n    'import',\r\n  ) as MappedUrlBuilder['api']['email']['import'];\r\n  ret.api.email.import.google = ret.api.email.import.child(\r\n    'google',\r\n  ) as MappedUrlBuilder['api']['email']['import']['google'];\r\n  ret.api.email.import.google.message = ret.api.email.import.google.child(\r\n    'message',\r\n  ) as MappedUrlBuilder['api']['email']['import']['google']['message'];\r\n  ret.api.email.import.google.message.status = mappedPageOverloadFactory(\r\n    ret.api.email.import.google.message,\r\n    'status',\r\n  );\r\n  ret.api.email.import.google.search = mappedPageOverloadFactory(\r\n    ret.api.email.import.google,\r\n    'search',\r\n  );\r\n  ret.api.email.import.list = mappedPageOverloadFactory(\r\n    ret.api.email.import,\r\n    'list',\r\n  );\r\n\r\n  ret.api.email.properties = (emailId: string) => {\r\n    const properties = new UrlBuilder({\r\n      parent: ret.api.email,\r\n      segment: emailId,\r\n      slug: 'properties',\r\n    }) as Partial<ReturnType<MappedUrlBuilder['api']['email']['properties']>>;\r\n    properties.callToAction = mappedPageOverloadFactory(\r\n      properties as IUrlBuilder,\r\n      'call-to-action',\r\n    );\r\n    properties.callToActionResponse = mappedPageOverloadFactory(\r\n      properties as IUrlBuilder,\r\n      'call-to-action-response',\r\n    );\r\n    properties.complianceScores = mappedPageOverloadFactory(\r\n      properties as IUrlBuilder,\r\n      'compliance-scores',\r\n    );\r\n    properties.keyPoints = mappedPageOverloadFactory(\r\n      properties as IUrlBuilder,\r\n      'key-points',\r\n    );\r\n    properties.sentimentAnalysis = mappedPageOverloadFactory(\r\n      properties as IUrlBuilder,\r\n      'sentiment-analysis',\r\n    );\r\n    properties.violationDetails = mappedPageOverloadFactory(\r\n      properties as IUrlBuilder,\r\n      'violation-details',\r\n    );\r\n    properties.emailHeader = mappedPageOverloadFactory(\r\n      properties as IUrlBuilder,\r\n      'email-header',\r\n    );\r\n    properties.notes = mappedPageOverloadFactory(\r\n      properties as IUrlBuilder,\r\n      'notes',\r\n    );\r\n    return properties as ReturnType<\r\n      MappedUrlBuilder['api']['email']['properties']\r\n    >;\r\n  };\r\n  \r\n  // Add AI chat builders\r\n  ret.api.ai = ret.api.child('ai') as MappedUrlBuilder['api']['ai'];\r\n  ret.api.ai.chat = ret.api.ai.child('chat') as MappedUrlBuilder['api']['ai']['chat'];\r\n  ret.api.ai.chat.history = mappedPageOverloadFactory(\r\n    ret.api.ai.chat,\r\n    'history',\r\n  );\r\n  ret.api.ai.chat.stats = mappedPageOverloadFactory(\r\n    ret.api.ai.chat,\r\n    'stats',\r\n  );\r\n  ret.api.ai.chat.rateRetry = ret.api.ai.chat.child('rate-retry') as MappedUrlBuilder['api']['ai']['chat']['rateRetry'];\r\n  ret.api.ai.chat.rateRetry.response = mappedPageOverloadFactory(\r\n    ret.api.ai.chat.rateRetry,\r\n    'response',\r\n  );\r\n\r\n  ret.email = ret.child('messages').child('email') as MappedUrlBuilder['email'];\r\n  ret.email.bulkEdit = mappedPageOverloadFactory(ret.email, 'bulk-edit');\r\n  ret.email.edit = mappedPageOverloadFactory(ret.email, 'edit');\r\n  ret.messages = ret.child('messages') as MappedUrlBuilder['messages'];\r\n  ret.messages.import = mappedPageOverloadFactory(ret.messages, 'import');\r\n  ret.messages.email = mappedPageOverloadFactory(ret.messages, 'email');\r\n  ret.messages.chat = ret.child('messages').child('chat') as MappedUrlBuilder['messages']['chat'];\r\n  ret.messages.chat.stats = mappedPageOverloadFactory(ret.messages.chat, 'stats');\r\n  ret.messages.chat.detail = mappedPageOverloadFactory(ret.messages.chat, '');\r\n\r\n  ret.chat = ret.messages.chat;\r\n    \r\n  return ret as MappedUrlBuilder;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\url-builder\\_impl.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\url-builder\\_impl.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":245,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { IUrlBuilder, UrlBuilderInfo } from './_types';\r\nimport { env } from '@/lib/site-util/env';\r\n\r\nconst appendParams = (url: URL, params: object | undefined) => {\r\n  if (!params) {\r\n    return url;\r\n  }\r\n  const copy = new URL(url);\r\n  if (params) {\r\n    const serializeParam = (\r\n      q: URLSearchParams,\r\n      key: string,\r\n      value: unknown,\r\n    ) => {\r\n      if (typeof value !== 'number' && !value) {\r\n        return;\r\n      }\r\n      if (Array.isArray(value)) {\r\n        value.forEach((v) => serializeParam(q, key, v));\r\n      } else if (typeof value === 'object') {\r\n        q.append(key, JSON.stringify(value));\r\n      } else {\r\n        q.append(key, String(value));\r\n      }\r\n    };\r\n    copy.search = Object.keys(params)\r\n      .reduce((q, key) => {\r\n        const value = params[key as keyof typeof params];\r\n        serializeParam(q, key, value);\r\n        return q;\r\n      }, copy.searchParams ?? new URLSearchParams())\r\n      .toString();\r\n  }\r\n  return copy;\r\n};\r\n\r\n\r\nexport class UrlBuilder implements IUrlBuilder {\r\n  /**\r\n   * Returns the root URL of the application.\r\n   *\r\n   * @returns {URL} The root URL constructed using the base path '/' and the hostname from the environment variable `NEXT_PUBLIC_HOSTNAME`.\r\n   */\r\n  static get root(): URL {\r\n    return new URL('/', env('NEXT_PUBLIC_HOSTNAME'));\r\n  }\r\n\r\n  /**\r\n   * Returns a new instance of `UrlBuilder` with the root configuration.\r\n   *\r\n   * @returns {UrlBuilder} A new `UrlBuilder` instance with no parent and an empty segment.\r\n   */\r\n  static get rootBuilder(): UrlBuilder {\r\n    return new UrlBuilder({\r\n      parent: null as unknown as IUrlBuilder,\r\n      segment: '',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Builds a slug part of a URL.\r\n   *\r\n   * @param slug - The slug to be included in the URL. It can be a string or a number.\r\n   *               If the slug is not provided or is an empty string, an empty string is returned.\r\n   *               If the slug is a number or a non-empty string, it returns the slug prefixed with a '/'.\r\n   * @returns A string representing the slug part of the URL.\r\n   */\r\n  static buildSlugPart = (slug?: string | number) =>\r\n    typeof slug !== 'number' && !slug ? '' : `/${slug}`;\r\n\r\n  /**\r\n   * Private data representing this URL builder.\r\n   */\r\n  private readonly info: UrlBuilderInfo;\r\n\r\n  /**\r\n   * Constructs a new instance of the class.\r\n   *\r\n   * @param info - An object containing URL builder information. It can either be of type `UrlBuilderInfo`\r\n   *               or an object with `parent` set to `null` and `segment` set to an empty string.\r\n   *\r\n   * @throws {TypeError} Throws an error if the provided `info` object is invalid or missing.\r\n   */\r\n  constructor(info: UrlBuilderInfo | { parent: null; segment: '' }) {\r\n    if (\r\n      !info ||\r\n      typeof info !== 'object' ||\r\n      !('segment' in info && 'parent' in info)\r\n    ) {\r\n      throw new TypeError(\r\n        `invalid or missing info object provided: ${JSON.stringify(\r\n          info ?? 'null',\r\n        )}`,\r\n      );\r\n    }\r\n    this.info = info as UrlBuilderInfo;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the path of the parent if it exists.\r\n   *\r\n   * @returns {string} The path of the parent if `this.info.parent` is not null; otherwise, an empty string.\r\n   */\r\n  private get parentPart(): string {\r\n    return this.info.parent == null ? '' : this.info.parent.path;\r\n  }\r\n\r\n  /**\r\n   * Gets the slug part formatted for a URL.\r\n   *\r\n   * @returns {string} The slug part of the URL.\r\n   */\r\n  private get slugPart(): string {\r\n    return UrlBuilder.buildSlugPart(this.info.slug);\r\n  }\r\n  /**\r\n   * Returns a URL object representing the current path with a trailing slash appended.\r\n   * The base URL is the root URL of the application.\r\n   *\r\n   * @private\r\n   * @returns {URL} The URL object with a trailing slash.\r\n   */\r\n  private get urlWithSlash(): URL {\r\n    return new URL(`${this.path}/`, UrlBuilder.root);\r\n  }\r\n\r\n  /**\r\n   * Gets the parent URL builder.\r\n   *\r\n   * @returns {IUrlBuilder | null} The parent URL builder or null if there is no parent.\r\n   */\r\n  get parent(): IUrlBuilder | null {\r\n    return this.info.parent;\r\n  }\r\n\r\n  /**\r\n   * Gets the segment of the URL.\r\n   *\r\n   * @returns {string} The segment of the URL.\r\n   */\r\n  get segment(): string {\r\n    return this.info.segment;\r\n  }\r\n\r\n  /**\r\n   * Gets the slug of the URL.\r\n   *\r\n   * @returns {string | number | undefined} The slug of the URL.\r\n   */\r\n  get slug(): string | number | undefined {\r\n    return this.info.slug;\r\n  }\r\n\r\n  /**\r\n   * Gets the full relative path of the URL.\r\n   *\r\n   * @returns {string} The path of the URL.\r\n   */\r\n  get path(): string {\r\n    const p = `${this.parentPart}/${this.info.segment}${this.slugPart}`;\r\n    return p.endsWith('/') ? p.slice(0, -1) : p;\r\n  }\r\n  /**\r\n   * Gets the URL object representing the current path.\r\n   *\r\n   * @returns {URL} The URL object representing the current path.\r\n   */\r\n  get url(): URL {\r\n    return new URL(this.path, UrlBuilder.root);\r\n  }\r\n\r\n  /**\r\n   * This is the same as calling `this.path`.\r\n   * @returns {string} The string representation of the URL.\r\n   */\r\n  toString(): string {\r\n    return this.path;\r\n  }\r\n\r\n  /**\r\n   * Creates a child URL builder with the specified segment and optional slug.\r\n   *\r\n   * @param segment - The segment for the child URL.\r\n   * @param slug - The optional slug for the child URL.\r\n   * @returns {UrlBuilder} A new `UrlBuilder` instance representing the child URL.\r\n   */\r\n  child(segment: string, slug?: string | number): UrlBuilder {\r\n    return new UrlBuilder({ parent: this, segment, slug });\r\n  }\r\n  /**\r\n   * Builds a URL relative to this instance given a page segment, slug value, and query paramters.\r\n   *\r\n   * @overload\r\n   * @param {string} page - Relative page segment appended to the URL.\r\n   * @param {string | number} slug - The slug or identifier included in the URL.\r\n   * @param {object} [params] - Optional object containing URL query paremeters..\r\n   * @returns {URL} - The constructed URL.\r\n   *\r\n   * @overload\r\n   * @param {string | number} slug - The slug or identifier included in the URL.\r\n   * @param {object} [params] - Optional object containing URL query paremeters.\r\n   * @returns {URL} - The constructed URL.\r\n   *\r\n   * @overload\r\n   * @param {object} params - Optional object containing URL query paremeters.\r\n   * @returns {URL} - The constructed URL.\r\n   *\r\n   * @overload\r\n   * @returns {URL} - The builder URL - essentially the same as accessing the url property.\r\n   */\r\n  page(page: string, slug: string | number, params?: object): URL;\r\n  page(page: string | number, params?: object): URL;\r\n  page(params: object): URL;\r\n  page(): URL;\r\n  page(\r\n    page?: number | string | object,\r\n    slug?: string | number | object,\r\n    params?: object,\r\n  ) {\r\n    if (typeof page === 'undefined') {\r\n      return this.url;\r\n    }\r\n    if (typeof page === 'object') {\r\n      return appendParams(this.url, page);\r\n    }\r\n    const normalizedPage = String(page);\r\n    if (normalizedPage.indexOf('/') > -1) {\r\n      throw new Error('Invalid page name.');\r\n    }\r\n    if (typeof slug === 'undefined') {\r\n      return new URL(normalizedPage, this.urlWithSlash);\r\n    }\r\n    if (typeof slug === 'object') {\r\n      return appendParams(new URL(normalizedPage, this.urlWithSlash), slug);\r\n    }\r\n    if (typeof slug === 'string' && slug.indexOf('/') > -1) {\r\n      throw new Error('Invalid slug name.');\r\n    }\r\n    const urlPart = new URL(`${normalizedPage}/${slug}`, this.urlWithSlash);\r\n    return typeof params === 'undefined'\r\n      ? urlPart\r\n      : appendParams(urlPart, params);\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\url-builder\\_sitemap.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\url-builder\\_types.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\url-builder\\_types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\url-builder\\index.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\site-util\\url-builder\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\styles\\utility-classes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\themes\\definitions.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":149,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":149,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6097,6100],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6097,6100],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\themes\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\themes\\provider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\themes\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":36,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Theme } from '@mui/material/styles';\r\n\r\n\r\n/**\r\n * ThemeType represents the type of theme used in the application.\r\n * It can be either 'dark' or 'light'.\r\n * This type is used to manage the current theme state and apply the appropriate styles.\r\n * @example\r\n * ```typescript\r\n * const currentTheme: ThemeType = 'dark';\r\n * // Apply dark theme styles\r\n * ```\r\n * @see {@link Theme} for the MUI theme object.\r\n */\r\nexport type ThemeType = 'dark' | 'light';\r\n  \r\n/**\r\n * Represents the context for theme management within the application.\r\n *\r\n * @property currentTheme - The currently {@link ThemeType} theme type ('dark' or 'light').\r\n * @property theme - The {@link Theme} object that defines the active theme.\r\n * @property setTheme - Function to update the current theme by specifying a new theme type.\r\n * @example\r\n * ```typescript\r\n * const { currentTheme, theme, setTheme } = useTheme();\r\n * setTheme('light'); // Switch to light theme\r\n * ```\r\n * @see {@link ThemeType} for the type of themes available.\r\n * @see {@link Theme} for the MUI theme object.\r\n */\r\nexport type ThemeContextType = {\r\n  currentTheme: ThemeType;\r\n  theme: Theme;\r\n  setTheme: (theme: ThemeType) => void;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\_generics.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\_generics.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":16,"column":1,"nodeType":"Program","endLine":35,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module GenericUtilities\r\n *\r\n * Shared compile-time helpers for modeling generic call signatures.\r\n * These utilities help reduce duplication when authoring APIs that\r\n * accept either scalar or array inputs.\r\n */\r\n\r\n/**\r\n * Describes a callable that can process either a single input value or an array\r\n * of values, returning the corresponding singular or array output.\r\n *\r\n * @template TInput - Incoming value type.\r\n * @template TOutput - Outgoing value type (defaults to {@link TInput}).\r\n */\r\nexport type OneOrMany<TInput, TOutput = TInput> = {\r\n  (input: TInput): TOutput;\r\n  (input: Array<TInput>): Array<TOutput>;\r\n};\r\n\r\n\r\nexport const forOneOrMany = <TInput, TOutput>(\r\n  forOne: (input: TInput) => TOutput,\r\n  input: TInput | Array<TInput>,\r\n): TInput extends Array<TInput> ? Array<TOutput> : TOutput => {\r\n  if (Array.isArray(input)) {\r\n    return input.map(forOne) as TInput extends Array<TInput>\r\n      ? Array<TOutput>\r\n      : TOutput;\r\n  }\r\n  return forOne(input) as TInput extends Array<TInput>\r\n    ? Array<TOutput>\r\n    : TOutput;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\_guards.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\_guards.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":9,"column":1,"nodeType":"Program","endLine":87,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":40,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1503,1506],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1503,1506],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":52,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1874,1877],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1874,1877],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module GuardUtilities\r\n *\r\n * A collection of narrow, reusable type guards and runtime checks used across the\r\n * application to improve safety when interacting with dynamic values, external\r\n * data, or asynchronous operations. Each helper promotes explicit intent and\r\n * preserves strong typing by exposing refined TypeScript predicates.\r\n */\r\nimport { IsNotNull, UnionToTuple } from './_types';\r\nimport { AbortablePromise } from './abortable-promise';\r\n\r\n\r\nexport const isOperationCancelledError =\r\n  AbortablePromise.isOperationCancelledError;\r\n\r\n\r\nexport const isAbortablePromise = AbortablePromise.isAbortablePromise;\r\n\r\n/**\r\n * Runtime signature for the {@link isKeyOf} guard, capturing the overloads\r\n * needed to work with concrete objects as well as literal key collections.\r\n */\r\ninterface IsKeyOfGuard {\r\n  // When called with a readonly array/tuple of literal keys, narrow the key to that array's element type\r\n  <T extends readonly (string | number | symbol)[]>(\r\n    key: unknown,\r\n    check: T,\r\n  ): key is T[number];\r\n  // Allow calling with no second argument or an explicit undefined/null to check only the key shape\r\n  <T extends object>(key: unknown, check?: undefined | null): key is keyof T;\r\n  <T extends object>(key: unknown): key is keyof T;\r\n  <T extends object>(key: unknown, check: T): key is keyof T;\r\n}\r\n\r\n\r\nexport const isKeyOf: IsKeyOfGuard = (\r\n  key: unknown,\r\n  check?: unknown,\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n): key is any => {\r\n  if (check === undefined || check === null) {\r\n    return false;\r\n  }\r\n  if (\r\n    typeof key === 'string' ||\r\n    typeof key === 'number' ||\r\n    typeof key === 'symbol'\r\n  ) {\r\n    if (Array.isArray(check)) {\r\n      // runtime: check if any element equals the key\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      return (check as any[]).some((v) => v === key);\r\n    }\r\n    if (check && typeof check === 'object') {\r\n      return key in (check as Record<PropertyKey, unknown>);\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n\r\nexport const isMemberOfUnion = <\r\n  T extends string | number | symbol,\r\n  TCheck extends UnionToTuple<T> = UnionToTuple<T>,\r\n>(\r\n  check: unknown,\r\n  union: TCheck,\r\n): check is T => {\r\n  return !!union?.includes(check as T);\r\n};\r\n\r\n\r\nexport const isPromise = <T = void>(check: unknown): check is Promise<T> =>\r\n  !!check &&\r\n  typeof check === 'object' &&\r\n  'then' in check &&\r\n  typeof check.then === 'function' &&\r\n  'catch' in check &&\r\n  typeof check.catch === 'function' &&\r\n  'finally' in check &&\r\n  typeof check.finally === 'function';\r\n\r\n\r\nexport const isNotNull = <T>(\r\n  value: T | null | undefined,\r\n): value is IsNotNull<T> => !!value;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\_record-decorators.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\_record-decorators.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":97,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { v4 as uuidv4 } from 'uuid';\r\n\r\n/**\r\n * A unique symbol used to mark a record as dirty.\r\n *\r\n * This symbol can be used as a key to indicate that a record has been modified\r\n * and needs to be saved or processed. It is typically used in conjunction with\r\n * decorators or other metadata mechanisms to track changes to objects.\r\n */\r\nconst RecordIsDirty = Symbol('RecordIsDirty');\r\n/**\r\n * A unique symbol used to identify a record by its UUID.\r\n *\r\n * @remarks\r\n * This symbol can be used as a unique key or identifier for records within the application.\r\n *\r\n * @example\r\n * ```typescript\r\n * const myRecord = {\r\n *   [RecordUuid]: '123e4567-e89b-12d3-a456-426614174000'\r\n * };\r\n * ```\r\n */\r\nconst RecordUuid = Symbol('RecordUuid');\r\n\r\n\r\nexport const getDecoratorSymbols = () => ({\r\n  dirty: RecordIsDirty,\r\n  uuid: RecordUuid,\r\n});\r\n\r\n/**\r\n * A type that extends a given object type `T` with an optional `RecordIsDirty` property.\r\n * This property is a boolean that indicates whether the record is considered \"dirty\" (i.e., has unsaved changes).\r\n *\r\n * @template T - The base object type that is being extended.\r\n */\r\nexport type RecordWithDirtyState<T extends object> = T & {\r\n  [RecordIsDirty]?: boolean;\r\n};\r\n\r\n/**\r\n * A type that extends a given object type `T` with an optional `RecordUuid` property.\r\n * The `RecordUuid` property can be a string or null.\r\n *\r\n * @template T - The base object type to extend.\r\n */\r\nexport type RecordWithUuid<T extends object> = T & {\r\n  [RecordUuid]?: string | null;\r\n};\r\n\r\n\r\nexport const isRecordWithDirtyState = <T extends object>(\r\n  check: unknown\r\n): check is RecordWithDirtyState<T> => {\r\n  const record = check as RecordWithDirtyState<T>;\r\n  return record[RecordIsDirty] !== undefined;\r\n};\r\n\r\n\r\nexport const isRecordDirty = (record: object): boolean =>\r\n  isRecordWithDirtyState(record) && record[RecordIsDirty] === true;\r\n\r\n\r\nexport const setRecordDirty = <T extends object>(\r\n  record: object,\r\n  isDirty: boolean = true\r\n): record is RecordWithDirtyState<T> => {\r\n  (record as RecordWithDirtyState<T>)[RecordIsDirty] = isDirty;\r\n  return true;\r\n};\r\n\r\n\r\nexport const isRecordWithUuid = <T extends object>(\r\n  check: T | unknown\r\n): check is RecordWithUuid<T> =>\r\n  (check &&\r\n    typeof check === 'object' &&\r\n    (check as RecordWithUuid<T>)[RecordUuid] !== undefined) == true;\r\n\r\n\r\nexport const getUuid = (record: unknown): string | null | undefined =>\r\n  isRecordWithUuid(record) ? record[RecordUuid] : undefined;\r\n\r\n\r\nexport const newUuid = () => uuidv4();\r\n\r\n\r\nexport const setUuid = <T extends object>(\r\n  record: T,\r\n  uuid?: string | null\r\n): RecordWithUuid<T> => {\r\n  const work = record as RecordWithUuid<T>;\r\n  work[RecordUuid] = uuid === undefined ? newUuid() : uuid;\r\n  return work;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\_types.d.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[886,889],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[886,889],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[937,940],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[937,940],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":32,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[988,991],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[988,991],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":51,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1480,1483],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1480,1483],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":64,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1940,1943],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1940,1943],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":82,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2387,2390],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2387,2390],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":247,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":247,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7480,7483],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7480,7483],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":258,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":258,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7808,7811],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7808,7811],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":264,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":264,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8011,8014],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8011,8014],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":283,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":283,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8592,8595],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8592,8595],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":283,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":283,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8600,8603],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8600,8603],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":285,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":285,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8653,8656],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8653,8656],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":286,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":286,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8665,8668],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8665,8668],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":300,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":300,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9047,9050],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9047,9050],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":300,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":300,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9055,9058],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9055,9058],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":302,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":302,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9104,9107],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9104,9107],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":322,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":322,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9541,9544],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9541,9544],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":322,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":322,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9551,9554],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9551,9554],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":355,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":355,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10399,10402],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10399,10402],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\_types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":25,"column":1,"nodeType":"Program","endLine":368,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[754,757],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[754,757],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[805,808],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[805,808],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":27,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[840,843],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[840,843],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":46,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1296,1299],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1296,1299],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":59,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1732,1735],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1732,1735],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":77,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2145,2148],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2145,2148],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":226,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":226,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6485,6488],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6485,6488],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":237,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":237,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6793,6796],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6793,6796],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":243,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":243,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6984,6987],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6984,6987],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":262,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":262,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7529,7532],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7529,7532],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":262,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":262,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7537,7540],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7537,7540],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":264,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":264,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7586,7589],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7586,7589],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":265,"column":6,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":265,"endColumn":9,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7596,7599],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7596,7599],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":279,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":279,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7952,7955],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7952,7955],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":279,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":279,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7960,7963],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7960,7963],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":281,"column":6,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":281,"endColumn":9,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8005,8008],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8005,8008],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":301,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":301,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8404,8407],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8404,8407],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":301,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":301,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8414,8417],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8414,8417],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":334,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":334,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9200,9203],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9200,9203],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/* eslint-disable @typescript-eslint/no-explicit-any */\r\n\r\n/**\r\n * @module _types\r\n * This module provides various utility types for TypeScript, including:\r\n * - Converting between union and tuple types.\r\n * - Transforming string literal types.\r\n * - Handling cancelable promises.\r\n */\r\n\r\n/**\r\n * Converts a union type `T` into a tuple type.\r\n *\r\n * This utility type takes a union type `T` and transforms it into a tuple type\r\n * where each element of the tuple corresponds to a member of the union.\r\n *\r\n * @template T - The union type to be converted into a tuple.\r\n *\r\n * @example\r\n * ```typescript\r\n * type Union = 'a' | 'b' | 'c';\r\n * type Tuple = UnionToTuple<Union>; // ['a', 'b', 'c']\r\n * ```\r\n */\r\nexport type UnionToTuple<T> = (\r\n  (T extends any ? (t: T) => T : never) extends (t: infer U) => any ? U : never\r\n) extends { [K in any]: infer E }\r\n  ? E[]\r\n  : never;\r\n\r\n/**\r\n * Converts a tuple type to a union type.\r\n *\r\n * @template T - A tuple type.\r\n * @example\r\n * ```typescript\r\n * type MyTuple = ['a', 'b', 'c'];\r\n * type MyUnion = TupleToUnion<MyTuple>; // 'a' | 'b' | 'c'\r\n * ```\r\n * @example\r\n * ```typescript\r\n * type MyTuple = [string, number, boolean];\r\n * type MyUnion = TupleToUnion<MyTuple>; // string | number | boolean\r\n * ```\r\n */\r\nexport type TupleToUnion<T extends any[]> = T[number];\r\n\r\n/**\r\n * Converts a union type to an object type with keys from the union and values of type `any`.\r\n *\r\n * @template T - The union type to be converted into an object type.\r\n * @example\r\n * ```typescript\r\n * type MyUnion = 'a' | 'b' | 'c';\r\n * type MyObject = UnionToObject<MyUnion>; // { 'a': any; 'b': any; 'c': any }\r\n * ```\r\n */\r\nexport type UnionToObject<T extends string | number | symbol> = {\r\n  [K in T]: any;\r\n};\r\n\r\n/**\r\n * Infers the element type of an array.\r\n *\r\n * @template T - The array type.\r\n * @example\r\n * ```typescript\r\n * type MyArray = string[];\r\n * type ElementType = ArrayElement<MyArray>; // string\r\n * ```\r\n * @example\r\n * ```typescript\r\n * type MyArray = (string | number)[];\r\n * type ElementType = ArrayElement<MyArray>; // string | number\r\n * ```\r\n */\r\nexport type ArrayElement<T extends readonly any[] | undefined | null> =\r\n  T extends readonly (infer U)[] ? U : never;\r\n\r\n/**\r\n * Picks a specific field type from an object type `T` by key `K`.\r\n *\r\n * @template T - The object type.\r\n * @template K - The key of the field to pick.\r\n * @example\r\n * ```typescript\r\n * type MyObject = { a: string; b: number; c: boolean };\r\n * type FieldType = PickField<MyObject, 'b'>; // number\r\n * ```\r\n */\r\nexport type PickField<T, K extends keyof T> = Pick<T, K>[K];\r\n\r\n/**\r\n * Constructs a type by making all properties in `T` optional, except for the properties specified in `K` which are required.\r\n *\r\n * @template T - The base type.\r\n * @template K - The keys from `T` that should be required.\r\n */\r\nexport type PartialExceptFor<T, K extends keyof T> = Partial<T> &\r\n  Required<Pick<T, K>>;\r\n\r\n/**\r\n * Converts a kebab-case string to camelCase.\r\n *\r\n * This utility type recursively transforms a kebab-case string literal type\r\n * into a camelCase string literal type. Each hyphen (`-`) in the input string\r\n * is removed, and the character immediately following the hyphen is\r\n * capitalized.\r\n *\r\n * @template S - The kebab-case string to be transformed.\r\n * @example\r\n * ```typescript\r\n * type CamelCase = KebabToCamelCase<'kebab-case-string'>; // 'kebabCaseString'\r\n * ```\r\n */\r\nexport type KebabToCamelCase<S extends string> =\r\n  S extends `${infer T}-${infer U}`\r\n    ? `${T}${Capitalize<KebabToCamelCase<U>>}`\r\n    : S;\r\n\r\n/**\r\n * Simple utility type for declaring keys of other types.\r\n */\r\nexport type KeyOf<T> = keyof T;\r\n/**\r\n * Extracts the resolved value type of a promise.\r\n *\r\n * @template T - The promise type.\r\n * @example\r\n * ```typescript\r\n * type MyPromise = Promise<string>;\r\n * type ResolvedType = UnwrapPromise<MyPromise>; // string\r\n * ```\r\n */\r\nexport type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;\r\n/**\r\n * Represents a promise that can be canceled.\r\n *\r\n * @template T - The type of the value that the promise resolves to.\r\n *\r\n * @extends {Promise<T>}\r\n *\r\n * @property {() => void} cancel - Cancels the promise.\r\n *\r\n * @example\r\n * ```typescript\r\n *\r\n * promise.then((value) => {\r\n *   console.log(value);\r\n * }).catch((error) => {\r\n *   console.error(error);\r\n * });\r\n *\r\n * // Cancel the promise\r\n * promise.cancel();\r\n * ```\r\n *\r\n * @property {Promise<T>} native - A wrapping native promise object\r\n */\r\nexport type ICancellablePromise<T> = Pick<\r\n  Promise<T>,\r\n  'then' | 'catch' | 'finally'\r\n> & {\r\n  cancel: () => void;\r\n\r\n  /**\r\n   * The native awaitable promise object.\r\n   */\r\n  readonly awaitable: Promise<T>;\r\n};\r\n\r\n/**\r\n * An extended version of `ICancellablePromise` that includes additional methods\r\n * for handling cancellation events.\r\n *\r\n * @template T - The type of the value that the promise resolves to.\r\n *\r\n * ```\r\n */\r\nexport type ICancellablePromiseExt<T> = Omit<\r\n  ICancellablePromise<T>,\r\n  'catch' | 'then' | 'finally'\r\n> & {\r\n  /**\r\n   * Registers a callback to be invoked when the promise is canceled.\r\n   *\r\n   * @template TRet - The type of the value that the promise resolves to.\r\n   * @template TSource - The chained type (if any) that the promise initially resolves to.\r\n   * @param {ICanceledCallback} oncanceled - The (@link ICanceledCallback `callback`} to be invoked when the promise is canceled.\r\n   * @returns {Promise<TRet>} A promise that resolves with the value returned by the callback.\r\n   *\r\n   * @example Behavior when the promise is canceled given a TSource of 'source':\r\n   * ```typescript\r\n   * const promise: ICancellablePromiseExt<string>;\r\n   *\r\n   * promise.cancelled((value) => {\r\n   *   console.log('Cancelled:', value);\r\n   *   return 'operation was cancelled.';\r\n   * });\r\n   *\r\n   * promise.then((value) => {\r\n   *   console.log('Then:', value);\r\n   *   return 'operation completed.';\r\n   * }).catch((error) => {\r\n   *   console.log('Error:', value);\r\n   *   return 'operation failed.';\r\n   * });\r\n   *\r\n   * console.log(await promise);\r\n   *\r\n   * // Console output if the promise is canceled -\r\n   * Cancelled: source\r\n   * operation was cancelled.\r\n   *\r\n   * // Console output if the promise is completed -\r\n   * Then: source\r\n   * operation completed.\r\n   *\r\n   * // Console output if the promise fails -\r\n   * Error: source\r\n   * operation failed.\r\n   * ```\r\n   */\r\n  cancelled<TResult = never>(\r\n    onrejected?:\r\n      | ((reason: any) => TResult | PromiseLike<TResult>)\r\n      | null\r\n      | undefined,\r\n  ): ICancellablePromiseExt<T | TResult>;\r\n\r\n  then<TResult1 = T, TResult2 = never>(\r\n    onfulfilled?:\r\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\r\n      | null\r\n      | undefined,\r\n    onrejected?:\r\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\r\n      | null\r\n      | undefined,\r\n  ): ICancellablePromiseExt<TResult1 | TResult2>;\r\n  catch<TResult = never>(\r\n    onrejected?:\r\n      | ((reason: any) => TResult | PromiseLike<TResult>)\r\n      | null\r\n      | undefined,\r\n  ): ICancellablePromiseExt<T | TResult>;\r\n  finally(\r\n    onfinally?: (() => void) | null | undefined,\r\n  ): ICancellablePromiseExt<T>;\r\n};\r\n\r\n/**\r\n * Infers the type of the first parameter passed to a function.\r\n *\r\n * @template T - The function type.\r\n * @example\r\n * ```typescript\r\n * type MyFunction = (arg1: string, arg2: number) => void;\r\n * type FirstParamType = FirstParameter<MyFunction>; // string\r\n * ```\r\n */\r\nexport type FirstParameter<T extends (...args: any) => any> = T extends (\r\n  arg1: infer P,\r\n  ...args: any\r\n) => any\r\n  ? P\r\n  : never;\r\n\r\n/**\r\n * Extracts the arguments of a function type as a tuple.\r\n *\r\n * @template T - The function type.\r\n * @example\r\n * ```typescript\r\n * type MyFunction = (arg1: string, arg2: number) => void;\r\n * type ArgsTuple = FunctionArguments<MyFunction>; // [string, number]\r\n * ```\r\n */\r\nexport type FunctionArguments<T extends (...args: any) => any> = T extends (\r\n  ...args: infer A\r\n) => any\r\n  ? A\r\n  : never;\r\n\r\n/**\r\n * Extracts the return type of a function type.\r\n * @template T - The function type.\r\n * @example\r\n *\r\n * ```typescript\r\n * type MyType = {\r\n *  a: string;\r\n *  b: number;\r\n *  c: boolean;\r\n *  d: () => void;\r\n * };\r\n * type KeysOfMethodsInMyType = KeysOfMethods<MyType>; // 'd'\r\n * ```\r\n */\r\nexport type KeysOfMethods<T> = {\r\n  [K in keyof T]: T[K] extends (...args: any[]) => any ? K : never;\r\n}[keyof T];\r\n\r\n/**\r\n * Extracts all methods from a given object type.\r\n * @template T - The object type.\r\n * @example\r\n *\r\n * ```typescript\r\n * type MyType = {\r\n * a: string;\r\n * b: () => number;\r\n * c: () => boolean;\r\n * };\r\n * type Methods = MethodsOf<MyType>; // { b: () => number; c: () => boolean; }\r\n * ```\r\n */\r\nexport type MethodsOf<T> = Pick<T, KeysOfMethods<T>>;\r\n\r\n/**\r\n * Extracts the return type of methods from an object type.\r\n * @template T - The object type.\r\n * @example\r\n * ```typescript\r\n * type MyType = {\r\n *  a: string;\r\n *  b: () => number;\r\n *  c: () => boolean;\r\n * };\r\n * type Returns = ReturnTypeOfMethods<MyType>; // { b: number; c: boolean; }\r\n * ```\r\n */\r\nexport type ReturnTypeOfMethods<T> = {\r\n  [K in keyof T]: T[K] extends (...args: any[]) => infer R ? R : never;\r\n}[keyof MethodsOf<T>];\r\n\r\n/**\r\n * Excludes types from `T` that are exactly the same as `U`.\r\n *\r\n * @template T - The union type from which to exclude exact matches.\r\n * @template U - The type to exclude from `T`.\r\n *\r\n * @example\r\n * ```typescript\r\n * type Result = ExcludeExactMatch<'a' | 'b' | 'c', 'b'>; // Result is 'a' | 'c'\r\n * ```\r\n */\r\nexport type ExcludeExactMatch<T, U> = T extends U ? never : T;\r\n\r\n/**\r\n * A type that excludes `null` and `undefined` from a given type `K`.\r\n *\r\n * @template K - The type to be checked.\r\n *\r\n * @example\r\n * ```typescript\r\n * type NonNullableString = IsNotNull<string | null | undefined>; // Result is string\r\n * type NonNullableNumber = IsNotNull<number | null>; // Result is number\r\n * type NonNullableBoolean = IsNotNull<boolean | undefined>; // Result is boolean\r\n * type NonNullableObject = IsNotNull<{ a: number } | null | undefined>; // Result is { a: number }\r\n * ```\r\n */\r\nexport type IsNotNull<K> = K extends null\r\n  ? never\r\n  : K extends undefined\r\n    ? never\r\n    : K;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\abortable-promise.d.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":120,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":120,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4171,4174],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4171,4174],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":157,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5337,5340],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5337,5340],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":171,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5813,5816],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5813,5816],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":217,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":217,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7298,7301],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7298,7301],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\abortable-promise.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1012,1015],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1012,1015],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":67,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2242,2245],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2242,2245],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":75,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2631,2634],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2631,2634],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":94,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3228,3231],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3228,3231],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\dual-key-map.d.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":49,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1814,1817],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1814,1817],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\dual-key-map.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":2,"column":1,"nodeType":"Program","endLine":128,"endColumn":1}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":4,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":4,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[148,151],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[148,151],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nexport class DualKeyMap<\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  TRecordType extends { [K in TIdField | TNameField]: any },\r\n  TRecordIdType extends PropertyKey,\r\n  TRecordNameType extends PropertyKey,\r\n  TIdField extends PropertyKey = PropertyKey,\r\n  TNameField extends PropertyKey = PropertyKey\r\n> {\r\n  private readonly idField: TIdField;\r\n  private readonly nameField: TNameField;\r\n  private readonly idToRecord: Map<TRecordIdType, TRecordType>;\r\n  private readonly nameToId: Map<TRecordNameType, TRecordIdType>;\r\n\r\n  /**\r\n   * Create a new DualKeyMap\r\n   * @param idField - The field name in the record that is the ID\r\n   * @param nameField - The field name in the record that is the name\r\n   * @param entries - Optional initial entries as [id, record] pairs\r\n   */\r\n  constructor(idField: TIdField, nameField: TNameField, entries?: IterableIterator<[TRecordIdType, TRecordType]>) {\r\n    this.idField = idField;\r\n    this.nameField = nameField;\r\n    this.idToRecord = new Map(entries ?? []);\r\n    this.nameToId = new Map();\r\n    this.initializeNameToIdMap();\r\n  }\r\n\r\n  /**\r\n   * All [id, record] entries\r\n   */\r\n  get entries(): IterableIterator<[TRecordIdType, TRecordType]> {\r\n    return this.idToRecord.entries();\r\n  }\r\n\r\n  /**\r\n   * All record IDs\r\n   */\r\n  get allIds(): TRecordIdType[] {\r\n    return Array.from(this.idToRecord.keys());\r\n  }\r\n\r\n  /**\r\n   * All record names\r\n   */\r\n  get allNames(): TRecordNameType[] {\r\n    return Array.from(this.nameToId.keys());\r\n  }\r\n\r\n  /**\r\n   * Lookup a record by ID or name\r\n   */\r\n  record(idOrName: TRecordIdType | TRecordNameType): TRecordType | undefined {\r\n    let ret = this.idToRecord.get(idOrName as TRecordIdType);\r\n    if (!ret) {\r\n      const id = this.nameToId.get(idOrName as TRecordNameType);\r\n      if (id) {\r\n        ret = this.idToRecord.get(id);\r\n      }\r\n    }\r\n    return ret;\r\n  }\r\n\r\n  /**\r\n   * Get the name for a given ID or name\r\n   */\r\n  name(idOrName: TRecordIdType | TRecordNameType): TRecordNameType | undefined {\r\n    const record = this.record(idOrName);\r\n    return record ? (record[this.nameField] as TRecordNameType) : undefined;\r\n  }\r\n\r\n  /**\r\n   * Get the ID for a given ID or name\r\n   */\r\n  id(idOrName: TRecordIdType | TRecordNameType): TRecordIdType | undefined {\r\n    const name = this.name(idOrName);\r\n    return name ? this.nameToId.get(name) : undefined;\r\n  }\r\n\r\n  /**\r\n   * Check if a record exists by ID or name\r\n   */\r\n  contains(idOrName: TRecordIdType | TRecordNameType): boolean {\r\n    return !!this.record(idOrName);\r\n  }\r\n\r\n  /**\r\n   * Add or update a record\r\n   */\r\n  set(id: TRecordIdType, record: TRecordType): void {\r\n    this.idToRecord.set(id, record);\r\n    this.nameToId.set(record[this.nameField] as TRecordNameType, id);\r\n  }\r\n\r\n  /**\r\n   * Remove a record by ID or name\r\n   */\r\n  delete(idOrName: TRecordIdType | TRecordNameType): boolean {\r\n    const id = this.id(idOrName);\r\n    if (id) {\r\n      const record = this.idToRecord.get(id);\r\n      if (record) {\r\n        this.nameToId.delete(record[this.nameField] as TRecordNameType);\r\n      }\r\n      return this.idToRecord.delete(id);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Clear all records\r\n   */\r\n  clear(): void {\r\n    this.idToRecord.clear();\r\n    this.nameToId.clear();\r\n  }\r\n\r\n  /**\r\n   * Rebuild the name-to-id map from the id-to-record map\r\n   */\r\n  private initializeNameToIdMap(): void {\r\n    this.nameToId.clear();\r\n    this.idToRecord.forEach((rec, id) => {\r\n      this.nameToId.set(rec[this.nameField] as TRecordNameType, id);\r\n    });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\index.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":14,"column":1,"nodeType":"Program","endLine":45,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @module @suetheschool/typescript\r\n *\r\n * This module serves as a collection of utility functions and types for the application.\r\n * It contains typeguars, type predicates, and other utility functions that are essential\r\n * for ensuruing code reusability and consistency.\r\n *\r\n * @remarks\r\n * Funtionality is divided into the following categories:\r\n * - _guards - TypeGuards used to ensure type safety\r\n * - _generics - Generic utility functions.\r\n * - _types - Magical utility types that allow for type manipulation and extraction.\r\n */\r\nexport * from './_guards';\r\nexport type {\r\n  IsNotNull,\r\n  ExcludeExactMatch,\r\n  ReturnTypeOfMethods,\r\n  MethodsOf,\r\n  KeysOfMethods,\r\n  FunctionArguments,\r\n  FirstParameter,\r\n  ICancellablePromiseExt,\r\n  ICancellablePromise,\r\n  UnwrapPromise,\r\n  KeyOf,\r\n  KebabToCamelCase,\r\n  PartialExceptFor,\r\n  PickField,\r\n  ArrayElement,\r\n  UnionToObject,\r\n  TupleToUnion,\r\n  UnionToTuple,\r\n} from './_types';\r\nexport * from './_record-decorators';\r\nexport * from './_generics';\r\nexport type { OperationCancelledError } from './abortable-promise';\r\nexport { AbortablePromise } from './abortable-promise';\r\nexport { zodToStructure } from './zod-to-json-structure';\r\nexport {\r\n  SingletonProvider,\r\n  globalSingleton,\r\n  type SingletonConfig,\r\n} from './singleton-provider';\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\singleton-provider\\index.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\singleton-provider\\index.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":49,"column":1,"nodeType":"Program","endLine":62,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Singleton Provider Module\r\n *\r\n * This module provides a comprehensive singleton management system for TypeScript applications.\r\n * It offers both global and scoped singleton storage with configurable memory management strategies,\r\n * including support for WeakMap-based storage to prevent memory leaks in long-running applications.\r\n *\r\n * The module implements a two-tier singleton system:\r\n * 1. **Global Singletons**: Stored on the global scope using Symbol.for() keys\r\n * 2. **Scoped Singletons**: Managed through the SingletonProvider instance with WeakMap support\r\n *\r\n * Key features:\r\n * - Memory-efficient singleton storage with WeakMap support\r\n * - Type-safe singleton creation and retrieval\r\n * - Automatic cleanup and resource management\r\n * - Configurable storage strategies (strong vs weak references)\r\n * - Thread-safe operations for Node.js environments\r\n *\r\n * @example\r\n * ```typescript\r\n * import { SingletonProvider, globalSingleton } from '@/lib/typescript/singleton-provider';\r\n *\r\n * // Using the global singleton function\r\n * const dbConnection = globalSingleton('database', () => createDatabaseConnection());\r\n *\r\n * // Using the SingletonProvider instance for scoped singletons\r\n * const provider = SingletonProvider.Instance;\r\n *\r\n * // Create a singleton with weak references for better memory management\r\n * const cache = provider.getOrCreate('app-cache', () => new Map(), { weakRef: true });\r\n *\r\n * // Check if a singleton exists\r\n * if (provider.has('user-session')) {\r\n *   const session = provider.get('user-session');\r\n *   // Use existing session\r\n * } else {\r\n *   // Create new session\r\n *   const newSession = provider.getOrCreate('user-session', createSession);\r\n * }\r\n *\r\n * // Clean up when done\r\n * provider.clear();\r\n * ```\r\n *\r\n * @since 1.0.0\r\n * @version 1.0.0\r\n */\r\n\r\nimport { SingletonProvider } from './provider';\r\nimport type { IsNotNull } from '../_types';\r\nimport type { SingletonConfig } from './types';\r\n\r\nexport type { SingletonConfig, SingletonStorageStrategy } from './types';\r\nexport { SingletonProvider } from './provider';\r\n\r\n\r\nexport const globalSingleton = <T, S extends string | symbol = string>(\r\n  symbol: S,\r\n  factory: () => IsNotNull<T>,\r\n  config: SingletonConfig = {},\r\n): T => SingletonProvider.Instance.getOrCreate<T, S>(symbol, factory, config);\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\singleton-provider\\provider.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\singleton-provider\\provider.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":374,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { IsNotNull } from '../_types';\r\nimport { StrongReferenceStorage } from './storage-strong-ref';\r\nimport { WeakReferenceStorage } from './storage-weak-refs';\r\nimport {\r\n  GlobalWithMyGlobal,\r\n  SingletonConfig,\r\n  SingletonStorageKey,\r\n  SingletonStorageStrategy,\r\n} from './types';\r\n\r\n\r\nexport class SingletonProvider {\r\n  #strongStorage = new StrongReferenceStorage();\r\n  #weakStorage = new WeakReferenceStorage();\r\n  #storageByKey: Map<SingletonStorageKey, SingletonStorageStrategy> = new Map();\r\n\r\n  /**\r\n   * Gets the global singleton instance of the SingletonProvider.\r\n   *\r\n   * This static getter provides access to the single global instance of the\r\n   * SingletonProvider class. It uses the internal singleton mechanism to ensure\r\n   * only one instance exists throughout the application lifecycle.\r\n   *\r\n   * The instance is lazily created on first access and stored globally using\r\n   * a well-known symbol to avoid naming conflicts.\r\n   *\r\n   * @static\r\n   * @returns The global SingletonProvider instance\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Get the global provider instance\r\n   * const provider = SingletonProvider.Instance;\r\n   *\r\n   * // Use it to manage singletons\r\n   * const db = provider.getOrCreate('database', createDbConnection);\r\n   * ```\r\n   */\r\n  static get Instance(): SingletonProvider {\r\n    const globalSymbol = Symbol.for(\r\n      '@noeducation/lib/typescript/SingletonProvider',\r\n    );\r\n    const globalWithProvider = globalThis as GlobalWithMyGlobal<\r\n      SingletonProvider,\r\n      typeof globalSymbol\r\n    >;\r\n    if (!globalWithProvider[globalSymbol]) {\r\n      globalWithProvider[globalSymbol] = new SingletonProvider();\r\n    }\r\n    return globalWithProvider[globalSymbol]!;\r\n  }\r\n\r\n  /**\r\n   * Private constructor to enforce singleton pattern.\r\n   *\r\n   * The constructor is private to prevent direct instantiation of the SingletonProvider.\r\n   * Instances should only be created through the static Instance property, which ensures\r\n   * a single global instance throughout the application.\r\n   *\r\n   * @private\r\n   */\r\n  private constructor() {\r\n    // Private constructor to enforce singleton pattern\r\n  }\r\n\r\n  #toStorageKey(symbol: string | symbol): SingletonStorageKey {\r\n    return typeof symbol === 'symbol' ? symbol : Symbol.for(symbol);\r\n  }\r\n\r\n  #selectStorage(\r\n    config: SingletonConfig | undefined,\r\n  ): SingletonStorageStrategy {\r\n    return config?.weakRef ? this.#weakStorage : this.#strongStorage;\r\n  }\r\n\r\n  #ensureWeakValue(value: unknown): asserts value is object {\r\n    if (typeof value !== 'object' || value === null) {\r\n      throw new TypeError(\r\n        'Weak reference singletons require a non-null object value.',\r\n      );\r\n    }\r\n  }\r\n\r\n  #lookupExisting<T>(key: SingletonStorageKey): T | undefined {\r\n    const preferred = this.#storageByKey.get(key);\r\n    if (preferred) {\r\n      const result = preferred.get(key);\r\n      if (result !== undefined) {\r\n        return result as T;\r\n      }\r\n      this.#storageByKey.delete(key);\r\n    }\r\n\r\n    const strong = this.#strongStorage.get(key);\r\n    if (strong !== undefined) {\r\n      this.#storageByKey.set(key, this.#strongStorage);\r\n      return strong as T;\r\n    }\r\n\r\n    const weak = this.#weakStorage.get(key);\r\n    if (weak !== undefined) {\r\n      this.#storageByKey.set(key, this.#weakStorage);\r\n      return weak as T;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  #store(\r\n    key: SingletonStorageKey,\r\n    storage: SingletonStorageStrategy,\r\n    value: unknown,\r\n  ): void {\r\n    if (storage === this.#weakStorage) {\r\n      this.#ensureWeakValue(value);\r\n      this.#strongStorage.delete(key);\r\n    } else {\r\n      this.#weakStorage.delete(key);\r\n    }\r\n    storage.set(key, value);\r\n    this.#storageByKey.set(key, storage);\r\n  }\r\n\r\n  /**\r\n   * Retrieves an existing singleton instance by symbol key.\r\n   *\r\n   * This method attempts to retrieve a singleton instance that was previously\r\n   * created and stored using the provided symbol key. It searches both WeakMap\r\n   * and global storage, returning undefined if no instance exists.\r\n   *\r\n   * Unlike getOrCreate, this method never creates new instances and only returns\r\n   * existing ones.\r\n   *\r\n   * @template T - The expected type of the singleton value (defaults to unknown)\r\n   * @template S - The symbol or string type used as the storage key\r\n   * @param symbol - The symbol or string key used to identify the singleton\r\n   * @returns The existing singleton instance, or undefined if not found\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Try to get an existing database connection\r\n   * const db = provider.get<DatabaseConnection>('database');\r\n   *\r\n   * if (db) {\r\n   *   // Use existing connection\r\n   *   await db.query('SELECT * FROM users');\r\n   * } else {\r\n   *   // Create new connection\r\n   *   const newDb = provider.getOrCreate('database', createConnection);\r\n   * }\r\n   * ```\r\n   */\r\n  get<T = unknown, S extends string | symbol = string>(\r\n    symbol: S,\r\n  ): T | undefined {\r\n    const key = this.#toStorageKey(symbol);\r\n    return this.#lookupExisting<T>(key);\r\n  }\r\n  /**\r\n   * Retrieves an existing singleton or creates a new one using the provided factory.\r\n   *\r\n   * This method implements the core singleton pattern: it first checks if a singleton\r\n   * instance already exists for the given symbol. If found, it returns the existing\r\n   * instance. If not found, it creates a new instance using the factory function and\r\n   * stores it according to the configuration.\r\n   *\r\n   * The method supports configurable storage strategies, allowing choice between\r\n   * strong references (global scope) and weak references (WeakMap) for better\r\n   * memory management.\r\n   *\r\n   * @template T - The type of singleton value being created\r\n   * @template S - The symbol or string type used as the storage key\r\n   * @param symbol - The symbol or string key for the singleton\r\n   * @param factory - Factory function that creates the singleton instance\r\n   * @param config - Optional configuration for storage strategy (defaults to strong references)\r\n   * @returns The existing or newly created singleton instance\r\n   *\r\n   * @throws {TypeError} When the factory function returns null or undefined\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Create a database connection singleton\r\n   * const db = provider.getOrCreate('database', () => {\r\n   *   return new DatabaseConnection(process.env.DB_URL);\r\n   * });\r\n   *\r\n   * // Create a cache with weak references for memory efficiency\r\n   * const cache = provider.getOrCreate('cache', () => new Map(), {\r\n   *   weakRef: true\r\n   * });\r\n   *\r\n   * // Multiple calls return the same instance\r\n   * const db1 = provider.getOrCreate('database', createDb);\r\n   * const db2 = provider.getOrCreate('database', createDb);\r\n   * console.log(db1 === db2); // true\r\n   * ```\r\n   */\r\n  getOrCreate<T, S extends string | symbol = string>(\r\n    symbol: S,\r\n    factory: () => IsNotNull<T>,\r\n    config: SingletonConfig = {},\r\n  ): T {\r\n    const key = this.#toStorageKey(symbol);\r\n    const existing = this.#lookupExisting<T>(key);\r\n    if (existing !== undefined) {\r\n      return existing;\r\n    }\r\n\r\n    const value = factory();\r\n    if (value === undefined || value === null) {\r\n      throw new TypeError(\r\n        'Factory for global singleton cannot return null or undefined.',\r\n      );\r\n    }\r\n\r\n    const storage = this.#selectStorage(config);\r\n    this.#store(key, storage, value);\r\n    return value;\r\n  }\r\n  /**\r\n   * Checks if a singleton instance exists for the given symbol.\r\n   *\r\n   * This method checks whether a singleton has been created and is being tracked\r\n   * by this provider instance. It checks both WeakMap and global storage to ensure\r\n   * the singleton actually exists.\r\n   *\r\n   * @template S - The symbol or string type used as the storage key\r\n   * @param symbol - The symbol or string key to check\r\n   * @returns True if a singleton exists for the key, false otherwise\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Check if a service has been initialized\r\n   * if (provider.has('user-service')) {\r\n   *   console.log('User service is available');\r\n   * } else {\r\n   *   console.log('User service needs to be initialized');\r\n   * }\r\n   *\r\n   * // Safe retrieval pattern\r\n   * const service = provider.has('api-client')\r\n   *   ? provider.get('api-client')\r\n   *   : provider.getOrCreate('api-client', createApiClient);\r\n   * ```\r\n   */\r\n  has<S extends string | symbol = string>(symbol: S): boolean {\r\n    const key = this.#toStorageKey(symbol);\r\n    const preferred = this.#storageByKey.get(key);\r\n    if (preferred?.has(key)) {\r\n      return true;\r\n    }\r\n    this.#storageByKey.delete(key);\r\n\r\n    if (this.#strongStorage.has(key)) {\r\n      this.#storageByKey.set(key, this.#strongStorage);\r\n      return true;\r\n    }\r\n\r\n    if (this.#weakStorage.has(key)) {\r\n      this.#storageByKey.set(key, this.#weakStorage);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n  /**\r\n   * Manually sets a singleton instance for the given symbol.\r\n   *\r\n   * This method allows direct assignment of singleton instances without using a factory.\r\n   * It's useful for setting pre-created instances or overriding existing singletons.\r\n   * The storage strategy (strong vs weak references) can be configured.\r\n   *\r\n   * When weakRef is true, the instance is stored in WeakMap and can be garbage collected\r\n   * if no other references exist. When false, it's stored globally with strong references.\r\n   *\r\n   * @template T - The type of singleton value being stored\r\n   * @template S - The symbol or string type used as the storage key\r\n   * @param symbol - The symbol or string key for the singleton\r\n   * @param value - The singleton instance to store (must not be null or undefined)\r\n   * @param config - Optional configuration for storage strategy (defaults to strong references)\r\n   *\r\n   * @throws {TypeError} When the value parameter is null or undefined\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Set a pre-configured logger instance\r\n   * const logger = new Logger({ level: 'info' });\r\n   * provider.set('logger', logger);\r\n   *\r\n   * // Set a cache with weak references for memory efficiency\r\n   * const cache = new Map();\r\n   * provider.set('cache', cache, { weakRef: true });\r\n   *\r\n   * // Override an existing singleton\r\n   * provider.set('database', newDatabaseConnection);\r\n   * ```\r\n   */\r\n  set<T, S extends string | symbol = string>(\r\n    symbol: S,\r\n    value: IsNotNull<T>,\r\n    config: SingletonConfig = {},\r\n  ): void {\r\n    if (value === null || value === undefined) {\r\n      throw new TypeError('Cannot set singleton value to null or undefined.');\r\n    }\r\n\r\n    const key = this.#toStorageKey(symbol);\r\n    const storage = this.#selectStorage(config);\r\n    this.#store(key, storage, value);\r\n  }\r\n  /**\r\n   * Clears all singleton instances managed by this provider.\r\n   *\r\n   * This method removes all singletons that were created through this provider instance,\r\n   * cleaning up both WeakMap and global storage. It's useful for testing, application\r\n   * shutdown, or when a complete reset is needed.\r\n   *\r\n   * The method iterates through all tracked keys and removes the corresponding instances\r\n   * from both storage locations (WeakMap and global scope) to ensure complete cleanup.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Clear all singletons during testing\r\n   * afterEach(() => {\r\n   *   provider.clear();\r\n   * });\r\n   *\r\n   * // Reset application state\r\n   * provider.clear();\r\n   * initializeApplication();\r\n   *\r\n   * // Graceful shutdown\r\n   * process.on('SIGTERM', () => {\r\n   *   provider.clear();\r\n   *   process.exit(0);\r\n   * });\r\n   * ```\r\n   */\r\n  clear(): void {\r\n    this.#strongStorage.clear();\r\n    this.#weakStorage.clear();\r\n    this.#storageByKey.clear();\r\n  }\r\n  /**\r\n   * Deletes a specific singleton instance by symbol key.\r\n   *\r\n   * This method removes a single singleton instance from both WeakMap and global storage,\r\n   * allowing it to be garbage collected if no other references exist. It's useful for\r\n   * cleaning up specific resources or resetting individual singletons.\r\n   *\r\n   * @template S - The symbol or string type used as the storage key\r\n   * @param symbol - The symbol or string key of the singleton to delete\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Remove a specific service\r\n   * provider.delete('user-service');\r\n   *\r\n   * // Reset a cache\r\n   * provider.delete('app-cache');\r\n   * const newCache = provider.getOrCreate('app-cache', () => new Map());\r\n   *\r\n   * // Clean up temporary singletons\r\n   * provider.delete('temp-session');\r\n   * ```\r\n   */\r\n  delete<S extends string | symbol = string>(symbol: S): void {\r\n    const key = this.#toStorageKey(symbol);\r\n    this.#strongStorage.delete(key);\r\n    this.#weakStorage.delete(key);\r\n    this.#storageByKey.delete(key);\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\singleton-provider\\storage-strong-ref.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\singleton-provider\\storage-strong-ref.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":15,"column":1,"nodeType":"Program","endLine":153,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Strong reference storage implementation for singleton management.\r\n *\r\n * This module provides a storage strategy that maintains strong references to singleton\r\n * instances on the global object. Unlike weak references, strong references prevent\r\n * garbage collection, ensuring singletons persist for the lifetime of the application.\r\n *\r\n * This is the recommended storage strategy for most singleton use cases where you want\r\n * guaranteed persistence and don't need automatic cleanup.\r\n *\r\n * @module lib/typescript/singleton-provider/storage-strong-ref\r\n * @see {@link SingletonStorageStrategy} for the interface this implements\r\n */\r\n\r\nimport {\r\n  GlobalWithMyGlobal,\r\n  SingletonStorageKey,\r\n  SingletonStorageStrategy,\r\n} from './types';\r\n\r\n\r\nexport class StrongReferenceStorage implements SingletonStorageStrategy {\r\n  /**\r\n   * Internal set tracking all keys that have been set.\r\n   * Used for efficient clear() operations and to prevent memory leaks.\r\n   * @private\r\n   */\r\n  #keys: Set<SingletonStorageKey> = new Set();\r\n\r\n  /**\r\n   * Reference to the global object with proper typing.\r\n   * Stores singleton instances directly on globalThis.\r\n   * @private\r\n   */\r\n  #global = globalThis as GlobalWithMyGlobal<unknown, SingletonStorageKey>;\r\n\r\n  /**\r\n   * Retrieves a singleton instance from storage.\r\n   *\r\n   * @param {SingletonStorageKey} key - The unique key (typically a Symbol) identifying the singleton\r\n   * @returns {unknown | undefined} The stored instance, or undefined if not found\r\n   *\r\n   * @example\r\n   * const myKey = Symbol('myService');\r\n   * storage.set(myKey, myService);\r\n   * const instance = storage.get(myKey); // Returns myService\r\n   * const missing = storage.get(Symbol('notFound')); // Returns undefined\r\n   */\r\n  get(key: SingletonStorageKey): unknown | undefined {\r\n    return this.#global[key];\r\n  }\r\n\r\n  /**\r\n   * Stores a singleton instance with strong reference semantics.\r\n   *\r\n   * The instance is stored directly on the global object and will not be garbage\r\n   * collected until explicitly deleted. The key is tracked internally for cleanup operations.\r\n   *\r\n   * @param {SingletonStorageKey} key - The unique key (typically a Symbol) to store the instance under\r\n   * @param {unknown} value - The singleton instance to store\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * const myKey = Symbol('myService');\r\n   * const myService = new MyService();\r\n   * storage.set(myKey, myService); // Stores with strong reference\r\n   *\r\n   * @example\r\n   * // Updating an existing singleton\r\n   * storage.set(myKey, oldInstance);\r\n   * storage.set(myKey, newInstance); // Replaces the old instance\r\n   */\r\n  set(key: SingletonStorageKey, value: unknown): void {\r\n    this.#global[key] = value;\r\n    this.#keys.add(key);\r\n  }\r\n\r\n  /**\r\n   * Checks if a singleton instance exists in storage.\r\n   *\r\n   * @param {SingletonStorageKey} key - The key to check\r\n   * @returns {boolean} True if an instance exists for the key, false otherwise\r\n   *\r\n   * @example\r\n   * const myKey = Symbol('myService');\r\n   * storage.has(myKey); // false\r\n   * storage.set(myKey, myService);\r\n   * storage.has(myKey); // true\r\n   * storage.delete(myKey);\r\n   * storage.has(myKey); // false\r\n   *\r\n   * @note Returns false for keys that were set to undefined\r\n   */\r\n  has(key: SingletonStorageKey): boolean {\r\n    return this.#global[key] !== undefined;\r\n  }\r\n\r\n  /**\r\n   * Removes a singleton instance from storage.\r\n   *\r\n   * Deletes the instance from the global object and removes the key from internal tracking.\r\n   * After deletion, the instance may be garbage collected if no other references exist.\r\n   *\r\n   * @param {SingletonStorageKey} key - The key of the singleton to remove\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * const myKey = Symbol('myService');\r\n   * storage.set(myKey, myService);\r\n   * storage.delete(myKey); // Removes the singleton\r\n   * storage.get(myKey); // Returns undefined\r\n   *\r\n   * @example\r\n   * // Safe to call on non-existent keys\r\n   * storage.delete(Symbol('nonExistent')); // No error, no-op\r\n   */\r\n  delete(key: SingletonStorageKey): void {\r\n    delete this.#global[key];\r\n    this.#keys.delete(key);\r\n  }\r\n\r\n  /**\r\n   * Removes all tracked singleton instances from storage.\r\n   *\r\n   * Iterates through all keys that have been set and removes them from the global object.\r\n   * This is useful for cleanup in testing environments or when resetting application state.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * // Cleanup all singletons\r\n   * storage.set(Symbol('service1'), service1);\r\n   * storage.set(Symbol('service2'), service2);\r\n   * storage.set(Symbol('service3'), service3);\r\n   * storage.clear(); // Removes all three services\r\n   *\r\n   * @example\r\n   * // Common pattern in test cleanup\r\n   * afterEach(() => {\r\n   *   storage.clear(); // Reset singleton state between tests\r\n   * });\r\n   *\r\n   * @note Only removes keys that were tracked by this storage instance.\r\n   * Does not affect other global properties.\r\n   */\r\n  clear(): void {\r\n    for (const key of this.#keys) {\r\n      delete this.#global[key];\r\n    }\r\n    this.#keys.clear();\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\singleton-provider\\storage-weak-refs.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\singleton-provider\\storage-weak-refs.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\singleton-provider\\types.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\singleton-provider\\types.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":35,"column":1,"nodeType":"Program","endLine":98,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Configuration options for singleton pattern implementations.\r\n *\r\n * This type defines optional configuration parameters for singleton creation and\r\n * management, particularly focusing on memory management strategies. The configuration\r\n * allows tuning the singleton behavior for different use cases and performance requirements.\r\n *\r\n * @typedef {Object} SingletonConfig\r\n *\r\n * @property {boolean} [weakRef] - Optional flag indicating whether to use WeakRef\r\n *   for singleton storage. When enabled, singletons can be garbage collected if\r\n *   no other references exist, preventing memory leaks in long-running applications.\r\n *   When disabled, singletons are stored with strong references and persist until\r\n *   explicitly cleared. Defaults to false for backward compatibility.\r\n *\r\n * @example\r\n * ```typescript\r\n * // Standard singleton with strong references\r\n * const standardConfig: SingletonConfig = {\r\n *   weakRef: false\r\n * };\r\n *\r\n * // Memory-efficient singleton with weak references\r\n * const memoryEfficientConfig: SingletonConfig = {\r\n *   weakRef: true\r\n * };\r\n *\r\n * // Default configuration (equivalent to not specifying config)\r\n * const defaultConfig: SingletonConfig = {};\r\n * ```\r\n *\r\n * @see {@link globalSingleton} in `/lib/typescript/_generics.ts` for singleton implementation\r\n * @since 1.0.0\r\n */\r\nexport type SingletonConfig = {\r\n  weakRef?: boolean;\r\n};\r\n\r\n/**\r\n * Key type used for singleton storage strategies.\r\n */\r\nexport type SingletonStorageKey = symbol;\r\n\r\n/**\r\n * Interface defining the storage strategy for singleton instances.\r\n * This interface abstracts the underlying storage mechanism, allowing\r\n * for different implementations such as in-memory maps, weak maps, or\r\n * custom storage solutions.\r\n * @internal\r\n * @since 1.0.0\r\n * @version 1.0.0\r\n * @example\r\n * ```typescript\r\n * // Example implementation using a simple Map\r\n * class MapStorageStrategy implements SingletonStorageStrategy {\r\n *   private storage = new Map<SingletonStorageKey, unknown>();\r\n *   get(key: SingletonStorageKey): unknown | undefined {\r\n *     return this.storage.get(key);\r\n *   }\r\n *   set(key: SingletonStorageKey, value: unknown): void {\r\n *     this.storage.set(key, value);\r\n *   }\r\n *   has(key: SingletonStorageKey): boolean {\r\n *     return this.storage.has(key);\r\n *   }\r\n *   delete(key: SingletonStorageKey): void {\r\n *     this.storage.delete(key);\r\n *   }\r\n *   clear(): void {\r\n *     this.storage.clear();\r\n *   }\r\n * }\r\n * ```\r\n *\r\n */\r\nexport interface SingletonStorageStrategy {\r\n  get(key: SingletonStorageKey): unknown | undefined;\r\n  set(key: SingletonStorageKey, value: unknown): void;\r\n  has(key: SingletonStorageKey): boolean;\r\n  delete(key: SingletonStorageKey): void;\r\n  clear(): void;\r\n}\r\n/**\r\n * Extended global object type with singleton storage capabilities.\r\n *\r\n * This utility type extends the globalThis object to include optional properties\r\n * for storing singleton instances keyed by symbols. It provides type-safe access\r\n * to globally stored singletons while maintaining compatibility with the standard\r\n * global object interface.\r\n *\r\n * @internal\r\n * @template T - The type of singleton value stored globally\r\n * @template S - The symbol type used as the storage key\r\n */\r\nexport type GlobalWithMyGlobal<T, S extends symbol> = typeof globalThis & {\r\n  [K in S]?: T;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\zod-to-json-structure.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\lib\\typescript\\zod-to-json-structure.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":29,"column":1,"nodeType":"Program","endLine":300,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Converts Zod schemas to human-readable JSON structure strings.\r\n *\r\n * This module provides utilities for transforming Zod validation schemas into\r\n * readable string representations that show the expected structure of data.\r\n * Useful for documentation, debugging, and displaying schema information to users.\r\n *\r\n * @module lib/typescript/zod-to-json-structure\r\n * @example\r\n * ```typescript\r\n * import { z } from 'zod';\r\n * import { zodToStructure } from '@/lib/typescript/zod-to-json-structure';\r\n *\r\n * const userSchema = z.object({\r\n *   name: z.string(),\r\n *   age: z.number().optional(),\r\n *   email: z.string()\r\n * });\r\n *\r\n * console.log(zodToStructure(userSchema));\r\n * // Output: {\r\n * //   name: <string>,\r\n * //   age: /* [optional] *\\/ <number>,\r\n * //   email: <string>,\r\n * // }\r\n * ```\r\n */\r\n\r\nimport {\r\n  ZodTypeAny,\r\n  ZodObject,\r\n  ZodArray,\r\n  ZodOptional,\r\n  ZodString,\r\n  ZodNumber,\r\n  ZodBoolean,\r\n  ZodDefault,\r\n  ZodNullable,\r\n  ZodDate,\r\n} from 'zod';\r\n\r\n/**\r\n * Function signature for converting a SchemaField to a string representation.\r\n * Supports both parameterless calls (default indent) and calls with custom indentation.\r\n *\r\n * @callback SchemaFieldToString\r\n * @returns {string} The string representation with default indentation\r\n *\r\n * @callback SchemaFieldToString\r\n * @param {number} indent - The indentation level (number of spaces = indent * 2)\r\n * @returns {string} The string representation with specified indentation\r\n */\r\ninterface SchemaFieldToString {\r\n  (): string;\r\n  (indent: number): string;\r\n}\r\n\r\n/**\r\n * Base properties shared by all schema field types.\r\n * Represents common metadata extracted from Zod schemas.\r\n *\r\n * @typedef {Object} BasedSchemaField\r\n * @property {string} type - The primitive type name (e.g., 'string', 'number', 'object', 'array')\r\n * @property {boolean} [optional] - Whether the field is optional (Zod optional() or has default())\r\n * @property {boolean} [nullable] - Whether the field accepts null values (Zod nullable())\r\n * @property {string} [description] - Description extracted from Zod schema's .describe() method\r\n * @property {SchemaFieldToString} toString - Function to convert field to string representation\r\n */\r\ntype BasedSchemaField = {\r\n  type: string;\r\n  optional?: boolean;\r\n  nullable?: boolean;\r\n  description?: string;\r\n  toString: SchemaFieldToString;\r\n};\r\n\r\n/**\r\n * Discriminated union representing different types of schema fields.\r\n * Each variant corresponds to a specific Zod schema type.\r\n *\r\n * @typedef {Object} SchemaField\r\n *\r\n * Array variant:\r\n * @property {'array'} type - Indicates this is an array type\r\n * @property {SchemaField} items - Schema for array elements\r\n *\r\n * Object variant:\r\n * @property {'object'} type - Indicates this is an object type\r\n * @property {Record<string, SchemaField>} properties - Map of property names to their schemas\r\n *\r\n * Primitive variants (number, boolean, date):\r\n * @property {'number'|'boolean'|'date'} type - The primitive type\r\n * @property {false|never} nullable - These types cannot be nullable in the schema\r\n *\r\n * String variant:\r\n * @property {'string'} type - Indicates this is a string type\r\n *\r\n * Any variant (fallback):\r\n * @property {'any'} type - Indicates an unrecognized or generic type\r\n * @property {Record<string, SchemaField>} [properties] - Optional properties if object-like\r\n * @property {SchemaField} [items] - Optional items if array-like\r\n */\r\ntype SchemaField =\r\n  | (BasedSchemaField & {\r\n      type: 'array';\r\n      items: Exclude<SchemaField, 'optional'>;\r\n    })\r\n  | (BasedSchemaField & {\r\n      type: 'object';\r\n      properties: Record<string, SchemaField>;\r\n    })\r\n  | (BasedSchemaField & {\r\n      type: 'number' | 'boolean' | 'date';\r\n      nullable: false | never;\r\n    })\r\n  | (BasedSchemaField & {\r\n      type: 'string';\r\n    })\r\n  | (BasedSchemaField & {\r\n      properties?: Record<string, SchemaField>;\r\n      items?: Exclude<SchemaField, 'optional'>;\r\n      type: 'any';\r\n    });\r\n\r\n/**\r\n * Adds a trailing comma to the last line of a multi-line string.\r\n * Intelligently places the comma before any trailing comments (optional/nullable flags or descriptions).\r\n *\r\n * Used when building object/array representations to ensure proper JSON-like formatting.\r\n *\r\n * @param {string} input - The multi-line string to process\r\n * @returns {string} The input string with a comma added to the last line before comments\r\n *\r\n * @example\r\n * withComma(\"name: <string> \\/\\* user's name *\\/\")\r\n * // Returns: \"name: <string>, \\/\\* user's name *\\/\"\r\n *\r\n * @example\r\n * withComma(\"age: \\/\\* [optional] *\\/ <number>\")\r\n * // Returns: \"age: \\/\\* [optional] *\\/ <number>,\"\r\n */\r\nconst withComma = (input: string): string => {\r\n  const current = input.split('\\n');\r\n  if (!current.length) {\r\n    return input;\r\n  }\r\n  const lastIndex = current.length - 1;\r\n  const lastItem = current[lastIndex];\r\n  let flagIndex = lastItem.indexOf('/* [optional');\r\n  if (flagIndex === -1) {\r\n    flagIndex = lastItem.indexOf('/* [nullable');\r\n  }\r\n  let descriptionCommentIndex = lastItem.lastIndexOf('/*');\r\n  if (descriptionCommentIndex === flagIndex) {\r\n    descriptionCommentIndex = -1;\r\n  }\r\n  current[lastIndex] =\r\n    descriptionCommentIndex > -1\r\n      ? `${lastItem.slice(0, descriptionCommentIndex - 1)},${lastItem.slice(descriptionCommentIndex - 1)}`\r\n      : lastItem + ',';\r\n  return current.join('\\n');\r\n};\r\n/**\r\n * Converts a Zod schema into a SchemaField representation.\r\n * Recursively processes nested schemas (objects, arrays) and handles wrapper types\r\n * like optional, nullable, and default.\r\n *\r\n * @param {ZodTypeAny} schema - The Zod schema to convert\r\n * @returns {SchemaField} A structured representation of the schema with type info and metadata\r\n *\r\n * @example\r\n * const schema = z.object({ name: z.string(), age: z.number().optional() });\r\n * const field = zodToSchemaField(schema);\r\n * // field.type === 'object'\r\n * // field.properties.name.type === 'string'\r\n * // field.properties.age.optional === true\r\n *\r\n * @internal This is an internal helper used by zodToStructure\r\n */\r\nconst zodToSchemaField = (schema: ZodTypeAny): SchemaField => {\r\n  let ret: Partial<SchemaField> = { description: schema.description };\r\n\r\n  /**\r\n   * Unwraps wrapper schemas (optional, nullable, default, effects) to get the inner type.\r\n   * Recursively processes the unwrapped schema.\r\n   *\r\n   * @returns {SchemaField} The unwrapped schema field\r\n   * @throws {Error} If unable to unwrap the schema\r\n   */\r\n  const unwrapType = () => {\r\n    // Handle effects/unwrapping\r\n    if ('schema' in schema._def) {\r\n      return zodToSchemaField(schema._def.schema);\r\n    }\r\n    if (\r\n      'unwrap' in schema &&\r\n      schema.unwrap &&\r\n      typeof schema.unwrap === 'function'\r\n    ) {\r\n      return zodToSchemaField(schema.unwrap());\r\n    }\r\n    return zodToSchemaField(schema._def.innerType);\r\n  };\r\n  // Type detection: Check Zod schema type and extract relevant information\r\n  if (schema instanceof ZodOptional || schema instanceof ZodDefault) {\r\n    // Optional fields: unwrap and mark as optional\r\n    ret = unwrapType();\r\n    ret.optional = true;\r\n  } else if (schema instanceof ZodNullable) {\r\n    // Nullable fields: unwrap and mark as nullable\r\n    ret = unwrapType();\r\n    ret.nullable = true;\r\n  } else if (schema instanceof ZodString) {\r\n    // String primitive\r\n    ret.type = 'string';\r\n  } else if (schema instanceof ZodNumber) {\r\n    // Number primitive\r\n    ret.type = 'number';\r\n  } else if (schema instanceof ZodBoolean) {\r\n    // Boolean primitive\r\n    ret.type = 'boolean';\r\n  } else if (schema instanceof ZodDate) {\r\n    // Date type\r\n    ret.type = 'date';\r\n  } else if (schema instanceof ZodArray) {\r\n    // Array type: recursively process element schema\r\n    ret.type = 'array';\r\n    if (ret.type === 'array') {\r\n      ret.items = zodToSchemaField(schema.element);\r\n    }\r\n  } else if (schema instanceof ZodObject) {\r\n    // Object type: recursively process all properties\r\n    ret.type = 'object';\r\n    if (ret.type === 'object') {\r\n      const shape = schema.shape as Record<string, ZodTypeAny>;\r\n      ret.properties = {};\r\n      for (const key in shape) {\r\n        ret.properties[key] = zodToSchemaField(shape[key]);\r\n      }\r\n    }\r\n  } else {\r\n    // Fallback for unrecognized types\r\n    ret.type = 'any';\r\n  }\r\n  /**\r\n   * Converts this SchemaField to a formatted string representation.\r\n   * Handles indentation, type annotations, optional/nullable flags, and descriptions.\r\n   *\r\n   * @param {number} [indent=0] - Current indentation level (each level = 2 spaces)\r\n   * @returns {string} Formatted string representation of the schema\r\n   */\r\n  ret.toString = (indent: number = 0) => {\r\n    let builder = '';\r\n    switch (ret.type) {\r\n      case 'array':\r\n        // Format: [ <element-type>, ... ] as Array<type>\r\n        builder = `[ ${ret.items ? withComma(ret.items.toString(indent + 1)) : withComma('unknown')} ... ] as Array<${ret.items?.type ?? 'any'}>`;\r\n        break;\r\n      case 'object':\r\n        // Format: { key: <type>, ... } with proper indentation\r\n        const indentStr = ' '.repeat((indent + 1) * 2);\r\n        builder =\r\n          '{' +\r\n          Object.entries(ret.properties ?? {})\r\n            .map(([key, value]) =>\r\n              withComma(`\\n${indentStr}${key}: ${value.toString(indent + 1)}`),\r\n            )\r\n            .join('') +\r\n          `\\n${' '.repeat(indent * 2)}}`;\r\n        break;\r\n      case undefined:\r\n        // Fallback for undefined type\r\n        builder = '<any>';\r\n        break;\r\n      default:\r\n        // Primitive types: <string>, <number>, etc.\r\n        builder = `<${ret.type}>`;\r\n        break;\r\n    }\r\n    // Add optional/nullable flags as comment prefix\r\n    if (ret.optional) {\r\n      builder = `/* [optional${ret.nullable ? ', nullable' : ''}] */ ${builder}`;\r\n    } else if (ret.nullable) {\r\n      builder = `/* [nullable] */ ${builder}`;\r\n    }\r\n    // Add description as comment suffix\r\n    if (ret.description) {\r\n      builder = `${builder} /* ${ret.description} */`;\r\n    }\r\n    return builder;\r\n  };\r\n  return ret as SchemaField;\r\n};\r\n\r\n\r\nexport const zodToStructure = (schema: ZodTypeAny): string => {\r\n  const asField = zodToSchemaField(schema);\r\n  return asField.toString();\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\next.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\playwright.config.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":1,"column":1,"nodeType":"Program","endLine":105,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { defineConfig, devices } from '@playwright/test';\r\n\r\n/**\r\n * See https://playwright.dev/docs/test-configuration.\r\n */\r\nexport default defineConfig({\r\n  testDir: './tests/e2e',\r\n  /* Run tests in files in parallel */\r\n  fullyParallel: true,\r\n  /* Fail the build on CI if you accidentally left test.only in the source code. */\r\n  forbidOnly: !!process.env.CI,\r\n  /* Retry on CI only */\r\n  retries: process.env.CI ? 2 : 0,\r\n  /* Opt out of parallel tests on CI. */\r\n  workers: process.env.CI ? 1 : undefined,\r\n  /* Reporter to use. See https://playwright.dev/docs/test-reporters */\r\n  reporter: 'html',\r\n  /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */\r\n  use: {\r\n    /* Base URL to use in actions like `await page.goto('/')`. */\r\n    baseURL: 'http://localhost:3000',\r\n\r\n    /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */\r\n    trace: 'on-first-retry',\r\n\r\n    /* Take screenshot on failure */\r\n    screenshot: 'only-on-failure',\r\n\r\n    /* Record video on first retry */\r\n    video: 'retain-on-failure',\r\n  },\r\n\r\n  /* Configure projects for major browsers */\r\n  projects: [\r\n    // Safe tests only (default) - excludes data mutation tests\r\n    {\r\n      name: 'chromium-safe',\r\n      use: { ...devices['Desktop Chrome'] },\r\n      grep: /^(?!.*@data-mutation)/,\r\n      testIgnore: ['**/navigation/error-handling.test.ts'], // Contains route mocking\r\n    },\r\n    {\r\n      name: 'firefox-safe',\r\n      use: { ...devices['Desktop Firefox'] },\r\n      grep: /^(?!.*@data-mutation)/,\r\n      testIgnore: ['**/navigation/error-handling.test.ts'],\r\n    },\r\n    {\r\n      name: 'webkit-safe',\r\n      use: { ...devices['Desktop Safari'] },\r\n      grep: /^(?!.*@data-mutation)/,\r\n      testIgnore: ['**/navigation/error-handling.test.ts'],\r\n    },\r\n    {\r\n      name: 'mobile-chrome-safe',\r\n      use: { ...devices['Pixel 5'] },\r\n      grep: /^(?!.*@data-mutation)/,\r\n      testIgnore: ['**/navigation/error-handling.test.ts'],\r\n    },\r\n    {\r\n      name: 'mobile-safari-safe',\r\n      use: { ...devices['iPhone 12'] },\r\n      grep: /^(?!.*@data-mutation)/,\r\n      testIgnore: ['**/navigation/error-handling.test.ts'],\r\n    },\r\n\r\n    // Data mutation tests (opt-in only) - require explicit environment variable\r\n    ...(process.env.ENABLE_DATA_MUTATION_TESTS === 'true' ? [\r\n      {\r\n        name: 'chromium-mutation',\r\n        use: { ...devices['Desktop Chrome'] },\r\n        grep: /@data-mutation/,\r\n      },\r\n      {\r\n        name: 'firefox-mutation',\r\n        use: { ...devices['Desktop Firefox'] },\r\n        grep: /@data-mutation/,\r\n      },\r\n    ] : []),\r\n\r\n    // All tests (including mutations) - require explicit flag\r\n    ...(process.env.RUN_ALL_TESTS === 'true' ? [\r\n      {\r\n        name: 'chromium-all',\r\n        use: { ...devices['Desktop Chrome'] },\r\n      },\r\n      {\r\n        name: 'firefox-all',\r\n        use: { ...devices['Desktop Firefox'] },\r\n      },\r\n      {\r\n        name: 'webkit-all',\r\n        use: { ...devices['Desktop Safari'] },\r\n      },\r\n    ] : []),\r\n  ],\r\n\r\n  /* Run your local dev server before starting the tests */\r\n  webServer: {\r\n    command: 'yarn dev',\r\n    url: 'http://localhost:3000',\r\n    reuseExistingServer: !process.env.CI,\r\n    timeout: 120 * 1000,\r\n  },\r\n});","usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\postcss.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\scripts\\migrate-jsdoc\\index.cjs","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":3,"column":12,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":3,"endColumn":25,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":14,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":29,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":5,"column":12,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":5,"endColumn":33,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\scripts\\migrate-jsdoc\\index.js","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":3,"column":12,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":3,"endColumn":25,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":14,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":29,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":5,"column":12,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":5,"endColumn":33,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\tests\\e2e\\auth\\authentication.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\tests\\e2e\\bulk-edit\\bulk-operations.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\tests\\e2e\\chat\\chat-interface.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\tests\\e2e\\email\\email-list.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\tests\\e2e\\helpers\\auth-helper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\tests\\e2e\\helpers\\test-data.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\tests\\e2e\\navigation\\error-handling.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\tests\\e2e\\navigation\\homepage.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\tests\\e2e\\navigation\\navigation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\tests\\lib\\react-util\\utility-methods.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\types\\ai.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\types\\material-ui.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\types\\nextauth.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\repos\\no-ed\\web-ui\\types\\statistics.ts","messages":[{"ruleId":"no-jsdoc-in-ts/no-jsdoc","severity":2,"message":"JSDoc block comments (/** */) are not allowed in implementation .ts/.tsx files. Move rich docs to a .d.ts file.","line":63,"column":1,"nodeType":"Program","endLine":211,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview TypeScript type definitions for application statistics and analytics\r\n *\r\n * This module defines the data structures used for collecting, processing, and displaying\r\n * statistics related to AI model usage, token consumption, request queuing, and system performance.\r\n * These types are used throughout the application for monitoring, analytics, and user-facing\r\n * statistics dashboards.\r\n *\r\n * The module includes types for:\r\n * - AI model statistics and usage tracking\r\n * - Token consumption metrics (prompt, completion, total)\r\n * - Request queuing and processing information\r\n * - API response structures for statistics endpoints\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { ModelStat, StatisticsData } from '@/types/statistics';\r\n *\r\n * // Working with model statistics\r\n * const modelStats: ModelStat[] = await fetchModelStats();\r\n * const activeModels = modelStats.filter(model => model.isActive);\r\n *\r\n * // Processing statistics data\r\n * const stats: StatisticsData = await fetchStatistics();\r\n * console.log('Total pending requests:', stats.queues.summary.totalPending);\r\n * ```\r\n *\r\n * @example\r\n * ```typescript\r\n * import type { TokenStats, QueueRequest } from '@//types/statistics';\r\n *\r\n * // Analyzing token usage\r\n * const hourlyStats: TokenStats = {\r\n *   promptTokens: 1500,\r\n *   completionTokens: 800,\r\n *   totalTokens: 2300,\r\n *   requestCount: 5\r\n * };\r\n *\r\n * // Processing queued requests\r\n * const request: QueueRequest = {\r\n *   id: 'req-123',\r\n *   modelClassification: 'gpt-4',\r\n *   request: {\r\n *     params: {},\r\n *     messages: [{ role: 'user', content: 'Hello' }]\r\n *   },\r\n *   metadata: {\r\n *     submittedAt: '2025-01-01T00:00:00Z',\r\n *     generation: 1,\r\n *     chatHistoryId: 'chat-123',\r\n *     userId: 'user-456'\r\n *   },\r\n *   queueTime: 30000,\r\n *   tokenEstimate: 500\r\n * };\r\n * ```\r\n */\r\n\r\n/**\r\n * Statistics for an individual AI model including usage metrics and availability.\r\n */\r\nexport interface ModelStat {\r\n  /** Unique identifier for the model */\r\n  id: string;\r\n  /** Internal model name used by the provider */\r\n  modelName: string;\r\n  /** Human-readable display name for the model */\r\n  displayName: string;\r\n  /** Detailed description of the model's capabilities */\r\n  description: string;\r\n  /** Whether the model is currently active and available for use */\r\n  isActive: boolean;\r\n  /** Unique identifier of the AI provider */\r\n  providerId: string;\r\n  /** Internal name of the AI provider */\r\n  providerName: string;\r\n  /** Human-readable name of the AI provider */\r\n  providerDisplayName: string;\r\n  /** Maximum tokens allowed per message for this model */\r\n  maxTokensPerMessage: number;\r\n  /** Maximum tokens allowed per minute for rate limiting */\r\n  maxTokensPerMinute: number;\r\n  /** Maximum tokens allowed per day for rate limiting */\r\n  maxTokensPerDay: number;\r\n  /** Unique key used to identify this model in the system */\r\n  modelKey: string;\r\n  /** Whether the model is currently available for requests */\r\n  available: boolean;\r\n  /** Token usage statistics across different time periods */\r\n  stats: {\r\n    minute: TokenStats;\r\n    hour: TokenStats;\r\n    day: TokenStats;\r\n  };\r\n}\r\n\r\n/**\r\n * Token usage statistics for a specific time period.\r\n */\r\nexport interface TokenStats {\r\n  /** Number of tokens used for prompts/input */\r\n  promptTokens: number;\r\n  /** Number of tokens used for completions/output */\r\n  completionTokens: number;\r\n  /** Total number of tokens used (prompt + completion) */\r\n  totalTokens: number;\r\n  /** Number of requests made in this time period */\r\n  requestCount: number;\r\n}\r\n\r\n/**\r\n * Represents a request waiting in the processing queue.\r\n */\r\nexport interface QueueRequest {\r\n  /** Unique identifier for the queued request */\r\n  id: string;\r\n  /** Classification/category of the model being requested */\r\n  modelClassification: string;\r\n  /** The actual request data including parameters and messages */\r\n  request: {\r\n    params: Record<string, unknown>;\r\n    messages: Array<{ role?: string; content?: string }>;\r\n  };\r\n  /** Metadata associated with the request */\r\n  metadata: {\r\n    submittedAt: string;\r\n    generation: 1 | 2;\r\n    chatHistoryId?: string;\r\n    userId?: string;\r\n  };\r\n  /** Time in milliseconds the request has been in queue */\r\n  queueTime: number;\r\n  /** Estimated number of tokens this request will consume */\r\n  tokenEstimate?: number;\r\n}\r\n\r\n/**\r\n * Statistics for a generation queue containing multiple requests.\r\n */\r\nexport interface QueueGenerationStats {\r\n  /** Number of requests currently in this queue */\r\n  size: number;\r\n  /** Array of all requests in the queue */\r\n  requests: QueueRequest[];\r\n  /** Timestamp of the oldest request in the queue */\r\n  oldestRequest?: Date;\r\n  /** Timestamp of the newest request in the queue */\r\n  newestRequest?: Date;\r\n  /** Average size of requests in this queue */\r\n  averageSize: number;\r\n  /** The largest request in the queue by token estimate */\r\n  largestRequest?: QueueRequest;\r\n}\r\n\r\n/**\r\n * Information about a specific queue classification.\r\n */\r\nexport interface QueueInfo {\r\n  /** The classification/category name for this queue */\r\n  classification: string;\r\n  /** Statistics for different generation types */\r\n  queues: {\r\n    generation1: QueueGenerationStats;\r\n    generation2: QueueGenerationStats;\r\n  };\r\n  /** Total number of pending requests across all generations */\r\n  totalPending: number;\r\n}\r\n\r\n/**\r\n * Summary of queue statistics across all classifications.\r\n */\r\nexport interface QueueSummary {\r\n  /** Total number of pending requests across all queues */\r\n  totalPending: number;\r\n  /** Number of generation 1 requests pending */\r\n  totalGen1: number;\r\n  /** Number of generation 2 requests pending */\r\n  totalGen2: number;\r\n}\r\n\r\n/**\r\n * Complete statistics data structure returned by the statistics API.\r\n */\r\nexport interface StatisticsData {\r\n  /** Array of statistics for all available models */\r\n  models: ModelStat[];\r\n  /** Queue statistics and information */\r\n  queues: {\r\n    summary: QueueSummary;\r\n    queues: QueueInfo[];\r\n  };\r\n}\r\n\r\n/**\r\n * Generic API response wrapper for statistics endpoints.\r\n *\r\n * @template T - The type of data contained in the response\r\n */\r\nexport interface ApiResponse<T> {\r\n  /** Whether the API request was successful */\r\n  success: boolean;\r\n  /** The response data payload */\r\n  data: T;\r\n  /** Error message if the request failed */\r\n  error?: string;\r\n  /** ISO timestamp of when the response was generated */\r\n  timestamp?: string;\r\n}\r\n","usedDeprecatedRules":[]}]